
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.classical.filter</title>
<meta name="description" content="Documentation of Coq module mathcomp.classical.filter" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.classical.filter</h1>
<span class="vernacular">From</span><span class="id"> HB</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> structures</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> all_ssreflect</span><span class="id"> all_algebra</span><span class="id"> finmap</span><span class="id"> generic_quotient</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> archimedean</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> boolp</span><span class="id"> classical_sets</span><span class="id"> functions</span><span class="id"> wochoice</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> cardinality</span><span class="id"> mathcomp_extra</span><span class="id"> fsbigop</span><span class="id"> set_interval</span>.<br/>
<br/>
<div class="ssrdoc md">
# Filters

The theory of (powerset) filters and tools for manipulating them.
This file introduces convergence for filters. It also provides the
interface of filtered types for associating a "canonical filter" to each
element. And lastly it provides typeclass instances for verifying when
a (set_system T) is really a filter in T, as a Filter or Properfilter.

## Structure of filter
```
                  filteredType U == interface type for types whose
                                    elements represent sets of sets on U
                                    These sets are intended to be filters
                                    on U but this is not enforced yet.
                                    The HB class is called Filtered.
                                    It extends Pointed.
                          nbhs p == set of sets associated to p (in a
                                    filtered type)
                 pfilteredType U == a pointed and filtered type
                         hasNbhs == factory for filteredType
                    continuous f == f is continuous w.r.t the topology
                filterI_iter F n == nth stage of recursively building the
                                    filter of finite intersections of F
                   finI_from D f == set of \bigcap_(i in E) f i where E is
                                    a finite subset of D
```

We endow several standard types with the structure of filter, e.g.:
- products `(X1 * X2)%type`
- matrices `'M[X]_(m, n)`
- natural numbers `nat`

## Theory of filters
```
                 filter_from D B == set of the supersets of the elements
                                    of the family of sets B whose indices
                                    are in the domain D
                                    This is a filter if (B_i)_(i in D)
                                    forms a filter base.
                 filter_prod F G == product of the filters F and G
                       F `=&gt;` G &lt;-&gt; G is included in F
                                    F and G are sets of sets.
                             \oo == "eventually" filter on nat: set of
                                    predicates on natural numbers that are
                                    eventually true
                        F --&gt; G &lt;-&gt; the canonical filter associated to G
                                    is included in the canonical filter
                                    associated to F
                           lim F == limit of the canonical filter
                                    associated with F if there is such a
                                    limit, i.e., an element l such that
                                    the canonical filter associated to l
                                    is a subset of F
                    [lim F in T] == limit of the canonical filter
                                    associated to F in T where T has type
                                    filteredType U
                   [cvg F in T] &lt;-&gt; the canonical filter associated to F
                                    converges in T
                          cvg F &lt;-&gt; same as [cvg F in T] where T is
                                    inferred from the type of the
                                    canonical filter associated to F
                        Filter F == type class proving that the set of
                                    sets F is a filter
                  ProperFilter F == type class proving that the set of
                                    sets F is a proper filter
                   UltraFilter F == type class proving that the set of
                                    sets F is an ultrafilter
                     filter_on T == interface type for sets of sets on T
                                    that are filters
                 FilterType F FF == packs the set of sets F with the proof
                                    FF of Filter F to build a filter_on T
                                    structure
                    pfilter_on T == interface type for sets of sets on T
                                    that are proper filters
                PFilterPack F FF == packs the set of sets F with the proof
                                    FF of ProperFilter F to build a
                                    pfilter_on T structure
                        fmap f F == image of the filter F by the function
                                    f
                    E @[x --&gt; F] == image of the canonical filter
                                    associated to F by the function
                                    (fun x =&gt; E)
                           f @ F == image of the canonical filter
                                    associated to F by the function f
                       fmapi f F == image of the filter F by the relation
                                    f
                   E `@[x --&gt; F] == image of the canonical filter
                                    associated to F by the relation
                                    (fun x =&gt; E)
                          f `@ F == image of the canonical filter
                                    associated to F by the relation f
                      globally A == filter of the sets containing A
               @frechet_filter T := [set S : set T | finite_set (~` S)]
                                    a.k.a. cofinite filter
                      at_point a == filter of the sets containing a
                      within D F == restriction of the filter F to the
                                    domain D
              principal_filter x == filter containing every superset of x
           principal_filter_type == alias for choice types with principal
                                    filters
               subset_filter F D == similar to within D F, but with
                                    dependent types
          powerset_filter_from F == the filter of downward closed subsets
                                    of F.
                                    Enables use of near notation to pick
                                    suitably small members of F
                     in_filter F == interface type for the sets that
                                    belong to the set of sets F
                     InFilter FP == packs a set P with a proof of F P to
                                    build a in_filter F structure
```

## Near notations and tactics
The purpose of the near notations and tactics is to make the manipulation
of filters easier. Instead of proving $F\; G$, one can prove $G\; x$ for
$x$ "near F", i.e., for x such that H x for H arbitrarily precise as long
as $F\; H$. The near tactics allow for a delayed introduction of $H$:
$H$ is introduced as an existential variable and progressively
instantiated during the proof process.

### Notations
```
                     {near F, P} == the property P holds near the
                                    canonical filter associated to F
                                    P must have the form forall x, Q x.
                                    Equivalent to F Q.
         \forall x \near F, P x &lt;-&gt; F (fun x =&gt; P x).
                    \near x, P x := \forall y \near x, P y.
                 {near F &amp; G, P} == same as {near H, P}, where H is the
                                    product of the filters F and G
  \forall x \near F &amp; y \near G, P x y := {near F &amp; G, forall x y, P x y}
    \forall x &amp; y \near F, P x y == same as before, with G = F
              \near x &amp; y, P x y := \forall z \near x &amp; t \near y, P x y
                    x \is_near F == x belongs to a set P : in_filter F
```

### Tactics
- near=&gt; x    introduces x:
  On the goal \forall x \near F, G x, introduces the variable x and an
  "existential", and an unaccessible hypothesis ?H x and asks the user to
  prove (G x) in this context.
  Under the hood, it delays the proof of F ?H and waits for near: x.
  Also exists under the form near=&gt; x y.
- near: x     discharges x:
  On the goal H_i x, and where x \is_near F, it asks the user to prove
  that (\forall x \near F, H_i x), provided that H_i x does not depend on
  variables introduced after x.
  Under the hood, it refines by intersection the existential variable ?H
  attached to x, computes the intersection with F, and asks the user to
  prove F H_i, right now.
- end_near should be used to close remaining existentials trivially.
- near F =&gt; x     poses a variable near F, where F is a proper filter
  It adds to the context a variable x that \is_near F, i.e., one may
  assume H x for any H in F. This new variable x can be dealt with using
  near: x, as for variables introduced by near=&gt;.

</div>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<br/>
<span class="vernacular">Obligation</span><span class="vernacular"> Tactic</span><span class="id"> :=</span><span class="id"> idtac</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> Order</span>.<span class="id">TTheory</span><span class="id"> GRing</span>.<span class="id">Theory</span><span class="id"> Num</span>.<span class="id">Theory</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'near' x , P }&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;{ 'near'  x ,  P }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'\forall' x '\near' x_0 , P&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 200,</span><span class="id"> x</span><span class="id"> name,</span><span class="id"> P</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 200,</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;'\forall'  x  '\near'  x_0 ,  P&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'\near' x , P&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 200,</span><span class="id"> x</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 99,</span><span class="id"> P</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 200,</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;'\near'  x ,  P&quot;</span><span class="id">,</span><span class="id"> only</span><span class="id"> parsing</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'near' x &amp; y , P }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;{ 'near'  x  &amp;  y ,  P }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'\forall' x '\near' x_0 &amp; y '\near' y_0 , P&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 200,</span><span class="id"> x</span><span class="id"> name,</span><span class="id"> y</span><span class="id"> name,</span><span class="id"> P</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 200,</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;'\forall'  x  '\near'  x_0  &amp;  y  '\near'  y_0 ,  P&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'\forall' x &amp; y '\near' z , P&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 200,</span><span class="id"> x</span><span class="id"> name,</span><span class="id"> y</span><span class="id"> name,</span><span class="id"> P</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 200,</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;'\forall'  x  &amp;  y  '\near'  z ,  P&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'\near' x &amp; y , P&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 200,</span><span class="id"> x,</span><span class="id"> y</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 99,</span><span class="id"> P</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 200,</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;'\near'  x  &amp;  y ,  P&quot;</span><span class="id">,</span><span class="id"> only</span><span class="id"> parsing</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;F `=&gt;` G&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 70,</span><span class="id"> format</span> <span class="id">&quot;F  `=&gt;`  G&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;F --&gt; G&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 70,</span><span class="id"> format</span> <span class="id">&quot;F  --&gt;  G&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;[ 'lim' F 'in' T ]&quot;</span> (<span class="id">format</span> <span class="id">&quot;[ 'lim'  F  'in'  T ]&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;[ 'cvg' F 'in' T ]&quot;</span> (<span class="id">format</span> <span class="id">&quot;[ 'cvg'  F  'in'  T ]&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;x \is_near F&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 10,</span><span class="id"> format</span> <span class="id">&quot;x  \is_near  F&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;E @[ x --&gt; F ]&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 60,</span><span class="id"> x</span><span class="id"> name,</span><span class="id"> format</span> <span class="id">&quot;E  @[ x  --&gt;  F ]&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;E @[ x \oo ]&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 60,</span><span class="id"> x</span><span class="id"> name,</span><span class="id"> format</span> <span class="id">&quot;E  @[ x  \oo ]&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;f @ F&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 60,</span><span class="id"> format</span> <span class="id">&quot;f  @  F&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;E `@[ x --&gt; F ]&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 60,</span><span class="id"> x</span><span class="id"> name,</span><span class="id"> format</span> <span class="id">&quot;E  `@[ x  --&gt;  F ]&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;f `@ F&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 60,</span><span class="id"> format</span> <span class="id">&quot;f  `@  F&quot;</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> set_system</span><span class="id"> U</span><span class="id"> :=</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> U</span>).<br/>
<span class="id">Identity</span><span class="vernacular"> Coercion</span><span class="id"> set_system_to_set</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> &gt;-&gt;</span><span class="id"> set</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> isFiltered</span><span class="id"> U</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">nbhs</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> set_system</span><span class="id"> U</span><br/>
<span class="id">}</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=</span><span class="id">&quot;filteredType&quot;</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> Filtered</span> (<span class="id">U</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<span class="id"> :=</span><span class="id"> {T</span><span class="id"> of</span><span class="id"> Choice</span><span class="id"> T</span><span class="id"> &amp;</span><span class="id"> isFiltered</span><span class="id"> U</span><span class="id"> T}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> nbhs</span><span class="id"> {_</span><span class="id"> _}</span><span class="id"> _</span><span class="id"> _</span><span class="id"> :</span><span class="id"> simpl</span><span class="id"> never</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=</span><span class="id">&quot;pfilteredType&quot;</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> PointedFiltered</span> (<span class="id">U</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<span class="id"> :=</span><span class="id"> {T</span><span class="id"> of</span><span class="id"> Pointed</span><span class="id"> T</span><span class="id"> &amp;</span><span class="id"> isFiltered</span><span class="id"> U</span><span class="id"> T}</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> Equality</span>.<span class="id">on</span> (<span class="id">set_system</span><span class="id"> T</span>).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> Choice</span>.<span class="id">on</span> (<span class="id">set_system</span><span class="id"> T</span>).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> Pointed</span>.<span class="id">on</span> (<span class="id">set_system</span><span class="id"> T</span>).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> isFiltered</span>.<span class="id">Build</span><span class="id"> T</span> (<span class="id">set_system</span><span class="id"> T</span>)<span class="id"> id</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> selfFiltered</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> {}</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> hasNbhs</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> {</span><span class="id"> nbhs</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> set_system</span><span class="id"> T</span><span class="id"> }</span>.<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> T</span><span class="id"> of</span><span class="id"> hasNbhs</span><span class="id"> T</span>.<br/>
&nbsp;&nbsp;<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isFiltered</span>.<span class="id">Build</span><span class="id"> T</span><span class="id"> T</span><span class="id"> nbhs</span>.<br/>
&nbsp;&nbsp;<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> selfFiltered</span>.<span class="id">Build</span><span class="id"> T</span>.<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=</span><span class="id">&quot;nbhsType&quot;</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> Nbhs</span><span class="id"> :=</span><span class="id"> {T</span><span class="id"> of</span><span class="id"> Choice</span><span class="id"> T</span><span class="id"> &amp;</span><span class="id"> hasNbhs</span><span class="id"> T}</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=</span><span class="id">&quot;pnbhsType&quot;</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> PointedNbhs</span><span class="id"> :=</span><span class="id"> {T</span><span class="id"> of</span><span class="id"> Pointed</span><span class="id"> T</span><span class="id"> &amp;</span><span class="id"> hasNbhs</span><span class="id"> T}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> filter_from</span><span class="id"> {I</span><span class="id"> T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">set_system</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> P</span><span class="id"> |</span><span class="gallina-kwd"> exists2</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> &amp;</span><span class="id"> B</span><span class="id"> i</span><span class="id"> `&lt;=`</span><span class="id"> P]</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> m</span><span class="id"> n</span><span class="id"> X</span> (<span class="id">Z</span><span class="id"> :</span><span class="id"> filteredType</span><span class="id"> X</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">isFiltered</span>.<span class="id">Build</span><span class="id"> 'M[X]_</span>(<span class="id">m,</span><span class="id"> n</span>)<span class="id"> 'M[Z]_</span>(<span class="id">m,</span><span class="id"> n</span>) (<span class="gallina-kwd">fun</span><span class="id"> mx</span><span class="id"> =&gt;</span><span class="id"> filter_from</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set</span><span class="id"> P</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> i</span><span class="id"> j,</span><span class="id"> nbhs</span> (<span class="id">mx</span><span class="id"> i</span><span class="id"> j</span>) (<span class="id">P</span><span class="id"> i</span><span class="id"> j</span>)<span class="id">]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> P</span><span class="id"> =&gt;</span><span class="id"> [set</span><span class="id"> my</span><span class="id"> :</span><span class="id"> 'M[X]_</span>(<span class="id">m,</span><span class="id"> n</span>)<span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> i</span><span class="id"> j,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> j</span> (<span class="id">my</span><span class="id"> i</span><span class="id"> j</span>)<span class="id">]</span>)).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> m</span><span class="id"> n</span> (<span class="id">X</span><span class="id"> :</span><span class="id"> nbhsType</span>)<span class="id"> :=</span><span class="id"> selfFiltered</span>.<span class="id">Build</span><span class="id"> 'M[X]_</span>(<span class="id">m,</span><span class="id"> n</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> filter_prod</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> Type}</span><br/>
&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>)<span class="id"> :</span><span class="id"> set_system</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> U</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">filter_from</span> (<span class="gallina-kwd">fun</span><span class="id"> P</span><span class="id"> =&gt;</span><span class="id"> F</span><span class="id"> P</span>.<span class="id">1</span><span class="id"> /\</span><span class="id"> G</span><span class="id"> P</span>.<span class="id">2</span>) (<span class="gallina-kwd">fun</span><span class="id"> P</span><span class="id"> =&gt;</span><span class="id"> P</span>.<span class="id">1</span><span class="id"> `*`</span><span class="id"> P</span>.<span class="id">2</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Near</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'all1' P }&quot;</span><span class="id"> :=</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'all2' P }&quot;</span><span class="id"> :=</span> (<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'all3' P }&quot;</span><span class="id"> :=</span> (<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z:</span><span class="gallina-kwd"> Prop</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> ph</span><span class="id"> :=</span> (<span class="id">phantom</span><span class="id"> _</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> prop_near1</span><span class="id"> {X}</span><span class="id"> {fX</span><span class="id"> :</span><span class="id"> filteredType</span><span class="id"> X}</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> fX</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id">P</span> (<span class="id">phP</span><span class="id"> :</span><span class="id"> ph</span><span class="id"> {all1</span><span class="id"> P}</span>)<span class="id"> :=</span><span class="id"> nbhs</span><span class="id"> x</span><span class="id"> P</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> prop_near2</span><span class="id"> {X</span><span class="id"> X'}</span><span class="id"> {fX</span><span class="id"> :</span><span class="id"> filteredType</span><span class="id"> X}</span><span class="id"> {fX'</span><span class="id"> :</span><span class="id"> filteredType</span><span class="id"> X'}</span><br/>
&nbsp;&nbsp;(<span class="id">x</span><span class="id"> :</span><span class="id"> fX</span>) (<span class="id">x'</span><span class="id"> :</span><span class="id"> fX'</span>)<span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> P</span><span class="id"> of</span><span class="id"> ph</span><span class="id"> {all2</span><span class="id"> P}</span><span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">filter_prod</span> (<span class="id">nbhs</span><span class="id"> x</span>) (<span class="id">nbhs</span><span class="id"> x'</span>) (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> P</span><span class="id"> x</span>.<span class="id">1</span><span class="id"> x</span>.<span class="id">2</span>).<br/>
<br/>
<span class="vernacular">End</span><span class="id"> Near</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'near' x , P }&quot;</span><span class="id"> :=</span> (<span class="id">@prop_near1</span><span class="id"> _</span><span class="id"> _</span><span class="id"> x</span><span class="id"> _</span> (<span class="id">inPhantom</span><span class="id"> P</span>))<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'\forall' x '\near' x_0 , P&quot;</span><span class="id"> :=</span><span class="id"> {near</span><span class="id"> x_0,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> P}</span><span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'\near' x , P&quot;</span><span class="id"> :=</span> (<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> x,</span><span class="id"> P</span>)<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'near' x &amp; y , P }&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">@prop_near2</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> x</span><span class="id"> y</span><span class="id"> _</span> (<span class="id">inPhantom</span><span class="id"> P</span>))<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'\forall' x '\near' x_0 &amp; y '\near' y_0 , P&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{near</span><span class="id"> x_0</span><span class="id"> &amp;</span><span class="id"> y_0,</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> P}</span><span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'\forall' x &amp; y '\near' z , P&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{near</span><span class="id"> z</span><span class="id"> &amp;</span><span class="id"> z,</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> P}</span><span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'\near' x &amp; y , P&quot;</span><span class="id"> :=</span> (<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> y,</span><span class="id"> P</span>)<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> prop_near1</span><span class="id"> :</span><span class="id"> simpl</span><span class="id"> never</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> prop_near2</span><span class="id"> :</span><span class="id"> simpl</span><span class="id"> never</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nearE</span><span class="id"> {T}</span><span class="id"> {F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> F</span><span class="id"> P</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_near</span><span class="id"> {T}</span><span class="id"> {F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T}</span> (<span class="id">P</span><span class="id"> Q</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> &lt;-&gt;</span><span class="id"> Q</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> Q</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /predeqP</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nbhs_filterE</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> nbhs</span><span class="id"> F</span><span class="id"> =</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Module</span><span class="vernacular"> Export</span><span class="id"> NbhsFilter</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> nbhs_simpl</span><span class="id"> :=</span> (<span class="id">@nbhs_filterE</span>).<br/>
<span class="vernacular">End</span><span class="id"> NbhsFilter</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> cvg_to</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :=</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> F</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;F `=&gt;` G&quot;</span><span class="id"> :=</span> (<span class="id">cvg_to</span><span class="id"> F</span><span class="id"> G</span>)<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_refl</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> F</span><span class="id"> `=&gt;`</span><span class="id"> F</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact</span>. Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> cvg_refl</span><span class="id"> {T</span><span class="id"> F}</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> cvg_refl</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_trans</span><span class="id"> T</span> (<span class="id">G</span><span class="id"> F</span><span class="id"> H</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">F</span><span class="id"> `=&gt;`</span><span class="id"> G</span>)<span class="id"> -&gt;</span> (<span class="id">G</span><span class="id"> `=&gt;`</span><span class="id"> H</span>)<span class="id"> -&gt;</span> (<span class="id">F</span><span class="id"> `=&gt;`</span><span class="id"> H</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> FG</span><span class="id"> GH</span><span class="id"> P</span><span class="id"> /GH</span><span class="id"> /FG</span>. Qed.</div></details>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;F --&gt; G&quot;</span><span class="id"> :=</span> (<span class="id">cvg_to</span> (<span class="id">nbhs</span><span class="id"> F</span>) (<span class="id">nbhs</span><span class="id"> G</span>))<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> type_of_filter</span><span class="id"> {T}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :=</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> lim_in</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> pfilteredType</span><span class="id"> U</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> get</span> (<span class="gallina-kwd">fun</span><span class="id"> l</span><span class="id"> :</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> l</span>).<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'lim' F 'in' T ]&quot;</span><span class="id"> :=</span> (<span class="id">@lim_in</span><span class="id"> _</span><span class="id"> T</span> (<span class="id">nbhs</span><span class="id"> F</span>))<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> lim</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> pnbhsType}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :=</span><span class="id"> [lim</span><span class="id"> F</span><span class="gallina-kwd"> in</span><span class="id"> T]</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'cvg' F 'in' T ]&quot;</span><span class="id"> :=</span> (<span class="id">F</span><span class="id"> --&gt;</span><span class="id"> [lim</span><span class="id"> F</span><span class="gallina-kwd"> in</span><span class="id"> T]</span>)<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Notation</span><span class="id"> cvg</span><span class="id"> F</span><span class="id"> :=</span> (<span class="id">F</span><span class="id"> --&gt;</span><span class="id"> lim</span><span class="id"> F</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> eventually</span><span class="id"> :=</span><span class="id"> filter_from</span><span class="id"> setT</span> (<span class="gallina-kwd">fun</span><span class="id"> N</span><span class="id"> =&gt;</span><span class="id"> [set</span><span class="id"> n</span><span class="id"> |</span> (<span class="id">N</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N]</span>).<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'\oo'&quot;</span><span class="id"> :=</span><span class="id"> eventually</span><span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> FilteredTheory</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> X1</span><span class="id"> X2</span> (<span class="id">Z1</span><span class="id"> :</span><span class="id"> filteredType</span><span class="id"> X1</span>) (<span class="id">Z2</span><span class="id"> :</span><span class="id"> filteredType</span><span class="id"> X2</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">isFiltered</span>.<span class="id">Build</span> (<span class="id">X1</span><span class="id"> *</span><span class="id"> X2</span>)<span class="id">%type</span> (<span class="id">Z1</span><span class="id"> *</span><span class="id"> Z2</span>)<span class="id">%type</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> filter_prod</span> (<span class="id">nbhs</span><span class="id"> x</span>.<span class="id">1</span>) (<span class="id">nbhs</span><span class="id"> x</span>.<span class="id">2</span>)).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">X1</span><span class="id"> X2</span><span class="id"> :</span><span class="id"> nbhsType</span>) <span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">selfFiltered</span>.<span class="id">Build</span> (<span class="id">X1</span><span class="id"> *</span><span class="id"> X2</span>)<span class="id">%type</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_prod</span><span class="id"> T</span><span class="id"> {U</span><span class="id"> U'</span><span class="id"> V</span><span class="id"> V'</span><span class="id"> :</span><span class="id"> filteredType</span><span class="id"> T}</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> U</span>) (<span class="id">l</span><span class="id"> :</span><span class="id"> U'</span>) (<span class="id">y</span><span class="id"> :</span><span class="id"> V</span>) (<span class="id">k</span><span class="id"> :</span><span class="id"> V'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">x</span><span class="id"> --&gt;</span><span class="id"> l</span><span class="id"> -&gt;</span><span class="id"> y</span><span class="id"> --&gt;</span><span class="id"> k</span><span class="id"> -&gt;</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> --&gt;</span> (<span class="id">l,</span><span class="id"> k</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> xl</span><span class="id"> yk</span><span class="id"> X</span><span class="id"> [[X1</span><span class="id"> X2]</span><span class="id"> /=</span><span class="id"> [HX1</span><span class="id"> HX2]</span><span class="id"> H];</span><span class="gallina-kwd"> exists</span> (<span class="id">X1,</span><span class="id"> X2</span>)<span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
<span class="id">split;</span><span class="id"> [exact:</span><span class="id"> xl</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> yk]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_in_ex</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> pfilteredType</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[cvg</span><span class="id"> F</span><span class="gallina-kwd"> in</span><span class="id"> T]</span><span class="id"> &lt;-&gt;</span> (<span class="gallina-kwd">exists</span><span class="id"> l</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> l</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split=&gt;</span><span class="id"> [cvg|/getPex//];</span><span class="gallina-kwd"> exists</span><span class="id"> [lim</span><span class="id"> F</span><span class="gallina-kwd"> in</span><span class="id"> T]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_ex</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> pnbhsType</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">cvg</span><span class="id"> F</span><span class="id"> &lt;-&gt;</span> (<span class="gallina-kwd">exists</span><span class="id"> l</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> l</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> cvg_in_ex</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_inP</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> pfilteredType</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>) (<span class="id">l</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">F</span><span class="id"> --&gt;</span><span class="id"> l</span><span class="id"> -&gt;</span><span class="id"> [cvg</span><span class="id"> F</span><span class="gallina-kwd"> in</span><span class="id"> T]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Fl;</span><span class="id"> apply/cvg_in_ex;</span><span class="gallina-kwd"> exists</span><span class="id"> l</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvgP</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> pnbhsType</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">l</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> l</span><span class="id"> -&gt;</span><span class="id"> cvg</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> cvg_inP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_in_toP</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> pfilteredType</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>) (<span class="id">l</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[cvg</span><span class="id"> F</span><span class="gallina-kwd"> in</span><span class="id"> T]</span><span class="id"> -&gt;</span><span class="id"> [lim</span><span class="id"> F</span><span class="gallina-kwd"> in</span><span class="id"> T]</span><span class="id"> =</span><span class="id"> l</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> l</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /[swap]-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_toP</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> pnbhsType</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">l</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">cvg</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> lim</span><span class="id"> F</span><span class="id"> =</span><span class="id"> l</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> l</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> cvg_in_toP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dvg_inP</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> pfilteredType</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">~</span><span class="id"> [cvg</span><span class="id"> F</span><span class="gallina-kwd"> in</span><span class="id"> T]</span><span class="id"> -&gt;</span><span class="id"> [lim</span><span class="id"> F</span><span class="gallina-kwd"> in</span><span class="id"> T]</span><span class="id"> =</span><span class="id"> point</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /lim_in</span><span class="id"> /=;</span><span class="id"> case</span><span class="id"> xgetP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dvgP</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> pnbhsType</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> ~</span><span class="id"> cvg</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> lim</span><span class="id"> F</span><span class="id"> =</span><span class="id"> point</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> dvg_inP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_inNpoint</span><span class="id"> {U}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> pfilteredType</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[lim</span><span class="id"> F</span><span class="gallina-kwd"> in</span><span class="id"> T]</span><span class="id"> !=</span><span class="id"> point</span><span class="id"> -&gt;</span><span class="id"> [cvg</span><span class="id"> F</span><span class="gallina-kwd"> in</span><span class="id"> T]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> contra_neqP;</span><span class="id"> apply:</span><span class="id"> dvg_inP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvgNpoint</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> pnbhsType</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> lim</span><span class="id"> F</span><span class="id"> !=</span><span class="id"> point</span><span class="id"> -&gt;</span><span class="id"> cvg</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> cvg_inNpoint</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> FilteredTheory</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> cvg_inP</span><span class="id"> {U</span><span class="id"> T</span><span class="id"> F}</span><span class="id"> l</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> dvg_inP</span><span class="id"> {U}</span><span class="id"> T</span><span class="id"> {F}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> cvgP</span><span class="id"> {T</span><span class="id"> F}</span><span class="id"> l</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> dvgP</span><span class="id"> {T</span><span class="id"> F}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nbhs_nearE</span><span class="id"> {U}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> filteredType</span><span class="id"> U}</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">nbhs</span><span class="id"> x</span><span class="id"> P</span><span class="id"> =</span><span class="id"> \near</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_nbhs</span><span class="id"> {U}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> filteredType</span><span class="id"> U}</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> nbhs</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> \near</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near2_curry</span><span class="id"> {U</span><span class="id"> V}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> V</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{near</span><span class="id"> F</span><span class="id"> &amp;</span><span class="id"> G,</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> y}</span><span class="id"> =</span><span class="id"> {near</span> (<span class="id">F,</span><span class="id"> G</span>)<span class="id">,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span>.<span class="id">1</span><span class="id"> x</span>.<span class="id">2}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near2_pair</span><span class="id"> {U</span><span class="id"> V}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> V</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">U</span><span class="id"> *</span><span class="id"> V</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{near</span><span class="id"> F</span><span class="id"> &amp;</span><span class="id"> G,</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> P</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id">}</span><span class="id"> =</span><span class="id"> {near</span> (<span class="id">F,</span><span class="id"> G</span>)<span class="id">,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> symmetry;</span><span class="id"> congr</span> (<span class="id">nbhs</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> -[]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> near2E</span><span class="id"> :=</span> (<span class="id">@near2_curry,</span><span class="id"> @near2_pair</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_of_nearI</span> (<span class="id">X</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">fX</span><span class="id"> :</span><span class="id"> filteredType</span><span class="id"> X</span>)<br/>
&nbsp;&nbsp;(<span class="id">x</span><span class="id"> :</span><span class="id"> fX</span>)<span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> P,</span><br/>
&nbsp;&nbsp;<span class="id">nbhs</span><span class="id"> x</span><span class="id"> P</span><span class="id"> =</span><span class="id"> @prop_near1</span><span class="id"> X</span><span class="id"> fX</span><span class="id"> x</span><span class="id"> P</span> (<span class="id">inPhantom</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Module</span><span class="vernacular"> Export</span><span class="id"> NearNbhs</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> near_simpl</span><span class="id"> :=</span> (<span class="id">@near_nbhs,</span><span class="id"> @nbhs_nearE,</span><span class="id"> filter_of_nearI</span>).<br/>
<span class="vernacular">Ltac</span><span class="id"> near_simpl</span><span class="id"> :=</span><span class="id"> rewrite</span><span class="id"> ?near_simpl</span>.<br/>
<span class="vernacular">End</span><span class="id"> NearNbhs</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_swap</span><span class="id"> {U</span><span class="id"> V}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> V</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F</span><span class="id"> &amp;</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> G,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> y</span>)<span class="id"> =</span> (<span class="id">\forall</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> G</span><span class="id"> &amp;</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> propeqE;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> -[[/=A</span><span class="id"> B]</span><span class="id"> [FA</span><span class="id"> FB]</span><span class="id"> ABP];</span><br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">B,</span><span class="id"> A</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[x</span><span class="id"> y]</span><span class="id"> [/=Bx</span><span class="id"> Ay];</span><span class="id"> apply:</span> (<span class="id">ABP</span> (<span class="id">y,</span><span class="id"> x</span>)).<br/>
Qed.</div></details>
<br/>
<div class="doc">Filters </div>
<br/>
<span class="vernacular">Class</span><span class="id"> Filter</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">filterT</span><span class="id"> :</span><span class="id"> F</span><span class="id"> setT</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">filterI</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span><span class="id"> F</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="id"> F</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> Q</span>)<span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">filterS</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span><span class="id"> P</span><span class="id"> `&lt;=`</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> Q</span><br/>
<span class="id">}</span>.<br/>
<span class="id">Global</span><span class="vernacular"> Hint</span><span class="id"> Mode</span><span class="id"> Filter</span><span class="id"> -</span><span class="id"> !</span><span class="id"> :</span><span class="id"> typeclass_instances</span>.<br/>
<br/>
<span class="vernacular">Class</span><span class="id"> ProperFilter</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">filter_not_empty</span><span class="id"> :</span><span class="id"> ~</span><span class="id"> F</span><span class="id"> set0</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">filter_filter</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span><br/>
<span class="id">}</span>.<br/>
<span class="id">Global</span><span class="id"> Existing</span><span class="vernacular"> Instance</span><span class="id"> filter_filter</span>.<br/>
<span class="id">Global</span><span class="vernacular"> Hint</span><span class="id"> Mode</span><span class="id"> ProperFilter</span><span class="id"> -</span><span class="id"> !</span><span class="id"> :</span><span class="id"> typeclass_instances</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> filter_not_empty</span><span class="id"> {T}</span><span class="id"> F</span><span class="id"> {_}</span>.<br/>
<span class="vernacular">Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">~</span><span class="id"> _</span><span class="id"> set0</span>)<span class="id"> =&gt;</span><span class="id"> solve</span><span class="id"> [apply:</span><span class="id"> filter_not_empty]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_setT</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<span class="id"> :</span><span class="id"> Filter</span><span class="id"> [set:</span><span class="id"> set</span><span class="id"> T]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> constructor</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filterP_strong</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> {FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">exists</span><span class="id"> Q</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span><span class="gallina-kwd"> exists</span><span class="id"> FQ</span> <span class="id"> :</span><span class="id"> F</span><span class="id"> Q,</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> Q</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> &lt;-&gt;</span><span class="id"> F</span><span class="id"> P</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> P</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [Q</span><span class="id"> [FQ</span><span class="id"> QP]];</span><span class="id"> apply:</span> (<span class="id">filterS</span><span class="id"> QP</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Structure</span><span class="id"> filter_on</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> FilterType</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">filter</span><span class="id"> :&gt;</span><span class="id"> set_system</span><span class="id"> T;</span><br/>
&nbsp;&nbsp;_<span class="id"> :</span><span class="id"> Filter</span><span class="id"> filter</span><br/>
<span class="id">}</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> filter_class</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> filter_on</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">let:</span><span class="id"> FilterType</span><span class="id"> _</span><span class="id"> class</span><span class="id"> :=</span><span class="id"> F</span><span class="gallina-kwd"> in</span><span class="id"> class</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> FilterType</span><span class="id"> {T}</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="id">#[global]</span><span class="id"> Existing</span><span class="vernacular"> Instance</span><span class="id"> filter_class</span>.<br/>
<span class="vernacular">Coercion</span><span class="id"> filter_filter</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> &gt;-&gt;</span><span class="id"> Filter</span>.<br/>
<br/>
<span class="vernacular">Structure</span><span class="id"> pfilter_on</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> PFilterPack</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">pfilter</span><span class="id"> :&gt;</span> (<span class="id">T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> -&gt;</span><span class="id"> Prop;</span><br/>
&nbsp;&nbsp;_<span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> pfilter</span><br/>
<span class="id">}</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> pfilter_class</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> pfilter_on</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">let:</span><span class="id"> PFilterPack</span><span class="id"> _</span><span class="id"> class</span><span class="id"> :=</span><span class="id"> F</span><span class="gallina-kwd"> in</span><span class="id"> class</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> PFilterPack</span><span class="id"> {T}</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="id">#[global]</span><span class="id"> Existing</span><span class="vernacular"> Instance</span><span class="id"> pfilter_class</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> pfilter_filter_on</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> pfilter_on</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">FilterType</span><span class="id"> F</span> (<span class="id">pfilter_class</span><span class="id"> F</span>).<br/>
<span class="vernacular">Coercion</span><span class="id"> pfilter_filter_on</span><span class="id"> :</span><span class="id"> pfilter_on</span><span class="id"> &gt;-&gt;</span><span class="id"> filter_on</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> PFilterType</span><span class="id"> {T}</span> (<span class="id">F</span><span class="id"> :</span> (<span class="id">T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<br/>
&nbsp;&nbsp;<span class="id">{fF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F}</span> (<span class="id">fN0</span><span class="id"> :</span><span class="id"> not</span> (<span class="id">F</span><span class="id"> set0</span>))<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">PFilterPack</span><span class="id"> F</span> (<span class="id">Build_ProperFilter</span><span class="id"> fN0</span><span class="id"> fF</span>).<br/>
<span class="vernacular">Arguments</span><span class="id"> PFilterType</span><span class="id"> {T}</span><span class="id"> F</span><span class="id"> {fF}</span><span class="id"> fN0</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> gen_eqMixin</span> (<span class="id">filter_on</span><span class="id"> T</span>).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> gen_choiceMixin</span> (<span class="id">filter_on</span><span class="id"> T</span>).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> isPointed</span>.<span class="id">Build</span> (<span class="id">filter_on</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;(<span class="id">FilterType</span><span class="id"> _</span> (<span class="id">filter_setT</span><span class="id"> T</span>)).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> isFiltered</span>.<span class="id">Build</span><span class="id"> T</span> (<span class="id">filter_on</span><span class="id"> T</span>) (<span class="id">@filter</span><span class="id"> T</span>).<br/>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> filter_on_Filter</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> filter_on</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> F</span>. Qed.</div></details>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> pfilter_on_ProperFilter</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> pfilter_on</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> F</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nbhs_filter_onE</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> filter_on</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> nbhs</span><span class="id"> F</span><span class="id"> =</span><span class="id"> nbhs</span> (<span class="id">filter</span><span class="id"> F</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">Definition</span><span class="id"> nbhs_simpl</span><span class="id"> :=</span> (<span class="id">@nbhs_simpl,</span><span class="id"> @nbhs_filter_onE</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_filter_onE</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> filter_on</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> \forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> filter</span><span class="id"> F,</span><span class="id"> P</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">Definition</span><span class="id"> near_simpl</span><span class="id"> :=</span> (<span class="id">@near_simpl,</span><span class="id"> @near_filter_onE</span>).<br/>
<br/>
<span class="id">Program</span><span class="vernacular"> Definition</span><span class="id"> trivial_filter_on</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> FilterType</span><span class="id"> [set</span><span class="id"> setT</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T]</span><span class="id"> _</span>.<br/>
<details>
<summary class="toggleproof">Next Obligation.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> //</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> -&gt;|Q</span><span class="id"> R</span><span class="id"> sQR</span><span class="id"> QT];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIT</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move;</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?</span><span class="id"> _;</span><span class="id"> apply/sQR;</span><span class="id"> rewrite</span><span class="id"> QT</span>.<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> trivial_filter_on</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_nbhsT</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> nbhs</span><span class="id"> F</span><span class="id"> setT</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> FF;</span><span class="id"> apply:</span><span class="id"> filterT</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> filter_nbhsT</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nearT</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> True</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> FF;</span><span class="id"> apply:</span><span class="id"> filterT</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> nearT</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_not_empty_ex</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> P,</span><span class="id"> F</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> ~</span><span class="id"> F</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /</span>(_<span class="id"> set0</span>)<span class="id"> ex</span><span class="id"> /ex</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> Build_ProperFilter_ex</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;(<span class="id">filter_ex</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> P,</span><span class="id"> F</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span>)<br/>
&nbsp;&nbsp;(<span class="id">FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Build_ProperFilter</span> (<span class="id">filter_not_empty_ex</span><span class="id"> filter_ex</span>)<span class="id"> FF</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_ex_subproof</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">~</span><span class="id"> F</span><span class="id"> set0</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> P,</span><span class="id"> F</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> NFset0</span><span class="id"> P</span><span class="id"> FP;</span><span class="id"> apply:</span><span class="id"> contra_notP</span><span class="id"> NFset0</span><span class="id"> =&gt;</span><span class="id"> nex;</span><span class="id"> suff</span><span class="id"> &lt;-</span><span class="id"> :</span><span class="id"> P</span><span class="id"> =</span><span class="id"> set0</span><span class="gallina-kwd"> by</span><span class="id"> []</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> funeqE</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> propeqE;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> Px;</span><span class="id"> apply:</span><span class="id"> nex;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> filter_ex</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> {FF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">filter_ex_subproof</span> (<span class="id">filter_not_empty</span><span class="id"> F</span>).<br/>
<span class="vernacular">Arguments</span><span class="id"> filter_ex</span><span class="id"> {T</span><span class="id"> F</span><span class="id"> FF</span><span class="id"> _}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_getP</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> pointedType}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> {FF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F}</span><br/>
&nbsp;&nbsp;(<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> F</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> P</span> (<span class="id">get</span><span class="id"> P</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /filter_ex</span><span class="id"> /getPex</span>. Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Record</span><span class="id"> in_filter</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :=</span><span class="id"> InFilter</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">prop_in_filter_proj</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> Prop;</span><br/>
&nbsp;&nbsp;<span class="id">prop_in_filterP_proj</span><span class="id"> :</span><span class="id"> F</span><span class="id"> prop_in_filter_proj</span><br/>
<span class="id">}</span>.<br/>
<br/>
<span class="vernacular">Module</span><span class="gallina-kwd"> Type</span><span class="id"> PropInFilterSig</span>.<br/>
<span class="vernacular">Axiom</span><span class="id"> t</span><span class="id"> :</span><span class="gallina-kwd"> forall</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id">,</span><span class="id"> in_filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>.<br/>
<span class="vernacular">Axiom</span><span class="id"> tE</span><span class="id"> :</span><span class="id"> t</span><span class="id"> =</span><span class="id"> prop_in_filter_proj</span>.<br/>
<span class="vernacular">End</span><span class="id"> PropInFilterSig</span>.<br/>
<span class="vernacular">Module</span><span class="id"> PropInFilter</span><span class="id"> :</span><span class="id"> PropInFilterSig</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> t</span><span class="id"> :=</span><span class="id"> prop_in_filter_proj</span>.<br/>
<span class="vernacular">Lemma</span><span class="id"> tE</span><span class="id"> :</span><span class="id"> t</span><span class="id"> =</span><span class="id"> prop_in_filter_proj</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">End</span><span class="id"> PropInFilter</span>.<br/>
<span class="vernacular">Notation</span><span class="id"> prop_of</span><span class="id"> :=</span><span class="id"> PropInFilter</span>.<span class="id">t</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> prop_ofE</span><span class="id"> :=</span><span class="id"> PropInFilter</span>.<span class="id">tE</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;x \is_near F&quot;</span><span class="id"> :=</span> (<span class="id">@PropInFilter</span>.<span class="id">t</span><span class="id"> _</span><span class="id"> F</span><span class="id"> _</span><span class="id"> x</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> is_nearE</span><span class="id"> :=</span><span class="id"> prop_ofE</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prop_ofP</span><span class="id"> T</span><span class="id"> F</span> (<span class="id">iF</span><span class="id"> :</span><span class="id"> @in_filter</span><span class="id"> T</span><span class="id"> F</span>)<span class="id"> :</span><span class="id"> F</span> (<span class="id">prop_of</span><span class="id"> iF</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> prop_ofE;</span><span class="id"> apply:</span><span class="id"> prop_in_filterP_proj</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> in_filterT</span><span class="id"> T</span><span class="id"> F</span> (<span class="id">FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span>)<span class="id"> :</span><span class="id"> @in_filter</span><span class="id"> T</span><span class="id"> F</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">InFilter</span> (<span class="id">filterT</span>).<br/>
<span class="vernacular">Canonical</span><span class="id"> in_filterI</span><span class="id"> T</span><span class="id"> F</span> (<span class="id">FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span>) (<span class="id">P</span><span class="id"> Q</span><span class="id"> :</span><span class="id"> @in_filter</span><span class="id"> T</span><span class="id"> F</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">InFilter</span> (<span class="id">filterI</span> (<span class="id">prop_in_filterP_proj</span><span class="id"> P</span>) (<span class="id">prop_in_filterP_proj</span><span class="id"> Q</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_near_of</span><span class="id"> T</span><span class="id"> F</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> @in_filter</span><span class="id"> T</span><span class="id"> F</span>) (<span class="id">Q</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> prop_of</span><span class="id"> P</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> Q</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> Q</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> P</span><span class="id"> =&gt;</span><span class="id"> [P</span><span class="id"> FP]</span><span class="id"> FF</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> prop_ofE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> /filterS;</span><span class="id"> apply</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> near_key</span><span class="id"> :</span><span class="id"> unit</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mark_near</span> (<span class="id">P</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><span class="id"> locked_with</span><span class="id"> near_key</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> P</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> unlock</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_acc</span><span class="id"> T</span><span class="id"> F</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> @in_filter</span><span class="id"> T</span><span class="id"> F</span>) (<span class="id">Q</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span>)<br/>
&nbsp;&nbsp;&nbsp;(<span class="id">FQ</span><span class="id"> :</span><span class="id"> \forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> Q</span><span class="id"> x</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">locked_with</span><span class="id"> near_key</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> prop_of</span> (<span class="id">in_filterI</span><span class="id"> FF</span><span class="id"> P</span> (<span class="id">InFilter</span><span class="id"> FQ</span>))<span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> Q</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> unlock</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> !prop_ofE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> -[Px]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_skip_subproof</span><span class="id"> T</span><span class="id"> F</span> (<span class="id">P</span><span class="id"> Q</span><span class="id"> :</span><span class="id"> @in_filter</span><span class="id"> T</span><span class="id"> F</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">locked_with</span><span class="id"> near_key</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> prop_of</span><span class="id"> P</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">locked_with</span><span class="id"> near_key</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> prop_of</span> (<span class="id">in_filterI</span><span class="id"> FF</span><span class="id"> P</span><span class="id"> Q</span>)<span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> !unlock</span><span class="id"> =&gt;</span><span class="id"> FG</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> !prop_ofE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> -[Px</span><span class="id"> Qx]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /=</span><span class="id"> :=</span><span class="id"> FG</span><span class="id"> x;</span><span class="id"> apply;</span><span class="id"> rewrite</span><span class="id"> prop_ofE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;near=&gt;&quot;</span><span class="id"> ident</span>(<span class="id">x</span>)<span class="id"> :=</span><span class="id"> apply:</span><span class="id"> filter_near_of</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> ?</span>.<br/>
<br/>
<span class="vernacular">Ltac</span><span class="id"> just_discharge_near</span><span class="id"> x</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">tryif</span><span class="gallina-kwd"> match</span><span class="id"> goal</span><span class="gallina-kwd"> with</span><span class="id"> Hx</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \is_near</span><span class="id"> _</span><span class="id"> |-</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> move:</span> (<span class="id">x</span>) (<span class="id">Hx</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> mark_near</span><span class="gallina-kwd"> end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">then</span><span class="id"> idtac</span><span class="gallina-kwd"> else</span><span class="id"> fail</span> <span class="id">&quot;the variable&quot;</span><span class="id"> x</span> <span class="id">&quot;is not a &quot;</span><span class="id">&quot;near&quot;</span><span class="id">&quot; variable&quot;</span>.<br/>
<span class="vernacular">Ltac</span><span class="id"> near_skip</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span><span class="id"> goal</span><span class="gallina-kwd"> with</span><span class="id"> |-</span><span class="id"> locked_with</span><span class="id"> near_key</span> (<span class="gallina-kwd">forall</span><span class="id"> _,</span><span class="id"> @PropInFilter</span>.<span class="id">t</span><span class="id"> _</span><span class="id"> _</span><span class="id"> ?P</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> _</span>)<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tryif</span><span class="id"> is_evar</span><span class="id"> P</span><span class="gallina-kwd"> then</span><span class="id"> fail</span> <span class="id">&quot;nothing to skip&quot;</span><span class="gallina-kwd"> else</span><span class="id"> apply:</span><span class="id"> near_skip_subproof</span><span class="gallina-kwd"> end</span>.<br/>
<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;near:&quot;</span><span class="id"> ident</span>(<span class="id">x</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">just_discharge_near</span><span class="id"> x;</span><br/>
&nbsp;&nbsp;<span class="id">tryif</span><span class="id"> do</span><span class="id"> ![apply:</span><span class="id"> near_acc;</span><span class="id"> first</span><span class="id"> shelve|near_skip]</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">then</span><span class="id"> idtac</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="id"> fail</span> <span class="id">&quot;the goal depends on variables introduced after&quot;</span><span class="id"> x</span>.<br/>
<br/>
<span class="vernacular">Ltac</span><span class="id"> under_near</span><span class="id"> i</span><span class="id"> tac</span><span class="id"> :=</span><span class="id"> near=&gt;</span><span class="id"> i;</span><span class="id"> tac;</span><span class="id"> near:</span><span class="id"> i</span>.<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;near=&gt;&quot;</span><span class="id"> ident</span>(<span class="id">i</span>) <span class="id">&quot;do&quot;</span><span class="id"> tactic3</span>(<span class="id">tac</span>)<span class="id"> :=</span><span class="id"> under_near</span><span class="id"> i</span><span class="id"> ltac:</span>(<span class="id">tac</span>).<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;near=&gt;&quot;</span><span class="id"> ident</span>(<span class="id">i</span>) <span class="id">&quot;do&quot;</span> <span class="id">&quot;[&quot;</span><span class="id"> tactic4</span>(<span class="id">tac</span>) <span class="id">&quot;]&quot;</span><span class="id"> :=</span><span class="id"> near=&gt;</span><span class="id"> i</span><span class="id"> do</span><span class="id"> tac</span>.<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;near&quot;</span> <span class="id">&quot;do&quot;</span><span class="id"> tactic3</span>(<span class="id">tac</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> i</span><span class="id"> :=</span><span class="id"> fresh</span> <span class="id">&quot;i&quot;</span><span class="gallina-kwd"> in</span><span class="id"> under_near</span><span class="id"> i</span><span class="id"> ltac:</span>(<span class="id">tac</span>).<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;near&quot;</span> <span class="id">&quot;do&quot;</span> <span class="id">&quot;[&quot;</span><span class="id"> tactic4</span>(<span class="id">tac</span>) <span class="id">&quot;]&quot;</span><span class="id"> :=</span><span class="id"> near</span><span class="id"> do</span><span class="id"> tac</span>.<br/>
<br/>
<span class="vernacular">Ltac</span><span class="id"> end_near</span><span class="id"> :=</span><span class="id"> do</span><span class="id"> ?exact:</span><span class="id"> in_filterT</span>.<br/>
<br/>
<span class="vernacular">Ltac</span><span class="id"> done</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">trivial;</span><span class="id"> hnf;</span><span class="id"> intros;</span><span class="id"> solve</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> do</span><span class="id"> ![solve</span><span class="id"> [trivial</span><span class="id"> |</span><span class="id"> apply:</span><span class="id"> sym_equal;</span><span class="id"> trivial]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> discriminate</span><span class="id"> |</span><span class="id"> contradiction</span><span class="id"> |</span><span class="id"> split]</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="gallina-kwd"> match</span><span class="id"> goal</span><span class="gallina-kwd"> with</span><span class="id"> H</span><span class="id"> :</span><span class="id"> ~</span><span class="id"> _</span><span class="id"> |-</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> solve</span><span class="id"> [case</span><span class="id"> H;</span><span class="id"> trivial]</span><span class="gallina-kwd"> end</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="gallina-kwd"> match</span><span class="id"> goal</span><span class="gallina-kwd"> with</span><span class="id"> |-</span><span class="id"> ?x</span><span class="id"> \is_near</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> near:</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> prop_ofP</span><span class="gallina-kwd"> end</span><span class="id"> ]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> have_near</span> (<span class="id">U</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">fT</span><span class="id"> :</span><span class="id"> filteredType</span><span class="id"> U</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> fT</span>) (<span class="id">P</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> (<span class="id">nbhs</span><span class="id"> x</span>)<span class="id"> -&gt;</span> (<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> x,</span><span class="id"> P</span>)<span class="id"> -&gt;</span><span class="id"> P</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> FF</span><span class="id"> nP;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> @filter_ex</span><span class="id"> _</span><span class="id"> _</span><span class="id"> FF</span> (<span class="id">fun=&gt;</span><span class="id"> P</span>). Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> have_near</span><span class="id"> {U</span><span class="id"> fT}</span><span class="id"> x</span>.<br/>
<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;near&quot;</span><span class="id"> constr</span>(<span class="id">F</span>) <span class="id">&quot;=&gt;&quot;</span><span class="id"> ident</span>(<span class="id">x</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">have_near</span><span class="id"> F</span>)<span class="id">;</span><span class="id"> near=&gt;</span><span class="id"> x</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> P</span> (<span class="id">FP</span><span class="id"> :</span><span class="id"> F</span><span class="id"> P</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;(<span class="id">Px</span><span class="id"> :</span><span class="id"> prop_of</span> (<span class="id">InFilter</span><span class="id"> FP</span>)<span class="id"> x</span>)<span class="id"> :</span><span class="id"> P</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> Px;</span><span class="id"> rewrite</span><span class="id"> prop_ofE</span>. Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> near</span><span class="id"> {T</span><span class="id"> F</span><span class="id"> P}</span><span class="id"> FP</span><span class="id"> x</span><span class="id"> Px</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nearW</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span><span class="id"> {F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> -&gt;</span> (<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> P</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> FF</span><span class="id"> FP;</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> filterT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filterE</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span><span class="id"> {F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> P</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [FT</span><span class="id"> _</span><span class="id"> +]</span><span class="id"> P</span><span class="id"> fP</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> setT</span>)<span class="id">;</span><span class="id"> apply</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_app</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span><span class="id"> F</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> P</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> Q</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> Q</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> FF</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> subPQ</span><span class="id"> FP;</span><span class="id"> near=&gt;</span><span class="id"> x</span><span class="id"> do</span><span class="id"> suff:</span><span class="id"> P</span><span class="id"> x</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_app2</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> R</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span> <span class="id"> F</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> P</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> Q</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">F</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ????</span><span class="id"> PQR</span><span class="id"> FP;</span><span class="id"> apply:</span><span class="id"> filter_app;</span><span class="id"> apply:</span><span class="id"> filter_app</span><span class="id"> FP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_app3</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> R</span><span class="id"> S</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span><span class="id"> F</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> P</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> Q</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">F</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?????</span><span class="id"> PQR</span><span class="id"> FP;</span><span class="id"> apply:</span><span class="id"> filter_app2;</span><span class="id"> apply:</span><span class="id"> filter_app</span><span class="id"> FP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filterS2</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> R</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> Q</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">F</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> apply:</span><span class="id"> filter_app2;</span><span class="id"> apply:</span><span class="id"> filterE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filterS3</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> R</span><span class="id"> S</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> Q</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">F</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> apply:</span><span class="id"> filter_app3;</span><span class="id"> apply:</span><span class="id"> filterE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_const</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span><span class="id"> {F}</span><span class="id"> {FF:</span><span class="id"> @ProperFilter</span><span class="id"> T</span><span class="id"> F}</span> (<span class="id">P</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">F</span> (<span class="id">fun=&gt;</span><span class="id"> P</span>)<span class="id"> -&gt;</span><span class="id"> P</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> FP;</span><span class="id"> case:</span> (<span class="id">filter_ex</span><span class="id"> FP</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> in_filter_from</span><span class="id"> {I</span><span class="id"> T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">i</span><span class="id"> :</span><span class="id"> I</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> filter_from</span><span class="id"> D</span><span class="id"> B</span> (<span class="id">B</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> in_nearW</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>) (<span class="id">S</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> S,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x}</span><span class="id"> -&gt;</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> P</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> FS</span><span class="id"> SP;</span><span class="id"> rewrite</span><span class="id"> -nbhs_nearE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">@filterS</span><span class="id"> _</span><span class="id"> F</span><span class="id"> _</span><span class="id"> S</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> /mem_set</span><span class="id"> /SP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_andP</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span><span class="id"> F</span> (<span class="id">b1</span><span class="id"> b2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> b1</span><span class="id"> x</span><span class="id"> /\</span><span class="id"> b2</span><span class="id"> x</span>)<span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> b1</span><span class="id"> x</span>)<span class="id"> /\</span> (<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> b2</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF;</span><span class="id"> split=&gt;</span><span class="id"> [H|[H1</span><span class="id"> H2]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> split;</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> H</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> []</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> filterS2</span><span class="id"> H1</span><span class="id"> H2</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nearP_dep</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T}</span><span class="id"> {G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U}</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">{FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F}</span><span class="id"> {FG</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> G}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F</span><span class="id"> &amp;</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> G,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> y</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> \forall</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> G,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [[Q</span><span class="id"> R]</span><span class="id"> [/=FQ</span><span class="id"> GR]]</span><span class="id"> QRP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> FQ</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> Q1x;</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> GR</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> Q2y;</span><span class="id"> apply:</span> (<span class="id">QRP</span> (<span class="id">_,</span><span class="id"> _</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter2P</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>)<br/>
&nbsp;&nbsp;<span class="id">{FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F}</span><span class="id"> {FG</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> G}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> U</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">exists2</span><span class="id"> Q</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> *</span><span class="id"> set</span><span class="id"> U,</span><span class="id"> F</span><span class="id"> Q</span>.<span class="id">1</span><span class="id"> /\</span><span class="id"> G</span><span class="id"> Q</span>.<span class="id">2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> forall</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">y</span><span class="id"> :</span><span class="id"> U</span>)<span class="id">,</span><span class="id"> Q</span>.<span class="id">1</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> Q</span>.<span class="id">2</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> P</span> (<span class="id">x,</span><span class="id"> y</span>))<br/>
&nbsp;&nbsp;&nbsp;<span class="id">&lt;-&gt;</span><span class="id"> \forall</span><span class="id"> x</span><span class="id"> \near</span> (<span class="id">F,</span><span class="id"> G</span>)<span class="id">,</span><span class="id"> P</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [][[A</span><span class="id"> B]</span><span class="id"> /=[FA</span><span class="id"> GB]</span><span class="id"> ABP];</span><span class="gallina-kwd"> exists</span> (<span class="id">A,</span><span class="id"> B</span>)<span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [a</span><span class="id"> b]</span><span class="id"> [/=Aa</span><span class="id"> Bb];</span><span class="id"> apply:</span><span class="id"> ABP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> b</span><span class="id"> Aa</span><span class="id"> Bb;</span><span class="id"> apply:</span> (<span class="id">ABP</span> (<span class="id">_,</span><span class="id"> _</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_ex2</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>)<br/>
&nbsp;&nbsp;<span class="id">{FF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F}</span><span class="id"> {FG</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> G}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">Q</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">F</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T,</span><span class="gallina-kwd"> exists2</span><span class="id"> y</span><span class="id"> :</span><span class="id"> U,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> Q</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /filter_ex</span><span class="id"> [x</span><span class="id"> Px]</span><span class="id"> /filter_ex</span><span class="id"> [y</span><span class="id"> Qy];</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> y</span>. Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> filter_ex2</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> F</span><span class="id"> G</span><span class="id"> FF</span><span class="id"> FG</span><span class="id"> _</span><span class="id"> _}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_fromP</span><span class="id"> {I</span><span class="id"> T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> `=&gt;`</span><span class="id"> filter_from</span><span class="id"> D</span><span class="id"> B</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> F</span> (<span class="id">B</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> FB</span><span class="id"> i</span><span class="id"> ?;</span><span class="id"> apply/FB/in_filter_from</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> FB</span><span class="id"> P</span><span class="id"> [i</span><span class="id"> Di</span><span class="id"> BjP];</span><span class="id"> apply:</span> (<span class="id">filterS</span><span class="id"> BjP</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> FB</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_fromTP</span><span class="id"> {I</span><span class="id"> T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">B</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> `=&gt;`</span><span class="id"> filter_from</span><span class="id"> setT</span><span class="id"> B</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> F</span> (<span class="id">B</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> FF;</span><span class="id"> rewrite</span><span class="id"> filter_fromP;</span><span class="id"> split=&gt;</span><span class="id"> [P</span><span class="id"> i|P</span><span class="id"> i</span><span class="id"> _];</span><span class="id"> apply:</span><span class="id"> P</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_from_filter</span><span class="id"> {I</span><span class="id"> T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">exists</span><span class="id"> i</span><span class="id"> :</span><span class="id"> I,</span><span class="id"> D</span><span class="id"> i</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i</span><span class="id"> j,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> D</span><span class="id"> j</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists2</span><span class="id"> k,</span><span class="id"> D</span><span class="id"> k</span><span class="id"> &amp;</span><span class="id"> B</span><span class="id"> k</span><span class="id"> `&lt;=`</span><span class="id"> B</span><span class="id"> i</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> j</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span> (<span class="id">filter_from</span><span class="id"> D</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [i0</span><span class="id"> Di0]</span><span class="id"> Binter;</span><span class="id"> constructor;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> i0</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> [i</span><span class="id"> Di</span><span class="id"> BiP]</span><span class="id"> [j</span><span class="id"> Dj</span><span class="id"> BjQ];</span><span class="id"> have</span><span class="id"> [k</span><span class="id"> Dk</span><span class="id"> BkPQ]:=</span><span class="id"> Binter</span><span class="id"> _</span><span class="id"> _</span><span class="id"> Di</span><span class="id"> Dj</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> /BkPQ</span><span class="id"> [/BiP</span><span class="id"> ?</span><span class="id"> /BjQ]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> subPQ</span><span class="id"> [i</span><span class="id"> Di</span><span class="id"> BiP];</span><span class="gallina-kwd"> exists</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> subset_trans</span><span class="id"> subPQ</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_fromT_filter</span><span class="id"> {I</span><span class="id"> T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">B</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">exists</span><span class="id"> _</span><span class="id"> :</span><span class="id"> I,</span><span class="id"> True</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i</span><span class="id"> j,</span><span class="gallina-kwd"> exists</span><span class="id"> k,</span><span class="id"> B</span><span class="id"> k</span><span class="id"> `&lt;=`</span><span class="id"> B</span><span class="id"> i</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> j</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span> (<span class="id">filter_from</span><span class="id"> setT</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [i0</span><span class="id"> _]</span><span class="id"> BI;</span><span class="id"> apply:</span><span class="id"> filter_from_filter;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> i0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> have</span><span class="id"> [k]</span><span class="id"> :=</span><span class="id"> BI</span><span class="id"> i</span><span class="id"> j;</span><span class="gallina-kwd"> exists</span><span class="id"> k</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_from_proper</span><span class="id"> {I</span><span class="id"> T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span> (<span class="id">filter_from</span><span class="id"> D</span><span class="id"> B</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> B</span><span class="id"> i</span><span class="id"> !=set0</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> (<span class="id">filter_from</span><span class="id"> D</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> BN0;</span><span class="id"> apply:</span><span class="id"> Build_ProperFilter_ex</span><span class="id"> =&gt;</span><span class="id"> P</span><span class="id"> [i</span><span class="id"> Di</span><span class="id"> BiP]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [x</span><span class="id"> Bix]</span><span class="id"> :=</span><span class="id"> BN0</span><span class="id"> _</span><span class="id"> Di;</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> BiP</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> eventually_filter</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> eventually</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">eapply</span><span class="id"> @filter_from_proper;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="id">apply:</span><span class="id"> filter_fromT_filter;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 0%N</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> i</span><span class="id"> j;</span><span class="gallina-kwd"> exists</span> (<span class="id">maxn</span><span class="id"> i</span><span class="id"> j</span>)<span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> geq_max</span><span class="id"> =&gt;</span><span class="id"> /andP[ltin</span><span class="id"> ltjn]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> eventually_filterType</span><span class="id"> :=</span><span class="id"> FilterType</span><span class="id"> eventually</span><span class="id"> _</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> eventually_pfilterType</span><span class="id"> :=</span><span class="id"> PFilterType</span><span class="id"> eventually</span> (<span class="id">filter_not_empty</span><span class="id"> _</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_bigI</span><span class="id"> T</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> I}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> F</span> (<span class="id">f</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">F</span> (<span class="id">\bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> [set`</span><span class="id"> D]</span>)<span class="id"> f</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> FfD</span>.<br/>
<span class="id">suff:</span><span class="id"> F</span><span class="id"> [set</span><span class="id"> p</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> enum_fset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> i</span><span class="id"> p]</span><span class="gallina-kwd"> by</span><span class="id"> []</span>.<br/>
<span class="id">have</span><span class="id"> {FfD}</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> enum_fset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> F</span> (<span class="id">f</span><span class="id"> i</span>)<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> /FfD</span>.<br/>
<span class="id">elim:</span> (<span class="id">enum_fset</span><span class="id"> D</span>)<span class="id"> =&gt;</span><span class="id"> [|i</span><span class="id"> s</span><span class="id"> ihs]</span><span class="id"> FfD;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> filterS</span><span class="id"> filterT</span>.<br/>
<span class="id">apply:</span> (<span class="id">@filterS</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">f</span><span class="id"> i</span><span class="id"> `&amp;`</span><span class="id"> [set</span><span class="id"> p</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> i</span><span class="id"> p]</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> p</span><span class="id"> [fip</span><span class="id"> fsp]</span><span class="id"> j;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /orP</span><span class="id"> [/eqP-&gt;|]</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> fsp</span>.<br/>
<span class="id">apply:</span><span class="id"> filterI;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> FfD;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> eq_refl</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> ihs</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> sj;</span><span class="id"> apply:</span><span class="id"> FfD;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> sj</span><span class="id"> orbC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_forall</span><span class="id"> T</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> finType</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i</span><span class="id"> :</span><span class="id"> I,</span><span class="id"> \forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> f</span><span class="id"> i</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> f</span><span class="id"> i</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> fIF;</span><span class="id"> apply:</span><span class="id"> filterS</span> (<span class="id">@filter_bigI</span><span class="id"> T</span><span class="id"> I</span><span class="id"> [fset</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> I]%fset</span><span class="id"> f</span><span class="id"> F</span><span class="id"> FF</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> fIx</span><span class="id"> i;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> fIx</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> inE/=;</span><span class="id"> apply</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> inE/=</span><span class="id"> =&gt;</span><span class="id"> _;</span><span class="id"> apply:</span> (<span class="id">fIF</span><span class="id"> i</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_imply</span><span class="id"> [T</span><span class="id"> :</span><span class="id"> Type]</span><span class="id"> [P</span><span class="id"> :</span><span class="id"> Prop]</span><span class="id"> [f</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T]</span><span class="id"> [F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T]</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span> (<span class="id">P</span><span class="id"> -&gt;</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> f</span><span class="id"> F</span>)<span class="id"> -&gt;</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ?</span><span class="id"> PF;</span><span class="id"> near</span><span class="id"> do</span><span class="id"> move=&gt;</span><span class="id"> /asboolP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> asboolP=&gt;</span><span class="id"> [/PF|_];</span><span class="gallina-kwd"> by</span><span class="id"> [apply:</span><span class="id"> filterS|apply:</span><span class="id"> nearW]</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<div class="doc">Limits expressed with filters </div>
<br/>
<span class="vernacular">Definition</span><span class="id"> fmap</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> P</span><span class="id"> |</span><span class="id"> F</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> P</span>)<span class="id">]</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> fmap</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> /</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fmapE</span><span class="id"> {U</span><span class="id"> V</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> V</span>)<span class="id"> :</span><span class="id"> fmap</span><span class="id"> f</span><span class="id"> F</span><span class="id"> P</span><span class="id"> =</span><span class="id"> F</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> P</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;E @[ x --&gt; F ]&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">fmap</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> E</span>) (<span class="id">nbhs</span><span class="id"> F</span>))<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;E @[ x \oo ]&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">fmap</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> E</span>)<span class="id"> \oo</span>)<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;f @ F&quot;</span><span class="id"> :=</span> (<span class="id">fmap</span><span class="id"> f</span> (<span class="id">nbhs</span><span class="id"> F</span>))<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span><span class="id"> limn</span><span class="id"> F</span><span class="id"> :=</span> (<span class="id">lim</span> (<span class="id">F</span><span class="id"> @</span><span class="id"> \oo</span>)).<br/>
<span class="vernacular">Notation</span><span class="id"> cvgn</span><span class="id"> F</span><span class="id"> :=</span> (<span class="id">cvg</span> (<span class="id">F</span><span class="id"> @</span><span class="id"> \oo</span>)).<br/>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> fmap_filter</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> Filter</span> (<span class="id">f</span><span class="id"> @</span><span class="id"> F</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF;</span><span class="id"> constructor</span><span class="id"> =&gt;</span><span class="id"> [|P</span><span class="id"> Q|P</span><span class="id"> Q</span><span class="id"> PQ];</span><span class="id"> rewrite</span><span class="id"> ?fmapE</span><span class="id"> //=</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> filterT</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> filterI</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterS=&gt;</span><span class="id"> ?/PQ</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> fmap_proper_filter</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> ProperFilter</span> (<span class="id">f</span><span class="id"> @</span><span class="id"> F</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> FF;</span><span class="id"> apply:</span><span class="id"> Build_ProperFilter;</span><span class="id"> rewrite</span><span class="id"> fmapE</span><span class="id"> preimage_set0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> fmapi</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_system</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> P</span><span class="id"> |</span><span class="id"> \forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="gallina-kwd"> exists</span><span class="id"> y,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /\</span><span class="id"> P</span><span class="id"> y]</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;E `@[ x --&gt; F ]&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">fmapi</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> E</span>) (<span class="id">nbhs</span><span class="id"> F</span>))<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;f `@ F&quot;</span><span class="id"> :=</span> (<span class="id">fmapi</span><span class="id"> f</span> (<span class="id">nbhs</span><span class="id"> F</span>))<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fmapiE</span><span class="id"> {U</span><span class="id"> V</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> V</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">fmapi</span><span class="id"> f</span><span class="id"> F</span><span class="id"> P</span><span class="id"> =</span><span class="id"> \forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="gallina-kwd"> exists</span><span class="id"> y,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /\</span><span class="id"> P</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> fmapi_filter</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{near</span><span class="id"> F,</span><span class="id"> is_totalfun</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> Filter</span> (<span class="id">f</span><span class="id"> `@</span><span class="id"> F</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> f_totalfun</span><span class="id"> FF;</span><span class="id"> rewrite</span><span class="id"> /fmapi;</span><span class="id"> apply:</span><span class="id"> Build_Filter</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> f_totalfun</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> [[y</span><span class="id"> Hy]</span><span class="id"> H];</span><span class="gallina-kwd"> exists</span><span class="id"> y</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> /=</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> FP</span><span class="id"> FQ;</span><span class="id"> near=&gt;</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [//|y</span><span class="id"> [fxy</span><span class="id"> Py]]</span><span class="id"> :=</span><span class="id"> near</span><span class="id"> FP</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [//|z</span><span class="id"> [fxz</span><span class="id"> Qz]]</span><span class="id"> :=</span><span class="id"> near</span><span class="id"> FQ</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [//|_</span><span class="id"> fx_prop]</span><span class="id"> :=</span><span class="id"> near</span><span class="id"> f_totalfun</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> y;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> [y]</span>(<span class="id">fx_prop</span><span class="id"> _</span><span class="id"> z</span>).<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> /=</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> subPQ</span><span class="id"> FP;</span><span class="id"> near=&gt;</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [//|y</span><span class="id"> [fxy</span><span class="id"> /subPQ</span><span class="id"> Qy]]</span><span class="id"> :=</span><span class="id"> near</span><span class="id"> FP</span><span class="id"> x;</span><span class="gallina-kwd"> exists</span><span class="id"> y</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="id">#[global]</span><span class="id"> Typeclasses</span><span class="vernacular"> Opaque</span><span class="id"> fmapi</span>.<br/>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> fmapi_proper_filter</span><br/>
&nbsp;&nbsp;<span class="id">T</span><span class="id"> U</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{near</span><span class="id"> F,</span><span class="id"> is_totalfun</span><span class="id"> f}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> ProperFilter</span> (<span class="id">f</span><span class="id"> `@</span><span class="id"> F</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> f_totalfun</span><span class="id"> FF;</span><span class="id"> apply:</span><span class="id"> Build_ProperFilter_ex</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> P;</span><span class="id"> rewrite</span><span class="id"> /fmapi/=</span><span class="id"> =&gt;</span><span class="id"> /filter_ex</span><span class="id"> [x</span><span class="id"> [y</span><span class="id"> [??]]];</span><span class="gallina-kwd"> exists</span><span class="id"> y</span>.<br/>
<span class="id">exact:</span><span class="id"> fmapi_filter</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_id</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> x</span><span class="id"> @[x</span><span class="id"> --&gt;</span><span class="id"> F]</span><span class="id"> --&gt;</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact</span>. Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> cvg_id</span><span class="id"> {T</span><span class="id"> F}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fmap_comp</span><span class="id"> {A</span><span class="id"> B</span><span class="id"> C}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> C</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> B</span>)<span class="id"> F:</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span> (<span class="id">f</span><span class="id"> \o</span><span class="id"> g</span>)<span class="id">%FUN</span><span class="id"> @</span><span class="id"> F</span><span class="id"> =</span><span class="id"> f</span><span class="id"> @</span> (<span class="id">g</span><span class="id"> @</span><span class="id"> F</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> appfilter</span><span class="id"> U</span><span class="id"> V</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> @</span><span class="id"> F</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> _</span><span class="id"> |</span><span class="id"> \forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> P</span> (<span class="id">f</span><span class="id"> x</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_app</span><span class="id"> U</span><span class="id"> V</span> (<span class="id">F</span><span class="id"> G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">F</span><span class="id"> --&gt;</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> @</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f</span><span class="id"> @</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> FG</span><span class="id"> P</span><span class="id"> /=;</span><span class="id"> exact:</span><span class="id"> FG</span>. Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> cvg_app</span><span class="id"> {U</span><span class="id"> V</span><span class="id"> F</span><span class="id"> G}</span><span class="id"> _</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvgi_app</span><span class="id"> U</span><span class="id"> V</span> (<span class="id">F</span><span class="id"> G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">F</span><span class="id"> --&gt;</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> `@</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f</span><span class="id"> `@</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> FG</span><span class="id"> P</span><span class="id"> /=;</span><span class="id"> exact:</span><span class="id"> FG</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_comp</span><span class="id"> T</span><span class="id"> U</span><span class="id"> V</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>) (<span class="id">H</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> @</span><span class="id"> F</span><span class="id"> `=&gt;`</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> g</span><span class="id"> @</span><span class="id"> G</span><span class="id"> `=&gt;`</span><span class="id"> H</span><span class="id"> -&gt;</span><span class="id"> g</span><span class="id"> \o</span><span class="id"> f</span><span class="id"> @</span><span class="id"> F</span><span class="id"> `=&gt;`</span><span class="id"> H</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> fFG</span><span class="id"> gGH;</span><span class="id"> apply:</span><span class="id"> cvg_trans</span><span class="id"> gGH</span><span class="id"> =&gt;</span><span class="id"> P</span><span class="id"> /fFG</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvgi_comp</span><span class="id"> T</span><span class="id"> U</span><span class="id"> V</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> V</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>) (<span class="id">H</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> @</span><span class="id"> F</span><span class="id"> `=&gt;`</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> g</span><span class="id"> `@</span><span class="id"> G</span><span class="id"> `=&gt;`</span><span class="id"> H</span><span class="id"> -&gt;</span><span class="id"> g</span><span class="id"> \o</span><span class="id"> f</span><span class="id"> `@</span><span class="id"> F</span><span class="id"> `=&gt;`</span><span class="id"> H</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> fFG</span><span class="id"> gGH;</span><span class="id"> apply:</span><span class="id"> cvg_trans</span><span class="id"> gGH</span><span class="id"> =&gt;</span><span class="id"> P</span><span class="id"> /fFG</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_eq_cvg</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T}</span><span class="id"> {FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F}</span> (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{near</span><span class="id"> F,</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> g}</span><span class="id"> -&gt;</span><span class="id"> g</span><span class="id"> @</span><span class="id"> F</span><span class="id"> `=&gt;`</span><span class="id"> f</span><span class="id"> @</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq_fg</span><span class="id"> P</span><span class="id"> /=;</span><span class="id"> apply:</span><span class="id"> filterS2</span><span class="id"> eq_fg</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=</span><span class="id"> &lt;-</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_cvg</span> (<span class="id">T</span><span class="id"> T'</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T'</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> =1</span><span class="id"> g</span><span class="id"> -&gt;</span> (<span class="id">f</span><span class="id"> @</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="id">g</span><span class="id"> @</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /funext-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_is_cvg_in</span> (<span class="id">T</span><span class="id"> T'</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">fT</span><span class="id"> :</span><span class="id"> pfilteredType</span><span class="id"> T'</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> =1</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> [cvg</span> (<span class="id">f</span><span class="id"> @</span><span class="id"> F</span>)<span class="gallina-kwd"> in</span><span class="id"> fT]</span><span class="id"> =</span><span class="id"> [cvg</span> (<span class="id">g</span><span class="id"> @</span><span class="id"> F</span>)<span class="gallina-kwd"> in</span><span class="id"> fT]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /funext-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_is_cvg</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">T'</span><span class="id"> :</span><span class="id"> pnbhsType</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> =1</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> cvg</span> (<span class="id">f</span><span class="id"> @</span><span class="id"> F</span>)<span class="id"> =</span><span class="id"> cvg</span> (<span class="id">g</span><span class="id"> @</span><span class="id"> F</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /funext-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> neari_eq_loc</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T}</span><span class="id"> {FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F}</span> (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{near</span><span class="id"> F,</span><span class="id"> f</span><span class="id"> =2</span><span class="id"> g}</span><span class="id"> -&gt;</span><span class="id"> g</span><span class="id"> `@</span><span class="id"> F</span><span class="id"> `=&gt;`</span><span class="id"> f</span><span class="id"> `@</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_fg</span><span class="id"> P</span><span class="id"> /=;</span><span class="id"> apply:</span><span class="id"> filterS2</span><span class="id"> eq_fg</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> eq_fg</span><span class="id"> [y</span><span class="id"> [fxy</span><span class="id"> Py]]</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> -eq_fg</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_near_const</span> (<span class="id">T</span><span class="id"> U</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> ProperFilter</span><span class="id"> G</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> G,</span><span class="id"> \forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> =</span><span class="id"> y</span>)<span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> @</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> FG</span><span class="id"> fFG</span><span class="id"> P</span><span class="id"> /=</span><span class="id"> GP;</span><span class="id"> rewrite</span><span class="id"> !near_simpl;</span><span class="id"> apply:</span> (<span class="id">have_near</span><span class="id"> G</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> filter_app</span><span class="id"> fFG;</span><span class="id"> near</span><span class="id"> do</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=</span><span class="id"> -&gt;</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> continuous_at</span> (<span class="id">T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> nbhsType</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">f%function</span><span class="id"> @</span><span class="id"> x</span><span class="id"> --&gt;</span><span class="id"> f%function</span><span class="id"> x</span>).<br/>
<span class="vernacular">Notation</span><span class="id"> continuous</span><span class="id"> f</span><span class="id"> :=</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> continuous_at</span><span class="id"> x</span><span class="id"> f</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_fun</span> (<span class="id">T</span><span class="id"> T'</span><span class="id"> :</span><span class="id"> nbhsType</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T'</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> T'</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{for</span><span class="id"> x,</span><span class="id"> continuous</span><span class="id"> f}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> f</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> y</span>)<span class="id"> -&gt;</span> (<span class="id">\near</span><span class="id"> x,</span><span class="id"> P</span> (<span class="id">f</span><span class="id"> x</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact</span>. Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> near_fun</span><span class="id"> {T</span><span class="id"> T'}</span><span class="id"> f</span><span class="id"> x</span>.<br/>
<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> globally</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">[set</span><span class="id"> P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> A</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> x]</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> globally</span><span class="id"> {T}</span><span class="id"> A</span><span class="id"> _</span><span class="id"> /</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> globally0</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> globally</span><span class="id"> set0</span><span class="id"> A</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> globally_filter</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span> (<span class="id">globally</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">constructor</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> P</span><span class="id"> Q;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> PQ</span><span class="id"> AP</span><span class="id"> x</span><span class="id"> /AP</span><span class="id"> /PQ</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> AP</span><span class="id"> AQ</span><span class="id"> x</span><span class="id"> Ax;</span><span class="id"> split;</span><span class="id"> [apply:</span><span class="id"> AP|apply:</span><span class="id"> AQ]</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> globally_properfilter</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> a</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> a</span><span class="id"> -&gt;</span><span class="id"> ProperFilter</span> (<span class="id">globally</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Aa;</span><span class="id"> apply:</span><span class="id"> Build_ProperFilter</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> a</span>)<span class="id">;</span><span class="id"> exact</span>. Qed.</div></details>
<br/>
<div class="doc">Specific filters </div>
<br/>
<span class="vernacular">Section</span><span class="id"> frechet_filter</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> frechet_filter</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> S</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> |</span><span class="id"> finite_set</span> (<span class="id">~`</span><span class="id"> S</span>)<span class="id">]</span>.<br/>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> frechet_properfilter</span><span class="id"> :</span><span class="id"> infinite_set</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span><span class="id"> frechet_filter</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> infT;</span><span class="id"> rewrite</span><span class="id"> /frechet_filter</span>.<br/>
<span class="id">constructor;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> setC0;</span><span class="id"> exact:</span><span class="id"> infT</span>.<br/>
<span class="id">constructor;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> setCT</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> setCI</span><span class="id"> finite_setU</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> PQ;</span><span class="id"> exact/sub_finite_set/subsetC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> frechet_filter</span>.<br/>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> frechet_properfilter_nat</span><span class="id"> :</span><span class="id"> ProperFilter</span> (<span class="id">@frechet_filter</span><span class="id"> nat</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> frechet_properfilter;</span><span class="id"> exact:</span><span class="id"> infinite_nat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> at_point</span>.<br/>
<br/>
<span class="vernacular">Context</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> at_point</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="gallina-kwd"> Prop</span><span class="id"> :=</span><span class="id"> P</span><span class="id"> a</span>.<br/>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> at_point_filter</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> ProperFilter</span> (<span class="id">at_point</span><span class="id"> a</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> constructor=&gt;</span><span class="id"> //;</span><span class="id"> constructor=&gt;</span><span class="id"> //</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> subPQ</span><span class="id"> /subPQ</span>. Qed.</div></details>
<span class="id">Typeclasses</span><span class="vernacular"> Opaque</span><span class="id"> at_point</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> at_point</span>.<br/>
<br/>
<div class="doc">Filters for pairs </div>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> filter_prod_filter</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> Filter</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> Filter</span> (<span class="id">filter_prod</span><span class="id"> F</span><span class="id"> G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> FG;</span><span class="id"> apply:</span><span class="id"> filter_from_filter</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">setT,</span><span class="id"> setT</span>)<span class="id">;</span><span class="id"> split;</span><span class="id"> apply:</span><span class="id"> filterT</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> [P</span><span class="id"> Q]</span><span class="id"> [P'</span><span class="id"> Q']</span><span class="id"> /=</span><span class="id"> [FP</span><span class="id"> GQ]</span><span class="id"> [FP'</span><span class="id"> GQ']</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> P',</span><span class="id"> Q</span><span class="id"> `&amp;`</span><span class="id"> Q'</span>)<span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> split;</span><span class="id"> apply:</span><span class="id"> filterI</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [x</span><span class="id"> y]</span><span class="id"> [/=</span><span class="id"> [??]</span><span class="id"> []]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> prod_filter_on</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> filter_on</span><span class="id"> T</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> filter_on</span><span class="id"> U</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">FilterType</span> (<span class="id">filter_prod</span><span class="id"> F</span><span class="id"> G</span>) (<span class="id">filter_prod_filter</span><span class="id"> _</span><span class="id"> _</span>).<br/>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> filter_prod_proper</span><span class="id"> {T1</span><span class="id"> T2</span><span class="id"> :</span><span class="id"> Type}</span><br/>
&nbsp;&nbsp;<span class="id">{F</span><span class="id"> :</span> (<span class="id">T1</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> -&gt;</span><span class="id"> Prop}</span><span class="id"> {G</span><span class="id"> :</span> (<span class="id">T2</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> -&gt;</span><span class="id"> Prop}</span><br/>
&nbsp;&nbsp;<span class="id">{FF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F}</span><span class="id"> {FG</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> G}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> (<span class="id">filter_prod</span><span class="id"> F</span><span class="id"> G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> filter_from_proper</span><span class="id"> =&gt;</span><span class="id"> -[A</span><span class="id"> B]</span><span class="id"> [/=FA</span><span class="id"> GB]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [[x</span><span class="id"> ?]</span><span class="id"> [y</span><span class="id"> ?]]</span><span class="id"> :=</span> (<span class="id">filter_ex</span><span class="id"> FA,</span><span class="id"> filter_ex</span><span class="id"> GB</span>)<span class="id">;</span><span class="gallina-kwd"> exists</span> (<span class="id">x,</span><span class="id"> y</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_prod1</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T}</span><span class="id"> {G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U}</span><br/>
&nbsp;&nbsp;<span class="id">{FG</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> G}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> \forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F</span><span class="id"> &amp;</span><span class="id"> _</span><span class="id"> \near</span><span class="id"> G,</span><span class="id"> P</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FP;</span><span class="gallina-kwd"> exists</span> (<span class="id">P,</span><span class="id"> setT</span>)<span class="id">=&gt;</span><span class="id"> //=</span><span class="id"> [|[??</span><span class="id"> []//]]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> filterT</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_prod2</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T}</span><span class="id"> {G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U}</span><br/>
&nbsp;&nbsp;<span class="id">{FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> G,</span><span class="id"> P</span><span class="id"> y</span>)<span class="id"> -&gt;</span><span class="id"> \forall</span><span class="id"> _</span><span class="id"> \near</span><span class="id"> F</span><span class="id"> &amp;</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> G,</span><span class="id"> P</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FP;</span><span class="gallina-kwd"> exists</span> (<span class="id">setT,</span><span class="id"> P</span>)<span class="id">=&gt;</span><span class="id"> //=</span><span class="id"> [|[??</span><span class="id"> []//]]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> filterT</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">Program</span><span class="vernacular"> Definition</span><span class="id"> in_filter_prod</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T}</span><span class="id"> {G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U}</span><br/>
&nbsp;&nbsp;(<span class="id">P</span><span class="id"> :</span><span class="id"> in_filter</span><span class="id"> F</span>) (<span class="id">Q</span><span class="id"> :</span><span class="id"> in_filter</span><span class="id"> G</span>)<span class="id"> :</span><span class="id"> in_filter</span> (<span class="id">filter_prod</span><span class="id"> F</span><span class="id"> G</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@InFilter</span><span class="id"> _</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> prop_of</span><span class="id"> P</span><span class="id"> x</span>.<span class="id">1</span><span class="id"> /\</span><span class="id"> prop_of</span><span class="id"> Q</span><span class="id"> x</span>.<span class="id">2</span>)<span class="id"> _</span>.<br/>
<details>
<summary class="toggleproof">Next Obligation.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> T</span><span class="id"> U</span><span class="id"> F</span><span class="id"> G</span><span class="id"> P</span><span class="id"> Q</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">prop_of</span><span class="id"> P,</span><span class="id"> prop_of</span><span class="id"> Q</span>)<span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> split;</span><span class="id"> apply:</span><span class="id"> prop_ofP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_pair</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T}</span><span class="id"> {G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F}</span><span class="id"> {FG</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> G}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P</span><span class="id"> :</span><span class="id"> in_filter</span><span class="id"> F</span>) (<span class="id">Q</span><span class="id"> :</span><span class="id"> in_filter</span><span class="id"> G</span>)<span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">prop_of</span><span class="id"> P</span><span class="id"> x</span>.<span class="id">1</span><span class="id"> -&gt;</span><span class="id"> prop_of</span><span class="id"> Q</span><span class="id"> x</span>.<span class="id">2</span><span class="id"> -&gt;</span><span class="id"> prop_of</span> (<span class="id">in_filter_prod</span><span class="id"> P</span><span class="id"> Q</span>)<span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> x=&gt;</span><span class="id"> x</span><span class="id"> y;</span><span class="id"> do</span><span class="id"> ?rewrite</span><span class="id"> prop_ofE</span><span class="id"> /=;</span><span class="id"> split</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_fst</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> F</span><span class="id"> G}</span><span class="id"> {FG</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> G}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">@fst</span><span class="id"> T</span><span class="id"> U</span>)<span class="id"> @</span><span class="id"> filter_prod</span><span class="id"> F</span><span class="id"> G</span><span class="id"> --&gt;</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> P;</span><span class="id"> apply:</span><span class="id"> filter_prod1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_snd</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> F</span><span class="id"> G}</span><span class="id"> {FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">@snd</span><span class="id"> T</span><span class="id"> U</span>)<span class="id"> @</span><span class="id"> filter_prod</span><span class="id"> F</span><span class="id"> G</span><span class="id"> --&gt;</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> P;</span><span class="id"> apply:</span><span class="id"> filter_prod2</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_map</span><span class="id"> {T</span><span class="id"> U}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> f</span><span class="id"> @</span><span class="id"> F,</span><span class="id"> P</span><span class="id"> y</span>)<span class="id"> =</span> (<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> P</span> (<span class="id">f</span><span class="id"> x</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_map2</span><span class="id"> {T</span><span class="id"> T'</span><span class="id"> U</span><span class="id"> U'}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> T'</span><span class="id"> -&gt;</span><span class="id"> U'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T'</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> U'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> Filter</span><span class="id"> G</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> f</span><span class="id"> @</span><span class="id"> F</span><span class="id"> &amp;</span><span class="id"> y'</span><span class="id"> \near</span><span class="id"> g</span><span class="id"> @</span><span class="id"> G,</span><span class="id"> P</span><span class="id"> y</span><span class="id"> y'</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F</span>    <span class="id"> &amp;</span><span class="id"> x'</span><span class="id"> \near</span><span class="id"> G</span>    <span class="id"> ,</span><span class="id"> P</span> (<span class="id">f</span><span class="id"> x</span>) (<span class="id">g</span><span class="id"> x'</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> FG;</span><span class="id"> rewrite</span><span class="id"> propeqE;</span><span class="id"> split=&gt;</span><span class="id"> -[[A</span><span class="id"> B]</span><span class="id"> /=</span><span class="id"> [fFA</span><span class="id"> fGB]</span><span class="id"> ABP]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> A,</span><span class="id"> g</span><span class="id"> @^-1`</span><span class="id"> B</span>)<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> -[x</span><span class="id"> y</span><span class="id"> /=]</span><span class="id"> xyAB</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">ABP</span> (<span class="id">_,</span><span class="id"> _</span>))<span class="id">;</span><span class="id"> apply:</span><span class="id"> xyAB</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> A,</span><span class="id"> g</span><span class="id"> @`</span><span class="id"> B</span>)<span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> -_</span><span class="id"> [/=</span><span class="id"> [x</span><span class="id"> Ax</span><span class="id"> &lt;-]</span><span class="id"> [x'</span><span class="id"> Bx'</span><span class="id"> &lt;-]];</span><span class="id"> apply:</span> (<span class="id">ABP</span> (<span class="id">_,</span><span class="id"> _</span>)).<br/>
<span class="id">rewrite</span><span class="id"> !nbhs_simpl</span><span class="id"> /fmap</span><span class="id"> /=;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> fFA=&gt;</span><span class="id"> x</span><span class="id"> Ax;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> fGB</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> Bx;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_mapi</span><span class="id"> {T</span><span class="id"> U}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> f</span><span class="id"> `@</span><span class="id"> F,</span><span class="id"> P</span><span class="id"> y</span>)<span class="id"> =</span> (<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="gallina-kwd"> exists</span><span class="id"> y,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /\</span><span class="id"> P</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_pair_set</span> (<span class="id">T</span><span class="id"> T'</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">F'</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> Filter</span><span class="id"> F'</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">P'</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'</span>) (<span class="id">Q</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> T'</span>))<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> x',</span><span class="id"> P</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> P'</span><span class="id"> x'</span><span class="id"> -&gt;</span><span class="id"> Q</span> (<span class="id">x,</span><span class="id"> x'</span>))<span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> P</span><span class="id"> /\</span><span class="id"> F'</span><span class="id"> P'</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">filter_prod</span><span class="id"> F</span><span class="id"> F'</span><span class="id"> Q</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> FF</span><span class="id"> FF'</span><span class="id"> P</span><span class="id"> P'</span><span class="id"> Q</span><span class="id"> PQ</span><span class="id"> [FP</span><span class="id"> FP'];</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">near=&gt;</span><span class="id"> x</span><span class="id"> do</span><span class="id"> [have</span><span class="id"> :=</span><span class="id"> PQ</span><span class="id"> x</span>.<span class="id">1</span><span class="id"> x</span>.<span class="id">2;</span><span class="id"> rewrite</span><span class="id"> -surjective_pairing;</span><span class="id"> apply];</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">[apply:</span><span class="id"> cvg_fst</span><span class="id"> |</span><span class="id"> apply:</span><span class="id"> cvg_snd]</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_pair_near_of</span> (<span class="id">T</span><span class="id"> T'</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">F'</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> Filter</span><span class="id"> F'</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> @in_filter</span><span class="id"> T</span><span class="id"> F</span>) (<span class="id">P'</span><span class="id"> :</span><span class="id"> @in_filter</span><span class="id"> T'</span><span class="id"> F'</span>) (<span class="id">Q</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> T'</span>))<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> x',</span><span class="id"> prop_of</span><span class="id"> P</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> prop_of</span><span class="id"> P'</span><span class="id"> x'</span><span class="id"> -&gt;</span><span class="id"> Q</span> (<span class="id">x,</span><span class="id"> x'</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">filter_prod</span><span class="id"> F</span><span class="id"> F'</span><span class="id"> Q</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> FF'</span><span class="id"> [P</span><span class="id"> FP]</span><span class="id"> [P'</span><span class="id"> FP']</span><span class="id"> Q</span><span class="id"> PQ;</span><span class="id"> rewrite</span><span class="id"> prop_ofE</span><span class="gallina-kwd"> in</span><span class="id"> FP</span><span class="id"> FP'</span><span class="id"> PQ</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">P,</span><span class="id"> P'</span>)<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> -[t</span><span class="id"> t']</span><span class="id"> []</span><span class="id"> /=;</span><span class="id"> exact:</span><span class="id"> PQ</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;near=&gt;&quot;</span><span class="id"> ident</span>(<span class="id">x</span>)<span class="id"> ident</span>(<span class="id">y</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">apply:</span><span class="id"> filter_pair_near_of</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> ?</span><span class="id"> ?</span>).<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;near&quot;</span><span class="id"> constr</span>(<span class="id">F</span>) <span class="id">&quot;=&gt;&quot;</span><span class="id"> ident</span>(<span class="id">x</span>)<span class="id"> ident</span>(<span class="id">y</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">have_near</span><span class="id"> F</span>)<span class="id">;</span><span class="id"> near=&gt;</span><span class="id"> x</span><span class="id"> y</span>.<br/>
<br/>
<span class="vernacular">Module</span><span class="vernacular"> Export</span><span class="id"> NearMap</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> near_simpl</span><span class="id"> :=</span> (<span class="id">@near_simpl,</span><span class="id"> @near_map,</span><span class="id"> @near_mapi,</span><span class="id"> @near_map2</span>).<br/>
<span class="vernacular">Ltac</span><span class="id"> near_simpl</span><span class="id"> :=</span><span class="id"> rewrite</span><span class="id"> ?near_simpl</span>.<br/>
<span class="vernacular">End</span><span class="id"> NearMap</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filterN</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> numDomainType}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> R</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> -</span><span class="id"> x</span><span class="id"> @[x</span><span class="id"> --&gt;</span><span class="id"> F],</span> (<span class="id">P</span><span class="id"> \o</span><span class="id"> -%R</span>)<span class="id"> x</span>)<span class="id"> =</span><span class="id"> \forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> P</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> near_simpl/=</span><span class="id"> !nearE;</span><span class="id"> under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> opprK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_pair</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> V</span><span class="id"> F}</span><span class="id"> {G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U}</span><span class="id"> {H</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> V}</span><br/>
&nbsp;&nbsp;<span class="id">{FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F}</span><span class="id"> {FG</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> G}</span><span class="id"> {FH</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> H}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> @</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> g</span><span class="id"> @</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> H</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">f</span><span class="id"> x,</span><span class="id"> g</span><span class="id"> x</span>)<span class="id"> @[x</span><span class="id"> --&gt;</span><span class="id"> F]</span><span class="id"> --&gt;</span> (<span class="id">G,</span><span class="id"> H</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> fFG</span><span class="id"> gFH</span><span class="id"> P;</span><span class="id"> rewrite</span><span class="id"> !near_simpl</span><span class="id"> =&gt;</span><span class="id"> -[[A</span><span class="id"> B]</span><span class="id"> /=[GA</span><span class="id"> HB]</span><span class="id"> ABP];</span><span class="id"> near=&gt;</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">ABP</span> (<span class="id">_,</span><span class="id"> _</span>))<span class="id">;</span><span class="id"> split=&gt;</span><span class="id"> //=;</span><span class="id"> near:</span><span class="id"> x;</span><span class="id"> [apply:</span><span class="id"> fFG|apply:</span><span class="id"> gFH]</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_comp2</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> V</span><span class="id"> W}</span><br/>
&nbsp;&nbsp;<span class="id">{F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T}</span><span class="id"> {G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U}</span><span class="id"> {H</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> V}</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> W}</span><br/>
&nbsp;&nbsp;<span class="id">{FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F}</span><span class="id"> {FG</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> G}</span><span class="id"> {FH</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> H}</span><br/>
&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> V</span>) (<span class="id">h</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> W</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> @</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> g</span><span class="id"> @</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> H</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">h</span> (<span class="id">fst</span><span class="id"> x</span>) (<span class="id">snd</span><span class="id"> x</span>)<span class="id"> @[x</span><span class="id"> --&gt;</span> (<span class="id">G,</span><span class="id"> H</span>)<span class="id">]</span><span class="id"> --&gt;</span><span class="id"> I</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">h</span> (<span class="id">f</span><span class="id"> x</span>) (<span class="id">g</span><span class="id"> x</span>)<span class="id"> @[x</span><span class="id"> --&gt;</span><span class="id"> F]</span><span class="id"> --&gt;</span><span class="id"> I</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> fFG</span><span class="id"> gFH</span><span class="id"> hGHI</span><span class="id"> P</span><span class="id"> /=</span><span class="id"> IP;</span><span class="id"> apply:</span><span class="id"> cvg_pair</span> (<span class="id">hGHI</span><span class="id"> _</span><span class="id"> IP</span>). Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> cvg_comp2</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> V</span><span class="id"> W</span><span class="id"> F</span><span class="id"> G</span><span class="id"> H</span><span class="id"> I</span><span class="id"> FF</span><span class="id"> FG</span><span class="id"> FH</span><span class="id"> f</span><span class="id"> g</span><span class="id"> h}</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> cvg_to_comp_2</span><span class="id"> :=</span><span class="id"> @cvg_comp2</span>.<br/>
<br/>
<br/>
<div class="doc">Restriction of a filter to a domain </div>
<br/>
<span class="vernacular">Section</span><span class="id"> within</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> within</span><span class="id"> D</span><span class="id"> F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> P</span><span class="id"> |</span><span class="id"> {near</span><span class="id"> F,</span><span class="id"> D</span><span class="id"> `&lt;=`</span><span class="id"> P}]</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> within</span><span class="id"> :</span><span class="id"> simpl</span><span class="id"> never</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_withinE</span><span class="id"> D</span><span class="id"> F</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> within</span><span class="id"> D</span><span class="id"> F,</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> {near</span><span class="id"> F,</span><span class="id"> D</span><span class="id"> `&lt;=`</span><span class="id"> P}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> withinT</span><span class="id"> F</span><span class="id"> D</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> within</span><span class="id"> D</span><span class="id"> F</span><span class="id"> D</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> FF;</span><span class="id"> rewrite</span><span class="id"> /within/=;</span><span class="id"> apply:</span><span class="id"> filterE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_withinT</span><span class="id"> F</span><span class="id"> D</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> \forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> within</span><span class="id"> D</span><span class="id"> F,</span><span class="id"> D</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> withinT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_within</span><span class="id"> {F}</span><span class="id"> {FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F}</span><span class="id"> D</span><span class="id"> :</span><span class="id"> within</span><span class="id"> D</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> P;</span><span class="id"> apply:</span><span class="id"> filterS</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> withinET</span><span class="id"> {F}</span><span class="id"> {FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F}</span><span class="id"> :</span><span class="id"> within</span><span class="id"> setT</span><span class="id"> F</span><span class="id"> =</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> eqEsubset</span><span class="id"> /within;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> X</span><span class="id"> //=;</span><br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> filter_app</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x;</span><span class="id"> apply</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> within</span>.<br/>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> within_filter</span><span class="id"> T</span><span class="id"> D</span><span class="id"> F</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> Filter</span> (<span class="id">@within</span><span class="id"> T</span><span class="id"> D</span><span class="id"> F</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF;</span><span class="id"> rewrite</span><span class="id"> /within;</span><span class="id"> constructor</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterE</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> P</span><span class="id"> Q;</span><span class="id"> apply:</span><span class="id"> filterS2</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> DP</span><span class="id"> DQ</span><span class="id"> Dx;</span><span class="id"> split;</span><span class="id"> [apply:</span><span class="id"> DP|apply:</span><span class="id"> DQ]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> subPQ;</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> DP</span><span class="id"> /DP</span><span class="id"> /subPQ</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">#[global]</span><span class="id"> Typeclasses</span><span class="vernacular"> Opaque</span><span class="id"> within</span>.<br/>
<br/>
<span class="vernacular">Canonical</span><span class="id"> within_filter_on</span><span class="id"> T</span><span class="id"> D</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> filter_on</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">FilterType</span> (<span class="id">within</span><span class="id"> D</span><span class="id"> F</span>) (<span class="id">within_filter</span><span class="id"> _</span><span class="id"> _</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_bigI_within</span><span class="id"> T</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> I}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> [set</span><span class="id"> j</span><span class="id"> |</span><span class="id"> P</span><span class="id"> j</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> i</span><span class="id"> j]</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">F</span> (<span class="id">[set</span><span class="id"> j</span><span class="id"> |</span><span class="id"> P</span><span class="id"> j</span><span class="id"> -&gt;</span> (<span class="id">\bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> [set`</span><span class="id"> D]</span>)<span class="id"> f</span><span class="id"> i</span>)<span class="id"> j]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> move=&gt;</span><span class="id"> FF</span><span class="id"> FfD;</span><span class="id"> exact:</span> (<span class="id">@filter_bigI</span><span class="id"> T</span><span class="id"> I</span><span class="id"> D</span><span class="id"> f</span><span class="id"> _</span> (<span class="id">within_filter</span><span class="id"> P</span><span class="id"> FF</span>)). Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> subset_filter</span><span class="id"> {T}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {x</span><span class="id"> |</span><span class="id"> D</span><span class="id"> x}</span><span class="id"> |</span><span class="id"> F</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> Dx</span><span class="id"> :</span><span class="id"> D</span><span class="id"> x,</span><span class="id"> P</span> (<span class="id">exist</span><span class="id"> _</span><span class="id"> x</span><span class="id"> Dx</span>)<span class="id">]]</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> subset_filter</span><span class="id"> {T}</span><span class="id"> F</span><span class="id"> D</span><span class="id"> _</span>.<br/>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> subset_filter_filter</span><span class="id"> T</span><span class="id"> F</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> Filter</span> (<span class="id">subset_filter</span><span class="id"> F</span><span class="id"> D</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF;</span><span class="id"> constructor;</span><span class="id"> rewrite</span><span class="id"> /subset_filter/=</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> filterE</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> P</span><span class="id"> Q;</span><span class="id"> apply:</span><span class="id"> filterS2=&gt;</span><span class="id"> x</span><span class="id"> PD</span><span class="id"> QD</span><span class="id"> Dx;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> subPQ;</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> =&gt;</span><span class="id"> R</span><span class="id"> PD</span><span class="id"> Dx;</span><span class="id"> apply:</span><span class="id"> subPQ</span>.<br/>
Qed.</div></details>
<span class="id">#[global]</span><span class="id"> Typeclasses</span><span class="vernacular"> Opaque</span><span class="id"> subset_filter</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subset_filter_proper</span><span class="id"> {T</span><span class="id"> F}</span><span class="id"> {FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F}</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> P,</span><span class="id"> F</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> ~</span><span class="id"> ~</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> D</span><span class="id"> x</span><span class="id"> /\</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> (<span class="id">subset_filter</span><span class="id"> F</span><span class="id"> D</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> DAP;</span><span class="id"> apply:</span><span class="id"> Build_ProperFilter;</span><span class="id"> rewrite</span><span class="id"> /subset_filter</span><span class="id"> =&gt;</span><span class="id"> subFD</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /</span>(_<span class="id"> subFD</span>)<span class="id"> :=</span><span class="id"> DAP</span> (<span class="id">~`</span><span class="id"> D</span>)<span class="id">;</span><span class="id"> apply</span><span class="id"> =&gt;</span><span class="id"> -[x</span><span class="id"> [dx</span><span class="id"> /</span>(_<span class="id"> dx</span>)<span class="id">]]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> NearSet</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {Y</span><span class="id"> :</span><span class="id"> Type}</span>.<br/>
<span class="vernacular">Context</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> Y</span>) (<span class="id">PF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> powerset_filter_from</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">set</span><span class="id"> Y</span>)<span class="id"> :=</span><span class="id"> filter_from</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> M</span><span class="id"> |</span><span class="id"> [/\</span><span class="id"> M</span><span class="id"> `&lt;=`</span><span class="id"> F,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> E1</span><span class="id"> E2,</span><span class="id"> M</span><span class="id"> E1</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> E2</span><span class="id"> -&gt;</span><span class="id"> E2</span><span class="id"> `&lt;=`</span><span class="id"> E1</span><span class="id"> -&gt;</span><span class="id"> M</span><span class="id"> E2</span>)<span class="id"> &amp;</span><span class="id"> M</span><span class="id"> !=set0</span><span class="id"> ]</span><span class="id"> ]</span><br/>
&nbsp;&nbsp;<span class="id">id</span>.<br/>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> powerset_filter_from_filter</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> powerset_filter_from</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [W</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> [N</span><span class="id"> +]]];</span><span class="id"> rewrite</span><span class="id"> subset0</span><span class="id"> =&gt;</span><span class="id"> /[swap]</span><span class="id"> -&gt;;</span><span class="id"> apply</span>.<br/>
<span class="id">apply:</span><span class="id"> filter_from_filter</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> F;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> setT;</span><span class="id"> exact:</span><span class="id"> filterT</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> M</span><span class="id"> N</span><span class="id"> /=</span><span class="id"> [entM</span><span class="id"> subM</span><span class="id"> [M0</span><span class="id"> MM0]]</span><span class="id"> [entN</span><span class="id"> subN</span><span class="id"> [N0</span><span class="id"> NN0]]</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> [set</span><span class="id"> E</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> P</span><span class="id"> Q,</span><span class="id"> [/\</span><span class="id"> M</span><span class="id"> P,</span><span class="id"> N</span><span class="id"> Q</span><span class="id"> &amp;</span><span class="id"> E</span><span class="id"> =</span><span class="id"> P</span><span class="id"> `&amp;`</span><span class="id"> Q]</span><span class="id"> ];</span><span class="id"> first</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> [?</span><span class="id"> [?</span><span class="id"> [?</span><span class="id"> ?</span><span class="id"> -&gt;]]];</span><span class="id"> apply:</span><span class="id"> filterI;</span><span class="id"> [exact:</span><span class="id"> entM</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> entN]</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> E2</span><span class="id"> [P</span><span class="id"> [Q</span><span class="id"> [MP</span><span class="id"> MQ</span><span class="id"> -&gt;]]]</span><span class="id"> entE2</span><span class="id"> E2subPQ;</span><span class="gallina-kwd"> exists</span><span class="id"> E2,</span><span class="id"> E2</span>.<br/>
&nbsp;&nbsp;<span class="id">split;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIid</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">subM</span><span class="id"> _</span><span class="id"> _</span><span class="id"> MP</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?</span><span class="id"> /E2subPQ</span><span class="id"> []</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">subN</span><span class="id"> _</span><span class="id"> _</span><span class="id"> MQ</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?</span><span class="id"> /E2subPQ</span><span class="id"> []</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span> (<span class="id">M0</span><span class="id"> `&amp;`</span><span class="id"> N0</span>)<span class="id">,</span><span class="id"> M0,</span><span class="id"> N0</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> E</span><span class="id"> /=</span><span class="id"> [P</span><span class="id"> [Q</span><span class="id"> [MP</span><span class="id"> MQ</span><span class="id"> -&gt;]]];</span><span class="id"> have</span><span class="id"> entPQ</span><span class="id"> :</span><span class="id"> F</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> Q</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> filterI;</span><span class="id"> [exact:</span><span class="id"> entM</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> entN]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split;</span><span class="id"> [apply:</span> (<span class="id">subM</span><span class="id"> _</span><span class="id"> _</span><span class="id"> MP</span>)<span class="id"> |</span><span class="id"> apply:</span> (<span class="id">subN</span><span class="id"> _</span><span class="id"> _</span><span class="id"> MQ</span>)<span class="id">]</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?</span><span class="id"> []</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_small_set</span><span class="id"> :</span><span class="id"> \forall</span><span class="id"> E</span><span class="id"> \near</span><span class="id"> powerset_filter_from,</span><span class="id"> F</span><span class="id"> E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> F</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> setT;</span><span class="id"> exact:</span><span class="id"> filterT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> small_set_sub</span> (<span class="id">E</span><span class="id"> :</span><span class="id"> set</span><span class="id"> Y</span>)<span class="id"> :</span><span class="id"> F</span><span class="id"> E</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\forall</span><span class="id"> E'</span><span class="id"> \near</span><span class="id"> powerset_filter_from,</span><span class="id"> E'</span><span class="id"> `&lt;=`</span><span class="id"> E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> entE;</span><span class="gallina-kwd"> exists</span><span class="id"> [set</span><span class="id"> E'</span><span class="id"> |</span><span class="id"> F</span><span class="id"> E'</span><span class="id"> /\</span><span class="id"> E'</span><span class="id"> `&lt;=`</span><span class="id"> E];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> []</span>.<br/>
<span class="id">split;</span><span class="id"> [by</span><span class="id"> move=&gt;</span><span class="id"> E'</span><span class="id"> []</span><span class="id"> |</span><span class="id"> |</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> E;</span><span class="id"> split]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> E1</span><span class="id"> E2</span><span class="id"> []</span><span class="id"> ?</span><span class="id"> subE</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> subset_trans</span><span class="id"> subE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_powerset_filter_fromP</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> Y</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> A</span><span class="id"> B,</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> A</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> U</span><span class="id"> \near</span><span class="id"> powerset_filter_from,</span><span class="id"> P</span><span class="id"> U</span>)<span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> exists2</span><span class="id"> U,</span><span class="id"> F</span><span class="id"> U</span><span class="id"> &amp;</span><span class="id"> P</span><span class="id"> U</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Psub;</span><span class="id"> split=&gt;</span><span class="id"> [[M</span><span class="id"> [FM</span><span class="id"> ?</span><span class="id"> [U</span><span class="id"> MU]]]</span><span class="id"> MsubP|[U</span><span class="id"> FU</span><span class="id"> PU]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> U;</span><span class="id"> [exact:</span><span class="id"> FM</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> MsubP]</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> [set</span><span class="id"> V</span><span class="id"> |</span><span class="id"> F</span><span class="id"> V</span><span class="id"> /\</span><span class="id"> V</span><span class="id"> `&lt;=`</span><span class="id"> U];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> V</span><span class="id"> [_]</span><span class="id"> /Psub;</span><span class="id"> exact</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> [E</span><span class="id"> []</span><span class="id"> //|</span><span class="id"> |];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> U;</span><span class="id"> split</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> E1</span><span class="id"> E2</span><span class="id"> [F1</span><span class="id"> E1U</span><span class="id"> F2</span><span class="id"> E2subE1];</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> subset_trans</span><span class="id"> E1U</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> powerset_filter_fromP</span><span class="id"> C</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">F</span><span class="id"> C</span><span class="id"> -&gt;</span><span class="id"> powerset_filter_from</span><span class="id"> [set</span><span class="id"> W</span><span class="id"> |</span><span class="id"> F</span><span class="id"> W</span><span class="id"> /\</span><span class="id"> W</span><span class="id"> `&lt;=`</span><span class="id"> C]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FC;</span><span class="gallina-kwd"> exists</span><span class="id"> [set</span><span class="id"> W</span><span class="id"> |</span><span class="id"> F</span><span class="id"> W</span><span class="id"> /\</span><span class="id"> W</span><span class="id"> `&lt;=`</span><span class="id"> C]</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> []</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> [_</span><span class="id"> AC]</span><span class="id"> FB</span><span class="id"> /subset_trans/</span>(_<span class="id"> AC</span>).<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> C;</span><span class="id"> split</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> NearSet</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_powerset_map</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;(<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> powerset_filter_from</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> @[x</span><span class="id"> --&gt;</span><span class="id"> F]</span>)<span class="id">,</span><span class="id"> P</span><span class="id"> y</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> powerset_filter_from</span><span class="id"> F,</span><span class="id"> P</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> y</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> []</span><span class="id"> G</span><span class="id"> /=</span><span class="id"> [Gf</span><span class="id"> Gs</span><span class="id"> [D</span><span class="id"> GD</span><span class="id"> GP]]</span>.<br/>
<span class="id">have</span><span class="id"> PpF</span><span class="id"> :</span><span class="id"> ProperFilter</span> (<span class="id">powerset_filter_from</span><span class="id"> F</span>).<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> powerset_filter_from_filter</span>.<br/>
<span class="id">have</span><span class="id"> /=</span><span class="id"> :=</span><span class="id"> Gf</span><span class="id"> _</span><span class="id"> GD;</span><span class="id"> rewrite</span><span class="id"> nbhs_simpl</span><span class="id"> =&gt;</span><span class="id"> FfD</span>.<br/>
<span class="id">near=&gt;</span><span class="id"> M;</span><span class="id"> apply:</span><span class="id"> GP;</span><span class="id"> apply:</span> (<span class="id">Gs</span><span class="id"> D</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> filterS;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> preimage_image</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">near</span> (<span class="id">near_small_set</span><span class="id"> _</span>)<span class="id"> M</span>).<br/>
<span class="id">have</span><span class="id"> :</span><span class="id"> M</span><span class="id"> `&lt;=`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> D</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span> (<span class="id">near</span> (<span class="id">small_set_sub</span><span class="id"> FfD</span>)<span class="id"> M</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> move/image_subset/subset_trans;</span><span class="id"> apply;</span><span class="id"> exact:</span><span class="id"> image_preimage_subset</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> near_powerset_map_monoE</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;(<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> X</span><span class="id"> Y,</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> Y</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> Y</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> X</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> powerset_filter_from</span><span class="id"> F,</span><span class="id"> P</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> y</span>))<span class="id"> =</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> powerset_filter_from</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> @[x</span><span class="id"> --&gt;</span><span class="id"> F]</span>)<span class="id">,</span><span class="id"> P</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Pmono</span><span class="id"> FF;</span><span class="id"> rewrite</span><span class="id"> propeqE;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> near_powerset_map</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> G</span><span class="id"> /=</span><span class="id"> [Gf</span><span class="id"> Gs</span><span class="id"> [D</span><span class="id"> GD</span><span class="id"> GP]]</span>.<br/>
<span class="id">have</span><span class="id"> PpF</span><span class="id"> :</span><span class="id"> ProperFilter</span> (<span class="id">powerset_filter_from</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> @[x--&gt;F]</span>)).<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> powerset_filter_from_filter</span>.<br/>
<span class="id">have</span><span class="id"> /=</span><span class="id"> :=</span><span class="id"> Gf</span><span class="id"> _</span><span class="id"> GD;</span><span class="id"> rewrite</span><span class="id"> nbhs_simpl</span><span class="id"> =&gt;</span><span class="id"> FfD;</span><span class="id"> have</span><span class="id"> ffiD</span><span class="id"> :</span><span class="id"> fmap</span><span class="id"> f</span><span class="id"> F</span> (<span class="id">f@`</span><span class="id"> D</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /fmap</span><span class="id"> /=;</span><span class="id"> apply:</span><span class="id"> filterS;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> preimage_image</span>.<br/>
<span class="id">near=&gt;</span><span class="id"> M;</span><span class="id"> have</span><span class="id"> FfM</span><span class="id"> :</span><span class="id"> fmap</span><span class="id"> f</span><span class="id"> F</span><span class="id"> M</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span> (<span class="id">near</span> (<span class="id">near_small_set</span><span class="id"> _</span>)<span class="id"> M</span>).<br/>
<span class="id">apply:</span> (<span class="id">@Pmono</span><span class="id"> _</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> D</span>))<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span> (<span class="id">near</span> (<span class="id">small_set_sub</span><span class="id"> ffiD</span>)<span class="id"> M</span>).<br/>
<span class="id">exact:</span><span class="id"> GP</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> PrincipalFilters</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> principal_filter</span><span class="id"> {X</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> X</span>)<span class="id"> :</span><span class="id"> set_system</span><span class="id"> X</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">globally</span><span class="id"> [set</span><span class="id"> x]</span>.<br/>
<br/>
<div class="doc">we introducing an alias for pointed types with principal filters </div>
<span class="vernacular">Definition</span><span class="id"> principal_filter_type</span> (<span class="id">P</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<span class="id"> :</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><span class="id"> P</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Choice</span>.<span class="id">copy</span> (<span class="id">principal_filter_type</span><span class="id"> P</span>)<span class="id"> P</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> pointedType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Pointed</span>.<span class="id">on</span> (<span class="id">principal_filter_type</span><span class="id"> P</span>).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">hasNbhs</span>.<span class="id">Build</span> (<span class="id">principal_filter_type</span><span class="id"> P</span>)<span class="id"> principal_filter</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> pointedType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Filtered</span>.<span class="id">on</span> (<span class="id">principal_filter_type</span><span class="id"> P</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> principal_filterP</span><span class="id"> {X}</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> X</span>) (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> X</span>)<span class="id"> :</span><span class="id"> principal_filter</span><span class="id"> x</span><span class="id"> W</span><span class="id"> &lt;-&gt;</span><span class="id"> W</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split=&gt;</span><span class="id"> [|?</span><span class="id"> ?</span><span class="id"> -&gt;];</span><span class="id"> [exact|]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> principal_filter_proper</span><span class="id"> {X}</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> X</span>)<span class="id"> :</span><span class="id"> ProperFilter</span> (<span class="id">principal_filter</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> globally_properfilter</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> hasNbhs</span>.<span class="id">Build</span><span class="id"> bool</span><span class="id"> principal_filter</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> PrincipalFilters</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> UltraFilters</span>.<br/>
<br/>
<span class="vernacular">Class</span><span class="id"> UltraFilter</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">#[global]</span><span class="id"> ultra_proper</span><span class="id"> ::</span><span class="id"> ProperFilter</span><span class="id"> F</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">max_filter</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T,</span><span class="id"> ProperFilter</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> `&lt;=`</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> =</span><span class="id"> F</span><br/>
<span class="id">}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ultraFilterLemma</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> G,</span><span class="id"> UltraFilter</span><span class="id"> G</span><span class="id"> /\</span><span class="id"> F</span><span class="id"> `&lt;=`</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span>.<br/>
<span class="id">set</span><span class="id"> filter_preordset</span><span class="id"> :=</span> (<span class="id">{G</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span><span class="id"> &amp;</span><span class="id"> ProperFilter</span><span class="id"> G</span><span class="id"> /\</span><span class="id"> F</span><span class="id"> `&lt;=`</span><span class="id"> G}</span>).<br/>
<span class="id">set</span><span class="id"> preorder</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> G1</span><span class="id"> G2</span><span class="id"> :</span><span class="id"> {classic</span><span class="id"> filter_preordset}</span><span class="id"> =&gt;</span><span class="id"> `[&lt;</span><span class="id"> projT1</span><span class="id"> G1</span><span class="id"> `&lt;=`</span><span class="id"> projT1</span><span class="id"> G2</span><span class="id"> &gt;]</span>.<br/>
<span class="id">suff</span><span class="id"> [G</span><span class="id"> Gmax]</span><span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> G</span><span class="id"> :</span><span class="id"> {classic</span><span class="id"> filter_preordset},</span><span class="id"> premaximal</span><span class="id"> preorder</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [GF</span><span class="id"> sFG]</span><span class="id"> :=</span><span class="id"> projT2</span><span class="id"> G;</span><span class="gallina-kwd"> exists</span> (<span class="id">projT1</span><span class="id"> G</span>)<span class="id">;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> sFG</span>.<br/>
&nbsp;&nbsp;<span class="id">split;</span><span class="id"> [exact:</span><span class="id"> GF|move=&gt;</span><span class="id"> H</span><span class="id"> HF</span><span class="id"> sGH]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sFH</span><span class="id"> :</span><span class="id"> F</span><span class="id"> `&lt;=`</span><span class="id"> H</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> subset_trans</span><span class="id"> sGH</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sHG</span><span class="id"> :</span><span class="id"> preorder</span> (<span class="id">existT</span><span class="id"> _</span><span class="id"> H</span> (<span class="id">conj</span><span class="id"> HF</span><span class="id"> sFH</span>))<span class="id"> G</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/asboolP</span><span class="gallina-kwd"> in</span><span class="id"> sGH;</span><span class="id"> exact:</span> (<span class="id">Gmax</span> (<span class="id">existT</span><span class="id"> _</span><span class="id"> H</span> (<span class="id">conj</span><span class="id"> HF</span><span class="id"> sFH</span>))<span class="id"> sGH</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> A;</span><span class="id"> split;</span><span class="id"> [move/asboolP</span><span class="id"> :</span><span class="id"> sHG;</span><span class="id"> exact|exact:</span><span class="id"> sGH]</span>.<br/>
<span class="id">have</span><span class="id"> sFF</span><span class="id"> :</span><span class="id"> F</span><span class="id"> `&lt;=`</span><span class="id"> F</span><span class="gallina-kwd"> by</span><span class="id"> []</span>.<br/>
<span class="id">apply:</span> (<span class="id">ZL_preorder</span> (<span class="id">existT</span><span class="id"> _</span><span class="id"> F</span> (<span class="id">conj</span><span class="id"> FF</span><span class="id"> sFF</span>))).<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> t;</span><span class="id"> exact/asboolP</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> r</span><span class="id"> s</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> /preorder</span><span class="id"> =&gt;</span><span class="id"> /asboolP</span><span class="id"> sr</span><span class="id"> /asboolP</span><span class="id"> st</span>.<br/>
&nbsp;&nbsp;<span class="id">exact/asboolP/</span>(<span class="id">subset_trans</span><span class="id"> _</span><span class="id"> st</span>).<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> Atot;</span><span class="id"> have</span><span class="id"> [[G</span><span class="id"> AG]</span><span class="id"> |</span><span class="id"> A0]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">A</span><span class="id"> !=set0</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">existT</span><span class="id"> _</span><span class="id"> F</span> (<span class="id">conj</span><span class="id"> FF</span><span class="id"> sFF</span>))<span class="id"> =&gt;</span><span class="id"> G</span><span class="id"> AG</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /asboolP</span><span class="id"> :=</span><span class="id"> A0;</span><span class="id"> rewrite</span><span class="id"> asbool_neg</span><span class="id"> =&gt;</span><span class="id"> /forallp_asboolPn</span><span class="id"> /</span>(_<span class="id"> G</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [GF</span><span class="id"> sFG]</span><span class="id"> :=</span><span class="id"> projT2</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="id">suff</span><span class="id"> UAF</span><span class="id"> :</span><span class="id"> ProperFilter</span> (<span class="id">\bigcup_</span>(<span class="id">H</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> projT1</span><span class="id"> H</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> sFUA</span><span class="id"> :</span><span class="id"> F</span><span class="id"> `&lt;=`</span><span class="id"> \bigcup_</span>(<span class="id">H</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> projT1</span><span class="id"> H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> B</span><span class="id"> FB;</span><span class="gallina-kwd"> exists</span><span class="id"> G</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> sFG</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">existT</span><span class="id"> _</span> (<span class="id">\bigcup_</span>(<span class="id">H</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> projT1</span><span class="id"> H</span>) (<span class="id">conj</span><span class="id"> UAF</span><span class="id"> sFUA</span>))<span class="id"> =&gt;</span><span class="id"> H</span><span class="id"> AH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/asboolP</span><span class="id"> =&gt;</span><span class="id"> B</span><span class="id"> HB</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> H</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> Build_ProperFilter_ex</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> B</span><span class="id"> [H</span><span class="id"> AH</span><span class="id"> HB];</span><span class="id"> have</span><span class="id"> [HF</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> projT2</span><span class="id"> H;</span><span class="id"> exact:</span> (<span class="id">@filter_ex</span><span class="id"> _</span><span class="id"> _</span><span class="id"> HF</span>).<br/>
&nbsp;&nbsp;<span class="id">split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> G</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> filterT</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> move=&gt;</span><span class="id"> B</span><span class="id"> C</span><span class="id"> [HB</span><span class="id"> AHB</span><span class="id"> HBB]</span><span class="id"> [HC</span><span class="id"> AHC</span><span class="id"> HCC];</span><span class="id"> have</span><span class="id"> [sHBC|sHCB]</span><span class="id"> :=</span><span class="id"> Atot</span><span class="id"> _</span><span class="id"> _</span><span class="id"> AHB</span><span class="id"> AHC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">*</span><span class="gallina-kwd"> exists</span><span class="id"> HC</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> have</span><span class="id"> [HCF</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> projT2</span><span class="id"> HC;</span><span class="id"> apply:</span><span class="id"> filterI</span><span class="id"> HCC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/asboolP</span><span class="id"> :</span><span class="id"> sHBC;</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">*</span><span class="gallina-kwd"> exists</span><span class="id"> HB</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> have</span><span class="id"> [HBF</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> projT2</span><span class="id"> HB;</span><span class="id"> apply:</span><span class="id"> filterI</span><span class="id"> HBB</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/asboolP</span><span class="id"> :</span><span class="id"> sHCB;</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> move=&gt;</span><span class="id"> B</span><span class="id"> C</span><span class="id"> SBC</span><span class="id"> [H</span><span class="id"> AH</span><span class="id"> HB];</span><span class="gallina-kwd"> exists</span><span class="id"> H</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> have</span><span class="id"> [HF</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> projT2</span><span class="id"> H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> filterS</span><span class="id"> HB</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_image</span> (<span class="id">T</span><span class="id"> U</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> setT</span><span class="id"> =</span><span class="id"> setT</span><span class="id"> -&gt;</span><span class="id"> Filter</span><span class="id"> [set</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> |</span><span class="id"> A</span><span class="gallina-kwd"> in</span><span class="id"> F]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> fsurj;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> setT</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> filterT</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [A</span><span class="id"> FA</span><span class="id"> &lt;-]</span><span class="id"> [B</span><span class="id"> FB</span><span class="id"> &lt;-]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">f</span><span class="id"> @^-1`</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> B</span>))<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> image_preimage</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sAB</span><span class="id"> :</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> f</span><span class="id"> @^-1`</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> B</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> [Ax</span><span class="id"> Bx];</span><span class="id"> split;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> sAB</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> filterI</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> sAB</span><span class="id"> [C</span><span class="id"> FC</span><span class="id"> fC_eqA]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> B</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> image_preimage</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> FC</span><span class="id"> =&gt;</span><span class="id"> p</span><span class="id"> Cp;</span><span class="id"> apply:</span><span class="id"> sAB;</span><span class="id"> rewrite</span><span class="id"> -fC_eqA;</span><span class="gallina-kwd"> exists</span><span class="id"> p</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> proper_image</span> (<span class="id">T</span><span class="id"> U</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> setT</span><span class="id"> =</span><span class="id"> setT</span><span class="id"> -&gt;</span><span class="id"> ProperFilter</span><span class="id"> [set</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> |</span><span class="id"> A</span><span class="gallina-kwd"> in</span><span class="id"> F]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> fsurj;</span><span class="id"> apply:</span><span class="id"> Build_ProperFilter_ex;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> filter_image</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> [A</span><span class="id"> FA</span><span class="id"> &lt;-];</span><span class="id"> have</span><span class="id"> /filter_ex</span><span class="id"> [p</span><span class="id"> Ap]</span><span class="id"> :=</span><span class="id"> FA;</span><span class="gallina-kwd"> exists</span> (<span class="id">f</span><span class="id"> p</span>)<span class="id">;</span><span class="gallina-kwd"> exists</span><span class="id"> p</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> principal_filter_ultra</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">UltraFilter</span> (<span class="id">principal_filter</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [|G</span><span class="id"> [G0</span><span class="id"> xG]</span><span class="id"> FG];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> principal_filter_proper</span>.<br/>
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> U</span><span class="id"> GU;</span><span class="id"> apply/principal_filterP</span>.<br/>
<span class="id">have</span><span class="id"> /</span>(<span class="id">filterI</span><span class="id"> GU</span>)<span class="id">:</span><span class="id"> G</span><span class="id"> [set</span><span class="id"> x]</span><span class="gallina-kwd"> by</span><span class="id"> exact/FG/principal_filterP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIC</span><span class="id"> set1I;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> /[!inE]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> in_ultra_setVsetC</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">UltraFilter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> A</span><span class="id"> \/</span><span class="id"> F</span> (<span class="id">~`</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FU;</span><span class="id"> case:</span> (<span class="id">pselect</span> (<span class="id">F</span> (<span class="id">~`</span><span class="id"> A</span>)))<span class="id"> =&gt;</span><span class="id"> [|nFnA];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> right</span>.<br/>
<span class="id">left;</span><span class="id"> suff</span><span class="id"> :</span><span class="id"> ProperFilter</span> (<span class="id">filter_from</span> (<span class="id">F</span><span class="id"> `|`</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> |</span><span class="id"> B</span><span class="gallina-kwd"> in</span><span class="id"> F]</span>)<span class="id"> id</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /max_filter</span><span class="id"> &lt;-;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> B</span><span class="id"> FB;</span><span class="gallina-kwd"> exists</span><span class="id"> B</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> left</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> right;</span><span class="gallina-kwd"> exists</span><span class="id"> setT;</span><span class="id"> [apply:</span><span class="id"> filterT|rewrite</span><span class="id"> setIT]</span>.<br/>
<span class="id">apply:</span><span class="id"> filter_from_proper;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> B</span><span class="id"> [|[C</span><span class="id"> FC</span><span class="id"> &lt;-]];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> filter_ex</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contrapT</span><span class="id"> =&gt;</span><span class="id"> /asboolP;</span><span class="id"> rewrite</span><span class="id"> asbool_neg</span><span class="id"> =&gt;</span><span class="id"> /forallp_asboolPn</span><span class="id"> AC0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> nFnA;</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> FC</span><span class="id"> =&gt;</span><span class="id"> p</span><span class="id"> Cp</span><span class="id"> Ap;</span><span class="id"> apply:</span> (<span class="id">AC0</span><span class="id"> p</span>).<br/>
<span class="id">apply:</span><span class="id"> filter_from_filter</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> A;</span><span class="id"> right;</span><span class="gallina-kwd"> exists</span><span class="id"> setT;</span><span class="id"> [apply:</span><span class="id"> filterT|rewrite</span><span class="id"> setIT]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> B</span><span class="id"> C</span><span class="id"> [FB|[DB</span><span class="id"> FDB</span><span class="id"> &lt;-]]</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> [FC|[DC</span><span class="id"> FDC</span><span class="id"> &lt;-]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span> (<span class="id">B</span><span class="id"> `&amp;`</span><span class="id"> C</span>)<span class="id">=&gt;</span><span class="id"> //;</span><span class="id"> left;</span><span class="id"> apply:</span><span class="id"> filterI</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">A</span><span class="id"> `&amp;`</span> (<span class="id">B</span><span class="id"> `&amp;`</span><span class="id"> DC</span>))<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setICA</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> right;</span><span class="gallina-kwd"> exists</span> (<span class="id">B</span><span class="id"> `&amp;`</span><span class="id"> DC</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> filterI</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> [FC|[DC</span><span class="id"> FDC</span><span class="id"> &lt;-]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">A</span><span class="id"> `&amp;`</span> (<span class="id">DB</span><span class="id"> `&amp;`</span><span class="id"> C</span>))<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIA</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> right;</span><span class="gallina-kwd"> exists</span> (<span class="id">DB</span><span class="id"> `&amp;`</span><span class="id"> C</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> filterI</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">A</span><span class="id"> `&amp;`</span> (<span class="id">DB</span><span class="id"> `&amp;`</span><span class="id"> DC</span>))<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ??;</span><span class="id"> rewrite</span><span class="id"> setIACA</span><span class="id"> setIid</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> right;</span><span class="gallina-kwd"> exists</span> (<span class="id">DB</span><span class="id"> `&amp;`</span><span class="id"> DC</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> filterI</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ultra_image</span> (<span class="id">T</span><span class="id"> U</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">UltraFilter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> setT</span><span class="id"> =</span><span class="id"> setT</span><span class="id"> -&gt;</span><span class="id"> UltraFilter</span><span class="id"> [set</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> |</span><span class="id"> A</span><span class="gallina-kwd"> in</span><span class="id"> F]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FU</span><span class="id"> fsurj;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> proper_image</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> G</span><span class="id"> GF</span><span class="id"> sfFG;</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> A;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> sfFG</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> GA;</span><span class="gallina-kwd"> exists</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> A</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> image_preimage</span>.<br/>
<span class="id">have</span><span class="id"> [//|FnAf]</span><span class="id"> :=</span><span class="id"> in_ultra_setVsetC</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> A</span>)<span class="id"> FU</span>.<br/>
<span class="id">have</span><span class="id"> :</span><span class="id"> G</span> (<span class="id">f</span><span class="id"> @`</span> (<span class="id">~`</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> A</span>)))<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> sfFG;</span><span class="gallina-kwd"> exists</span> (<span class="id">~`</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> A</span>)).<br/>
<span class="id">suff</span><span class="id"> :</span><span class="id"> ~</span><span class="id"> G</span> (<span class="id">f</span><span class="id"> @`</span> (<span class="id">~`</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> A</span>)))<span class="gallina-kwd"> by</span><span class="id"> []</span>.<br/>
<span class="id">rewrite</span><span class="id"> preimage_setC</span><span class="id"> image_preimage</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> GnA</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /filter_ex</span><span class="id"> [?</span><span class="id"> []]</span><span class="id"> :</span><span class="id"> G</span> (<span class="id">A</span><span class="id"> `&amp;`</span> (<span class="id">~`</span><span class="id"> A</span>))<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterI</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> UltraFilters</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> filter_supremums</span>.<br/>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> smallest_filter_filter</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span> (<span class="id">smallest</span><span class="id"> Filter</span><span class="id"> F</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> G</span><span class="id"> [?</span><span class="id"> _];</span><span class="id"> apply:</span><span class="id"> filterT</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> sFP</span><span class="id"> sFQ</span><span class="id"> ?</span><span class="id"> [?</span><span class="id"> ?];</span><span class="id"> apply:</span><span class="id"> filterI;</span><span class="id"> [apply:</span><span class="id"> sFP</span><span class="id"> |</span><span class="id"> apply:</span><span class="id"> sFQ]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> /filterS</span><span class="id"> +</span><span class="id"> sFP</span><span class="id"> ?</span><span class="id"> [?</span><span class="id"> ?];</span><span class="id"> apply;</span><span class="id"> apply:</span><span class="id"> sFP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> filterI_iter</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)) (<span class="id">n</span><span class="id"> :</span><span class="id"> nat</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> n</span><span class="id"> is</span><span class="id"> m</span>.<span class="id">+1</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">then</span><span class="id"> [set</span><span class="id"> P</span><span class="id"> `&amp;`</span><span class="id"> Q</span><span class="id"> |</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P</span><span class="gallina-kwd"> in</span><span class="id"> filterI_iter</span><span class="id"> F</span><span class="id"> m</span><span class="id"> &amp;</span><span class="id"> Q</span><span class="gallina-kwd"> in</span><span class="id"> filterI_iter</span><span class="id"> F</span><span class="id"> m]</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="id"> setT</span><span class="id"> |`</span><span class="id"> F</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filterI_iter_sub</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{homo</span><span class="id"> filterI_iter</span><span class="id"> F</span><span class="id"> :</span><span class="id"> i</span><span class="id"> j</span><span class="id"> /</span> (<span class="id">i</span><span class="id"> &lt;=</span><span class="id"> j</span>)<span class="id">%N</span><span class="id"> &gt;-&gt;</span><span class="id"> i</span><span class="id"> `&lt;=`</span><span class="id"> j}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> +</span><span class="id"> j;</span><span class="id"> elim:</span><span class="id"> j;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> leqn0</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> j</span><span class="id"> IH</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> leq_eqVlt</span><span class="id"> =&gt;</span><span class="id"> /predU1P[-&gt;//|]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /IH/subset_trans;</span><span class="id"> apply=&gt;</span><span class="id"> A</span><span class="id"> ?;</span><span class="id"> do</span><span class="id"> 2</span><span class="gallina-kwd"> exists</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> setIid</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filterI_iterE</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">smallest</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> =</span><span class="id"> filter_from</span> (<span class="id">\bigcup_n</span> (<span class="id">filterI_iter</span><span class="id"> F</span><span class="id"> n</span>))<span class="id"> id</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> smallest_sub</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> FA;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> O</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> right</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> filter_from_filter;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> setT;</span><span class="gallina-kwd"> exists</span><span class="id"> O</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> left</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> [i</span><span class="id"> _</span><span class="id"> sFP]</span><span class="id"> [j</span><span class="id"> _</span><span class="id"> sFQ];</span><span class="gallina-kwd"> exists</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> Q</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">maxn</span><span class="id"> i</span><span class="id"> j</span>).<span class="id">+1</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="gallina-kwd"> exists</span><span class="id"> P</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> filterI_iter_sub;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> leq_maxl</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> Q</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> filterI_iter_sub;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> leq_maxr</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> +</span><span class="id"> [+</span><span class="id"> [n</span><span class="id"> _]];</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [A</span><span class="id"> B|n</span><span class="id"> IH/=</span><span class="id"> A</span><span class="id"> B]</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> [-&gt;</span><span class="id"> /[!</span>(<span class="id">@subTset</span><span class="id"> T</span>)<span class="id">]</span><span class="id"> -&gt;|];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> filterT</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> FB</span><span class="id"> /filterS;</span><span class="id"> apply;</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> [P</span><span class="id"> sFP]</span><span class="id"> [Q</span><span class="id"> sFQ]</span><span class="id"> PQB</span><span class="id"> /filterS;</span><span class="id"> apply;</span><span class="id"> rewrite</span><span class="id"> -PQB</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">filterI</span><span class="id"> _</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> [exact:</span> (<span class="id">IH</span><span class="id"> _</span><span class="id"> _</span><span class="id"> sFP</span>)<span class="id">|exact:</span> (<span class="id">IH</span><span class="id"> _</span><span class="id"> _</span><span class="id"> sFQ</span>)<span class="id">]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> finI_from</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> T</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> \bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> [set`</span><span class="id"> D']</span>)<span class="id"> f</span><span class="id"> i</span><span class="id"> |</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">D'</span><span class="gallina-kwd"> in</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> I}</span><span class="id"> |</span><span class="id"> {subset</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> D}]]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finI_from_cover</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> T</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\bigcup_</span>(<span class="id">A</span><span class="gallina-kwd"> in</span><span class="id"> finI_from</span><span class="id"> D</span><span class="id"> f</span>)<span class="id"> A</span><span class="id"> =</span><span class="id"> setT</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> t;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span><span class="id"> setT</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> fset0</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> set_fset0</span><span class="id"> bigcap_set0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finI_from1</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> T</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> i</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> finI_from</span><span class="id"> D</span><span class="id"> f</span> (<span class="id">f</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Di;</span><span class="gallina-kwd"> exists</span><span class="id"> [fset</span><span class="id"> i]%fset;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> bigcap_fset</span><span class="id"> big_seq_fset1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finI_from_countable</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> pointedType</span>)<span class="id"> T</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">countable</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> countable</span> (<span class="id">finI_from</span><span class="id"> D</span><span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ?;</span><span class="id"> apply:</span> (<span class="id">card_le_trans</span> (<span class="id">card_image_le</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
<span class="id">exact:</span><span class="id"> fset_subset_countable</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finI_fromI</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> T</span><span class="id"> D</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finI_from</span><span class="id"> D</span><span class="id"> f</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finI_from</span><span class="id"> D</span><span class="id"> f</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> finI_from</span><span class="id"> D</span><span class="id"> f</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>) .<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case=&gt;</span><span class="id"> N</span><span class="id"> ND</span><span class="id"> &lt;-</span><span class="id"> [M</span><span class="id"> MD</span><span class="id"> &lt;-];</span><span class="gallina-kwd"> exists</span> (<span class="id">N</span><span class="id"> `|`</span><span class="id"> M</span>)<span class="id">%fset</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /orP[/ND</span><span class="id"> |</span><span class="id"> /MD]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -bigcap_setU</span><span class="id"> set_fsetU</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filterI_iter_finI</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> T</span><span class="id"> D</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finI_from</span><span class="id"> D</span><span class="id"> f</span><span class="id"> =</span><span class="id"> \bigcup_n</span> (<span class="id">filterI_iter</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> D</span>)<span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> [N</span><span class="id"> /=</span><span class="id"> +</span><span class="id"> &lt;-];</span><span class="id"> have</span><span class="id"> /finite_setP[n]</span><span class="id"> :=</span><span class="id"> finite_fset</span><span class="id"> N;</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> N</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> II0</span><span class="id"> card_eq0</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> bigcap_set0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> O</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> left</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> n</span><span class="id"> IH</span><span class="id"> N</span><span class="id"> /eq_cardSP[x</span><span class="id"> Ax</span><span class="id"> +</span><span class="id"> ND];</span><span class="id"> rewrite</span><span class="id"> -set_fsetD1</span><span class="id"> =&gt;</span><span class="id"> Nxn</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> NxD</span><span class="id"> :</span><span class="id"> {subset</span> (<span class="id">N</span><span class="id"> `\</span><span class="id"> x</span>)<span class="id">%fset</span><span class="id"> &lt;=</span><span class="id"> D}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> ?inE</span><span class="id"> =&gt;</span><span class="id"> /andP</span><span class="id"> [_</span><span class="id"> /ND</span><span class="id"> /set_mem]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [r</span><span class="id"> _</span><span class="id"> xr]</span><span class="id"> :=</span><span class="id"> IH</span><span class="id"> _</span><span class="id"> Nxn</span><span class="id"> NxD;</span><span class="gallina-kwd"> exists</span><span class="id"> r</span>.<span class="id">+1</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span> (<span class="id">f</span><span class="id"> x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">@filterI_iter_sub</span><span class="id"> _</span><span class="id"> _</span><span class="id"> O</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> right;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -inE;</span><span class="id"> apply:</span><span class="id"> ND</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">\bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> [set`</span> (<span class="id">N</span><span class="id"> `\</span><span class="id"> x</span>)<span class="id">%fset]</span>)<span class="id"> f</span><span class="id"> i</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -bigcap_setU1</span><span class="id"> set_fsetD1</span><span class="id"> setD1K</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> [n</span><span class="id"> _];</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> A</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> a</span><span class="id"> [-&gt;</span><span class="id"> |[i</span><span class="id"> Di</span><span class="id"> &lt;-]];</span><span class="id"> [exists</span><span class="id"> fset0</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> [fset</span><span class="id"> i]%fset]</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> set_fset0</span><span class="id"> bigcap_set0</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> set_fset1</span><span class="id"> bigcap_set1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> IH</span><span class="id"> A</span><span class="id"> /=</span><span class="id"> [B</span><span class="id"> snB</span><span class="id"> [C</span><span class="id"> snC</span><span class="id"> &lt;-]];</span><span class="id"> apply:</span><span class="id"> finI_fromI;</span><span class="id"> apply:</span><span class="id"> IH</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> smallest_filter_finI</span><span class="id"> {I</span><span class="id"> T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">filter_from</span> (<span class="id">finI_from</span><span class="id"> D</span><span class="id"> f</span>)<span class="id"> id</span><span class="id"> =</span><span class="id"> smallest</span> (<span class="id">@Filter</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> @`</span><span class="id"> D</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> filterI_iter_finI</span><span class="id"> filterI_iterE</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> filter_supremums</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> finI</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> T</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> D'</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> I},</span><span class="id"> {subset</span><span class="id"> D'</span><span class="id"> &lt;=</span><span class="id"> D}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> [set</span><span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> D']</span>)<span class="id"> f</span><span class="id"> i</span><span class="id"> !=set0</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finI_filter</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> T</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finI</span><span class="id"> D</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> ProperFilter</span> (<span class="id">filter_from</span> (<span class="id">finI_from</span><span class="id"> D</span><span class="id"> f</span>)<span class="id"> id</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> finIf;</span><span class="id"> apply:</span> (<span class="id">filter_from_proper</span> (<span class="id">filter_from_filter</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> setT;</span><span class="gallina-kwd"> exists</span><span class="id"> fset0</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> predeqE</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> [DA</span><span class="id"> sDA</span><span class="id"> IfA]</span><span class="id"> [DB</span><span class="id"> sDB</span><span class="id"> IfB];</span><span class="gallina-kwd"> exists</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">DA</span><span class="id"> `|`</span><span class="id"> DB</span>)<span class="id">%fset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /orP</span><span class="id"> [/sDA|/sDB]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -IfA</span><span class="id"> -IfB</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> p;</span><span class="id"> split=&gt;</span><span class="id"> [Ifp|[IfAp</span><span class="id"> IfBp]</span><span class="id"> i]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> i</span><span class="id"> Di;</span><span class="id"> apply:</span><span class="id"> Ifp;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> inE</span><span class="id"> Di</span><span class="id"> //</span><span class="id"> orbC</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /orP</span><span class="id"> [];</span><span class="id"> [apply:</span><span class="id"> IfAp|apply:</span><span class="id"> IfBp]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> [??</span><span class="id"> &lt;-];</span><span class="id"> apply:</span><span class="id"> finIf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_finI</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span><span class="id"> F</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> A,</span><span class="id"> D</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> F</span> (<span class="id">f</span><span class="id"> A</span>))<span class="id"> -&gt;</span><span class="id"> finI</span><span class="id"> D</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> sDFf</span><span class="id"> D'</span><span class="id"> sD;</span><span class="id"> apply:</span> (<span class="id">@filter_ex</span><span class="id"> _</span><span class="id"> F</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> filter_bigI</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> /sD;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /sDFf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> meets_globallyl</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> G</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">globally</span><span class="id"> A</span><span class="id"> `#`</span><span class="id"> G</span><span class="id"> =</span><span class="gallina-kwd"> forall</span><span class="id"> B,</span><span class="id"> G</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> !=set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> propeqE;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [/</span>(_<span class="id"> _</span><span class="id"> _</span> (<span class="id">fun=&gt;</span><span class="id"> id</span>))<span class="id">//|clA</span><span class="id"> A'</span><span class="id"> B</span><span class="id"> sA]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /clA;</span><span class="id"> apply:</span><span class="id"> subsetI_neq0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> meets_globallyr</span><span class="id"> T</span><span class="id"> F</span> (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">F</span><span class="id"> `#`</span><span class="id"> globally</span><span class="id"> B</span><span class="id"> =</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> F</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> !=set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> meetsC</span><span class="id"> meets_globallyl;</span><span class="id"> under</span><span class="id"> eq_forall</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> setIC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> meetsxx</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span>)<span class="id"> :</span><span class="id"> F</span><span class="id"> `#`</span><span class="id"> F</span><span class="id"> =</span><span class="id"> ~</span> (<span class="id">F</span><span class="id"> set0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> propeqE;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [FmF</span><span class="id"> F0|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> [x</span><span class="id"> []]</span><span class="id"> :=</span><span class="id"> FmF</span><span class="id"> _</span><span class="id"> _</span><span class="id"> F0</span><span class="id"> F0</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> FN0</span><span class="id"> A</span><span class="id"> B</span><span class="id"> /filterI</span><span class="id"> FAI</span><span class="id"> {}/FAI</span><span class="id"> FAB;</span><span class="id"> apply/set0P/eqP</span><span class="id"> =&gt;</span><span class="id"> AB0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> AB0</span><span class="gallina-kwd"> in</span><span class="id"> FAB</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> proper_meetsxx</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">FF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F</span>)<span class="id"> :</span><span class="id"> F</span><span class="id"> `#`</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> meetsxx</span>. Qed.</div></details>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
