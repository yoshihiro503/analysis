
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.analysis.separation_axioms</title>
<meta name="description" content="Documentation of Coq module mathcomp.analysis.separation_axioms" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.analysis.separation_axioms</h1>
<span class="vernacular">From</span><span class="id"> HB</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> structures</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> all_ssreflect</span><span class="id"> all_algebra</span><span class="id"> finmap</span><span class="id"> generic_quotient</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> archimedean</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> boolp</span><span class="id"> classical_sets</span><span class="id"> functions</span><span class="id"> wochoice</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> cardinality</span><span class="id"> mathcomp_extra</span><span class="id"> fsbigop</span><span class="id"> set_interval</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> filter</span><span class="id"> reals</span><span class="id"> signed</span><span class="id"> topology</span>.<br/>
<br/>
<div class="ssrdoc md">
# Separation Axioms

This file introduces the separation axioms, a series of topological
properties about separating points and sets. They are somtimes denoted by
the names T0 through T6. Although we use their full names (hausdorff,
accessible, uniform, etc). This file also provides related topological
properties like zero dimensional and perfect, and discrete.

```
             set_nbhs A == filter from open sets containing A
```

## The classic separation axioms
```
     kolmogorov_space T == T is a Kolmogorov space (T0)
     accessible_space T == T is an accessible space (T1)
      hausdorff_space T == T is a Hausdorff space (T2)
              close x y == x and y are arbitrarily close w.r.t. open sets
         normal_space T == T is normal (sometimes called T4)
        regular_space T == T is regular (sometimes called T3)
```
## related concepts
```
 totally_disconnected A == the only connected subsets of A are
                           empty or singletons
     zero_dimensional T == points are separable by a clopen set
          perfect_set A == A is closed, and every point in A is
                           a limit point of A
```
## metrizability for uniform spaces
```
 countable_uniform.type == endows a pseudoMetric on a uniform type whose
                           entourage has a countable basis
       sup_pseudometric == the pseudometric induced for the supremum
                           of countably many pseudoMetrics
                gauge E == for an entourage E, gauge E is a filter which
                           includes `iter n split_ent E`.
                           Critically, `gauge E` forms a uniform space
                           with a countable uniformity.
         perfect_set A  := closed A /\ limit_point A = A
```
</div>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> Order</span>.<span class="id">TTheory</span><span class="id"> GRing</span>.<span class="id">Theory</span><span class="id"> Num</span>.<span class="id">Theory</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> mathcomp_extra</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> set_nbhs</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> topologicalType}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> set_nbhs</span><span class="id"> :=</span><span class="id"> \bigcap_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> nbhs</span><span class="id"> x</span>.<br/>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> set_nbhs_filter</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> set_nbhs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> P</span><span class="id"> Q;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> filterT</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Px</span><span class="id"> Qx</span><span class="id"> x</span><span class="id"> Ax;</span><span class="id"> apply:</span><span class="id"> filterI;</span><span class="id"> [exact:</span><span class="id"> Px</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> Qx]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> PQ</span><span class="id"> +</span><span class="id"> x</span><span class="id"> Ax</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> Ax</span>)<span class="id">/filterS;</span><span class="id"> exact</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> set_nbhs_pfilter</span><span class="id"> :</span><span class="id"> A</span><span class="id"> !=set0</span><span class="id"> -&gt;</span><span class="id"> ProperFilter</span><span class="id"> set_nbhs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case=&gt;</span><span class="id"> x</span><span class="id"> Ax;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> set_nbhs_filter</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/</span>(_<span class="id"> x</span><span class="id"> Ax</span>)<span class="id">/nbhs_singleton</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_nbhsP</span> (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">set_nbhs</span><span class="id"> B</span><span class="id"> &lt;-&gt;</span> (<span class="gallina-kwd">exists</span><span class="id"> C,</span><span class="id"> [/\</span><span class="id"> open</span><span class="id"> C,</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> C</span><span class="id"> &amp;</span><span class="id"> C</span><span class="id"> `&lt;=`</span><span class="id"> B]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> V</span><span class="id"> [?</span><span class="id"> AV</span><span class="id"> /filterS</span><span class="id"> +]</span><span class="id"> x</span><span class="id"> /AV</span><span class="id"> ?;</span><span class="id"> apply;</span><span class="id"> apply:</span><span class="id"> open_nbhs_nbhs</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> snB;</span><span class="id"> have</span><span class="id"> Ux</span><span class="id"> x</span><span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> U,</span><span class="id"> A</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> [/\</span><span class="id"> U</span><span class="id"> x,</span><span class="id"> open</span><span class="id"> U</span><span class="id"> &amp;</span><span class="id"> U</span><span class="id"> `&lt;=`</span><span class="id"> B]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [/snB|?]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">A</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> point</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nbhsE</span><span class="id"> =&gt;</span><span class="id"> -[V</span><span class="id"> [?</span><span class="id"> ?</span><span class="id"> ?]];</span><span class="gallina-kwd"> exists</span><span class="id"> V</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">\bigcup_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>) (<span class="id">projT1</span> (<span class="id">cid</span> (<span class="id">Ux</span><span class="id"> x</span>))))<span class="id">;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> bigcup_open</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> Ax;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> projT2</span> (<span class="id">cid</span> (<span class="id">Ux</span><span class="id"> x</span>)).<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> Ax;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> projT2</span> (<span class="id">cid</span> (<span class="id">Ux</span><span class="id"> x</span>)).<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> [y</span><span class="id"> Ay];</span><span class="id"> have</span><span class="id"> [//|</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> projT2</span> (<span class="id">cid</span> (<span class="id">Ux</span><span class="id"> y</span>))<span class="id">;</span><span class="id"> exact</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> set_nbhs</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> point_separation_axioms</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> topologicalType}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> kolmogorov_space</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> y</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span> (<span class="id">A</span><span class="id"> \in</span><span class="id"> nbhs</span><span class="id"> x</span><span class="id"> /\</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> ~`</span><span class="id"> A</span>)<span class="id"> \/</span> (<span class="id">A</span><span class="id"> \in</span><span class="id"> nbhs</span><span class="id"> y</span><span class="id"> /\</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> ~`</span><span class="id"> A</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> accessible_space</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> y</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span><span class="id"> [/\</span><span class="id"> open</span><span class="id"> A,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> ~`</span><span class="id"> A]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> hausdorff_space</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> p</span><span class="id"> q</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> cluster</span> (<span class="id">nbhs</span><span class="id"> p</span>)<span class="id"> q</span><span class="id"> -&gt;</span><span class="id"> p</span><span class="id"> =</span><span class="id"> q</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> compact_closed</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> -&gt;</span><span class="id"> compact</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> closed</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> hT</span><span class="id"> Aco</span><span class="id"> p</span><span class="id"> clAp;</span><span class="id"> have</span><span class="id"> pA</span><span class="id"> :=</span><span class="id"> !!</span><span class="id"> @withinT</span><span class="id"> _</span> (<span class="id">nbhs</span><span class="id"> p</span>)<span class="id"> A</span><span class="id"> _</span>.<br/>
<span class="id">have</span><span class="id"> [q</span><span class="id"> [Aq</span><span class="id"> clsAp_q]]</span><span class="id"> :=</span><span class="id"> !!</span><span class="id"> Aco</span><span class="id"> _</span><span class="id"> _</span><span class="id"> pA;</span><span class="id"> rewrite</span> (<span class="id">hT</span><span class="id"> p</span><span class="id"> q</span>)<span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> cvg_cluster</span><span class="id"> clsAp_q;</span><span class="id"> apply:</span><span class="id"> cvg_within</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> discrete_hausdorff</span><span class="id"> {dsc</span><span class="id"> :</span><span class="id"> discrete_space</span><span class="id"> T}</span><span class="id"> :</span><span class="id"> hausdorff_space</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> p</span><span class="id"> q</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> _</span> (<span class="id">discrete_set1</span><span class="id"> p</span>) (<span class="id">discrete_set1</span><span class="id"> q</span>))<span class="id"> []</span><span class="id"> //</span><span class="id"> x</span><span class="id"> []</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> compact_cluster_set1</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> F</span><span class="id"> V</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span><span class="id"> -&gt;</span><span class="id"> compact</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> nbhs</span><span class="id"> x</span><span class="id"> V</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> cluster</span><span class="id"> F</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> x]</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ?</span><span class="id"> cptV</span><span class="id"> nxV</span><span class="id"> PF</span><span class="id"> FV</span><span class="id"> clFx1</span><span class="id"> U</span><span class="id"> nbhsU;</span><span class="id"> rewrite</span><span class="id"> nbhs_simpl</span>.<br/>
<span class="id">wlog</span><span class="id"> oU</span><span class="id"> :</span><span class="id"> U</span><span class="id"> nbhsU</span><span class="id"> /</span><span class="id"> open</span><span class="id"> U</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> nbhsE</span><span class="gallina-kwd"> in</span><span class="id"> nbhsU;</span><span class="id"> case:</span><span class="id"> nbhsU</span><span class="id"> =&gt;</span><span class="id"> O</span><span class="id"> oO</span><span class="id"> OsubU</span><span class="id"> /</span>(_<span class="id"> O</span>)<span class="id"> WH</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">filterS</span><span class="id"> OsubU</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> WH;</span><span class="id"> [exact:</span><span class="id"> open_nbhs_nbhs</span><span class="id"> |</span><span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> oO]</span>.<br/>
<span class="id">have</span><span class="id"> /compact_near_coveringP</span><span class="id"> :</span><span class="id"> compact</span> (<span class="id">V</span><span class="id"> `\`</span><span class="id"> U</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">subclosed_compact</span><span class="id"> _</span><span class="id"> cptV</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> closedI;</span><span class="id"> [exact:</span><span class="id"> compact_closed</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> open_closedC]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /</span>(_<span class="id"> _</span> (<span class="id">powerset_filter_from</span><span class="id"> F</span>) (<span class="gallina-kwd">fun</span><span class="id"> W</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> ~</span><span class="id"> W</span><span class="id"> x</span>))<span class="id">[]</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> [Vz</span><span class="id"> ?];</span><span class="id"> have</span><span class="id"> zE</span><span class="id"> :</span><span class="id"> x</span><span class="id"> &lt;&gt;</span><span class="id"> z</span><span class="gallina-kwd"> by</span><span class="id"> move/nbhs_singleton:</span><span class="id"> nbhsU</span><span class="id"> =&gt;</span><span class="id"> /[swap]</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> :</span><span class="id"> ~</span><span class="id"> cluster</span><span class="id"> F</span><span class="id"> z</span><span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> zE;</span><span class="id"> apply:</span><span class="id"> contra_not;</span><span class="id"> rewrite</span><span class="id"> clFx1</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">case/existsNP=&gt;</span><span class="id"> C</span><span class="id"> /existsPNP</span><span class="id"> [D]</span><span class="id"> FC</span><span class="id"> /existsNP</span><span class="id"> [Dz]</span><span class="id"> /set0P/negP/negPn/eqP</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setIC</span><span class="id"> =&gt;</span><span class="id"> /disjoints_subset</span><span class="id"> CD0;</span><span class="gallina-kwd"> exists</span> (<span class="id">D,</span><span class="id"> [set</span><span class="id"> W</span><span class="id"> |</span><span class="id"> F</span><span class="id"> W</span><span class="id"> /\</span><span class="id"> W</span><span class="id"> `&lt;=`</span><span class="id"> C]</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> //=</span><span class="id"> nbhs_simpl;</span><span class="id"> exact:</span><span class="id"> powerset_filter_fromP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case</span><span class="id"> =&gt;</span><span class="id"> t</span><span class="id"> W</span><span class="id"> [Dt]</span><span class="id"> [FW]</span><span class="id"> /subsetCP;</span><span class="id"> apply;</span><span class="id"> apply:</span><span class="id"> CD0</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> M</span><span class="id"> [MF</span><span class="id"> ME2</span><span class="id"> [W]</span><span class="id"> MW</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> MW</span>)<span class="id"> VUW]</span>.<br/>
<span class="id">apply:</span> (<span class="id">@filterS</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">V</span><span class="id"> `&amp;`</span><span class="id"> W</span>))<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> MF</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> t</span><span class="id"> [Vt</span><span class="id"> Wt];</span><span class="id"> apply:</span><span class="id"> contrapT</span><span class="id"> =&gt;</span><span class="id"> Ut;</span><span class="id"> exact:</span> (<span class="id">VUW</span><span class="id"> t</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> compact_precompact</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span><span class="id"> -&gt;</span><span class="id"> compact</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> precompact</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> h</span><span class="id"> c;</span><span class="id"> rewrite</span><span class="id"> precompactE</span> (<span class="id"> _</span><span class="id"> :</span><span class="id"> closure</span><span class="id"> A</span><span class="id"> =</span><span class="id"> A</span>)<span class="id">//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/esym/closure_id;</span><span class="id"> exact:</span><span class="id"> compact_closed</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> open_hausdorff</span><span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> T</span>)<span class="id">,</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> y</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> AB,</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> AB</span>.<span class="id">1</span><span class="id"> /\</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> AB</span>.<span class="id">2</span>)<span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> open</span><span class="id"> AB</span>.<span class="id">1,</span><span class="id"> open</span><span class="id"> AB</span>.<span class="id">2</span><span class="id"> &amp;</span><span class="id"> AB</span>.<span class="id">1</span><span class="id"> `&amp;`</span><span class="id"> AB</span>.<span class="id">2</span><span class="id"> ==</span><span class="id"> set0]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> propeqE;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [T_filterT2|T_openT2]</span><span class="id"> x</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> :=</span><span class="id"> contra_not</span> (<span class="id">T_filterT2</span><span class="id"> x</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> rewrite</span> (<span class="id">rwP</span><span class="id"> eqP</span>) (<span class="id">rwP</span><span class="id"> negP</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /[apply]</span><span class="id"> /asboolPn/existsp_asboolPn[A];</span><span class="id"> rewrite</span><span class="id"> -existsNE</span><span class="id"> =&gt;</span><span class="id"> -[B]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [nbhs</span><span class="id"> _</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> _]</span>(<span class="id">rwP</span><span class="id"> imply_asboolP</span>)<span class="id"> =&gt;</span><span class="id"> /negP</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> asbool_imply</span><span class="id"> !negb_imply</span><span class="id"> =&gt;</span><span class="id"> /andP[/asboolP</span><span class="id"> xA]</span><span class="id"> /andP[/asboolP</span><span class="id"> yB]</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /asboolPn;</span><span class="id"> rewrite</span><span class="id"> -set0P</span><span class="id"> =&gt;</span><span class="id"> /negP;</span><span class="id"> rewrite</span><span class="id"> negbK</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> AIB_eq0</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> xA</span><span class="id"> yB;</span><span class="id"> rewrite</span><span class="id"> !nbhsE</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> -</span><span class="id"> [oA</span><span class="id"> [oA_open</span><span class="id"> oAx]</span><span class="id"> oAA]</span><span class="id"> [oB</span><span class="id"> [oB_open</span><span class="id"> oBx]</span><span class="id"> oBB]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">oA,</span><span class="id"> oB</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?inE;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> subsetI_eq0</span><span class="id"> AIB_eq0</span>.<br/>
<span class="id">apply:</span><span class="id"> contraPP</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> /T_openT2[[/=A</span><span class="id"> B]]</span>.<br/>
<span class="id">rewrite</span><span class="id"> !inE</span><span class="id"> =&gt;</span><span class="id"> -</span><span class="id"> [xA</span><span class="id"> yB]</span><span class="id"> [Aopen</span><span class="id"> Bopen</span><span class="id"> /eqP</span><span class="id"> AIB_eq0]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /</span>(_<span class="id"> A</span><span class="id"> B</span> (<span class="id">open_nbhs_nbhs</span><span class="id"> _</span>) (<span class="id">open_nbhs_nbhs</span><span class="id"> _</span>)).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -set0P</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> _</span>)<span class="id">/negP;</span><span class="id"> apply</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> hausdorff_accessible</span><span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> -&gt;</span><span class="id"> accessible_space</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> open_hausdorff</span><span class="id"> =&gt;</span><span class="id"> hsdfT</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /hsdfT</span><span class="id"> [[U</span><span class="id"> V]</span><span class="id"> [xU</span><span class="id"> yV]]</span><span class="id"> [/=</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> /eqP]</span>.<br/>
<span class="id">rewrite</span><span class="id"> setIC</span><span class="id"> =&gt;</span><span class="id"> /disjoints_subset</span><span class="id"> VUc;</span><span class="gallina-kwd"> exists</span><span class="id"> U;</span><span class="id"> repeat</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> apply:</span><span class="id"> VUc;</span><span class="id"> rewrite</span><span class="id"> -inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> accessible_closed_set1</span><span class="id"> :</span><span class="id"> accessible_space</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> closed</span><span class="id"> [set</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> T1</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> closed</span><span class="id"> X]setCK;</span><span class="id"> apply:</span><span class="id"> open_closedC</span>.<br/>
<span class="id">rewrite</span><span class="id"> openE</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> /eqP</span><span class="id"> /T1</span><span class="id"> [U</span><span class="id"> [oU</span><span class="id"> yU</span><span class="id"> xU]]</span>.<br/>
<span class="id">rewrite</span><span class="id"> /interior</span><span class="id"> nbhsE</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> U;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subsetC1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> set_mem</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> accessible_kolmogorov</span><span class="id"> :</span><span class="id"> accessible_space</span><span class="id"> -&gt;</span><span class="id"> kolmogorov_space</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> T1</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /T1</span><span class="id"> [A</span><span class="id"> [oA</span><span class="id"> xA</span><span class="id"> yA]];</span><span class="gallina-kwd"> exists</span><span class="id"> A;</span><span class="id"> left;</span><span class="id"> split=&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nbhsE</span><span class="id"> inE;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="gallina-kwd"> in</span><span class="id"> xA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> accessible_finite_set_closed</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">accessible_space</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> closed</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> [TT1</span><span class="id"> A</span><span class="id"> fA|h</span><span class="id"> x</span><span class="id"> y</span><span class="id"> xy]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">fsbig_setU_set1</span><span class="id"> fA</span>)<span class="id"> fsbig_finite//=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> closed_bigsetU</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> xA;</span><span class="id"> exact:</span><span class="id"> accessible_closed_set1</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">~`</span><span class="id"> [set</span><span class="id"> y]</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !inE/=;</span><span class="id"> split;</span><br/>
&nbsp;&nbsp;<span class="id">[rewrite</span><span class="id"> openC;</span><span class="id"> exact:</span><span class="id"> h|exact/eqP|]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> point_separation_axioms</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> hausdorff_space</span><span class="id"> :</span><span class="id"> clear</span><span class="id"> implicits</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> accessible_space</span><span class="id"> :</span><span class="id"> clear</span><span class="id"> implicits</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> kolmogorov_space</span><span class="id"> :</span><span class="id"> clear</span><span class="id"> implicits</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subspace_hausdorff</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> topologicalType}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> hausdorff_space</span> (<span class="id">subspace</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> ?open_hausdorff</span><span class="id"> =&gt;</span><span class="id"> +</span><span class="id"> x</span><span class="id"> y</span><span class="id"> xNy</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> x</span><span class="id"> y</span><span class="id"> xNy</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> [[P</span><span class="id"> Q]]</span><span class="id"> /=</span><span class="id"> [Px</span><span class="id"> Qx]</span><span class="id"> /=</span><span class="id"> [/open_subspaceW</span><span class="id"> oP</span><span class="id"> /open_subspaceW</span><span class="id"> oQ]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="gallina-kwd"> exists</span> (<span class="id">P,</span><span class="id"> Q</span>)<span class="id">;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> [exact:</span><span class="id"> oP</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> oQ]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> order_hausdorff</span><span class="id"> {d}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> orderTopologicalType</span><span class="id"> d}</span><span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> T</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> open_hausdorff=&gt;</span><span class="id"> p</span><span class="id"> q;</span><span class="id"> wlog</span><span class="id"> :</span><span class="id"> p</span><span class="id"> q</span><span class="id"> /</span> (<span class="id">p</span><span class="id"> &lt;</span><span class="id"> q</span>)<span class="id">%O</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /orP[]</span><span class="id"> :=</span><span class="id"> le_total</span><span class="id"> p</span><span class="id"> q;</span><span class="id"> rewrite</span><span class="id"> le_eqVlt</span><span class="id"> =&gt;</span><span class="id"> /predU1P[-&gt;|]</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> eqxx</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> eqxx</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> qp</span><span class="id"> WH;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> =&gt;</span><span class="id"> /</span>(<span class="id">WH</span><span class="id"> _</span><span class="id"> _</span><span class="id"> qp</span>)<span class="id">[[P</span><span class="id"> Q]</span><span class="id"> [?</span><span class="id"> ?]</span><span class="id"> [?</span><span class="id"> ?</span><span class="id"> ?]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">Q,</span><span class="id"> P</span>)<span class="id">;</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> setIC</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> plq</span><span class="id"> ?;</span><span class="id"> have</span><span class="id"> [[z</span><span class="id"> /andP[pz</span><span class="id"> zq]]|]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="gallina-kwd">exists</span><span class="id"> z,</span><span class="id"> p</span><span class="id"> &lt;</span><span class="id"> z</span><span class="id"> &lt;</span><span class="id"> q</span>)<span class="id">%O</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">`]-oo,z[,</span><span class="id"> `]z,+oo[</span>)<span class="id">%classic</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> apply/mem_set;</span><span class="id"> rewrite</span><span class="id"> set_itvE</span>.<br/>
&nbsp;&nbsp;<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> ;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -subset0</span><span class="id"> =&gt;</span><span class="id"> r;</span><span class="id"> rewrite</span><span class="id"> set_itvE</span><span class="id"> =&gt;</span><span class="id"> -[/=</span><span class="id"> rz]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/negP;</span><span class="id"> rewrite</span><span class="id"> in_itv/=</span><span class="id"> andbT</span><span class="id"> -leNgt</span> (<span class="id">ltW</span><span class="id"> rz</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> npzq;</span><span class="gallina-kwd"> exists</span> (<span class="id">`]-oo,</span><span class="id"> q[,</span><span class="id"> `]p,</span><span class="id"> +oo[</span>)<span class="id">%classic;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply</span><span class="id"> /mem_set;</span><span class="id"> rewrite</span><span class="id"> set_itvE</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply</span><span class="id"> /mem_set;</span><span class="id"> rewrite</span><span class="id"> set_itvE</span>.<br/>
<span class="id">-</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -subset0</span><span class="id"> =&gt;</span><span class="id"> r;</span><span class="id"> rewrite</span><span class="id"> !set_itvE</span><span class="id"> =&gt;</span><span class="id"> -[/=</span><span class="id"> rz</span><span class="id"> zr]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> npzq;</span><span class="gallina-kwd"> exists</span><span class="id"> r;</span><span class="id"> rewrite</span><span class="id"> rz</span><span class="id"> zr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> ball_hausdorff</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numDomainType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> pseudoMetricType</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ball_hausdorff</span><span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> T</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> T</span>)<span class="id">,</span><span class="id"> a</span><span class="id"> !=</span><span class="id"> b</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> r</span><span class="id"> :</span><span class="id"> {posnum</span><span class="id"> R}</span><span class="id"> *</span><span class="id"> {posnum</span><span class="id"> R},</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ball</span><span class="id"> a</span><span class="id"> r</span>.<span class="id">1%:num</span><span class="id"> `&amp;`</span><span class="id"> ball</span><span class="id"> b</span><span class="id"> r</span>.<span class="id">2%:num</span><span class="id"> ==</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> propeqE</span><span class="id"> open_hausdorff;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> T2T</span><span class="id"> a</span><span class="id"> b</span><span class="id"> /T2T[[/=]]</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B;</span><span class="id"> rewrite</span><span class="id"> 2!inE</span><span class="id"> =&gt;</span><span class="id"> [[aA</span><span class="id"> bB]</span><span class="id"> [oA</span><span class="id"> oB</span><span class="id"> /eqP</span><span class="id"> ABeq0]]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /nbhs_ballP[_/posnumP[r]</span><span class="id"> rA]:</span><span class="id"> nbhs</span><span class="id"> a</span><span class="id"> A</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> open_nbhs_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /nbhs_ballP[_/posnumP[s]</span><span class="id"> rB]:</span><span class="id"> nbhs</span><span class="id"> b</span><span class="id"> B</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> open_nbhs_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">r,</span><span class="id"> s</span>)<span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> rewrite</span> (<span class="id">subsetI_eq0</span><span class="id"> _</span><span class="id"> _</span><span class="id"> ABeq0</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> r</span><span class="id"> s</span><span class="id"> /eqP</span><span class="id"> brs_eq0;</span><span class="gallina-kwd"> exists</span> ((<span class="id">ball</span><span class="id"> a</span><span class="id"> r%:num</span>)<span class="id">^°,</span> (<span class="id">ball</span><span class="id"> b</span><span class="id"> s%:num</span>)<span class="id">^°</span>)<span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">split;</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> apply:</span><span class="id"> nbhs_singleton;</span><span class="id"> apply:</span><span class="id"> nbhs_interior;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/nbhs_ballP;</span><span class="id"> apply:</span><span class="id"> in_filter_from</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="id">split;</span><span class="id"> do</span><span class="id"> ?by</span><span class="id"> apply:</span><span class="id"> open_interior</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">subsetI_eq0</span><span class="id"> _</span><span class="id"> _</span><span class="id"> brs_eq0</span>)<span class="id">//;</span><span class="id"> apply:</span><span class="id"> interior_subset</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> ball_hausdorff</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> numFieldTopology</span>.<span class="vernacular">Exports</span>.<br/>
<span class="vernacular">Lemma</span><span class="id"> Rhausdorff</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> order_hausdorff</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> one_point_compactification_hausdorff</span><span class="id"> {X</span><span class="id"> :</span><span class="id"> topologicalType}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">locally_compact</span><span class="id"> [set:</span><span class="id"> X]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">hausdorff_space</span><span class="id"> X</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">hausdorff_space</span> (<span class="id">one_point_compactification</span><span class="id"> X</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> lcpt</span><span class="id"> hsdfX</span><span class="id"> [x|]</span><span class="id"> [y|]</span><span class="id"> //=</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> clxy;</span><span class="id"> congr</span><span class="id"> Some;</span><span class="id"> apply:</span><span class="id"> hsdfX</span><span class="id"> =&gt;</span><span class="id"> U</span><span class="id"> V</span><span class="id"> Ux</span><span class="id"> Vy</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> clxy</span> (<span class="id">Some</span><span class="id"> @`</span><span class="id"> U</span>) (<span class="id">Some</span><span class="id"> @`</span><span class="id"> V</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> Ux;</span><span class="id"> exact:</span><span class="id"> preimage_image</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> Vy;</span><span class="id"> exact:</span><span class="id"> preimage_image</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> [_|]</span><span class="id"> []</span><span class="id"> /=</span><span class="id"> [//</span><span class="id"> p</span><span class="id"> /[swap]</span><span class="id"> -[]</span><span class="id"> &lt;-</span><span class="id"> Up]</span><span class="id"> [q</span><span class="id"> /[swap]</span><span class="id"> -[]</span><span class="id"> -&gt;</span><span class="id"> Vp];</span><span class="gallina-kwd"> exists</span><span class="id"> p</span>.<br/>
<span class="id">-</span><span class="id"> have</span><span class="id"> [U]</span><span class="id"> :=</span><span class="id"> lcpt</span><span class="id"> x</span><span class="id"> I;</span><span class="id"> rewrite</span><span class="id"> withinET</span><span class="id"> =&gt;</span><span class="id"> Ux</span><span class="id"> [cU</span><span class="id"> clU]</span>.<br/>
&nbsp;&nbsp;<span class="id">case/</span>(_ (<span class="id">Some</span><span class="id"> @`</span><span class="id"> U</span>) (<span class="id">Some</span><span class="id"> @`</span> (<span class="id">~`</span><span class="id"> U</span>)<span class="id"> `|`</span><span class="id"> [set</span><span class="id"> None]</span>)).<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> exact:</span><span class="id"> one_point_compactification_some_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> U</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [?|]</span><span class="id"> [][]//</span><span class="id"> z</span><span class="id"> /[swap]</span><span class="id"> -[]</span><span class="id"> &lt;-</span><span class="id"> ?</span><span class="id"> []//=</span><span class="id"> [?</span><span class="id"> /[swap]</span><span class="id"> -[]</span><span class="id"> -&gt;]</span>.<br/>
<span class="id">-</span><span class="id"> have</span><span class="id"> [U]</span><span class="id"> :=</span><span class="id"> lcpt</span><span class="id"> y</span><span class="id"> I;</span><span class="id"> rewrite</span><span class="id"> withinET</span><span class="id"> =&gt;</span><span class="id"> Uy</span><span class="id"> [cU</span><span class="id"> clU]</span>.<br/>
&nbsp;&nbsp;<span class="id">case/</span>(_ (<span class="id">Some</span><span class="id"> @`</span> (<span class="id">~`</span><span class="id"> U</span>)<span class="id"> `|`</span><span class="id"> [set</span><span class="id"> None]</span>) (<span class="id">Some</span><span class="id"> @`</span><span class="id"> U</span>))<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> U</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> one_point_compactification_some_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> [?|]</span><span class="id"> []</span><span class="id"> []</span><span class="id"> //=</span><span class="id"> +</span><span class="id"> []</span><span class="id"> ?</span><span class="id"> //</span><span class="id"> /[swap]</span><span class="id"> -[]</span><span class="id"> -&gt;</span><span class="id"> =&gt;</span><span class="id"> -[?</span><span class="id"> /[swap]</span><span class="id"> -[]</span><span class="id"> &lt;-]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> hausdorff_topologicalType</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="id"> topologicalType</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> close</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> M,</span><span class="id"> open_nbhs</span><span class="id"> y</span><span class="id"> M</span><span class="id"> -&gt;</span><span class="id"> closure</span><span class="id"> M</span><span class="id"> x</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> closeEnbhs</span><span class="id"> x</span><span class="id"> :</span><span class="id"> close</span><span class="id"> x</span><span class="id"> =</span><span class="id"> cluster</span> (<span class="id">nbhs</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">transitivity</span> (<span class="id">cluster</span> (<span class="id">open_nbhs</span><span class="id"> x</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /cluster;</span><span class="id"> under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> -meets_openl</span>.<br/>
<span class="id">rewrite</span><span class="id"> clusterEonbhs</span><span class="id"> /close</span><span class="id"> funeqE</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> meetsC</span><span class="id"> /meets</span>.<br/>
<span class="id">apply/eq_forall</span><span class="id"> =&gt;</span><span class="id"> A;</span><span class="id"> rewrite</span><span class="id"> forall_swap</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> closureEonbhs/=</span><span class="id"> meets_globallyl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> closeEonbhs</span><span class="id"> x</span><span class="id"> :</span><span class="id"> close</span><span class="id"> x</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> y</span><span class="id"> |</span><span class="id"> open_nbhs</span><span class="id"> x</span><span class="id"> `#`</span><span class="id"> open_nbhs</span><span class="id"> y]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> closeEnbhs;</span><span class="id"> under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> -meets_openl</span><span class="id"> -meets_openr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> close_sym</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> close</span><span class="id"> x</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> close</span><span class="id"> y</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !closeEnbhs</span><span class="id"> /cluster/=</span><span class="id"> meetsC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_close</span><span class="id"> {F}</span><span class="id"> {FF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F}</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> close</span><span class="id"> x</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /sub_meets</span><span class="id"> sx</span><span class="id"> /sx;</span><span class="id"> rewrite</span><span class="id"> closeEnbhs;</span><span class="id"> apply;</span><span class="id"> apply/proper_meetsxx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> close_refl</span><span class="id"> x</span><span class="id"> :</span><span class="id"> close</span><span class="id"> x</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span> (<span class="id">@cvg_close</span> (<span class="id">nbhs</span><span class="id"> x</span>)). Qed.</div></details>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> close_refl</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvgx_close</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> x</span><span class="id"> --&gt;</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> close</span><span class="id"> x</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> cvg_close</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvgi_close</span><span class="id"> T'</span><span class="id"> {F}</span><span class="id"> {FF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T'</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">l</span><span class="id"> l'</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{near</span><span class="id"> F,</span><span class="id"> is_fun</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> `@</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> l</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> `@</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> l'</span><span class="id"> -&gt;</span><span class="id"> close</span><span class="id"> l</span><span class="id"> l'</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> f_prop</span><span class="id"> fFl</span><span class="id"> fFl'</span>.<br/>
<span class="id">suff</span><span class="id"> f_totalfun:</span><span class="id"> {near</span><span class="id"> F,</span><span class="id"> is_totalfun</span><span class="id"> f}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> cvg_close</span><span class="id"> fFl</span><span class="id"> fFl';</span><span class="id"> exact:</span><span class="id"> fmapi_proper_filter</span>.<br/>
<span class="id">apply:</span><span class="id"> filter_app</span><span class="id"> f_prop;</span><span class="id"> near</span><span class="id"> do</span><span class="id"> split=&gt;</span><span class="id"> //=</span>.<br/>
<span class="id">have:</span> (<span class="id">f</span><span class="id"> `@</span><span class="id"> F</span>)<span class="id"> setT</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> fFl;</span><span class="id"> apply:</span><span class="id"> filterT</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> fmapiE;</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> [y</span><span class="id"> []];</span><span class="gallina-kwd"> exists</span><span class="id"> y</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.5.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;use `cvgi_close` instead&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Definition</span><span class="id"> cvg_toi_locally_close</span><span class="id"> :=</span><span class="id"> @cvgi_close</span>.<br/>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> sep</span><span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> closeE</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> close</span><span class="id"> x</span><span class="id"> y</span><span class="id"> =</span> (<span class="id">x</span><span class="id"> =</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> propeqE;</span><span class="id"> split;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> -&gt;;</span><span class="id"> exact:</span><span class="id"> close_refl</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> closeEnbhs;</span><span class="id"> exact:</span><span class="id"> sep</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> close_eq</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> close</span><span class="id"> x</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> =</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> closeE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_unique</span><span class="id"> {F}</span><span class="id"> {FF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F}</span><span class="id"> :</span><span class="id"> is_subset1</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T</span><span class="id"> |</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> move=&gt;</span><span class="id"> Fx</span><span class="id"> Fy;</span><span class="id"> rewrite</span><span class="id"> -closeE</span><span class="id"> //;</span><span class="id"> exact:</span> (<span class="id">@cvg_close</span><span class="id"> F</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_eq</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> x</span><span class="id"> --&gt;</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> =</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -closeE</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> cvg_close</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvgi_unique</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> Type}</span><span class="id"> {F}</span><span class="id"> {FF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{near</span><span class="id"> F,</span><span class="id"> is_fun</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> is_subset1</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T</span><span class="id"> |</span><span class="id"> f</span><span class="id"> `@</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ffun</span><span class="id"> fx</span><span class="id"> fy;</span><span class="id"> rewrite</span><span class="id"> -closeE</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> cvgi_close</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> hausdorff_topologicalType</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> hausdorff_ptopologicalType</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="id"> ptopologicalType</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> close_cvg</span> (<span class="id">F1</span><span class="id"> F2</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>)<span class="id"> {FF2</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F2}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">F1</span><span class="id"> --&gt;</span><span class="id"> F2</span><span class="id"> -&gt;</span><span class="id"> F2</span><span class="id"> --&gt;</span><span class="id"> F1</span><span class="id"> -&gt;</span><span class="id"> close</span> (<span class="id">lim</span><span class="id"> F1</span>) (<span class="id">lim</span><span class="id"> F2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F12</span><span class="id"> F21</span>.<br/>
<span class="id">have</span><span class="id"> [/</span>(<span class="id">cvg_trans</span><span class="id"> F21</span>)<span class="id"> F2l|dvgF1]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">cvg</span><span class="id"> F1</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">@cvg_close</span><span class="id"> _</span><span class="id"> F2</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> cvgP</span><span class="id"> F2l</span>.<br/>
<span class="id">have</span><span class="id"> [/</span>(<span class="id">cvg_trans</span><span class="id"> F12</span>)<span class="id">/cvgP//|dvgF2]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">cvg</span><span class="id"> F2</span>).<br/>
<span class="id">rewrite</span><span class="id"> dvgP</span><span class="id"> //</span><span class="id"> dvgP</span><span class="id"> //;</span><span class="id"> exact/close_refl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> sep</span><span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lim_id</span><span class="id"> x</span><span class="id"> :</span><span class="id"> lim</span> (<span class="id">nbhs</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/esym/cvg_eq/cvg_ex</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_lim</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> Type}</span><span class="id"> {F}</span><span class="id"> {FF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> T</span>) (<span class="id">l</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> @</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> l</span><span class="id"> -&gt;</span><span class="id"> lim</span> (<span class="id">f</span><span class="id"> @</span><span class="id"> F</span>)<span class="id"> =</span><span class="id"> l</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /[dup]</span><span class="id"> /cvgP</span><span class="id"> /cvg_unique;</span><span class="id"> apply</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lim_near_cst</span><span class="id"> {U}</span><span class="id"> {F}</span><span class="id"> {FF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F}</span> (<span class="id">l</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> x</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> =</span><span class="id"> l</span>)<span class="id"> -&gt;</span><span class="id"> lim</span> (<span class="id">f</span><span class="id"> @</span><span class="id"> F</span>)<span class="id"> =</span><span class="id"> l</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /cvg_near_cst/cvg_lim</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lim_cst</span><span class="id"> {U}</span><span class="id"> {F}</span><span class="id"> {FF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F}</span> (<span class="id">k</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">lim</span> ((<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> :</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> k</span>)<span class="id"> @</span><span class="id"> F</span>)<span class="id"> =</span><span class="id"> k</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> cvg_lim;</span><span class="id"> apply:</span><span class="id"> cvg_cst</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvgi_lim</span><span class="id"> {U}</span><span class="id"> {F}</span><span class="id"> {FF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>) (<span class="id">l</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">F</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> :</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> is_subset1</span> (<span class="id">f</span><span class="id"> x</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> `@</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> l</span><span class="id"> -&gt;</span><span class="id"> lim</span> (<span class="id">f</span><span class="id"> `@</span><span class="id"> F</span>)<span class="id"> =</span><span class="id"> l</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> f_prop</span><span class="id"> fl;</span><span class="id"> apply:</span><span class="id"> get_unique</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> l'</span><span class="id"> fl';</span><span class="id"> exact:</span><span class="id"> cvgi_unique</span><span class="id"> _</span><span class="id"> fl'</span><span class="id"> fl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> hausdorff_ptopologicalType</span>.<br/>
<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed to `cvg_lim`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> cvg_map_lim</span><span class="id"> :=</span><span class="id"> cvg_lim</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed to `cvgi_lim`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> cvgi_map_lim</span><span class="id"> :=</span><span class="id"> cvgi_lim</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> close_refl</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> close_cvg</span><span class="id"> {T}</span><span class="id"> F1</span><span class="id"> F2</span><span class="id"> {FF2}</span><span class="id"> _</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> close_uniform</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> uniformType</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> entourage_close</span><span class="id"> {U}</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">close</span><span class="id"> x</span><span class="id"> y</span><span class="id"> =</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> entourage</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> A</span> (<span class="id">x,</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> propeqE;</span><span class="id"> split=&gt;</span><span class="id"> [cxy</span><span class="id"> A</span><span class="id"> entA|cxy]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /entourage_split_ent</span><span class="id"> entsA</span><span class="id"> :=</span><span class="id"> entA;</span><span class="id"> rewrite</span><span class="id"> closeEnbhs</span><span class="gallina-kwd"> in</span><span class="id"> cxy</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> yl</span><span class="id"> :=</span><span class="id"> nbhs_entourage</span><span class="id"> _</span> (<span class="id">entourage_inv</span><span class="id"> entsA</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> yr</span><span class="id"> :=</span><span class="id"> nbhs_entourage</span><span class="id"> _</span><span class="id"> entsA</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [z</span><span class="id"> [/xsectionP</span><span class="id"> zx</span><span class="id"> /xsectionP</span><span class="id"> zy]]</span><span class="id"> :=</span><span class="id"> cxy</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">yr</span><span class="id"> x</span>) (<span class="id">yl</span><span class="id"> y</span>).<br/>
&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">entourage_split</span><span class="id"> z</span>).<br/>
<span class="id">rewrite</span><span class="id"> closeEnbhs</span><span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> /nbhsP[E1</span><span class="id"> entE1</span><span class="id"> sE1A]</span><span class="id"> /nbhsP[E2</span><span class="id"> entE2</span><span class="id"> sE2B]</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> y;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply/sE1A/xsectionP;</span><span class="id"> exact:</span><span class="id"> cxy</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply/sE2B/xsectionP;</span><span class="id"> exact:</span><span class="id"> entourage_refl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> close_trans</span><span class="id"> {U}</span> (<span class="id">y</span><span class="id"> x</span><span class="id"> z</span><span class="id"> :</span><span class="id"> U</span>)<span class="id"> :</span><span class="id"> close</span><span class="id"> x</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> close</span><span class="id"> y</span><span class="id"> z</span><span class="id"> -&gt;</span><span class="id"> close</span><span class="id"> x</span><span class="id"> z</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> !entourage_close</span><span class="id"> =&gt;</span><span class="id"> cxy</span><span class="id"> cyz</span><span class="id"> A</span><span class="id"> entA</span>.<br/>
<span class="id">exact:</span><span class="id"> entourage_split</span> (<span class="id">cxy</span><span class="id"> _</span><span class="id"> _</span>) (<span class="id">cyz</span><span class="id"> _</span><span class="id"> _</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> close_cvgxx</span><span class="id"> {U}</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> U</span>)<span class="id"> :</span><span class="id"> close</span><span class="id"> x</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> --&gt;</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> entourage_close</span><span class="id"> =&gt;</span><span class="id"> cxy</span><span class="id"> P</span><span class="id"> /=</span><span class="id"> /nbhsP[A</span><span class="id"> entA</span><span class="id"> sAP]</span>.<br/>
<span class="id">apply/nbhsP;</span><span class="gallina-kwd"> exists</span> (<span class="id">split_ent</span><span class="id"> A</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> z</span><span class="id"> /xsectionP</span><span class="id"> xz;</span><span class="id"> apply:</span><span class="id"> sAP</span>.<br/>
<span class="id">apply/xsectionP;</span><span class="id"> apply:</span> (<span class="id">entourage_split</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> cxy</span><span class="id"> _</span> (<span class="id">entourage_inv</span> (<span class="id">entourage_split_ent</span><span class="id"> entA</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_closeP</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> puniformType}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> U</span>) (<span class="id">l</span><span class="id"> :</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ProperFilter</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">F</span><span class="id"> --&gt;</span><span class="id"> l</span><span class="id"> &lt;-&gt;</span> (<span class="id">[cvg</span><span class="id"> F</span><span class="gallina-kwd"> in</span><span class="id"> U]</span><span class="id"> /\</span><span class="id"> close</span> (<span class="id">lim</span><span class="id"> F</span>)<span class="id"> l</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF;</span><span class="id"> split=&gt;</span><span class="id"> [Fl|[cvF]Cl]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /cvgP</span><span class="id"> :=</span><span class="id"> Fl;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply:</span> (<span class="id">@cvg_close</span><span class="id"> _</span><span class="id"> F</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> cvg_trans</span> (<span class="id">close_cvgxx</span><span class="id"> Cl</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ball_close</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> numFieldType}</span><span class="id"> {M</span><span class="id"> :</span><span class="id"> pseudoMetricType</span><span class="id"> R}</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> M</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">close</span><span class="id"> x</span><span class="id"> y</span><span class="id"> =</span><span class="gallina-kwd"> forall</span><span class="id"> eps</span><span class="id"> :</span><span class="id"> {posnum</span><span class="id"> R},</span><span class="id"> ball</span><span class="id"> x</span><span class="id"> eps%:num</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> propeqE;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [cxy</span><span class="id"> eps|cxy]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> :=</span><span class="id"> !!</span><span class="id"> cxy</span><span class="id"> _</span> (<span class="id">open_nbhs_ball</span><span class="id"> _</span> (<span class="id">eps%:num/2</span>)<span class="id">%:pos</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> closureEonbhs/=</span><span class="id"> meetsC</span><span class="id"> meets_globallyr</span>.<br/>
&nbsp;&nbsp;<span class="id">move/</span>(_<span class="id"> _</span> (<span class="id">open_nbhs_ball</span><span class="id"> _</span> (<span class="id">eps%:num/2</span>)<span class="id">%:pos</span>))<span class="id"> =&gt;</span><span class="id"> [z</span><span class="id"> [zx</span><span class="id"> zy]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">@ball_splitl</span><span class="id"> _</span><span class="id"> _</span><span class="id"> z</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> interior_subset</span>.<br/>
<span class="id">rewrite</span><span class="id"> closeEnbhs</span><span class="id"> =&gt;</span><span class="id"> B</span><span class="id"> A</span><span class="id"> /nbhs_ballP[_/posnumP[e2</span><span class="id"> e2B]]</span><br/>
&nbsp;&nbsp;<span class="id">/nbhs_ballP[_/posnumP[e1</span><span class="id"> e1A]]</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> y;</span><span class="id"> split;</span><span class="id"> [apply/e2B|apply/e1A;</span><span class="id"> exact:</span><span class="id"> ballxx]</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> close_uniform</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> set_separations</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> topologicalType}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> normal_space</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span><span class="id"> closed</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">filter_from</span> (<span class="id">set_nbhs</span><span class="id"> A</span>)<span class="id"> closure</span><span class="id"> `=&gt;`</span><span class="id"> set_nbhs</span><span class="id"> A</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> regular_space</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> a</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> filter_from</span> (<span class="id">nbhs</span><span class="id"> a</span>)<span class="id"> closure</span><span class="id"> --&gt;</span><span class="id"> a</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> compact_regular</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> V</span><span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> compact</span><span class="id"> V</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">nbhs</span><span class="id"> x</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> {for</span><span class="id"> x,</span><span class="id"> regular_space}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sep</span><span class="id"> cptv</span><span class="id"> Vx;</span><span class="id"> apply:</span> (<span class="id">@compact_cluster_set1</span><span class="id"> T</span><span class="id"> x</span><span class="id"> _</span><span class="id"> V</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> filter_from_proper</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> /nbhs_singleton/subset_closure</span><span class="id"> ?;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> filter_from_filter;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> setT;</span><span class="id"> exact:</span><span class="id"> filterT</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> Px</span><span class="id"> Qx;</span><span class="gallina-kwd"> exists</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> Q</span>)<span class="id">;</span><span class="id"> [exact:</span><span class="id"> filterI</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> closureI]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> V</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> have</span><span class="id"> /closure_id</span><span class="id"> &lt;-</span><span class="id"> :</span><span class="id"> closed</span><span class="id"> V</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> compact_closed</span>.<br/>
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> [C</span><span class="id"> Cx</span><span class="id"> CA</span><span class="id"> /nbhs_singleton</span><span class="id"> Bx];</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/CA/subset_closure;</span><span class="id"> exact:</span><span class="id"> nbhs_singleton</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> apply:</span><span class="id"> contraPeq;</span><span class="id"> move:</span><span class="id"> sep;</span><span class="id"> rewrite</span><span class="id"> open_hausdorff</span><span class="id"> =&gt;</span><span class="id"> /[apply]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> [[B</span><span class="id"> A]]/=;</span><span class="id"> rewrite</span><span class="id"> ?inE;</span><span class="id"> case=&gt;</span><span class="id"> By</span><span class="id"> Ax</span><span class="id"> [oB</span><span class="id"> oA</span><span class="id"> BA0]</span>.<br/>
<span class="id">apply/existsNP;</span><span class="gallina-kwd"> exists</span> (<span class="id">closure</span><span class="id"> A</span>)<span class="id">;</span><span class="id"> apply/existsNP;</span><span class="gallina-kwd"> exists</span><span class="id"> B;</span><span class="id"> apply/not_implyP</span>.<br/>
<span class="id">split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> open_nbhs_nbhs</span>.<br/>
<span class="id">apply/not_implyP;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> open_nbhs_nbhs</span>.<br/>
<span class="id">apply/set0P/negP;</span><span class="id"> rewrite</span><span class="id"> negbK;</span><span class="id"> apply/eqP/disjoints_subset</span>.<br/>
<span class="id">have</span><span class="id"> /closure_id</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> closed</span> (<span class="id">~`</span><span class="id"> B</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> open_closedC</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/closure_subset/disjoints_subset;</span><span class="id"> rewrite</span><span class="id"> setIC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> compact_normal_local</span> (<span class="id">K</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> compact</span><span class="id"> K</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> K^°</span><span class="id"> -&gt;</span><span class="id"> {for</span><span class="id"> A,</span><span class="id"> normal_space}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> hT</span><span class="id"> cptV</span><span class="id"> A</span><span class="id"> AK</span><span class="id"> clA</span><span class="id"> B</span><span class="id"> snAB;</span><span class="id"> have</span><span class="id"> /compact_near_coveringP</span><span class="id"> cvA</span><span class="id"> :</span><span class="id"> compact</span><span class="id"> A</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/</span>(<span class="id">subclosed_compact</span><span class="id"> clA</span><span class="id"> cptV</span>)<span class="id">/</span>(<span class="id">subset_trans</span><span class="id"> AK</span>).<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> interior_subset</span>.<br/>
<span class="id">have</span><span class="id"> snbC</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> Filter</span> (<span class="id">filter_from</span> (<span class="id">set_nbhs</span><span class="id"> U</span>)<span class="id"> closure</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> filter_from_filter;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> setT;</span><span class="id"> apply:</span><span class="id"> filterT</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> sAP</span><span class="id"> sAQ;</span><span class="gallina-kwd"> exists</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> Q</span>)<span class="id">;</span><span class="id"> [apply</span><span class="id"> filterI|exact:</span><span class="id"> closureI]</span>.<br/>
<span class="id">have</span><span class="id"> [/</span>(<span class="id">congr1</span><span class="id"> setC</span>)<span class="id">|/set0P[b0</span><span class="id"> B0]]</span><span class="id"> :=</span><span class="id"> eqVneq</span> (<span class="id">~`</span><span class="id"> B</span>)<span class="id"> set0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setCK</span><span class="id"> setC0</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> exact:</span><span class="id"> filterT</span>.<br/>
<span class="id">have</span><span class="id"> PsnA</span><span class="id"> :</span><span class="id"> ProperFilter</span> (<span class="id">filter_from</span> (<span class="id">set_nbhs</span> (<span class="id">~`</span><span class="id"> B</span>))<span class="id"> closure</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> filter_from_proper</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> P</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> b0;</span><span class="id"> apply/subset_closure;</span><span class="id"> apply:</span><span class="id"> nbhs_singleton;</span><span class="id"> exact:</span><span class="id"> P</span>.<br/>
<span class="id">pose</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> powerset_filter_from</span> (<span class="id">filter_from</span> (<span class="id">set_nbhs</span> (<span class="id">~`</span><span class="id"> B</span>))<span class="id"> closure</span>).<br/>
<span class="id">have</span><span class="id"> PF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> powerset_filter_from_filter</span>.<br/>
<span class="id">have</span><span class="id"> cvP</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> A</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> \forall</span><span class="id"> x'</span><span class="id"> \near</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> i</span><span class="id"> \near</span><span class="id"> F,</span> (<span class="id">~`</span><span class="id"> i</span>)<span class="id"> x'</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> Ax;</span><span class="id"> case/set_nbhsP</span><span class="id"> :</span><span class="id"> snAB</span><span class="id"> =&gt;</span><span class="id"> C</span><span class="id"> [oC</span><span class="id"> AC</span><span class="id"> CB]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> @compact_regular</span><span class="id"> x</span><span class="id"> _</span><span class="id"> hT</span><span class="id"> cptV</span><span class="id"> _</span><span class="id"> C;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> AK</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nbhsE</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> C</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> AC</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> D</span><span class="id"> /nbhs_interior</span><span class="id"> nD</span><span class="id"> cDC</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> snBD</span><span class="id"> :</span><span class="id"> filter_from</span> (<span class="id">set_nbhs</span> (<span class="id">~`</span><span class="id"> B</span>))<span class="id"> closure</span> (<span class="id">closure</span> (<span class="id">~`</span><span class="id"> closure</span><span class="id"> D</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">closure</span> (<span class="id">~`</span><span class="id"> closure</span><span class="id"> D</span>))<span class="id"> =&gt;</span><span class="id"> [z|]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> nBZ;</span><span class="id"> apply:</span><span class="id"> filterS;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> subset_closure</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> open_nbhs_nbhs;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact/closed_openC/closed_closure</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact/</span>(<span class="id">subsetC</span><span class="id"> _</span><span class="id"> nBZ</span>)<span class="id">/</span>(<span class="id">subset_trans</span><span class="id"> cDC</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> @closed_closure</span><span class="id"> _</span> (<span class="id">~`</span><span class="id"> closure</span><span class="id"> D</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> closure_id</span><span class="id"> =&gt;</span><span class="id"> &lt;-</span>.<br/>
&nbsp;&nbsp;<span class="id">near=&gt;</span><span class="id"> y</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> have</span><span class="id"> Dy</span><span class="id"> :</span><span class="id"> D^°</span><span class="id"> y</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span> (<span class="id">near</span><span class="id"> nD</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> UclD</span><span class="id"> :</span><span class="id"> U</span><span class="id"> `&lt;=`</span><span class="id"> closure</span> (<span class="id">~`</span><span class="id"> closure</span><span class="id"> D</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">near</span> (<span class="id">small_set_sub</span><span class="id"> snBD</span>)<span class="id"> U</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> Uy;</span><span class="id"> have</span><span class="id"> [z</span><span class="id"> [/=</span><span class="id"> +</span><span class="id"> Dz]]</span><span class="id"> :=</span><span class="id"> UclD</span><span class="id"> _</span><span class="id"> Uy</span><span class="id"> _</span><span class="id"> Dy</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply;</span><span class="id"> exact:</span><span class="id"> subset_closure</span>.<br/>
<span class="id">case/</span>(_<span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> cvP</span>)<span class="id"> :</span><span class="id"> cvA</span><span class="id"> =&gt;</span><span class="id"> R</span><span class="id"> /=</span><span class="id"> [RA</span><span class="id"> Rmono</span><span class="id"> [U</span><span class="id"> RU]</span><span class="id"> RBx]</span>.<br/>
<span class="id">have</span><span class="id"> [V</span><span class="id"> /set_nbhsP</span><span class="id"> [W</span><span class="id"> [oW</span><span class="id"> cBW</span><span class="id"> WV]</span><span class="id"> clVU]]</span><span class="id"> :=</span><span class="id"> RA</span><span class="id"> _</span><span class="id"> RU;</span><span class="gallina-kwd"> exists</span> (<span class="id">~`</span><span class="id"> W</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/set_nbhsP;</span><span class="gallina-kwd"> exists</span> (<span class="id">~`</span><span class="id"> closure</span><span class="id"> W</span>)<span class="id">;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact/closed_openC/closed_closure</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> /</span>(<span class="id">RBx</span><span class="id"> _</span><span class="id"> RU</span>)<span class="id"> +</span><span class="id"> Wy;</span><span class="id"> apply;</span><span class="id"> exact/clVU/</span>(<span class="id">closure_subset</span><span class="id"> WV</span>).<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> subsetC;</span><span class="id"> exact/subset_closure</span>.<br/>
<span class="id">have</span><span class="id"> :</span><span class="id"> closed</span> (<span class="id">~`</span><span class="id"> W</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> open_closedC</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> closure_id</span><span class="id"> =&gt;</span><span class="id"> &lt;-;</span><span class="id"> exact:</span><span class="id"> subsetCl</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> compact_normal</span><span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> compact</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> -&gt;</span><span class="id"> normal_space</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ?</span><span class="id"> /compact_normal_local</span><span class="id"> +</span><span class="id"> A</span><span class="id"> clA;</span><span class="id"> apply</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> z</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> filterT</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> set_separations</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> normal_space</span><span class="id"> :</span><span class="id"> clear</span><span class="id"> implicits</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> regular_space</span><span class="id"> :</span><span class="id"> clear</span><span class="id"> implicits</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> relation_scope</span>.<br/>
<span class="vernacular">Lemma</span><span class="id"> uniform_regular</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> uniformType}</span><span class="id"> :</span><span class="id"> @regular_space</span><span class="id"> T</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> R</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -{1}nbhs_entourageE</span><span class="id"> =&gt;</span><span class="id"> -[E</span><span class="id"> entE</span><span class="id"> ER]</span>.<br/>
<span class="id">pose</span><span class="id"> E'</span><span class="id"> :=</span><span class="id"> split_ent</span><span class="id"> E;</span><span class="id"> have</span><span class="id"> eE'</span><span class="id"> :</span><span class="id"> entourage</span><span class="id"> E'</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> entourage_split_ent</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">xsection</span> (<span class="id">E'</span><span class="id"> `&amp;`</span><span class="id"> E'^-1</span>)<span class="id"> x</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -nbhs_entourageE;</span><span class="gallina-kwd"> exists</span> (<span class="id">E'</span><span class="id"> `&amp;`</span><span class="id"> E'^-1</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> filterI</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> /=</span><span class="id"> clEz;</span><span class="id"> apply/ER/xsectionP;</span><span class="id"> apply:</span><span class="id"> subset_split_ent</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> clEz</span> (<span class="id">xsection</span> (<span class="id">E'</span><span class="id"> `&amp;`</span><span class="id"> E'^-1</span>)<span class="id"> z</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -nbhs_entourageE;</span><span class="gallina-kwd"> exists</span> (<span class="id">E'</span><span class="id"> `&amp;`</span><span class="id"> E'^-1</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> filterI</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> /=</span><span class="id"> [/xsectionP[?</span><span class="id"> ?]</span><span class="id"> /xsectionP[?</span><span class="id"> ?]];</span><span class="gallina-kwd"> exists</span><span class="id"> y</span>.<br/>
Qed.</div></details>
<span class="vernacular">Local</span><span class="vernacular"> Close</span><span class="vernacular"> Scope</span><span class="id"> relation_scope</span>.<br/>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> uniform_regular</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> totally_disconnected</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> T</span><span class="id"> :</span><span class="id"> topologicalType</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> totally_disconnected</span><span class="id"> {T}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> A</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> connected_component</span><span class="id"> A</span><span class="id"> x</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> x]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> zero_dimensional</span><span class="id"> T</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> U</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span><span class="id"> [/\</span><span class="id"> clopen</span><span class="id"> U,</span><span class="id"> U</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> ~</span><span class="id"> U</span><span class="id"> y]</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> discrete_zero_dimension</span><span class="id"> {T}</span><span class="id"> :</span><span class="id"> discrete_space</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> zero_dimensional</span><span class="id"> T</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> dctT</span><span class="id"> x</span><span class="id"> y</span><span class="id"> xny;</span><span class="gallina-kwd"> exists</span><span class="id"> [set</span><span class="id"> x];</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> exact/nesym/eqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split;</span><span class="id"> [exact:</span><span class="id"> discrete_open</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> discrete_closed]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> zero_dimension_totally_disconnected</span><span class="id"> {T}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">zero_dimensional</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> totally_disconnected</span><span class="id"> [set:</span><span class="id"> T]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> zdA</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> [z</span><span class="id"> [R</span><span class="id"> [Rx</span><span class="id"> _</span><span class="id"> ctdR</span><span class="id"> Rz]]|_</span><span class="id"> -&gt;];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> connected_component_refl</span>.<br/>
<span class="id">apply:</span><span class="id"> contrapT</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> znx;</span><span class="id"> have</span><span class="id"> [U</span><span class="id"> [[oU</span><span class="id"> cU]</span><span class="id"> Uz</span><span class="id"> Ux]]</span><span class="id"> :=</span><span class="id"> zdA</span><span class="id"> _</span><span class="id"> _</span> <span class="id"> znx</span>.<br/>
<span class="id">suff</span><span class="id"> :</span><span class="id"> R</span><span class="id"> `&amp;`</span><span class="id"> U</span><span class="id"> =</span><span class="id"> R</span><span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> Rx</span><span class="id"> =&gt;</span><span class="id"> /[swap]</span><span class="id"> &lt;-</span><span class="id"> []</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> ctdR;</span><span class="id"> [exists</span><span class="id"> z|exists</span><span class="id"> U|exists</span><span class="id"> U]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> zero_dimensional_cvg</span><span class="id"> {T}</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> zero_dimensional</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> compact</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">filter_from</span><span class="id"> [set</span><span class="id"> D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> |</span><span class="id"> D</span><span class="id"> x</span><span class="id"> /\</span><span class="id"> clopen</span><span class="id"> D]</span><span class="id"> id</span><span class="id"> --&gt;</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> filter_from</span><span class="id"> [set</span><span class="id"> D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> |</span><span class="id"> D</span><span class="id"> x</span><span class="id"> /\</span><span class="id"> clopen</span><span class="id"> D]</span><span class="id"> id</span>.<br/>
<span class="id">have</span><span class="id"> FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> filter_from_filter;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> setT;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> clopenT</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> [?</span><span class="id"> ?]</span><span class="id"> [?</span><span class="id"> ?];</span><span class="gallina-kwd"> exists</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> clopenI</span>.<br/>
<span class="id">have</span><span class="id"> PF</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filter_from_proper;</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> [?</span><span class="id"> _];</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> hsdfT</span><span class="id"> zdT</span><span class="id"> cmpT</span><span class="id"> U</span><span class="id"> Ux;</span><span class="id"> rewrite</span><span class="id"> nbhs_simpl</span><span class="id"> -/F</span>.<br/>
<span class="id">wlog</span><span class="id"> oU</span><span class="id"> :</span><span class="id"> U</span><span class="id"> Ux</span><span class="id"> /</span><span class="id"> open</span><span class="id"> U</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> Ux;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> nbhsE</span><span class="id"> =&gt;</span><span class="id"> -[]</span><span class="id"> V</span><span class="id"> [?</span><span class="id"> ?]</span><span class="id"> /filterS</span><span class="id"> +</span><span class="id"> /</span>(_<span class="id"> V</span>)<span class="id"> P</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply;</span><span class="id"> apply:</span><span class="id"> P</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> V</span>.<br/>
<span class="id">have</span><span class="id"> /</span>(<span class="id">iffLR</span> (<span class="id">compact_near_coveringP</span><span class="id"> _</span>))<span class="id"> :</span><span class="id"> compact</span> (<span class="id">~`</span><span class="id"> U</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">subclosed_compact</span><span class="id"> _</span><span class="id"> cmpT</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> open_closedC</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> _</span><span class="id"> setC</span> (<span class="id">powerset_filter_from_filter</span><span class="id"> PF</span>))<span class="id">[]</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> y</span><span class="id"> nUy;</span><span class="id"> have</span><span class="id"> /zdT</span><span class="id"> [C</span><span class="id"> [[oC</span><span class="id"> cC]</span><span class="id"> Cx</span><span class="id"> Cy]]</span><span class="id"> :</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra_notN</span><span class="id"> nUy</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> &lt;-;</span><span class="id"> exact:</span><span class="id"> nbhs_singleton</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">~`</span><span class="id"> C,</span><span class="id"> [set</span><span class="id"> U</span><span class="id"> |</span><span class="id"> U</span><span class="id"> `&lt;=`</span><span class="id"> C]</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> open_nbhs_nbhs;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> closed_openC</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> apply/near_powerset_filter_fromP;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> subset_trans</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> C</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> C</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> case=&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> [?</span><span class="id"> /subsetC];</span><span class="id"> apply</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> D</span><span class="id"> [DF</span><span class="id"> _</span><span class="id"> [C</span><span class="id"> DC]]/</span>(_<span class="id"> _</span><span class="id"> DC</span>)<span class="id">/subsetC2/filterS;</span><span class="id"> apply;</span><span class="id"> exact:</span><span class="id"> DF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> zero_dimensional_ray</span><span class="id"> {d}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> orderTopologicalType</span><span class="id"> d}</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">x</span><span class="id"> &lt;</span><span class="id"> y</span>)<span class="id">%O</span><span class="id"> -&gt;</span><span class="id"> zero_dimensional</span><span class="id"> T</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> U,</span><span class="id"> [/\</span><span class="id"> clopen</span><span class="id"> U,</span><span class="id"> U</span><span class="id"> y</span><span class="id"> ,</span><span class="id"> ~</span><span class="id"> U</span><span class="id"> x</span><span class="id"> &amp;</span><span class="gallina-kwd"> forall</span><span class="id"> l</span><span class="id"> r,</span><span class="id"> U</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="id"> ~</span><span class="id"> U</span><span class="id"> l</span><span class="id"> -&gt;</span><span class="id"> l</span><span class="id"> &lt;</span><span class="id"> r]%O</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> xy</span><span class="id"> zt;</span><span class="id"> have</span><span class="id"> xNy</span><span class="id"> :</span><span class="id"> y</span><span class="id"> !=</span><span class="id"> x</span><span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> xy;</span><span class="id"> rewrite</span><span class="id"> lt_def</span><span class="id"> =&gt;</span><span class="id"> /andP[]</span>.<br/>
<span class="id">have</span><span class="id"> [U</span><span class="id"> [clU</span><span class="id"> Uy</span><span class="id"> nUx]]</span><span class="id"> :=</span><span class="id"> zt</span><span class="id"> y</span><span class="id"> x</span><span class="id"> xNy</span>.<br/>
<span class="id">have</span><span class="id"> :=</span><span class="id"> clopen_bigcup_clopen</span><span class="id"> clU</span><span class="id"> Uy;</span><span class="id"> set</span><span class="id"> I</span><span class="id"> :=</span> (<span class="id">I</span><span class="gallina-kwd"> in</span><span class="id"> clopen</span><span class="id"> I</span>)<span class="id">;</span><span class="id"> case=&gt;</span><span class="id"> ?</span><span class="id"> ?</span>.<br/>
<span class="id">pose</span><span class="id"> V</span><span class="id"> :=</span><span class="id"> I</span><span class="id"> `|`</span><span class="id"> `[y,</span><span class="id"> +oo[;</span><span class="id"> have</span><span class="id"> Iy</span><span class="id"> :</span><span class="id"> I</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> clU</span><span class="id"> =&gt;</span><span class="id"> +</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> openE</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> Uy</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /interior</span><span class="id"> /=</span><span class="id"> itv_nbhsE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> -[i</span><span class="id"> []</span><span class="id"> iy</span><span class="id"> yi</span><span class="id"> iU]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> itv_open_ends_open</span>.<br/>
<span class="id">have</span><span class="id"> IU</span><span class="id"> :</span><span class="id"> I</span><span class="id"> `&lt;=`</span><span class="id"> U</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> [?</span><span class="id"> [+</span><span class="id"> _</span><span class="id"> _]]</span><span class="id"> =&gt;</span><span class="id"> /subset_trans;</span><span class="id"> exact</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> V;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="id"> suff</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> V</span><span class="id"> =</span><span class="id"> I</span><span class="id"> `|`</span><span class="id"> `]y,+oo[</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> openU</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> z;</span><span class="id"> case;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> left</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setU1itv</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> -[-&gt;|];</span><span class="id"> [left|</span><span class="id"> right]</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> left</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /V</span><span class="id"> -setU1itv</span><span class="id"> //;</span><span class="id"> right;</span><span class="id"> right</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> closedU</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> rray_closed</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> left</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [/IU</span><span class="id"> //|];</span><span class="id"> rewrite</span><span class="id"> set_itvE/=</span><span class="id"> leNgt</span><span class="id"> xy</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> l</span><span class="id"> r</span><span class="id"> Vr</span><span class="id"> Vl;</span><span class="id"> rewrite</span><span class="id"> ltNge;</span><span class="id"> apply/negP;</span><span class="id"> move:</span><span class="id"> Vl;</span><span class="id"> apply:</span><span class="id"> contra_not</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> rl;</span><span class="id"> case:</span><span class="id"> Vr;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> set_itvE</span><span class="id"> =&gt;</span><span class="id"> yr;</span><span class="id"> right;</span><span class="id"> rewrite</span><span class="id"> set_itvE;</span><span class="id"> exact:</span> (<span class="id">le_trans</span><span class="id"> yr</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /orP[|ly]</span><span class="id"> :=</span><span class="id"> le_total</span><span class="id"> y</span><span class="id"> l;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> +</span><span class="id"> _;</span><span class="id"> right;</span><span class="id"> rewrite</span><span class="id"> set_itvE</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> i</span><span class="id"> [iu</span><span class="id"> oi</span><span class="id"> /=</span><span class="id"> yi</span><span class="id"> ri];</span><span class="id"> left;</span><span class="gallina-kwd"> exists</span><span class="id"> i;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> iu</span><span class="id"> oi</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> i</span><span class="id"> yi</span><span class="id"> ri</span><span class="id"> =&gt;</span><span class="id"> p</span><span class="id"> q</span><span class="id"> /=</span><span class="id"> /andP</span><span class="id"> [py</span><span class="id"> yq]</span><span class="id"> /andP[pr</span><span class="id"> rq]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/andP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> pr</span>)<span class="id">//</span><span class="id"> bnd_simp</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span><span class="id"> yq</span>)<span class="id">//</span><span class="id"> bnd_simp</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> totally_disconnected</span>.<br/>
<br/>
<span class="vernacular">Module</span><span class="id"> countable_uniform</span>.<br/>
<span class="vernacular">Section</span><span class="id"> countable_uniform</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> relation_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> uniformType}</span>.<br/>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> cnt_unif</span><span class="id"> :</span><span class="id"> @countable_uniformity</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> f_</span><span class="id"> :=</span><span class="id"> projT1</span> (<span class="id">cid2</span> (<span class="id">iffLR</span><span class="id"> countable_uniformityP</span><span class="id"> cnt_unif</span>)).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> countableBase</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> entourage</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> N,</span><span class="id"> f_</span><span class="id"> N</span><span class="id"> `&lt;=`</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> projT2</span> (<span class="id">cid2</span> (<span class="id">iffLR</span><span class="id"> countable_uniformityP</span><span class="id"> cnt_unif</span>)). Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> entF</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> n,</span><span class="id"> entourage</span> (<span class="id">f_</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> projT2</span> (<span class="id">cid2</span> (<span class="id">iffLR</span><span class="id"> countable_uniformityP</span><span class="id"> cnt_unif</span>)). Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fixpoint</span><span class="id"> g_</span><span class="id"> n</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> n</span><span class="id"> is</span><span class="id"> n</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="gallina-kwd"> let</span><span class="id"> W</span><span class="id"> :=</span><span class="id"> split_ent</span> (<span class="id">split_ent</span> (<span class="id">g_</span><span class="id"> n</span>))<span class="id"> `&amp;`</span><span class="id"> f_</span><span class="id"> n</span><span class="gallina-kwd"> in</span><span class="id"> W</span><span class="id"> `&amp;`</span><span class="id"> W^-1</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="id"> [set:</span><span class="id"> T*T]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> entG</span><span class="id"> n</span><span class="id"> :</span><span class="id"> entourage</span> (<span class="id">g_</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> entourageT</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> entg;</span><span class="id"> apply/entourage_invI;</span><span class="id"> exact:</span><span class="id"> filterI</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> symG</span><span class="id"> n</span><span class="id"> :</span> (<span class="id">g_</span><span class="id"> n</span>)<span class="id">^-1</span><span class="id"> =</span><span class="id"> g_</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split;</span><span class="id"> case=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> andC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> descendG1</span><span class="id"> n</span><span class="id"> :</span><span class="id"> g_</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> `&lt;=`</span><span class="id"> g_</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> subIset;</span><span class="id"> left;</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left;</span><span class="id"> apply:</span><span class="id"> subset_trans</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> split_ent_subset;</span><span class="id"> exact:</span><span class="id"> entourage_split_ent</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subset_trans;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> split_ent_subset</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> descendG</span><span class="id"> n</span><span class="id"> m</span><span class="id"> :</span> (<span class="id">m</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> g_</span><span class="id"> n</span><span class="id"> `&lt;=`</span><span class="id"> g_</span><span class="id"> m</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> ?leqn0;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;/eqP</span><span class="id"> -&gt;</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> n</span><span class="id"> IH;</span><span class="id"> rewrite</span><span class="id"> leq_eqVlt</span><span class="id"> ltnS</span><span class="id"> =&gt;</span><span class="id"> /orP</span><span class="id"> [/eqP</span><span class="id"> &lt;-</span><span class="id"> //|]</span><span class="id"> /IH</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subset_trans;</span><span class="id"> exact:</span><span class="id"> descendG1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> splitG3</span><span class="id"> n</span><span class="id"> :</span><span class="id"> g_</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> \;</span><span class="id"> g_</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> \;</span><span class="id"> g_</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> `&lt;=`</span><span class="id"> g_</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">suff</span><span class="id"> g2split</span><span class="id"> :</span><span class="id"> g_</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> \;</span><span class="id"> g_</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> `&lt;=`</span><span class="id"> split_ent</span> (<span class="id">g_</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> subset_trans;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> subset_split_ent</span> (<span class="id">entG</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> set_compose_subset</span> (<span class="id">g2split</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -[_</span><span class="id"> n</span>.<span class="id">+1]set_compose_diag</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> subset_trans</span><span class="id"> g2split;</span><span class="id"> apply:</span><span class="id"> set_compose_subset</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [_</span><span class="id"> _]</span><span class="id"> [z</span><span class="id"> _]</span><span class="id"> [&lt;-</span><span class="id"> &lt;-];</span><span class="id"> exact:</span><span class="id"> entourage_refl</span>.<br/>
<span class="id">apply:</span><span class="id"> subset_trans;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> subset_split_ent</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> set_compose_subset;</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left;</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> gsubf</span><span class="id"> n</span><span class="id"> :</span><span class="id"> g_</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> `&lt;=`</span><span class="id"> f_</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left;</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> right</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> countableBaseG</span><span class="id"> A</span><span class="id"> :</span><span class="id"> entourage</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> N,</span><span class="id"> g_</span><span class="id"> N</span><span class="id"> `&lt;=`</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /countableBase</span><span class="id"> [N]</span><span class="id"> fnA;</span><span class="gallina-kwd"> exists</span><span class="id"> N</span>.<span class="id">+1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subset_trans</span><span class="id"> fnA;</span><span class="id"> exact:</span><span class="id"> gsubf</span>.<br/>
Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Definition</span><span class="id"> distN</span> (<span class="id">e</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> nat</span><span class="id"> :=</span><span class="id"> `|Num</span>.<span class="id">floor</span><span class="id"> e^-1|%N</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> distN0</span><span class="id"> :</span><span class="id"> distN</span><span class="id"> 0</span><span class="id"> =</span><span class="id"> 0%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /distN</span><span class="id"> invr0</span><span class="id"> floor0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> distN_nat</span> (<span class="id">n</span><span class="id"> :</span><span class="id"> nat</span>)<span class="id"> :</span><span class="id"> distN</span><span class="id"> n%:R^-1</span><span class="id"> =</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /distN</span><span class="id"> invrK</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">@eqr_nat</span><span class="id"> R</span>)<span class="id"> natr_absz</span><span class="id"> ger0_norm</span><span class="id"> ?floor_ge0//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -intrEfloor</span><span class="id"> intrEge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> distN_le</span><span class="id"> e1</span><span class="id"> e2</span><span class="id"> :</span><span class="id"> e1</span><span class="id"> &gt;</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> e1</span><span class="id"> &lt;=</span><span class="id"> e2</span><span class="id"> -&gt;</span> (<span class="id">distN</span><span class="id"> e2</span><span class="id"> &lt;=</span><span class="id"> distN</span><span class="id"> e1</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> e1pos</span><span class="id"> e1e2;</span><span class="id"> rewrite</span><span class="id"> /distN;</span><span class="id"> apply:</span><span class="id"> lez_abs2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> floor_ge0</span><span class="id"> ltW//</span><span class="id"> invr_gt0</span> (<span class="id">lt_le_trans</span><span class="id"> _</span><span class="id"> e1e2</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> floor_le//</span><span class="id"> lef_pV2</span><span class="id"> ?invrK</span><span class="id"> ?invr_gt0//;</span><span class="id"> exact:</span> (<span class="id">lt_le_trans</span><span class="id"> _</span><span class="id"> e1e2</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fixpoint</span><span class="id"> n_step_ball</span><span class="id"> n</span><span class="id"> x</span><span class="id"> e</span><span class="id"> z</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> n</span><span class="id"> is</span><span class="id"> n</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="gallina-kwd"> exists</span><span class="id"> y</span><span class="id"> d1</span><span class="id"> d2,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> n_step_ball</span><span class="id"> n</span><span class="id"> x</span><span class="id"> d1</span><span class="id"> y,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">0</span><span class="id"> &lt;</span><span class="id"> d1,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">0</span><span class="id"> &lt;</span><span class="id"> d2,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_</span> (<span class="id">distN</span><span class="id"> d2</span>) (<span class="id">y,</span><span class="id"> z</span>)<span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">d1</span><span class="id"> +</span><span class="id"> d2</span><span class="id"> =</span><span class="id"> e]</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="id"> e</span><span class="id"> &gt;</span><span class="id"> 0</span><span class="id"> /\</span><span class="id"> g_</span> (<span class="id">distN</span><span class="id"> e</span>) (<span class="id">x,</span><span class="id"> z</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Definition</span><span class="id"> step_ball</span><span class="id"> x</span><span class="id"> e</span><span class="id"> z</span><span class="id"> :=</span><span class="gallina-kwd"> exists</span><span class="id"> i,</span> (<span class="id">n_step_ball</span><span class="id"> i</span><span class="id"> x</span><span class="id"> e</span><span class="id"> z</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> n_step_ball_pos</span><span class="id"> n</span><span class="id"> x</span><span class="id"> e</span><span class="id"> z</span><span class="id"> :</span><span class="id"> n_step_ball</span><span class="id"> n</span><span class="id"> x</span><span class="id"> e</span><span class="id"> z</span><span class="id"> -&gt;</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> e</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [[]|]</span><span class="id"> //</span><span class="id"> n;</span><span class="id"> case=&gt;</span><span class="id"> [?]</span><span class="id"> [?]</span><span class="id"> [?]</span><span class="id"> []</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> &lt;-;</span><span class="id"> exact:</span><span class="id"> addr_gt0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> step_ball_pos</span><span class="id"> x</span><span class="id"> e</span><span class="id"> z</span><span class="id"> :</span><span class="id"> step_ball</span><span class="id"> x</span><span class="id"> e</span><span class="id"> z</span><span class="id"> -&gt;</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> e</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> n_step_ball_pos</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> entourage_nball</span><span class="id"> e</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">0</span><span class="id"> &lt;</span><span class="id"> e</span><span class="id"> -&gt;</span><span class="id"> entourage</span><span class="id"> [set</span><span class="id"> xy</span><span class="id"> |</span><span class="id"> step_ball</span><span class="id"> xy</span>.<span class="id">1</span><span class="id"> e</span><span class="id"> xy</span>.<span class="id">2]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> epos;</span><span class="id"> apply:</span> (<span class="id">@filterS</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">g_</span> (<span class="id">distN</span><span class="id"> e</span>)))<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> [[x</span><span class="id"> y]]</span><span class="id"> ?</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> 0%N</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> n_step_ball_center</span><span class="id"> x</span><span class="id"> e</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> e</span><span class="id"> -&gt;</span><span class="id"> n_step_ball</span><span class="id"> 0</span><span class="id"> x</span><span class="id"> e</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> epos;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> entourage_refl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> step_ball_center</span><span class="id"> x</span><span class="id"> e</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> e</span><span class="id"> -&gt;</span><span class="id"> step_ball</span><span class="id"> x</span><span class="id"> e</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> epos;</span><span class="gallina-kwd"> exists</span><span class="id"> 0%N;</span><span class="id"> apply:</span><span class="id"> n_step_ball_center</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> n_step_ball_triangle</span><span class="id"> n</span><span class="id"> m</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> d1</span><span class="id"> d2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span><span class="id"> n</span><span class="id"> x</span><span class="id"> d1</span><span class="id"> y</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span><span class="id"> m</span><span class="id"> y</span><span class="id"> d2</span><span class="id"> z</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span> (<span class="id">n</span><span class="id"> +</span><span class="id"> m</span>).<span class="id">+1</span><span class="id"> x</span> (<span class="id">d1</span><span class="id"> +</span><span class="id"> d2</span>)<span class="id"> z</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move:</span><span class="id"> n</span><span class="id"> z</span><span class="id"> d2;</span><span class="id"> elim:</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> [n</span><span class="id"> z</span><span class="id"> d2</span><span class="id"> Nxy</span><span class="id"> [?</span><span class="id"> ?]|n</span><span class="id"> IH</span><span class="id"> m</span><span class="id"> z</span><span class="id"> d2</span><span class="id"> Oxy]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> y,</span><span class="id"> d1,</span><span class="id"> d2;</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> ?addn0</span><span class="id"> //</span> (<span class="id">n_step_ball_pos</span><span class="id"> Nxy</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> [w]</span><span class="id"> [e1]</span><span class="id"> [e2]</span><span class="id"> [Oyw</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> &lt;-]</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> w,</span> (<span class="id">d1</span><span class="id"> +</span><span class="id"> e1</span>)<span class="id">,</span><span class="id"> e2;</span><span class="id"> rewrite</span><span class="id"> addnS</span><span class="id"> addrA</span>.<br/>
<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> addr_gt0//;</span><span class="id"> exact:</span><span class="id"> n_step_ball_pos</span><span class="id"> Oxy</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">IH</span><span class="id"> m</span><span class="id"> w</span><span class="id"> e1</span><span class="id"> Oxy</span><span class="id"> Oyw</span>)<span class="id"> =&gt;</span><span class="id"> t</span><span class="id"> [e3]</span><span class="id"> [e4]</span><span class="id"> []</span><span class="id"> Oxt</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> &lt;-;</span><span class="gallina-kwd"> exists</span><span class="id"> t,</span><span class="id"> e3,</span><span class="id"> e4</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> step_ball_triangle</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> d1</span><span class="id"> d2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">step_ball</span><span class="id"> x</span><span class="id"> d1</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> step_ball</span><span class="id"> y</span><span class="id"> d2</span><span class="id"> z</span><span class="id"> -&gt;</span><span class="id"> step_ball</span><span class="id"> x</span> (<span class="id">d1</span><span class="id"> +</span><span class="id"> d2</span>)<span class="id"> z</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [n</span><span class="id"> Oxy]</span><span class="id"> [m</span><span class="id"> Oyz];</span><span class="gallina-kwd"> exists</span> (<span class="id">n</span><span class="id"> +</span><span class="id"> m</span>).<span class="id">+1</span>.<br/>
<span class="id">exact:</span><span class="id"> n_step_ball_triangle</span><span class="id"> Oxy</span><span class="id"> Oyz</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> n_step_ball_sym</span><span class="id"> n</span><span class="id"> x</span><span class="id"> y</span><span class="id"> e</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span><span class="id"> n</span><span class="id"> x</span><span class="id"> e</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> n_step_ball</span><span class="id"> n</span><span class="id"> y</span><span class="id"> e</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move:</span><span class="id"> x</span><span class="id"> y</span><span class="id"> e;</span><span class="id"> elim:</span><span class="id"> n;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> -{1}symG</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> n</span><span class="id"> IH</span><span class="id"> x</span><span class="id"> y</span><span class="id"> e</span><span class="id"> [t]</span><span class="id"> [d1]</span><span class="id"> [d2]</span><span class="id"> []</span><span class="id"> /IH</span><span class="id"> Oty</span><span class="id"> ?</span><span class="id"> ?</span>.<br/>
<span class="id">rewrite</span><span class="id"> addrC</span><span class="id"> -symG</span><span class="id"> -[n]add0n</span><span class="id"> =&gt;</span><span class="id"> gty</span><span class="id"> &lt;-;</span><span class="id"> apply:</span> (<span class="id">n_step_ball_triangle</span><span class="id"> _</span><span class="id"> Oty</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> gty</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> step_ball_sym</span><span class="id"> x</span><span class="id"> y</span><span class="id"> e</span><span class="id"> :</span><span class="id"> step_ball</span><span class="id"> x</span><span class="id"> e</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> step_ball</span><span class="id"> y</span><span class="id"> e</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case=&gt;</span><span class="id"> n</span><span class="id"> /n_step_ball_sym</span><span class="id"> ?;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>. Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> n_step_ball_le</span><span class="id"> n</span><span class="id"> x</span><span class="id"> e1</span><span class="id"> e2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">e1</span><span class="id"> &lt;=</span><span class="id"> e2</span><span class="id"> -&gt;</span><span class="id"> n_step_ball</span><span class="id"> n</span><span class="id"> x</span><span class="id"> e1</span><span class="id"> `&lt;=`</span><span class="id"> n_step_ball</span><span class="id"> n</span><span class="id"> x</span><span class="id"> e2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move:</span><span class="id"> x</span><span class="id"> e1</span><span class="id"> e2;</span><span class="id"> elim:</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> e1</span><span class="id"> e2</span><span class="id"> e1e2</span><span class="id"> y</span><span class="id"> [?]</span><span class="id"> gxy;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span> (<span class="id">lt_le_trans</span><span class="id"> _</span><span class="id"> e1e2</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> descendG;</span><span class="id"> last</span> (<span class="id">exact:</span><span class="id"> gxy</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> distN_le</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> n</span><span class="id"> IH</span><span class="id"> x</span><span class="id"> e1</span><span class="id"> e2</span><span class="id"> e1e2</span><span class="id"> z</span><span class="id"> [y]</span><span class="id"> [d1]</span><span class="id"> [d2]</span><span class="id"> []</span><span class="id"> /IH</span><span class="id"> P</span><span class="id"> d1pos</span><span class="id"> d2pos</span><span class="id"> gyz</span><span class="id"> d1d2e1</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> y,</span> (<span class="id">e2</span><span class="id"> -</span><span class="id"> d2</span>)<span class="id">,</span><span class="id"> d2;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> P;</span><span class="id"> rewrite</span><span class="id"> lerBrDr</span><span class="id"> d1d2e1</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> lt_le_trans</span><span class="id"> d1pos</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> lerBrDr</span><span class="id"> d1d2e1</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subrK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> step_ball_le</span><span class="id"> x</span><span class="id"> e1</span><span class="id"> e2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">e1</span><span class="id"> &lt;=</span><span class="id"> e2</span><span class="id"> -&gt;</span><span class="id"> step_ball</span><span class="id"> x</span><span class="id"> e1</span><span class="id"> `&lt;=`</span><span class="id"> step_ball</span><span class="id"> x</span><span class="id"> e2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> e1e2</span><span class="id"> ?</span><span class="id"> [n</span><span class="id"> P];</span><span class="gallina-kwd"> exists</span><span class="id"> n;</span><span class="id"> exact:</span> (<span class="id">n_step_ball_le</span><span class="id"> e1e2</span>). Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> distN_half</span> (<span class="id">n</span><span class="id"> :</span><span class="id"> nat</span>)<span class="id"> :</span><span class="id"> n</span>.<span class="id">+1%:R^-1</span><span class="id"> /</span> (<span class="id">2:R</span>)<span class="id"> &lt;=</span><span class="id"> n</span>.<span class="id">+2%:R^-1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -invrM</span><span class="id"> //;</span><span class="id"> [|exact:</span><span class="id"> unitf_gt0</span><span class="id"> |exact:</span><span class="id"> unitf_gt0]</span>.<br/>
<span class="id">rewrite</span><span class="id"> lef_pV2</span><span class="id"> ?posrE</span><span class="id"> //</span><span class="id"> -?natrM</span><span class="id"> ?ler_nat</span><span class="id"> -addn1</span><span class="id"> -addn1</span><span class="id"> -addnA</span><span class="id"> mulnDr</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> muln1</span><span class="id"> leq_add2r</span><span class="id"> leq_pmull</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> split_n_step_ball</span><span class="id"> n</span><span class="id"> x</span><span class="id"> e1</span><span class="id"> e2</span><span class="id"> z</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">0</span><span class="id"> &lt;</span><span class="id"> e1</span><span class="id"> -&gt;</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> e2</span><span class="id"> -&gt;</span><span class="id"> n_step_ball</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> x</span> (<span class="id">e1</span><span class="id"> +</span><span class="id"> e2</span>)<span class="id"> z</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> t1</span><span class="id"> t2</span><span class="id"> a</span><span class="id"> b,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n_step_ball</span><span class="id"> a</span><span class="id"> x</span><span class="id"> e1</span><span class="id"> t1,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n_step_ball</span><span class="id"> 0</span><span class="id"> t1</span> (<span class="id">e1</span><span class="id"> +</span><span class="id"> e2</span>)<span class="id"> t2,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n_step_ball</span><span class="id"> b</span><span class="id"> t2</span><span class="id"> e2</span><span class="id"> z</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">a</span><span class="id"> +</span><span class="id"> b</span><span class="id"> =</span><span class="id"> n</span>)<span class="id">%N</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move:</span><span class="id"> e1</span><span class="id"> e2</span><span class="id"> x</span><span class="id"> z;</span><span class="id"> elim:</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> e1</span><span class="id"> e2</span><span class="id"> x</span><span class="id"> z</span><span class="id"> e1pos</span><span class="id"> e2pos</span><span class="id"> [y]</span><span class="id"> [d1]</span><span class="id"> [d2]</span><span class="id"> []</span><span class="id"> Oxy</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> gd2yz</span><span class="id"> deE</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">pselect</span> (<span class="id">e1</span><span class="id"> &lt;=</span><span class="id"> d1</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> e1d1;</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> y,</span><span class="id"> 0%N,</span><span class="id"> 0%N;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> n_step_ball_center</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> apply:</span><span class="id"> n_step_ball_le;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> Oxy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -deE</span><span class="id"> lerDl;</span><span class="id"> apply:</span><span class="id"> ltW</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> apply:</span> (<span class="id">@n_step_ball_le</span><span class="id"> _</span><span class="id"> _</span><span class="id"> d2</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -[e2]addr0</span><span class="id"> -</span>(<span class="id">subrr</span><span class="id"> e1</span>)<span class="id"> addrA</span><span class="id"> -lerBlDr</span><span class="id"> opprK</span><span class="id"> [leLHS]addrC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [e2</span><span class="id"> +</span><span class="id"> _]addrC</span><span class="id"> -deE;</span><span class="id"> exact:</span><span class="id"> lerD</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> addn0</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /negP;</span><span class="id"> rewrite</span><span class="id"> -ltNge//</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> e1d1;</span><span class="gallina-kwd"> exists</span><span class="id"> y,</span><span class="id"> z,</span><span class="id"> 0%N,</span><span class="id"> 0%N;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> n_step_ball_le;</span><span class="id"> last</span> (<span class="id">exact:</span><span class="id"> Oxy</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> ltW</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> -deE;</span><span class="id"> apply:</span> (<span class="id">@n_step_ball_le</span><span class="id"> _</span><span class="id"> _</span><span class="id"> d2</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> lerDr;</span><span class="id"> apply:</span><span class="id"> ltW</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> n_step_ball_center</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> addn0</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> n</span><span class="id"> IH</span><span class="id"> e1</span><span class="id"> e2</span><span class="id"> x</span><span class="id"> z</span><span class="id"> e1pos</span><span class="id"> e2pos</span><span class="id"> [y]</span><span class="id"> [d1]</span><span class="id"> [d2]</span><span class="id"> []</span><span class="id"> Od1xy</span><span class="id"> d1pos</span><span class="id"> d2pos</span><span class="id"> gd2yz</span><span class="id"> deE</span>.<br/>
<span class="id">case:</span> (<span class="id">pselect</span> (<span class="id">e2</span><span class="id"> &lt;=</span><span class="id"> d2</span>)).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> e2d2;</span><span class="gallina-kwd"> exists</span><span class="id"> y,</span><span class="id"> z,</span><span class="id"> n</span>.<span class="id">+1,</span><span class="id"> 0%N;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> apply:</span> (<span class="id">@n_step_ball_le</span><span class="id"> _</span><span class="id"> _</span><span class="id"> d1</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> -[e1]addr0</span><span class="id"> -</span>(<span class="id">subrr</span><span class="id"> e2</span>)<span class="id"> addrA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -deE</span><span class="id"> -lerBlDr</span><span class="id"> opprK</span><span class="id"> lerD</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> apply:</span> (<span class="id">@n_step_ball_le</span><span class="id"> _</span><span class="id"> _</span><span class="id"> d2</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -deE</span><span class="id"> lerDr;</span><span class="id"> exact:</span><span class="id"> ltW</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> n_step_ball_center</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> addn0</span>.<br/>
<span class="id">have</span><span class="id"> d1E'</span><span class="id"> :</span><span class="id"> d1</span><span class="id"> =</span><span class="id"> e1</span><span class="id"> +</span> (<span class="id">e2</span><span class="id"> -</span><span class="id"> d2</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> addrA</span><span class="id"> -deE</span><span class="id"> addrK</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /negP;</span><span class="id"> rewrite</span><span class="id"> -ltNge//</span><span class="id"> =&gt;</span><span class="id"> d2lee2</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">IH</span><span class="id"> e1</span> (<span class="id">e2</span><span class="id"> -</span><span class="id"> d2</span>)<span class="id"> x</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?subr_gt0</span><span class="id"> //</span><span class="id"> -d1E'</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t1</span><span class="id"> [t2]</span><span class="id"> [c1]</span><span class="id"> [c2]</span><span class="id"> []</span><span class="id"> Oxy1</span><span class="id"> gt1t2</span><span class="id"> t2y</span><span class="id"> &lt;-</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> t1,</span><span class="id"> t2,</span><span class="id"> c1,</span><span class="id"> c2</span>.<span class="id">+1;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">@n_step_ball_le</span><span class="id"> _</span><span class="id"> _</span><span class="id"> d1</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -?deE</span><span class="id"> //</span><span class="id"> ?lerDl;</span><span class="id"> exact:</span><span class="id"> ltW</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> y,</span> (<span class="id">e2</span><span class="id"> -</span><span class="id"> d2</span>)<span class="id">,</span><span class="id"> d2;</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> ?subr_gt0//</span><span class="id"> subrK</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> addnS</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> n_step_ball_le_g</span><span class="id"> x</span><span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span><span class="id"> 0</span><span class="id"> x</span><span class="id"> n%:R^-1</span><span class="id"> `&lt;=`</span><span class="id"> [set</span><span class="id"> y</span><span class="id"> |</span><span class="id"> g_</span><span class="id"> n</span> (<span class="id">x,y</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> []</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> distN_nat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> subset_n_step_ball</span><span class="id"> n</span><span class="id"> x</span><span class="id"> N</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">n_step_ball</span><span class="id"> n</span><span class="id"> x</span><span class="id"> N</span>.<span class="id">+1%:R^-1</span><span class="id"> `&lt;=`</span><span class="id"> [set</span><span class="id"> y</span><span class="id"> |</span> (<span class="id">g_</span><span class="id"> N</span>) (<span class="id">x,</span><span class="id"> y</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move:</span><span class="id"> N</span><span class="id"> x;</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> {-2}n</span> (<span class="id">leqnn</span><span class="id"> n</span>)<span class="id"> =&gt;</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> leqn0</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;</span><span class="id"> N</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> subset_trans</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> n_step_ball_le_g</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> descendG</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> IH1</span><span class="id"> +</span><span class="id"> +</span><span class="id"> N</span><span class="id"> x1</span><span class="id"> x4;</span><span class="id"> case</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> [?]</span><span class="id"> P;</span><span class="id"> apply:</span><span class="id"> descendG</span><span class="id"> _</span><span class="id"> P;</span><span class="id"> rewrite</span><span class="id"> distN_nat</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> l</span><span class="id"> ln1</span><span class="id"> Ox1x4</span>.<br/>
<span class="id">case:</span> (<span class="id">@split_n_step_ball</span><span class="id"> l</span><span class="id"> x1</span> (<span class="id">N</span>.<span class="id">+1%:R^-1/2</span>) (<span class="id">N</span>.<span class="id">+1%:R^-1/2</span>)<span class="id"> x4</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -splitr</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x2</span><span class="id"> [x3]</span><span class="id"> [l1]</span><span class="id"> [l2]</span><span class="id"> []</span><span class="id"> P1</span><span class="id"> [?</span><span class="id"> +]</span><span class="id"> P3</span><span class="id"> l1l2;</span><span class="id"> rewrite</span><span class="id"> -splitr</span><span class="id"> distN_nat</span><span class="id"> =&gt;</span><span class="id"> ?</span>.<br/>
<span class="id">have</span><span class="id"> l1n</span><span class="id"> :</span> (<span class="id">l1</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">leq_trans</span> (<span class="id">leq_addr</span><span class="id"> l2</span><span class="id"> l1</span>))<span class="id">//</span><span class="id"> l1l2</span><span class="id"> -ltnS</span>.<br/>
<span class="id">have</span><span class="id"> l2n</span><span class="id"> :</span> (<span class="id">l2</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">leq_trans</span> (<span class="id">leq_addl</span><span class="id"> l1</span><span class="id"> l2</span>))<span class="id">//</span><span class="id"> l1l2</span><span class="id"> -ltnS</span>.<br/>
<span class="id">apply:</span><span class="id"> splitG3;</span><span class="gallina-kwd"> exists</span><span class="id"> x3;</span><span class="id"> [exists</span><span class="id"> x2</span><span class="id"> =&gt;</span><span class="id"> //|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/</span>(<span class="id">n_step_ball_le</span> (<span class="id">distN_half</span><span class="id"> N</span>))<span class="id">/</span>(<span class="id">IH1</span><span class="id"> _</span><span class="id"> l1n</span>)<span class="id"> :</span><span class="id"> P1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/</span>(<span class="id">n_step_ball_le</span> (<span class="id">distN_half</span><span class="id"> N</span>))<span class="id">/</span>(<span class="id">IH1</span><span class="id"> _</span><span class="id"> l2n</span>)<span class="id"> :</span><span class="id"> P3</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> subset_step_ball</span><span class="id"> x</span><span class="id"> N</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">step_ball</span><span class="id"> x</span><span class="id"> N</span>.<span class="id">+1%:R^-1</span><span class="id"> `&lt;=`</span><span class="id"> [set</span><span class="id"> y</span><span class="id"> |</span> (<span class="id">g_</span><span class="id"> N</span>) (<span class="id">x,</span><span class="id"> y</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> []</span><span class="id"> n;</span><span class="id"> exact:</span><span class="id"> subset_n_step_ball</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> step_ball_entourage</span><span class="id"> :</span><span class="id"> entourage</span><span class="id"> =</span><span class="id"> entourage_</span><span class="id"> step_ball</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> E;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> e</span><span class="id"> /=</span><span class="id"> epos</span><span class="id"> esubE;</span><span class="id"> apply:</span> (<span class="id">filterS</span><span class="id"> esubE</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> entourage_nball</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> entE;</span><span class="id"> case:</span> (<span class="id">countableBase</span><span class="id"> entE</span>)<span class="id"> =&gt;</span><span class="id"> N</span><span class="id"> fN</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> N</span>.<span class="id">+2%:R^-1;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> invr_gt0</span>.<br/>
<span class="id">apply:</span> (<span class="id">subset_trans</span><span class="id"> _</span><span class="id"> fN</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> subset_trans;</span><span class="id"> last</span><span class="id"> apply:</span><span class="id"> gsubf</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /=</span><span class="id"> N1ball;</span><span class="id"> apply:</span> (<span class="id">@subset_step_ball</span><span class="id"> x</span><span class="id"> N</span>.<span class="id">+1</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> type</span><span class="id"> :</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><span class="gallina-kwd"> let</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> countableBase</span><span class="gallina-kwd"> in</span><span class="gallina-kwd"> let</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> entF</span><span class="gallina-kwd"> in</span><span class="id"> T</span>.<br/>
<br/>
<span class="id">#[export]</span><span class="id"> HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Uniform</span>.<span class="id">on</span><span class="id"> type</span>.<br/>
<span class="id">#[export]</span><span class="id"> HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Uniform_isPseudoMetric</span>.<span class="id">Build</span><span class="id"> R</span><span class="id"> type</span><br/>
&nbsp;&nbsp;<span class="id">step_ball_center</span><span class="id"> step_ball_sym</span><span class="id"> step_ball_triangle</span><span class="id"> step_ball_entourage</span>.<br/>
<span class="id">#[export]</span><span class="id"> HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> {q</span><span class="id"> :</span><span class="id"> Pointed</span><span class="id"> T}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Pointed</span>.<span class="id">copy</span><span class="id"> type</span> (<span class="id">Pointed</span>.<span class="id">Pack</span><span class="id"> q</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> countable_uniform_bounded</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> U</span><span class="id"> :=</span><span class="id"> [the</span><span class="id"> pseudoMetricType</span><span class="id"> R</span><span class="id"> of</span><span class="id"> type]</span><span class="gallina-kwd"> in</span><span class="id"> @ball</span><span class="id"> _</span><span class="id"> U</span><span class="id"> x</span><span class="id"> 2</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /ball;</span><span class="gallina-kwd"> exists</span><span class="id"> O%N;</span><span class="id"> rewrite</span><span class="id"> /n_step_ball;</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> /distN</span>.<br/>
<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> `|X|%N]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> 0</span>)<span class="id"> ?absz0//</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -[_</span><span class="id"> ==</span><span class="id"> _]negbK;</span><span class="id"> rewrite</span><span class="id"> floor_neq0</span><span class="id"> negb_or</span><span class="id"> -?ltNge</span><span class="id"> -?leNgt</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/andP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> invf_lt1</span><span class="id"> //=</span><span class="id"> ltrDl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> countable_uniform</span>.<br/>
<br/>
<span class="vernacular">Module</span><span class="vernacular"> Exports</span>.<span class="id"> HB</span>.<span class="id">reexport</span>.<span class="vernacular"> End</span><span class="vernacular"> Exports</span>.<br/>
<span class="vernacular">End</span><span class="id"> countable_uniform</span>.<br/>
<span class="vernacular">Export</span><span class="id"> countable_uniform</span>.<span class="vernacular">Exports</span>.<br/>
<br/>
<span class="vernacular">Notation</span><span class="id"> countable_uniform</span><span class="id"> :=</span><span class="id"> countable_uniform</span>.<span class="id">type</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> sup_pseudometric</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">Ii</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<br/>
&nbsp;&nbsp;(<span class="id">Tc</span><span class="id"> :</span><span class="id"> Ii</span><span class="id"> -&gt;</span><span class="id"> PseudoMetric</span><span class="id"> R</span><span class="id"> T</span>) (<span class="id">Icnt</span><span class="id"> :</span><span class="id"> countable</span><span class="id"> [set:</span><span class="id"> Ii]</span>)<span class="id"> :</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> sup_pseudometric</span>.<br/>
<span class="vernacular">Variable</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">Ii</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>).<br/>
<span class="vernacular">Variable</span> (<span class="id">Tc</span><span class="id"> :</span><span class="id"> Ii</span><span class="id"> -&gt;</span><span class="id"> PseudoMetric</span><span class="id"> R</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> Icnt</span><span class="id"> :</span><span class="id"> countable</span><span class="id"> [set:</span><span class="id"> Ii]</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> S</span><span class="id"> :=</span> (<span class="id">sup_pseudometric</span><span class="id"> Tc</span><span class="id"> Icnt</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> TS</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> PseudoMetric</span>.<span class="id">Pack</span> (<span class="id">Tc</span><span class="id"> i</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> countable_uniformityT</span><span class="id"> :=</span><span class="id"> @countable_sup_ent</span><span class="id"> T</span><span class="id"> Ii</span><span class="id"> Tc</span><span class="id"> Icnt</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> @countable_uniformity_metric</span><span class="id"> _</span> (<span class="id">TS</span><span class="id"> i</span>)).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :</span><span class="id"> PseudoMetric</span><span class="id"> R</span><span class="id"> S</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">PseudoMetric</span>.<span class="id">on</span> (<span class="id">countable_uniform</span><span class="id"> countable_uniformityT</span>).<br/>
<br/>
<span class="vernacular">End</span><span class="id"> sup_pseudometric</span>.<br/>
<br/>
<span class="vernacular">Module</span><span class="id"> gauge</span>.<br/>
<span class="vernacular">Section</span><span class="id"> gauge</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> relation_scope</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> split_sym</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> uniformType}</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> T</span>))<span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">split_ent</span><span class="id"> W</span>)<span class="id"> `&amp;`</span> (<span class="id">split_ent</span><span class="id"> W</span>)<span class="id">^-1</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> entourage_gauge</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> uniformType}</span> (<span class="id">E</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> T</span>)) (<span class="id">entE</span><span class="id"> :</span><span class="id"> entourage</span><span class="id"> E</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> gauge</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">filter_from</span><span class="id"> [set:</span><span class="id"> nat]</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> iter</span><span class="id"> n</span><span class="id"> split_sym</span> (<span class="id">E</span><span class="id"> `&amp;`</span><span class="id"> E^-1</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> iter_split_ent</span><span class="id"> j</span><span class="id"> :</span><span class="id"> entourage</span> (<span class="id">iter</span><span class="id"> j</span><span class="id"> split_sym</span> (<span class="id">E</span><span class="id"> `&amp;`</span><span class="id"> E^-1</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> [|i</span><span class="id"> IH];</span><span class="id"> exact:</span><span class="id"> filterI</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gauge_ent</span><span class="id"> A</span><span class="id"> :</span><span class="id"> gauge</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> entourage</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case=&gt;</span><span class="id"> n;</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> A;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> _</span><span class="id"> /filterS;</span><span class="id"> apply;</span><span class="id"> apply:</span><span class="id"> filterI</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> ?</span><span class="id"> A</span><span class="id"> _</span><span class="id"> /filterS;</span><span class="id"> apply;</span><span class="id"> apply:</span><span class="id"> filterI;</span><span class="id"> have</span><span class="id"> ?</span><span class="id"> :=</span><span class="id"> iter_split_ent</span><span class="id"> n</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gauge_filter</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> gauge</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> filter_from_filter;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 0%N</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> wlog</span><span class="id"> ilej</span><span class="id"> :</span><span class="id"> i</span><span class="id"> j</span><span class="id"> /</span> (<span class="id">i</span><span class="id"> &lt;=</span><span class="id"> j</span>)<span class="id">%N</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> WH;</span><span class="id"> have</span><span class="id"> [|/ltnW]</span><span class="id"> :=</span><span class="id"> leqP</span><span class="id"> i</span><span class="id"> j;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[|rewrite</span> (<span class="id">setIC</span> (<span class="id">iter</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>))<span class="id">];</span><span class="id"> exact:</span><span class="id"> WH</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> subsetI;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> elim:</span><span class="id"> j</span><span class="id"> i</span><span class="id"> ilej</span><span class="id"> =&gt;</span><span class="id"> [i|j</span><span class="id"> IH</span><span class="id"> i]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> leqn0</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;</span>.<br/>
<span class="id">rewrite</span><span class="id"> leq_eqVlt</span><span class="id"> =&gt;</span><span class="id"> /predU1P[&lt;-//|/ltnSE/IH];</span><span class="id"> apply:</span><span class="id"> subset_trans</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x/=</span><span class="id"> [jx</span><span class="id"> _];</span><span class="id"> apply:</span><span class="id"> split_ent_subset</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> iter_split_ent</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gauge_refl</span><span class="id"> A</span><span class="id"> :</span><span class="id"> gauge</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> diagonal</span><span class="id"> `&lt;=`</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case=&gt;</span><span class="id"> n</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> subset_trans</span><span class="id"> =&gt;</span><span class="id"> -[_</span><span class="id"> a]/diagonalP</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> entourage_refl;</span><span class="id"> exact:</span><span class="id"> iter_split_ent</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gauge_inv</span><span class="id"> A</span><span class="id"> :</span><span class="id"> gauge</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> gauge</span><span class="id"> A^-1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case=&gt;</span><span class="id"> n</span><span class="id"> _</span><span class="id"> EA;</span><span class="id"> apply:</span> (<span class="id">@filterS</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">iter</span><span class="id"> n</span><span class="id"> split_sym</span> (<span class="id">E</span><span class="id"> `&amp;`</span><span class="id"> E^-1</span>))).<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> gauge_filter</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> n</span><span class="id"> EA;</span><span class="id"> last</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> move=&gt;</span><span class="id"> EA</span><span class="id"> [?</span><span class="id"> ?]</span><span class="id"> [/=]</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> EA</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> n</span> .<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gauge_split</span><span class="id"> A</span><span class="id"> :</span><span class="id"> gauge</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists2</span><span class="id"> B,</span><span class="id"> gauge</span><span class="id"> B</span><span class="id"> &amp;</span><span class="id"> B</span><span class="id"> \;</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> _</span><span class="id"> EA;</span><span class="gallina-kwd"> exists</span> (<span class="id">iter</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> split_sym</span> (<span class="id">E</span><span class="id"> `&amp;`</span><span class="id"> E^-1</span>))<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<span class="id">+1</span>.<br/>
<span class="id">apply:</span><span class="id"> subset_trans</span><span class="id"> EA;</span><span class="id"> apply:</span><span class="id"> subset_trans;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subset_split_ent;</span><span class="id"> exact:</span><span class="id"> iter_split_ent</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> a</span><span class="id"> c</span><span class="id"> [b]</span><span class="id"> []</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> []</span><span class="id"> ?</span><span class="id"> ?;</span><span class="gallina-kwd"> exists</span><span class="id"> b</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> gauged</span><span class="id"> :</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><span class="id"> T</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Choice</span>.<span class="id">on</span><span class="id"> gauged</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@isUniform</span>.<span class="id">Build</span><span class="id"> gauged</span><span class="id"> gauge</span><span class="id"> gauge_filter</span><span class="id"> gauge_refl</span><span class="id"> gauge_inv</span><span class="id"> gauge_split</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gauge_countable_uniformity</span><span class="id"> :</span><span class="id"> countable_uniformity</span><span class="id"> gauged</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">exists</span><span class="id"> [set</span><span class="id"> iter</span><span class="id"> n</span><span class="id"> split_sym</span> (<span class="id">E</span><span class="id"> `&amp;`</span><span class="id"> E^-1</span>)<span class="id"> |</span><span class="id"> n</span><span class="gallina-kwd"> in</span><span class="id"> [set:</span><span class="id"> nat]]</span>.<br/>
<span class="id">split;</span><span class="id"> [exact:</span><span class="id"> card_image_le</span><span class="id"> |</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> W</span><span class="id"> [n]</span><span class="id"> _</span><span class="id"> &lt;-;</span><span class="gallina-kwd"> exists</span><span class="id"> n|]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> D</span><span class="id"> [n</span><span class="id"> _</span><span class="id"> ?];</span><span class="gallina-kwd"> exists</span> (<span class="id">iter</span><span class="id"> n</span><span class="id"> split_sym</span> (<span class="id">E</span><span class="id"> `&amp;`</span><span class="id"> E^-1</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> type</span><span class="id"> :=</span><span class="id"> countable_uniform</span>.<span class="id">type</span><span class="id"> gauge_countable_uniformity</span>.<br/>
<span class="vernacular">End</span><span class="id"> entourage_gauge</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> gauge</span>.<br/>
<span class="vernacular">Module</span><span class="vernacular"> Exports</span>.<span class="id"> HB</span>.<span class="id">reexport</span>.<span class="vernacular"> End</span><span class="vernacular"> Exports</span>.<br/>
<span class="vernacular">End</span><span class="id"> gauge</span>.<br/>
<span class="vernacular">Export</span><span class="id"> gauge</span>.<span class="vernacular">Exports</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniform_pseudometric_sup</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> puniformType}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">@entourage</span><span class="id"> T</span><span class="id"> =</span><span class="id"> @sup_ent</span><span class="id"> T</span><span class="id"> {E</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> T</span>)<span class="id"> |</span><span class="id"> @entourage</span><span class="id"> T</span><span class="id"> E}</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> E</span><span class="id"> =&gt;</span><span class="id"> Uniform</span>.<span class="id">class</span> (<span class="id">@gauge</span>.<span class="id">type</span><span class="id"> T</span> (<span class="id">projT1</span><span class="id"> E</span>) (<span class="id">projT2</span><span class="id"> E</span>))).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [E</span><span class="id"> entE|E]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> E</span><span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> pe</span><span class="id"> :</span><span class="id"> {classic</span><span class="id"> {E0</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> T</span>)<span class="id"> |</span><span class="id"> _}}</span><span class="id"> *</span><span class="id"> _</span><span class="id"> :=</span> (<span class="id">exist</span><span class="id"> _</span><span class="id"> E</span><span class="id"> entE,</span><span class="id"> E</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> entPE</span><span class="id"> :</span><span class="id"> `[&lt;</span><span class="id"> @entourage</span> (<span class="id">gauge</span>.<span class="id">type</span><span class="id"> entE</span>)<span class="id"> E</span><span class="id"> &gt;]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/asboolP;</span><span class="gallina-kwd"> exists</span><span class="id"> 0%N</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?</span><span class="id"> []</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">fset1</span> (<span class="id">exist</span><span class="id"> _</span><span class="id"> pe</span><span class="id"> entPE</span>))<span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> in_setE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> set_fset1</span><span class="id"> bigcap_set1</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> W</span><span class="id"> /=</span><span class="id"> [/=</span><span class="id"> J]</span><span class="id"> _</span><span class="id"> &lt;-</span><span class="id"> /filterS;</span><span class="id"> apply;</span><span class="id"> apply:</span><span class="id"> filter_bigI</span><span class="id"> =&gt;</span><span class="id"> -[]</span><span class="id"> []</span><span class="id"> []</span><span class="id"> /=</span><span class="id"> D</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> entD</span><span class="id"> G</span><span class="id"> /[dup]</span><span class="id"> /asboolP</span><span class="id"> [n</span><span class="id"> _</span><span class="id"> +</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> =&gt;</span><span class="id"> /filterS;</span><span class="id"> apply</span>.<br/>
<span class="id">exact:</span><span class="id"> gauge</span>.<span class="id">iter_split_ent</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> perfect_sets</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> topologicalType</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> perfect_set</span><span class="id"> {T}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><span class="id"> closed</span><span class="id"> A</span><span class="id"> /\</span><span class="id"> limit_point</span><span class="id"> A</span><span class="id"> =</span><span class="id"> A</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perfectTP</span><span class="id"> {T}</span><span class="id"> :</span><span class="id"> perfect_set</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> ~</span><span class="id"> open</span><span class="id"> [set</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> case=&gt;</span><span class="id"> _</span><span class="id"> +</span><span class="id"> x</span><span class="id"> Ox</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> x</span><span class="id"> I</span><span class="id"> [set</span><span class="id"> x]</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case;</span><span class="id"> [by</span><span class="id"> apply:</span><span class="id"> open_nbhs_nbhs;</span><span class="id"> split</span><span class="id"> |]</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> [+</span><span class="id"> _]</span><span class="id"> =&gt;</span><span class="id"> /[swap]</span><span class="id"> -&gt;</span><span class="id"> /eqP</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> NOx;</span><span class="id"> split;</span><span class="id"> [exact:</span><span class="id"> closedT</span><span class="id"> |];</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> //</span><span class="id"> _</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> U;</span><span class="id"> rewrite</span><span class="id"> nbhsE;</span><span class="id"> case=&gt;</span><span class="id"> V</span><span class="id"> []</span><span class="id"> oV</span><span class="id"> Vx</span><span class="id"> VU</span>.<br/>
<span class="id">have</span><span class="id"> Vnx:</span><span class="id"> V</span><span class="id"> !=</span><span class="id"> [set</span><span class="id"> x]</span><span class="gallina-kwd"> by</span><span class="id"> apply/eqP</span><span class="id"> =&gt;</span><span class="id"> M;</span><span class="id"> apply:</span> (<span class="id">NOx</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -M</span>.<br/>
<span class="id">have</span><span class="id"> /existsNP</span><span class="id"> [y</span><span class="id"> /existsNP</span><span class="id"> [Vy</span><span class="id"> Ynx]]</span><span class="id"> :</span><span class="id"> ~</span><span class="gallina-kwd"> forall</span><span class="id"> y,</span><span class="id"> V</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> y</span><span class="id"> =</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">move/negP:</span><span class="id"> Vnx;</span><span class="id"> apply:</span><span class="id"> contra_not</span><span class="id"> =&gt;</span><span class="id"> Vxy;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> y;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> [exact/eqP</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> VU]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perfectTP_ex</span><span class="id"> {T}</span><span class="id"> :</span><span class="id"> perfect_set</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id">,</span><span class="id"> open</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> !=set0</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> [/\</span><span class="id"> U</span><span class="id"> x,</span><span class="id"> U</span><span class="id"> y</span><span class="id"> &amp;</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> y]</span> .<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iff_trans</span><span class="id"> perfectTP</span>)<span class="id">;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> nx1</span><span class="id"> U</span><span class="id"> oU</span><span class="id"> []</span><span class="id"> x</span><span class="id"> Ux;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> :</span><span class="id"> U</span><span class="id"> &lt;&gt;</span><span class="id"> [set</span><span class="id"> x]</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Ux1;</span><span class="id"> apply:</span> (<span class="id">nx1</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -Ux1</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contra_notP</span><span class="id"> =&gt;</span><span class="id"> /not_existsP/contrapT=&gt;</span><span class="id"> Uyx;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [y</span><span class="id"> Uy|?</span><span class="id"> -&gt;//];</span><span class="id"> have</span><span class="id"> /not_and3P[//|//|/negP/negPn/eqP]</span><span class="id"> :=</span><span class="id"> Uyx</span><span class="id"> y</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> Unxy</span><span class="id"> x</span><span class="id"> Ox;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> Unxy</span><span class="id"> _</span><span class="id"> Ox;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> []</span><span class="id"> ?</span><span class="id"> [-&gt;]</span><span class="id"> -&gt;</span><span class="id"> /eqP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> perfect_sets</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> sigT_separations</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {X</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> topologicalType}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigT_hausdorff</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> hausdorff_space</span> (<span class="id">X</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> hausdorff_space</span><span class="id"> {i</span><span class="id"> &amp;</span><span class="id"> X</span><span class="id"> i}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> hX</span><span class="id"> [i</span><span class="id"> x]</span><span class="id"> [j</span><span class="id"> y];</span><span class="id"> rewrite/cluster</span><span class="id"> /=</span><span class="id"> /nbhs</span><span class="id"> /=</span><span class="id"> 2!sigT_nbhsE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> cl</span>.<br/>
<span class="id">have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> cl</span> (<span class="id">existT</span><span class="id"> X</span><span class="id"> i</span><span class="id"> @`</span><span class="id"> [set:</span><span class="id"> X</span><span class="id"> i]</span>) (<span class="id">existT</span><span class="id"> X</span><span class="id"> j</span><span class="id"> @`</span><span class="id"> [set:</span><span class="id"> X</span><span class="id"> j]</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;<span class="id">[by</span><span class="id"> apply:</span><span class="id"> existT_nbhs;</span><span class="id"> exact:</span><span class="id"> filterT</span>..<span class="id">|]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> p</span><span class="id"> [/=</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> &lt;-]</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> [ji]]]</span><span class="id"> _</span>.<br/>
<span class="id">rewrite</span><span class="id"> {}ji</span><span class="id"> {j}</span><span class="gallina-kwd"> in</span><span class="id"> x</span><span class="id"> y</span><span class="id"> cl</span><span class="id"> *</span>.<br/>
<span class="id">congr</span><span class="id"> existT;</span><span class="id"> apply:</span><span class="id"> hX</span><span class="id"> =&gt;</span><span class="id"> U</span><span class="id"> V</span><span class="id"> Ux</span><span class="id"> Vy</span>.<br/>
<span class="id">have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> cl</span> (<span class="id">existT</span><span class="id"> X</span><span class="id"> i</span><span class="id"> @`</span><span class="id"> U</span>) (<span class="id">existT</span><span class="id"> X</span><span class="id"> i</span><span class="id"> @`</span><span class="id"> V</span>)<span class="id">;</span><span class="id"> [exact:</span><span class="id"> existT_nbhs</span>..<span class="id">|]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> []</span><span class="id"> [l</span><span class="id"> Ul</span><span class="id"> &lt;-]</span><span class="id"> [r</span><span class="id"> Vr</span><span class="id"> lr];</span><span class="gallina-kwd"> exists</span><span class="id"> l;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">existT_inj2</span><span class="id"> lr</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> sigT_separations</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
