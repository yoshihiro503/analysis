
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.analysis.topology_theory.connected</title>
<meta name="description" content="Documentation of Coq module mathcomp.analysis.topology_theory.connected" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.analysis.topology_theory.connected</h1>
<span class="vernacular">From</span><span class="id"> HB</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> structures</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> all_ssreflect</span><span class="id"> all_algebra</span><span class="id"> all_classical</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> topology_structure</span>.<br/>
<br/>
<div class="ssrdoc md">
# Connectedness
This file provides connected and its related notions.

```
                  connected A &lt;-&gt; the only non empty subset of A which is
                                  both open and closed in A is A
                 separated A B == the two sets A and B are separated
         connected_component x == the connected component of point x
```
</div>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> connected_sets</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="id"> topologicalType</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> A</span><span class="id"> B</span><span class="id"> C</span><span class="id"> D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> connected</span><span class="id"> A</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> B,</span><span class="id"> B</span><span class="id"> !=set0</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">exists2</span><span class="id"> C,</span><span class="id"> open</span><span class="id"> C</span><span class="id"> &amp;</span><span class="id"> B</span><span class="id"> =</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> C</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">exists2</span><span class="id"> C,</span><span class="id"> closed</span><span class="id"> C</span><span class="id"> &amp;</span><span class="id"> B</span><span class="id"> =</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> C</span>)<span class="id"> -&gt;</span><span class="id"> B</span><span class="id"> =</span><span class="id"> A</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connected0</span><span class="id"> :</span><span class="id"> connected</span> (<span class="id">@set0</span><span class="id"> T</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> [?</span><span class="id"> ?];</span><span class="id"> rewrite</span><span class="id"> set0I</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> separated</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">closure</span><span class="id"> A</span>)<span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> =</span><span class="id"> set0</span><span class="id"> /\</span><span class="id"> A</span><span class="id"> `&amp;`</span> (<span class="id">closure</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> set0</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> separatedC</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> separated</span><span class="id"> A</span><span class="id"> B</span><span class="id"> =</span><span class="id"> separated</span><span class="id"> B</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /separated</span><span class="id"> andC</span><span class="id"> setIC</span> (<span class="id">setIC</span><span class="id"> _</span><span class="id"> B</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> separated_disjoint</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> separated</span><span class="id"> A</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> =</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> AB;</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[Ax</span><span class="id"> Bx]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> AB;</span><span class="id"> rewrite</span><span class="id"> /separated</span><span class="id"> =&gt;</span><span class="id"> -[&lt;-</span><span class="id"> _];</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> subset_closure</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connectedPn</span><span class="id"> A</span><span class="id"> :</span><span class="id"> ~</span><span class="id"> connected</span><span class="id"> A</span><span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> E</span><span class="id"> :</span><span class="id"> bool</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T,</span><span class="id"> [/\</span><span class="gallina-kwd"> forall</span><span class="id"> b,</span><span class="id"> E</span><span class="id"> b</span><span class="id"> !=set0,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> =</span><span class="id"> E</span><span class="id"> false</span><span class="id"> `|`</span><span class="id"> E</span><span class="id"> true</span><span class="id"> &amp;</span><span class="id"> separated</span> (<span class="id">E</span><span class="id"> false</span>) (<span class="id">E</span><span class="id"> true</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -propeqE;</span><span class="id"> apply:</span><span class="id"> notLR;</span><span class="id"> rewrite</span><span class="id"> propeqE</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> [conE</span><span class="id"> [E</span><span class="id"> [E0</span><span class="id"> EU</span><span class="id"> [E1</span><span class="id"> E2]]]|conE</span><span class="id"> B</span><span class="id"> B0</span><span class="id"> [C</span><span class="id"> oC</span><span class="id"> BAC]</span><span class="id"> [D</span><span class="id"> cD</span><span class="id"> BAD]]</span>.<br/>
&nbsp;&nbsp;<span class="id">suff</span><span class="id"> :</span><span class="id"> E</span><span class="id"> true</span><span class="id"> =</span><span class="id"> A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move/esym/</span>(<span class="id">congr1</span> (<span class="id">setD^~</span> (<span class="id">closure</span> (<span class="id">E</span><span class="id"> true</span>))))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> EU</span><span class="id"> setDUl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> :=</span><span class="id"> @subset_closure</span><span class="id"> _</span> (<span class="id">E</span><span class="id"> true</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -setD_eq0</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> setU0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/setDidPl</span><span class="id"> :</span><span class="id"> E2</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> exact/eqP/set0P</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">conE</span><span class="id"> _</span> (<span class="id">E0</span><span class="id"> true</span>)).<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> exists</span> (<span class="id">~`</span> (<span class="id">closure</span> (<span class="id">E</span><span class="id"> false</span>)))<span class="id">;</span><span class="id"> first</span><span class="id"> exact/closed_openC/closed_closure</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> EU</span><span class="id"> setIUl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /subsets_disjoint</span><span class="id"> -&gt;</span><span class="id"> :=</span><span class="id"> @subset_closure</span><span class="id"> _</span> (<span class="id">E</span><span class="id"> false</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> set0U</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/esym/setIidPl/disjoints_subset;</span><span class="id"> rewrite</span><span class="id"> setIC</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> exists</span> (<span class="id">closure</span> (<span class="id">E</span><span class="id"> true</span>))<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> closed_closure</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> EU</span><span class="id"> setIUl</span><span class="id"> E2</span><span class="id"> set0U;</span><span class="id"> exact/esym/setIidPl/subset_closure</span>.<br/>
<span class="id">apply:</span><span class="id"> contrapT</span><span class="id"> =&gt;</span><span class="id"> AF;</span><span class="id"> apply:</span><span class="id"> conE</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> i</span><span class="id"> is</span><span class="id"> false</span><span class="gallina-kwd"> then</span><span class="id"> A</span><span class="id"> `\`</span><span class="id"> C</span><span class="gallina-kwd"> else</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> C</span>)<span class="id">;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="id"> case=&gt;</span><span class="id"> /=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -BAC</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/set0P/eqP</span><span class="id"> =&gt;</span><span class="id"> /disjoints_subset;</span><span class="id"> rewrite</span><span class="id"> setCK</span><span class="id"> =&gt;</span><span class="id"> EC</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> AF;</span><span class="id"> rewrite</span><span class="id"> BAC;</span><span class="id"> exact/setIidPl</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> -setIUr</span><span class="id"> setUCl</span><span class="id"> setIT</span>.<br/>
<span class="id">-</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> rewrite</span><span class="id"> setIC;</span><span class="id"> apply/disjoints_subset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -interiorC</span><span class="id"> interiorEbigcup</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> [?</span><span class="id"> ?]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> C</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> setCI</span><span class="id"> setCK;</span><span class="id"> right</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> apply/disjoints_subset</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> -[Ay</span><span class="id"> Cy]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -BAC</span><span class="id"> BAD</span><span class="id"> =&gt;</span><span class="id"> /closureI[_];</span><span class="id"> move/closure_id</span><span class="id"> :</span><span class="id"> cD</span><span class="id"> =&gt;</span><span class="id"> &lt;-</span><span class="id"> Dy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> :</span><span class="id"> B</span><span class="id"> y;</span><span class="id"> [by</span><span class="id"> rewrite</span><span class="id"> BAD;</span><span class="id"> split|rewrite</span><span class="id"> BAC</span><span class="id"> =&gt;</span><span class="id"> -[]]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connectedP</span><span class="id"> A</span><span class="id"> :</span><span class="id"> connected</span><span class="id"> A</span><span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> E</span><span class="id"> :</span><span class="id"> bool</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T,</span><span class="id"> ~</span><span class="id"> [/\</span><span class="gallina-kwd"> forall</span><span class="id"> b,</span><span class="id"> E</span><span class="id"> b</span><span class="id"> !=set0,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> =</span><span class="id"> E</span><span class="id"> false</span><span class="id"> `|`</span><span class="id"> E</span><span class="id"> true</span><span class="id"> &amp;</span><span class="id"> separated</span> (<span class="id">E</span><span class="id"> false</span>) (<span class="id">E</span><span class="id"> true</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -propeqE</span><span class="id"> forallNE;</span><span class="id"> apply:</span><span class="id"> notRL;</span><span class="id"> rewrite</span><span class="id"> propeqE;</span><span class="id"> exact:</span><span class="id"> connectedPn</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connected_subset</span><span class="id"> A</span><span class="id"> B</span><span class="id"> C</span><span class="id"> :</span><span class="id"> separated</span><span class="id"> A</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> C</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> `|`</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">connected</span><span class="id"> C</span><span class="id"> -&gt;</span><span class="id"> C</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> \/</span><span class="id"> C</span><span class="id"> `&lt;=`</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> AB</span><span class="id"> CAB;</span><span class="id"> have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> C</span><span class="id"> =</span> (<span class="id">C</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="id"> `|`</span> (<span class="id">C</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> split=&gt;</span><span class="id"> [Cx|[]</span><span class="id"> []</span><span class="id"> //]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [Ax|Bx]</span><span class="id"> :=</span><span class="id"> CAB</span><span class="id"> _</span><span class="id"> Cx;</span><span class="id"> [left|right]</span>.<br/>
<span class="id">move/connectedP/</span>(_ (<span class="gallina-kwd">fun</span><span class="id"> b</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> b</span><span class="gallina-kwd"> then</span><span class="id"> C</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="gallina-kwd"> else</span><span class="id"> C</span><span class="id"> `&amp;`</span><span class="id"> A</span>))<span class="id"> =&gt;</span><span class="id"> /not_and3P[]//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/existsNP</span><span class="id"> =&gt;</span><span class="id"> [b</span><span class="id"> /set0P/negP/negPn];</span><span class="id"> case:</span><span class="id"> b</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !</span>(<span class="id">setU0,set0U</span>)<span class="id">;</span><span class="id"> [left|right];</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> right</span>.<br/>
<span class="id">case/not_andP</span><span class="id"> =&gt;</span><span class="id"> /eqP/set0P[x</span><span class="id"> []]</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> /closureI[cCx</span><span class="id"> cAx]</span><span class="id"> [Cx</span><span class="id"> Bx];</span><span class="id"> exfalso</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> AB;</span><span class="id"> rewrite</span><span class="id"> /separated</span><span class="id"> =&gt;</span><span class="id"> -[]</span><span class="id"> +</span><span class="id"> _;</span><span class="id"> apply/eqP/set0P;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> [Cx</span><span class="id"> Ax]</span><span class="id"> /closureI[cCx</span><span class="id"> cBx];</span><span class="id"> exfalso</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> AB;</span><span class="id"> rewrite</span><span class="id"> /separated</span><span class="id"> =&gt;</span><span class="id"> -[]</span><span class="id"> _;</span><span class="id"> apply/eqP/set0P;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connected1</span><span class="id"> x</span><span class="id"> :</span><span class="id"> connected</span><span class="id"> [set</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> X</span><span class="id"> [y</span><span class="id"> +]</span><span class="id"> [O</span><span class="id"> Oopen</span><span class="id"> XO]</span><span class="id"> [C</span><span class="id"> Cclosed</span><span class="id"> XC];</span><span class="id"> rewrite</span><span class="id"> XO</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [{y}-&gt;</span><span class="id"> Ox];</span><span class="id"> apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> [[-&gt;//]|-&gt;]</span>.<br/>
Qed.</div></details>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> connected1</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigcup_connected</span><span class="id"> I</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> P</span>) (<span class="id">A</span><span class="id"> i</span>)<span class="id"> !=set0</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> connected</span> (<span class="id">A</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">connected</span> (<span class="id">\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> P</span>) (<span class="id">A</span><span class="id"> i</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [c</span><span class="id"> AIc]</span><span class="id"> cA;</span><span class="id"> have</span><span class="id"> [[i</span><span class="id"> Pi]|]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="gallina-kwd">exists</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">move/forallNP</span><span class="id"> =&gt;</span><span class="id"> P0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> P</span><span class="id"> =</span><span class="id"> set0</span>)<span class="id"> ?bigcup_set0;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> connected0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> P0</span>.<br/>
<span class="id">apply/connectedP</span><span class="id"> =&gt;</span><span class="id"> [E</span><span class="id"> [E0</span><span class="id"> EU</span><span class="id"> sE]]</span>.<br/>
<span class="id">wlog</span><span class="id"> E0c</span><span class="id"> :</span><span class="id"> E</span><span class="id"> E0</span><span class="id"> EU</span><span class="id"> sE</span><span class="id"> /</span><span class="id"> E</span><span class="id"> false</span><span class="id"> c</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> G;</span><span class="id"> have</span><span class="id"> :</span> (<span class="id">\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> P</span>)<span class="id"> A</span><span class="id"> i</span>)<span class="id"> c</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> AIc</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> EU</span><span class="id"> =&gt;</span><span class="id"> -[E0c|E1c];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">G</span> (<span class="id">E</span><span class="id"> \o</span><span class="id"> negb</span>))<span class="id"> =&gt;</span><span class="id"> //;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[case</span><span class="id"> =&gt;</span><span class="id"> /=|rewrite</span><span class="id"> EU</span><span class="id"> setUC|rewrite</span><span class="id"> separatedC]</span>.<br/>
<span class="id">move:</span> (<span class="id">E0</span><span class="id"> true</span>)<span class="id"> =&gt;</span><span class="id"> /set0P/eqP;</span><span class="id"> apply</span>.<br/>
<span class="id">have</span><span class="id"> [/eqP</span><span class="id"> //|/set0P[d</span><span class="id"> E1d]]</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">E</span><span class="id"> true</span><span class="id"> ==</span><span class="id"> set0</span>).<br/>
<span class="id">have</span><span class="id"> :</span><span class="id"> \bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> P</span>)<span class="id"> A</span><span class="id"> i</span><span class="id"> `&lt;=`</span><span class="id"> E</span><span class="id"> false</span>.<br/>
&nbsp;&nbsp;<span class="id">suff</span><span class="id"> AE</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> i</span><span class="id"> `&lt;=`</span><span class="id"> E</span><span class="id"> false</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> [j</span><span class="id"> ?</span><span class="id"> ?];</span><span class="id"> exact:</span> (<span class="id">AE</span><span class="id"> j</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> j</span><span class="id"> Pj</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span> (<span class="id">@connected_subset</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">A</span><span class="id"> j</span>)<span class="id"> sE</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -EU</span><span class="id"> =&gt;</span><span class="id"> /</span>(_ (<span class="id">bigcup_sup</span><span class="id"> _</span>) (<span class="id">cA</span><span class="id"> _</span><span class="id"> Pj</span>))<span class="id"> [//|</span><span class="id"> |</span><span class="id"> AjE1];</span><span class="id"> first</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;<span class="id">exfalso;</span><span class="id"> have</span><span class="id"> E1c</span><span class="id"> :=</span><span class="id"> AjE1</span><span class="id"> _</span> (<span class="id">AIc</span><span class="id"> _</span><span class="id"> Pj</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/separated_disjoint</span><span class="id"> :</span><span class="id"> sE;</span><span class="id"> apply/eqP/set0P;</span><span class="gallina-kwd"> exists</span><span class="id"> c</span>.<br/>
<span class="id">rewrite</span><span class="id"> EU</span><span class="id"> subUset</span><span class="id"> =&gt;</span><span class="id"> -[_]</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> E1d</span>)<span class="id"> E0d;</span><span class="id"> exfalso</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/separated_disjoint</span><span class="id"> :</span><span class="id"> sE;</span><span class="id"> apply/eqP/set0P;</span><span class="gallina-kwd"> exists</span><span class="id"> d</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connectedU</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> !=set0</span><span class="id"> -&gt;</span><span class="id"> connected</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> connected</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">connected</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [x</span><span class="id"> [Ax</span><span class="id"> Bx]]</span><span class="id"> Ac</span><span class="id"> Bc;</span><span class="id"> rewrite</span><span class="id"> -bigcup2inE;</span><span class="id"> apply:</span><span class="id"> bigcup_connected</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> -[|[|[]]]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [|[|[]]]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connected_closure</span><span class="id"> A</span><span class="id"> :</span><span class="id"> connected</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> connected</span> (<span class="id">closure</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ctdA</span><span class="id"> U</span><span class="id"> U0</span><span class="id"> [C1</span><span class="id"> oC1</span><span class="id"> C1E]</span><span class="id"> [C2</span><span class="id"> cC2</span><span class="id"> C2E];</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> C2E;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">suff</span><span class="id"> :</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> U</span>.<br/>
&nbsp;&nbsp;<span class="id">move/closure_subset;</span><span class="id"> rewrite</span><span class="id"> [_</span><span class="id"> `&amp;`</span><span class="id"> _]</span>(<span class="id">iffLR</span> (<span class="id">closure_id</span><span class="id"> _</span>))<span class="id"> ?C2E//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> closedI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> closed_closure</span>.<br/>
<span class="id">rewrite</span><span class="id"> -setIidPl;</span><span class="id"> apply:</span><span class="id"> ctdA</span>.<br/>
<span class="id">-</span><span class="id"> move:</span><span class="id"> U0;</span><span class="id"> rewrite</span><span class="id"> C1E</span><span class="id"> =&gt;</span><span class="id"> -[z</span><span class="id"> [clAx</span><span class="id"> C1z]];</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> clAx</span><span class="id"> C1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> open_nbhs_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> w</span><span class="id"> [Aw</span><span class="id"> C1w];</span><span class="gallina-kwd"> exists</span><span class="id"> w;</span><span class="id"> rewrite</span><span class="id"> setIA</span> (<span class="id">setIidl</span> (<span class="id">@subset_closure</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> C1</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> C1E</span><span class="id"> setIA</span> (<span class="id">setIidl</span> (<span class="id">@subset_closure</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> C2</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> C2E</span><span class="id"> setIA</span> (<span class="id">setIidl</span> (<span class="id">@subset_closure</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> connected_component</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">\bigcup_</span>(<span class="id">A</span><span class="gallina-kwd"> in</span><span class="id"> [set</span><span class="id"> C</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> |</span><span class="id"> [/\</span><span class="id"> C</span><span class="id"> x,</span><span class="id"> C</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> connected</span><span class="id"> C]]</span>)<span class="id"> A</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> component_connected</span><span class="id"> A</span><span class="id"> x</span><span class="id"> :</span><span class="id"> connected</span> (<span class="id">connected_component</span><span class="id"> A</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> bigcup_connected;</span><span class="id"> [exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> C</span><span class="id"> []|move=&gt;</span><span class="id"> C</span><span class="id"> []]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connected_component_sub</span><span class="id"> A</span><span class="id"> x</span><span class="id"> :</span><span class="id"> connected_component</span><span class="id"> A</span><span class="id"> x</span><span class="id"> `&lt;=`</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> [B</span><span class="id"> [_</span><span class="id"> +</span><span class="id"> _]]</span><span class="id"> =&gt;</span><span class="id"> /[apply]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connected_component_id</span><span class="id"> A</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> connected</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> connected_component</span><span class="id"> A</span><span class="id"> x</span><span class="id"> =</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Ax</span><span class="id"> Ac;</span><span class="id"> apply/seteqP;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> connected_component_sub</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> Ay;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connected_component_out</span><span class="id"> A</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">~</span><span class="id"> A</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> connected_component</span><span class="id"> A</span><span class="id"> x</span><span class="id"> =</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> NAx;</span><span class="id"> rewrite</span><span class="id"> -subset0</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> [B</span><span class="id"> [/[swap]/[apply]]]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connected_component_max</span><span class="id"> A</span><span class="id"> B</span><span class="id"> x</span><span class="id"> :</span><span class="id"> B</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">connected</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> connected_component</span><span class="id"> A</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Bx</span><span class="id"> BA</span><span class="id"> Bc</span><span class="id"> y</span><span class="id"> By;</span><span class="gallina-kwd"> exists</span><span class="id"> B</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connected_component_refl</span><span class="id"> A</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> connected_component</span><span class="id"> A</span><span class="id"> x</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Ax;</span><span class="gallina-kwd"> exists</span><span class="id"> [set</span><span class="id"> x]</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connected_component_cover</span><span class="id"> A</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\bigcup_</span>(<span class="id">A</span><span class="gallina-kwd"> in</span><span class="id"> connected_component</span><span class="id"> A</span><span class="id"> @`</span><span class="id"> A</span>)<span class="id"> A</span><span class="id"> =</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/predeqP</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> split=&gt;</span><span class="id"> [[B</span><span class="id"> [y</span><span class="id"> By</span><span class="id"> &lt;-</span><span class="id"> /connected_component_sub//]]|Ax]</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">connected_component</span><span class="id"> A</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> connected_component_refl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connected_component_sym</span><span class="id"> A</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">connected_component</span><span class="id"> A</span><span class="id"> x</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> connected_component</span><span class="id"> A</span><span class="id"> y</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [B</span><span class="id"> [*]];</span><span class="gallina-kwd"> exists</span><span class="id"> B</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> connected_component_trans</span><span class="id"> A</span><span class="id"> y</span><span class="id"> x</span><span class="id"> z</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">connected_component</span><span class="id"> A</span><span class="id"> x</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> connected_component</span><span class="id"> A</span><span class="id"> y</span><span class="id"> z</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">connected_component</span><span class="id"> A</span><span class="id"> x</span><span class="id"> z</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [B</span><span class="id"> [Bx</span><span class="id"> BA</span><span class="id"> Ac</span><span class="id"> Ay]]</span><span class="id"> [C</span><span class="id"> [Cy</span><span class="id"> CA</span><span class="id"> Cc</span><span class="id"> Cz]];</span><span class="gallina-kwd"> exists</span> (<span class="id">B</span><span class="id"> `|`</span><span class="id"> C</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> right</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split;</span><span class="id"> [left</span><span class="id"> |</span><span class="id"> rewrite</span><span class="id"> subUset</span><span class="id"> |</span><span class="id"> apply:</span><span class="id"> connectedU=&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> y]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> same_connected_component</span><span class="id"> A</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> connected_component</span><span class="id"> A</span><span class="id"> x</span><span class="id"> y</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">connected_component</span><span class="id"> A</span><span class="id"> x</span><span class="id"> =</span><span class="id"> connected_component</span><span class="id"> A</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Axy;</span><span class="id"> apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> z;</span><span class="id"> apply:</span><span class="id"> connected_component_trans</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> connected_component_sym</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> component_closed</span><span class="id"> A</span><span class="id"> x</span><span class="id"> :</span><span class="id"> closed</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> closed</span> (<span class="id">connected_component</span><span class="id"> A</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> clA;</span><span class="id"> have</span><span class="id"> [Ax|Ax]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">A</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> connected_component_out</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> closed0</span>.<br/>
<span class="id">rewrite</span><span class="id"> closure_id</span><span class="id"> eqEsubset;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> subset_closure</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> Axz;</span><span class="gallina-kwd"> exists</span> (<span class="id">closure</span> (<span class="id">connected_component</span><span class="id"> A</span><span class="id"> x</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">split;</span><span class="id"> first</span><span class="id"> exact/subset_closure/connected_component_refl</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> `&lt;=`</span><span class="id"> X]</span>(<span class="id">closure_id</span><span class="id"> A</span>).<span class="id">1//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> closure_subset;</span><span class="id"> exact:</span><span class="id"> connected_component_sub</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> connected_closure;</span><span class="id"> exact:</span><span class="id"> component_connected</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> clopen_separatedP</span><span class="id"> A</span><span class="id"> :</span><span class="id"> clopen</span><span class="id"> A</span><span class="id"> &lt;-&gt;</span><span class="id"> separated</span><span class="id"> A</span> (<span class="id">~`</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [[oA</span><span class="id"> cA]|[]</span><span class="id"> /[!</span>(<span class="id">@disjoints_subset</span><span class="id"> T</span>)<span class="id">]</span><span class="id"> /[!</span>(<span class="id">@setCK</span><span class="id"> T</span>)<span class="id">]</span><span class="id"> clAA</span><span class="id"> AclA]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /separated</span><span class="id"> -</span>((<span class="id">closure_id</span><span class="id"> A</span>).<span class="id">1</span><span class="id"> cA</span>)<span class="id"> setICr</span><span class="id"> ;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>((<span class="id">closure_id</span><span class="id"> _</span>).<span class="id">1</span> (<span class="id">open_closedC</span><span class="id"> oA</span>))<span class="id"> setICr</span>.<br/>
<span class="id">split;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> closure_id</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> subset_closure</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -closedC</span><span class="id"> closure_id</span><span class="id"> eqEsubset;</span><span class="id"> split;</span><br/>
&nbsp;&nbsp;<span class="id">[exact:</span><span class="id"> subset_closure|exact:</span><span class="id"> subsetCr]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> connected_sets</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> connected</span><span class="id"> {T}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> connected_component</span><span class="id"> {T}</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
