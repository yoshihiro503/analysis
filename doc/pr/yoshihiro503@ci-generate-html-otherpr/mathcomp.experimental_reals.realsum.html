
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.experimental_reals.realsum</title>
<meta name="description" content="Documentation of Coq module mathcomp.experimental_reals.realsum" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.experimental_reals.realsum</h1>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> all_ssreflect</span><span class="id"> all_algebra</span><span class="id"> archimedean</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span>.<span class="id">classical</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> boolp</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> xfinmap</span><span class="id"> constructive_ereal</span><span class="id"> reals</span><span class="id"> discrete</span><span class="id"> realseq</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span>.<span class="id">classical</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> classical_sets</span><span class="id"> functions</span>.<br/>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<span class="vernacular">Unset</span><span class="id"> SsrOldRewriteGoalsOrder</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> Order</span>.<span class="id">TTheory</span><span class="id"> GRing</span>.<span class="id">Theory</span><span class="id"> Num</span>.<span class="id">Theory</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span>.<span class="id">classical</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> mathcomp_extra</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> fset_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;\`| f |&quot;</span><span class="id"> :=</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> `|f</span><span class="id"> x|</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> simpm</span><span class="id"> :=</span><span class="id"> Monoid</span>.<span class="id">simpm</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Summable</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> summable</span><span class="id"> :=</span><span class="gallina-kwd"> exists</span> (<span class="id">M</span><span class="id"> :</span><span class="id"> R</span>)<span class="id">,</span><span class="gallina-kwd"> forall</span> (<span class="id">J</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">x</span><span class="id"> :</span><span class="id"> J</span>)<span class="id"> `|f</span> (<span class="id">val</span><span class="id"> x</span>)<span class="id">|</span><span class="id"> &lt;=</span><span class="id"> M</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summableP</span><span class="id"> :</span><span class="id"> summable</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> M</span><span class="id"> |</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> M</span><span class="id"> &amp;</span><span class="gallina-kwd"> forall</span> (<span class="id">J</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span>)<span class="id">,</span><span class="id"> \sum_</span>(<span class="id">x</span><span class="id"> :</span><span class="id"> J</span>)<span class="id"> `|f</span> (<span class="id">val</span><span class="id"> x</span>)<span class="id">|</span><span class="id"> &lt;=</span><span class="id"> M</span><span class="id"> }</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/asboolP/exists_asboolP=&gt;</span><span class="id"> h;</span><span class="id"> have</span><span class="id"> :=</span> (<span class="id">xchooseP</span><span class="id"> h</span>).<br/>
<span class="id">move:</span> (<span class="id">xchoose</span><span class="id"> _</span>)<span class="id">=&gt;</span><span class="id"> {h}</span><span class="id"> M</span><span class="id"> /asboolP</span><span class="id"> h;</span><span class="gallina-kwd"> exists</span><span class="id"> M</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> h</span><span class="id"> fset0;</span><span class="id"> rewrite</span><span class="id"> big_pred0</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> -[x];</span><span class="id"> rewrite</span><span class="id"> in_fset0</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> Summable</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Sum</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> fpos</span><span class="id"> f</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> `|Num</span>.<span class="id">max</span><span class="id"> 0</span> (<span class="id">f</span><span class="id"> x</span>)<span class="id">|</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> fneg</span><span class="id"> f</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> `|Num</span>.<span class="id">min</span><span class="id"> 0</span> (<span class="id">f</span><span class="id"> x</span>)<span class="id">|</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_fpos</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> fpos</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> fpos</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq_fg</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /fpos</span><span class="id"> eq_fg</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_fneg</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> fneg</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> fneg</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq_fg</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /fneg</span><span class="id"> eq_fg</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fpos0</span><span class="id"> x</span><span class="id"> :</span><span class="id"> fpos</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> :</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> 0</span>)<span class="id"> x</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> :&gt;</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /fpos</span><span class="id"> maxxx</span><span class="id"> normr0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fneg0</span><span class="id"> x</span><span class="id"> :</span><span class="id"> fneg</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> :</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> 0</span>)<span class="id"> x</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> :&gt;</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /fneg</span><span class="id"> minxx</span><span class="id"> normr0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fnegN</span><span class="id"> f</span><span class="id"> :</span><span class="id"> fneg</span> (<span class="id">-</span><span class="id"> f</span>)<span class="id"> =1</span><span class="id"> fpos</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /fpos</span><span class="id"> /fneg</span><span class="id"> -{1}oppr0</span><span class="id"> -oppr_max</span><span class="id"> normrN</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fposN</span><span class="id"> f</span><span class="id"> :</span><span class="id"> fpos</span> (<span class="id">-</span><span class="id"> f</span>)<span class="id"> =1</span><span class="id"> fneg</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /fpos</span><span class="id"> /fneg</span><span class="id"> -{1}oppr0</span><span class="id"> -oppr_min</span><span class="id"> normrN</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fposZ</span><span class="id"> f</span><span class="id"> c</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> c</span><span class="id"> -&gt;</span><span class="id"> fpos</span> (<span class="id">c</span><span class="id"> \*o</span><span class="id"> f</span>)<span class="id"> =1</span><span class="id"> c</span><span class="id"> \*o</span><span class="id"> fpos</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ge0_c</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /fpos</span><span class="id"> /=</span><span class="id"> -{1}</span>(<span class="id">mulr0</span><span class="id"> c</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -maxr_pMr</span><span class="id"> //</span><span class="id"> normrM</span><span class="id"> ger0_norm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fnegZ</span><span class="id"> f</span><span class="id"> c</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> c</span><span class="id"> -&gt;</span><span class="id"> fneg</span> (<span class="id">c</span><span class="id"> \*o</span><span class="id"> f</span>)<span class="id"> =1</span><span class="id"> c</span><span class="id"> \*o</span><span class="id"> fneg</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ge0_c</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> -!fposN;</span><span class="id"> have</span><span class="id"> /=&lt;-</span><span class="id"> :=</span> (<span class="id">fposZ</span> (<span class="id">-</span><span class="id"> f</span>)<span class="id"> ge0_c</span><span class="id"> x</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_fpos=&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> mulrN</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fpos_natrM</span><span class="id"> f</span> (<span class="id">n</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> nat</span>)<span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">fpos</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">n</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> f</span><span class="id"> x</span>)<span class="id"> x</span><span class="id"> =</span> (<span class="id">n</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> fpos</span><span class="id"> f</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /fpos</span><span class="id"> -[in</span><span class="id"> RHS]normr_nat</span><span class="id"> -normrM</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> maxr_pMr</span><span class="id"> ?ler0n</span><span class="id"> //</span><span class="id"> mulr0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fneg_natrM</span><span class="id"> f</span> (<span class="id">n</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> nat</span>)<span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">fneg</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">n</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> f</span><span class="id"> x</span>)<span class="id"> x</span><span class="id"> =</span> (<span class="id">n</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> fneg</span><span class="id"> f</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -[in</span><span class="id"> RHS]fposN</span><span class="id"> -fpos_natrM</span><span class="id"> -fposN</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_fpos=&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> mulrN</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fneg_ge0</span><span class="id"> f</span><span class="id"> x</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> f</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> fneg</span><span class="id"> f</span><span class="id"> x</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> /fneg</span><span class="id"> min_l</span><span class="id"> ?normr0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fpos_ge0</span><span class="id"> f</span><span class="id"> x</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> f</span><span class="id"> x</span> )<span class="id"> -&gt;</span><span class="id"> fpos</span><span class="id"> f</span><span class="id"> x</span><span class="id"> =</span><span class="id"> f</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> /fpos</span><span class="id"> max_r</span><span class="id"> ?ger0_norm</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ge0_fpos</span><span class="id"> f</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> fpos</span><span class="id"> f</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/normr_ge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ge0_fneg</span><span class="id"> f</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> fneg</span><span class="id"> f</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/normr_ge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_fpos_norm</span><span class="id"> f</span><span class="id"> x</span><span class="id"> :</span><span class="id"> fpos</span><span class="id"> f</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> `|f</span><span class="id"> x|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /fpos</span><span class="id"> ger0_norm</span><span class="id"> ?</span>(<span class="id">le_max,</span><span class="id"> lexx</span>)<span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ge_max</span><span class="id"> normr_ge0</span><span class="id"> ler_norm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_fpos</span><span class="id"> f1</span><span class="id"> f2</span><span class="id"> :</span><span class="id"> f1</span><span class="id"> &lt;=1</span><span class="id"> f2</span><span class="id"> -&gt;</span><span class="id"> fpos</span><span class="id"> f1</span><span class="id"> &lt;=1</span><span class="id"> fpos</span><span class="id"> f2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> le_f</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /fpos</span><span class="id"> !ger0_norm</span><span class="id"> ?le_max</span><span class="id"> ?lexx</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ge_max</span><span class="id"> lexx</span><span class="id"> /=;</span><span class="id"> case:</span><span class="id"> ltP</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> le_f</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fposBfneg</span><span class="id"> f</span><span class="id"> x</span><span class="id"> :</span><span class="id"> fpos</span><span class="id"> f</span><span class="id"> x</span><span class="id"> -</span><span class="id"> fneg</span><span class="id"> f</span><span class="id"> x</span><span class="id"> =</span><span class="id"> f</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /fpos</span><span class="id"> /fneg</span><span class="id"> maxC</span>.<br/>
<span class="id">case:</span> (<span class="id">leP</span> (<span class="id">f</span><span class="id"> x</span>)<span class="id"> 0</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> normr0</span> (<span class="id">subr0,</span><span class="id"> sub0r</span>)<span class="id"> =&gt;</span><span class="id"> ?</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ler0_norm</span><span class="id"> ?opprK</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> gtr0_norm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> psum</span><span class="id"> f</span><span class="id"> :</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> S</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> J</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T},</span><span class="id"> x</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">x</span><span class="id"> :</span><span class="id"> J</span>)<span class="id"> `|f</span> (<span class="id">val</span><span class="id"> x</span>)<span class="id">|</span><span class="id"> ]%classic</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> `[&lt;summable</span><span class="id"> f&gt;]</span><span class="gallina-kwd"> then</span><span class="id"> sup</span><span class="id"> S</span><span class="gallina-kwd"> else</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> sum</span><span class="id"> f</span><span class="id"> :</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> psum</span> (<span class="id">fpos</span><span class="id"> f</span>)<span class="id"> -</span><span class="id"> psum</span> (<span class="id">fneg</span><span class="id"> f</span>).<br/>
<span class="vernacular">End</span><span class="id"> Sum</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> SummableCountable</span>.<br/>
<span class="vernacular">Variable</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_countn0</span><span class="id"> :</span><span class="id"> summable</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> countable</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> f</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> 0]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case/summableP=&gt;</span><span class="id"> M</span><span class="id"> ge0_M</span><span class="id"> bM;</span><span class="id"> pose</span><span class="id"> E</span> (<span class="id">p</span><span class="id"> :</span><span class="id"> nat</span>)<span class="id"> :=</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> `|f</span><span class="id"> x|</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="id"> /</span><span class="id"> p</span>.<span class="id">+1%:~R]</span>.<br/>
<span class="id">set</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> _];</span><span class="id"> have</span><span class="id"> le:</span><span class="id"> {subset</span><span class="id"> F</span><span class="id"> &lt;=</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> `[&lt;</span><span class="gallina-kwd"> exists</span><span class="id"> p,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> E</span><span class="id"> p</span><span class="id"> &gt;]]}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> =&gt;</span><span class="id"> nz_fx;</span><span class="gallina-kwd"> exists</span> (<span class="id">Num</span>.<span class="id">trunc</span><span class="id"> `|f</span><span class="id"> x|^-1</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> mul1r</span><span class="id"> invf_plt</span><span class="id"> ?unfold_in</span><span class="id"> /=</span><span class="id"> ?normr_gt0</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have/trunc_itv/andP[]:</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> `|f</span><span class="id"> x|^-1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> invr_ge0</span><span class="id"> normr_ge0</span>.<br/>
<span class="id">apply/</span>(<span class="id">countable_sub</span><span class="id"> le</span>)<span class="id">/cunion_countable=&gt;</span><span class="id"> i</span><span class="id"> /=</span>.<br/>
<span class="id">case:</span> (<span class="id">existsTP</span> (<span class="gallina-kwd">fun</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> {subset</span><span class="id"> E</span><span class="id"> i</span><span class="id"> &lt;=</span><span class="id"> s}</span>))<span class="id">=&gt;</span><span class="id"> /=</span><span class="id"> [[s</span><span class="id"> le_Eis]|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/finite_countable/finiteP;</span><span class="gallina-kwd"> exists</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /le_Eis</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /finiteNP/</span>(_ ((<span class="id">Num</span>.<span class="id">trunc</span><span class="id"> M</span>).<span class="id">+1</span><span class="id"> *</span><span class="id"> i</span>.<span class="id">+1</span>)<span class="id">%N</span>)<span class="id">/asboolP/exists_asboolP</span><span class="id"> h</span>.<br/>
<span class="id">have/asboolP[]</span><span class="id"> :=</span><span class="id"> xchooseP</span><span class="id"> h</span>.<br/>
<span class="id">set</span><span class="id"> s</span><span class="id"> :=</span><span class="id"> xchoose</span><span class="id"> h=&gt;</span><span class="id"> eq_si</span><span class="id"> uq_s</span><span class="id"> le_sEi;</span><span class="id"> pose</span><span class="id"> J</span><span class="id"> :=</span><span class="id"> [fset</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> s]</span>.<br/>
<span class="id">suff:</span><span class="id"> \sum_</span>(<span class="id">x</span><span class="id"> :</span><span class="id"> J</span>)<span class="id"> `|f</span> (<span class="id">val</span><span class="id"> x</span>)<span class="id">|</span><span class="id"> &gt;</span><span class="id"> M</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ltNge</span><span class="id"> bM</span>.<br/>
<span class="id">apply/</span>(<span class="id">@lt_le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">\sum_</span>(<span class="id">x</span><span class="id"> :</span><span class="id"> J</span>)<span class="id"> 1</span><span class="id"> /</span><span class="id"> i</span>.<span class="id">+1%:~R</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/ler_sum=&gt;</span><span class="id"> /=</span><span class="id"> m</span><span class="id"> _;</span><span class="id"> apply/ltW</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have:=</span><span class="id"> fsvalP</span><span class="id"> m;</span><span class="id"> rewrite</span><span class="id"> in_fset</span><span class="id"> =&gt;</span><span class="id"> /le_sEi</span>.<br/>
<span class="id">rewrite</span><span class="id"> mul1r</span><span class="id"> sumr_const</span><span class="id"> -cardfE</span><span class="id"> card_fseq</span><span class="id"> undup_id</span><span class="id"> //</span><span class="id"> eq_si</span>.<br/>
<span class="id">rewrite</span><span class="id"> -mulr_natr</span><span class="id"> natrM</span><span class="id"> mulrC</span><span class="id"> mulfK</span><span class="id"> ?pnatr_eq0//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case/trunc_itv/andP:</span><span class="id"> ge0_M</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> SummableCountable</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PosCnv</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ncvg_mono</span> (<span class="id">u</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> y,</span> (<span class="id">x</span><span class="id"> &lt;=</span><span class="id"> y</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> u</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> u</span><span class="id"> y</span>)<br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="gallina-kwd"> exists2</span><span class="id"> l,</span> (<span class="id">-oo</span><span class="id"> &lt;</span><span class="id"> l</span>)<span class="id">%E</span><span class="id"> &amp;</span><span class="id"> ncvg</span><span class="id"> u</span><span class="id"> l</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mono_u;</span><span class="id"> pose</span><span class="id"> E</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> n,</span><span class="id"> x</span><span class="id"> =</span><span class="id"> u</span><span class="id"> n]%classic</span>.<br/>
<span class="id">have</span><span class="id"> nzE:</span><span class="id"> nonempty</span><span class="id"> E</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span> (<span class="id">u</span><span class="id"> 0%N</span>)<span class="id">;</span><span class="gallina-kwd"> exists</span><span class="id"> 0%N</span>.<br/>
<span class="id">case:</span> (<span class="id">pselect</span> (<span class="id">has_sup</span><span class="id"> E</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">move/has_supPn=&gt;</span><span class="id"> -/</span>(_<span class="id"> nzE</span>)<span class="id"> h;</span><span class="gallina-kwd"> exists</span><span class="id"> +oo%E</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> elim/nbh_pinfW</span><span class="id"> =&gt;</span><span class="id"> M</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">case/</span>(_<span class="id"> M</span>)<span class="id">:</span><span class="id"> h=&gt;</span><span class="id"> x</span><span class="id"> [K</span><span class="id"> -&gt;</span><span class="id"> lt_MuK];</span><span class="gallina-kwd"> exists</span><span class="id"> K=&gt;</span><span class="id"> n</span><span class="id"> le_Kn;</span><span class="id"> rewrite</span><span class="id"> inE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">lt_le_trans</span><span class="id"> lt_MuK</span>)<span class="id">/mono_u</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> supE;</span><span class="gallina-kwd"> exists</span> (<span class="id">sup</span><span class="id"> E</span>)<span class="id">%:E</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> ltNyr</span>.<br/>
<span class="id">elim/nbh_finW=&gt;e</span><span class="id"> /=</span><span class="id"> gt0_e</span>.<br/>
<span class="id">case:</span> (<span class="id">sup_adherent</span><span class="id"> gt0_e</span><span class="id"> supE</span>)<span class="id">=&gt;</span><span class="id"> x</span><span class="id"> [K</span><span class="id"> -&gt;]</span><span class="id"> lt_uK</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> K=&gt;</span><span class="id"> n</span><span class="id"> le_Kn;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> distrC</span><span class="id"> ger0_norm</span><span class="id"> ?subr_ge0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/ubP:</span> (<span class="id">sup_upper_bound</span><span class="id"> supE</span>)<span class="id">;</span><span class="id"> apply;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
<span class="id">rewrite</span><span class="id"> ltrBlDr</span><span class="id"> addrC</span><span class="id"> -ltrBlDr</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">lt_le_trans</span><span class="id"> lt_uK</span>)<span class="id"> //;</span><span class="id"> apply/mono_u</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ncvg_mono_bnd</span> (<span class="id">u</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> y,</span> (<span class="id">x</span><span class="id"> &lt;=</span><span class="id"> y</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> u</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> u</span><span class="id"> y</span>)<br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> nbounded</span><span class="id"> u</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> l,</span><span class="id"> ncvg</span><span class="id"> u</span><span class="id"> l%:E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case/ncvg_mono=&gt;</span><span class="id"> -[x||]</span><span class="id"> //</span><span class="id"> _</span><span class="id"> cu</span><span class="id"> bdu;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
<span class="id">case/asboolP/nboundedP:</span><span class="id"> bdu=&gt;</span><span class="id"> M</span><span class="id"> gt0_M</span><span class="id"> bdu</span>.<br/>
<span class="id">case/</span>(_ (<span class="id">NPInf</span><span class="id"> M</span>))<span class="id">:</span><span class="id"> cu</span><span class="id"> =&gt;</span><span class="id"> K</span><span class="id"> /=</span><span class="id"> /</span>(_<span class="id"> K</span> (<span class="id">leqnn</span><span class="id"> _</span>)).<br/>
<span class="id">rewrite</span><span class="id"> inE/=</span><span class="id"> =&gt;</span><span class="id"> /ltW</span><span class="id"> /le_trans</span><span class="id"> /</span>(_ (<span class="id">ler_norm</span><span class="id"> _</span>)).<br/>
<span class="gallina-kwd">by</span><span class="id"> move/le_lt_trans/</span>(_ (<span class="id">bdu</span><span class="id"> _</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ltxx</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> PosCnv</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> SumTh</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>).<br/>
<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_sup</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> has_sup</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> x</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> J</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T},</span><span class="id"> x</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> :</span><span class="id"> J</span>)<span class="id"> `|S</span> (<span class="id">val</span><span class="id"> j</span>)<span class="id">|]%classic</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case/summableP=&gt;</span><span class="id"> M</span><span class="id"> _</span><span class="id"> hbd;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> 0,</span><span class="id"> fset0;</span><span class="id"> rewrite</span><span class="id"> big_fset0</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> M;</span><span class="id"> apply/ubP=&gt;</span><span class="id"> y</span><span class="id"> [J</span><span class="id"> -&gt;]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum_sup</span><span class="id"> S</span><span class="id"> :</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">sup</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> J</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T},</span><span class="id"> x</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">x</span><span class="id"> :</span><span class="id"> J</span>)<span class="id"> `|S</span> (<span class="id">val</span><span class="id"> x</span>)<span class="id">|]%classic</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /psum;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> /asboolPn</span><span class="id"> h</span>.<br/>
<span class="id">rewrite</span><span class="id"> sup_out</span><span class="id"> //;</span><span class="id"> set</span><span class="id"> X</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> r</span><span class="id"> |</span><span class="id"> _]%classic</span><span class="id"> =&gt;</span><span class="id"> hs</span>.<br/>
<span class="id">apply:</span><span class="id"> h;</span><span class="gallina-kwd"> exists</span> (<span class="id">sup</span><span class="id"> X</span>)<span class="id"> =&gt;</span><span class="id"> J</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/ubP</span><span class="id"> :</span> (<span class="id">sup_upper_bound</span><span class="id"> hs</span>)<span class="id">;</span><span class="id"> apply;</span><span class="gallina-kwd"> exists</span><span class="id"> J</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum_sup_seq</span><span class="id"> S</span><span class="id"> :</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">sup</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> |</span><span class="gallina-kwd"> exists2</span><span class="id"> J</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> J</span><span class="id"> &amp;</span><span class="id"> x</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> J</span>)<span class="id"> `|S</span><span class="id"> x|</span><span class="id"> ]%classic</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> psum_sup;</span><span class="id"> congr</span><span class="id"> sup;</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> J</span><span class="id"> -&gt;;</span><span class="gallina-kwd"> exists</span> (<span class="id">enum_fset</span><span class="id"> J</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> J</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> J</span><span class="id"> /canonical_uniq</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">big_fset_seq</span><span class="id"> \`|_|</span>)<span class="id"> /=</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> J</span><span class="id"> uqJ</span><span class="id"> -&gt;;</span><span class="gallina-kwd"> exists</span><span class="id"> [fset</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> J]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">big_seq_fset</span><span class="id"> \`|_|</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_summable</span> (<span class="id">S1</span><span class="id"> S2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">S1</span><span class="id"> =1</span><span class="id"> S2</span>)<span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> S1</span><span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> S2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_12</span><span class="id"> [M</span><span class="id"> h];</span><span class="gallina-kwd"> exists</span><span class="id"> M</span><span class="id"> =&gt;</span><span class="id"> J;</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">h</span><span class="id"> J</span>))<span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> le_eqVlt;</span><span class="id"> apply/orP;</span><span class="id"> left;</span><span class="id"> apply/eqP/eq_bigr</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /=</span><span class="id"> K</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> eq_12</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_summableb</span> (<span class="id">S1</span><span class="id"> S2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">S1</span><span class="id"> =1</span><span class="id"> S2</span>)<span class="id"> -&gt;</span><span class="id"> `[&lt;</span><span class="id"> summable</span><span class="id"> S2</span><span class="id"> &gt;]</span><span class="id"> =</span><span class="id"> `[&lt;</span><span class="id"> summable</span><span class="id"> S1</span><span class="id"> &gt;]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq_12;</span><span class="id"> apply/asboolP/asboolP;</span><span class="id"> apply/eq_summable</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_ppsum</span> (<span class="id">F1</span><span class="id"> F2</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> F1</span><span class="id"> =1</span><span class="id"> F2</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">sup</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> J,</span><span class="id"> x</span><span class="id"> =</span><span class="id"> F1</span><span class="id"> J]</span><span class="id"> =</span><span class="id"> sup</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> J,</span><span class="id"> x</span><span class="id"> =</span><span class="id"> F2</span><span class="id"> J]</span>)<span class="id">%classic</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_12;</span><span class="id"> congr</span><span class="id"> sup;</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> -[J</span><span class="id"> -&gt;];</span><span class="gallina-kwd"> exists</span><span class="id"> J</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_psum</span> (<span class="id">F1</span><span class="id"> F2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> F1</span><span class="id"> =1</span><span class="id"> F2</span><span class="id"> -&gt;</span><span class="id"> psum</span><span class="id"> F1</span><span class="id"> =</span><span class="id"> psum</span><span class="id"> F2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_12;</span><span class="id"> rewrite</span><span class="id"> /psum</span> (<span class="id">eq_summableb</span><span class="id"> eq_12</span>).<br/>
<span class="id">case:</span><span class="id"> `[&lt;</span><span class="id"> summable</span><span class="id"> F1</span><span class="id"> &gt;]</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">congr</span><span class="id"> sup</span>.<br/>
<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> split=&gt;</span><span class="id"> -[J</span><span class="id"> -&gt;];</span><span class="gallina-kwd"> exists</span><span class="id"> J;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eq_bigr=&gt;</span><span class="id"> /=</span><span class="id"> K</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> eq_12</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_sum</span> (<span class="id">F1</span><span class="id"> F2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> F1</span><span class="id"> =1</span><span class="id"> F2</span><span class="id"> -&gt;</span><span class="id"> sum</span><span class="id"> F1</span><span class="id"> =</span><span class="id"> sum</span><span class="id"> F2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_fg;</span><span class="id"> rewrite</span><span class="id"> /sum;</span><span class="id"> congr</span> (_<span class="id"> -</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply/eq_psum</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eq_fpos</span>.<span class="gallina-kwd"> by</span><span class="id"> apply/eq_fneg</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_summable</span> (<span class="id">F1</span><span class="id"> F2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> F1</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> F2</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> F2</span><span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> F1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> le_F</span><span class="id"> [M</span><span class="id"> leM];</span><span class="gallina-kwd"> exists</span><span class="id"> M</span><span class="id"> =&gt;</span><span class="id"> J;</span><span class="id"> apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">leM</span><span class="id"> J</span>)).<br/>
<span class="id">apply/ler_sum</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> case/andP:</span> (<span class="id">le_F</span> (<span class="id">val</span><span class="id"> j</span>))<span class="id"> =&gt;</span><span class="id"> h1</span><span class="id"> h2</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !ger0_norm</span><span class="id"> //</span> (<span class="id">le_trans</span><span class="id"> h1</span><span class="id"> h2</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_psum</span> (<span class="id">F1</span><span class="id"> F2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> F1</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> F2</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> F2</span><span class="id"> -&gt;</span><span class="id"> psum</span><span class="id"> F1</span><span class="id"> &lt;=</span><span class="id"> psum</span><span class="id"> F2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> le_F</span><span class="id"> smF2;</span><span class="id"> have</span><span class="id"> smF1:</span><span class="id"> summable</span><span class="id"> F1</span><span class="gallina-kwd"> by</span><span class="id"> apply/</span>(<span class="id">le_summable</span><span class="id"> le_F</span>).<br/>
<span class="id">rewrite</span><span class="id"> /psum</span> (<span class="id">asboolT</span><span class="id"> smF1</span>) (<span class="id">asboolT</span><span class="id"> smF2</span>)<span class="id">;</span><span class="id"> apply/le_sup;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply/summable_sup</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 0,</span><span class="id"> fset0;</span><span class="id"> rewrite</span><span class="id"> big_fset0</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> [J</span><span class="id"> -&gt;];</span><span class="id"> apply/downP;</span><span class="gallina-kwd"> exists</span> (<span class="id">\sum_</span>(<span class="id">j</span><span class="id"> :</span><span class="id"> J</span>)<span class="id"> `|F2</span> (<span class="id">val</span><span class="id"> j</span>)<span class="id">|</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> J</span>.<br/>
<span class="id">apply/ler_sum=&gt;</span><span class="id"> /=</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> case/andP:</span> (<span class="id">le_F</span> (<span class="id">val</span><span class="id"> j</span>))<span class="id"> =&gt;</span><span class="id"> h1</span><span class="id"> h2</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !ger0_norm</span><span class="id"> //</span> (<span class="id">le_trans</span><span class="id"> h1</span><span class="id"> h2</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum_out</span><span class="id"> S</span><span class="id"> :</span><span class="id"> ~</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/asboolPn/negbTE=&gt;</span><span class="id"> smN;</span><span class="id"> rewrite</span><span class="id"> /psum</span><span class="id"> smN</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psumE</span><span class="id"> S</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> S</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">sup</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> J</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T},</span><span class="id"> x</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> :</span><span class="id"> J</span>)<span class="id"> S</span> (<span class="id">val</span><span class="id"> j</span>)<span class="id">]%classic</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> gt0_S</span><span class="id"> smS;</span><span class="id"> rewrite</span><span class="id"> /psum</span> (<span class="id">asboolT</span><span class="id"> smS</span>)<span class="id">;</span><span class="id"> apply/eq_ppsum=&gt;</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> J;</span><span class="id"> apply/eq_bigr=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> ger0_norm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum_absE</span><span class="id"> S</span><span class="id"> :</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">sup</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> J</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T},</span><span class="id"> x</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> :</span><span class="id"> J</span>)<span class="id"> `|S</span> (<span class="id">val</span><span class="id"> j</span>)<span class="id">|]%classic</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> smS;</span><span class="id"> rewrite</span><span class="id"> /psum</span> (<span class="id">asboolT</span><span class="id"> smS</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_seqP</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> S</span><span class="id"> &lt;-&gt;</span> (<span class="gallina-kwd">exists2</span><span class="id"> M,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> M</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T,</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> \sum_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> s</span>)<span class="id"> `|S</span><span class="id"> x|</span><span class="id"> &lt;=</span><span class="id"> M</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [/summableP|]</span><span class="id"> [M</span><span class="id"> gt0_M</span><span class="id"> h];</span><span class="gallina-kwd"> exists</span><span class="id"> M</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> s</span><span class="id"> uq_s;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> h</span><span class="id"> [fset</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> s];</span><span class="id"> rewrite</span> (<span class="id">big_seq_fset</span><span class="id"> \`|S|</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> J</span><span class="id"> cJ;</span><span class="id"> rewrite</span> (<span class="id">big_fset_seq</span><span class="id"> \`|_|</span>)<span class="id"> /=;</span><span class="id"> apply/h/canonical_uniq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gerfin_psum</span><span class="id"> S</span> (<span class="id">J</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> :</span><span class="id"> J</span>)<span class="id"> `|S</span> (<span class="id">val</span><span class="id"> j</span>)<span class="id">|</span><span class="id"> &lt;=</span><span class="id"> psum</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> smS;</span><span class="id"> rewrite</span><span class="id"> /psum</span> (<span class="id">asboolT</span><span class="id"> smS</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> move/ubP</span><span class="id"> :</span> (<span class="id">sup_upper_bound</span> (<span class="id">summable_sup</span><span class="id"> smS</span>))<span class="id">;</span><span class="id"> apply;</span><span class="gallina-kwd"> exists</span><span class="id"> J</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gerfinseq_psum</span><span class="id"> S</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> &lt;-</span><span class="id"> r</span>)<span class="id"> `|S</span><span class="id"> j|</span><span class="id"> &lt;=</span><span class="id"> psum</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> uq_r</span><span class="id"> /gerfin_psum</span><span class="id"> -/</span>(_<span class="id"> [fset</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> r]</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">big_seq_fset</span><span class="id"> \`|S|</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum_le</span><span class="id"> S</span><span class="id"> z</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> J,</span><span class="id"> uniq</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> &lt;-</span><span class="id"> J</span>)<span class="id"> `|S</span><span class="id"> j|</span><span class="id"> &lt;=</span><span class="id"> z</span>)<span class="id"> -&gt;</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> &lt;=</span><span class="id"> z</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> le_z;</span><span class="id"> have:</span><span class="id"> summable</span><span class="id"> S;</span><span class="id"> first</span> (<span class="id">apply/summable_seqP;</span><span class="gallina-kwd"> exists</span><span class="id"> z</span>).<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">le_z</span><span class="id"> [::]</span><span class="id"> _</span>))<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> big_nil</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> J</span><span class="id"> uqJ;</span><span class="id"> apply/le_z</span>.<br/>
<span class="id">move/summable_sup=&gt;</span><span class="id"> [neS</span><span class="id"> hsS];</span><span class="id"> rewrite</span><span class="id"> psum_sup</span>.<br/>
<span class="id">apply/sup_le_ub</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply/ubP=&gt;</span><span class="id"> r</span><span class="id"> [J</span><span class="id"> -&gt;]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">big_fset_seq</span><span class="id"> \`|_|</span>)<span class="id"> le_z</span><span class="id"> /=;</span><span class="id"> case:</span><span class="id"> J</span><span class="id"> =&gt;</span><span class="id"> J</span><span class="id"> /=</span><span class="id"> /canonical_uniq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lt_psum</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> l</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> l</span><span class="id"> &lt;</span><span class="id"> psum</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> J</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T},</span><span class="id"> l</span><span class="id"> &lt;</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> :</span><span class="id"> J</span>)<span class="id"> `|F</span> (<span class="id">val</span><span class="id"> j</span>)<span class="id">|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> smF;</span><span class="id"> rewrite</span><span class="id"> /psum</span> (<span class="id">asboolT</span><span class="id"> smF</span>)<span class="id"> =&gt;</span><span class="id"> /lt_sup_imfset</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> /=</span><span class="id"> [|J</span><span class="id"> lt_lJ</span><span class="id"> _];</span><span class="id"> [apply/summable_sup</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> J]</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> SumTh</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> max_sup</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> x</span> (<span class="id">E</span><span class="id"> :</span><span class="id"> set</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">E</span><span class="id"> `&amp;`</span><span class="id"> ubound</span><span class="id"> E</span>)<span class="id">%classic</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> sup</span><span class="id"> E</span><span class="id"> =</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case=&gt;</span><span class="id"> /=</span><span class="id"> xE</span><span class="id"> xubE;</span><span class="id"> have</span><span class="id"> nzE:</span><span class="id"> nonempty</span><span class="id"> E</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le</span><span class="id"> sup_le_ub</span><span class="id"> //=</span>.<br/>
<span class="id">have</span><span class="id"> :</span><span class="id"> has_sup</span><span class="id"> E</span><span class="gallina-kwd"> by</span><span class="id"> split;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/sup_upper_bound/ubP;</span><span class="id"> apply</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> FinSumTh</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> finType</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_fin</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> summable</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">exists</span> (<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> :</span><span class="id"> [fset</span><span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="id"> :</span><span class="id"> I]</span>)<span class="id"> `|f</span> (<span class="id">val</span><span class="id"> i</span>)<span class="id">|</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> J;</span><span class="id"> apply:</span> (<span class="id">big_fset_subset</span> (<span class="id">F</span><span class="id"> :=</span><span class="id"> \`|_|</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> normr_ge0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> apply/imfsetP;</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum_fin</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> psum</span><span class="id"> f</span><span class="id"> =</span><span class="id"> \sum_i</span><span class="id"> `|f</span><span class="id"> i|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
                          <span class="comment">(*&nbsp;FIXME&nbsp;*)</span><br/>
<span class="id">pose</span><span class="id"> S</span><span class="id"> :=</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> :</span><span class="id"> [fset</span><span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="id"> :</span><span class="id"> I]</span>)<span class="id"> `|f</span> (<span class="id">val</span><span class="id"> i</span>)<span class="id">|</span>.<br/>
<span class="id">rewrite</span><span class="id"> /psum</span> (<span class="id">asboolT</span> (<span class="id">summable_fin</span><span class="id"> f</span>)) (<span class="id">@max_sup</span><span class="id"> _</span><span class="id"> S</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /=;</span><span class="id"> split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> [fset</span><span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="id"> :</span><span class="id"> I]%fset</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/ubP=&gt;</span><span class="id"> y</span><span class="id"> [J</span><span class="id"> -&gt;];</span><span class="id"> apply/</span>(<span class="id">big_fset_subset</span> (<span class="id">F</span><span class="id"> :=</span><span class="id"> \`|_|</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> normr_ge0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> j</span><span class="id"> jJ;</span><span class="id"> apply/in_imfset</span>.<br/>
<span class="id">rewrite</span><span class="id"> /S</span><span class="id"> -</span>(<span class="id">big_map</span><span class="id"> val</span><span class="id"> xpredT</span><span class="id"> \`|f|</span>)<span class="id">;</span><span class="id"> apply/perm_big</span>.<br/>
<span class="id">rewrite</span><span class="id"> /index_enum</span><span class="id"> -!enumT;</span><span class="id"> apply/</span>(<span class="id">perm_trans</span><span class="id"> _</span><span class="id"> enum_fsetT</span>).<br/>
<span class="id">apply/uniq_perm;</span><span class="id"> rewrite</span><span class="id"> ?map_inj_uniq</span><span class="id"> ?enum_uniq</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/val_inj</span>.<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -enumT</span><span class="id"> enum_uniq</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> i</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> mem_enum</span><span class="id"> in_imfset</span><span class="id"> //;</span><span class="id"> apply/mapP</span>.<br/>
<span class="id">have</span><span class="id"> h:</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> [fset</span><span class="id"> j</span><span class="id"> |</span><span class="id"> j</span><span class="id"> :</span><span class="id"> I]</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> in_imfset</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">FSetSub</span><span class="id"> h</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> mem_enum</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> FinSumTh</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PSumGe</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>).<br/>
<br/>
<span class="vernacular">Variable</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ger_big_psum</span><span class="id"> r</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> r</span>)<span class="id"> `|S</span><span class="id"> x|</span><span class="id"> &lt;=</span><span class="id"> psum</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> uq_r</span><span class="id"> smS;</span><span class="id"> rewrite</span><span class="id"> /psum</span> (<span class="id">asboolT</span><span class="id"> smS</span>).<br/>
<span class="id">set</span><span class="id"> E</span><span class="id"> :=</span> (<span class="id">X</span><span class="gallina-kwd"> in</span><span class="id"> sup</span><span class="id"> X</span>).<br/>
<span class="id">have</span><span class="id"> :</span><span class="id"> has_sup</span><span class="id"> E</span><span class="gallina-kwd"> by</span><span class="id"> apply/summable_sup</span>.<br/>
<span class="id">move/sup_upper_bound/ubP;</span><span class="id"> apply</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> [fset</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> r];</span><span class="id"> rewrite</span> (<span class="id">big_seq_fset</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> `|S</span><span class="id"> i|</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ger1_psum</span><span class="id"> x</span><span class="id"> :</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> `|S</span><span class="id"> x|</span><span class="id"> &lt;=</span><span class="id"> psum</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> smS;</span><span class="id"> have</span><span class="id"> h</span><span class="id"> :=</span><span class="id"> @ger_big_psum</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> _</span><span class="id"> smS</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">h</span><span class="id"> _</span>))<span class="id"> ?big_seq1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ge0_psum</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> psum</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
                          <span class="comment">(*&nbsp;FIXME:&nbsp;asbool_spec&nbsp;*)</span><br/>
<span class="id">case/boolP:</span><span class="id"> `[&lt;</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> &gt;]</span><span class="id"> =&gt;</span><span class="id"> [|/asboolPn/psum_out</span><span class="id"> -&gt;//]</span>.<br/>
<span class="id">move/asboolP=&gt;</span><span class="id"> smS;</span><span class="id"> have</span><span class="id"> h</span><span class="id"> :=</span><span class="id"> @ger_big_psum</span><span class="id"> [::]</span><span class="id"> _</span><span class="id"> smS</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">h</span><span class="id"> _</span>))<span class="id"> ?big_nil</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> PSumGe</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PSumNatGe</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span>.<br/>
<br/>
<span class="vernacular">Variable</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">smS</span><span class="id"> :</span><span class="id"> summable</span><span class="id"> S</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ger_big_ord_psum</span><span class="id"> n</span><span class="id"> :</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> `|S</span><span class="id"> i|</span><span class="id"> &lt;=</span><span class="id"> psum</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">big_mkord</span><span class="id"> predT</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> `|S</span><span class="id"> i|</span>))<span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/ger_big_psum</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> iota_uniq</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> PSumNatGe</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PSumCnv</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span>.<br/>
<br/>
<span class="vernacular">Variable</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> ge0_S</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> S</span><span class="id"> n</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> smS</span>  <span class="id"> :</span><span class="id"> summable</span><span class="id"> S</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ptsum_homo</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> &lt;=</span><span class="id"> y</span>)<span class="id">%N</span><span class="id"> -&gt;</span> (<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> x</span>)<span class="id"> S</span><span class="id"> i</span><span class="id"> &lt;=</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> y</span>)<span class="id"> S</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> le_xy;</span><span class="id"> rewrite</span><span class="id"> -!</span>(<span class="id">big_mkord</span><span class="id"> predT</span>)<span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> le_xy</span>)<span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /index_iota</span><span class="id"> !subn0</span><span class="id"> iotaD</span><span class="id"> big_cat</span><span class="id"> /=</span><span class="id"> lerDl</span><span class="id"> sumr_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psummable_ptbounded</span><span class="id"> :</span><span class="id"> nbounded</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> S</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/asboolP/nboundedP;</span><span class="gallina-kwd"> exists</span> (<span class="id">psum</span><span class="id"> S</span><span class="id"> +</span><span class="id"> 1</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ltr_pwDr</span><span class="id"> ?ltr01</span><span class="id"> 1?</span>(<span class="id">le_trans</span> (<span class="id">normr_ge0</span> (<span class="id">S</span><span class="id"> 0%N</span>)))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/ger1_psum</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> ltr_pwDr</span><span class="id"> ?ltr01</span><span class="id"> //</span><span class="id"> ger0_norm</span><span class="id"> ?sumr_ge0</span><span class="id"> //</span>.<br/>
<span class="id">apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">ger_big_ord_psum</span><span class="id"> _</span><span class="id"> n</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/ler_sum=&gt;</span><span class="id"> /=</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> apply/ler_norm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ncvg_sum</span><span class="id"> :</span><span class="id"> ncvg</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> S</span><span class="id"> i</span>) (<span class="id">psum</span><span class="id"> S</span>)<span class="id">%:E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">set</span><span class="id"> u</span><span class="id"> :=</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> contraPP</span><span class="id"> smS</span><span class="id"> =&gt;</span><span class="id"> ncv</span><span class="id"> _</span>.<br/>
<span class="id">case:</span> (<span class="id">ncvg_mono_bnd</span> (<span class="id">u</span><span class="id"> :=</span><span class="id"> u</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/ptsum_homo</span>.<span class="gallina-kwd"> by</span><span class="id"> apply/psummable_ptbounded</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> cvux;</span><span class="id"> suff</span><span class="id"> xE:</span><span class="id"> x</span><span class="id"> =</span> (<span class="id">psum</span><span class="id"> S</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> xE</span><span class="gallina-kwd"> in</span><span class="id"> cvux</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> case:</span> (<span class="id">x</span><span class="id"> =P</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> /eqP</span><span class="id"> /lt_total</span><span class="id"> /orP[];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
<span class="id">+</span><span class="id"> rewrite</span><span class="id"> -lte_fin</span><span class="id"> =&gt;</span><span class="id"> /ncvg_gt</span><span class="id"> /</span>(_<span class="id"> cvux</span>)<span class="id"> [K</span><span class="id"> /</span>(_<span class="id"> _</span> (<span class="id">leqnn</span><span class="id"> _</span>))<span class="id">]</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ltNge</span><span class="id"> lee_fin</span> (<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">ger_big_ord_psum</span><span class="id"> _</span><span class="id"> K</span>))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/ler_sum=&gt;</span><span class="id"> /=</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> apply/ler_norm</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> lt_xS;</span><span class="id"> pose</span><span class="id"> e</span><span class="id"> :=</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> -</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> ge0_e:</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> e</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subr_gt0</span>.<br/>
<span class="id">case:</span> (<span class="id">sup_adherent</span><span class="id"> ge0_e</span> (<span class="id">summable_sup</span><span class="id"> smS</span>))<span class="id"> =&gt;</span><span class="id"> y</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> /=</span><span class="id"> J</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> /e</span><span class="id"> /psum</span> (<span class="id">asboolT</span><span class="id"> smS</span>).<br/>
<span class="id">rewrite</span><span class="id"> opprB</span><span class="id"> addrCA</span><span class="id"> subrr</span><span class="id"> addr0</span><span class="id"> =&gt;</span><span class="id"> lt_xSJ</span>.<br/>
<span class="id">pose</span><span class="id"> k</span><span class="id"> :=</span><span class="id"> \max_</span>(<span class="id">j</span><span class="id"> :</span><span class="id"> J</span>) (<span class="id">val</span><span class="id"> j</span>)<span class="id">;</span><span class="id"> have</span><span class="id"> lt_x_uSk:</span><span class="id"> x</span><span class="id"> &lt;</span><span class="id"> u</span><span class="id"> k</span>.<span class="id">+1</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/</span>(<span class="id">lt_le_trans</span><span class="id"> lt_xSJ</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> /u</span><span class="id"> big_ord_mkfset</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">eq_bigr</span> (<span class="id">S</span><span class="id"> \o</span><span class="id"> val</span>))<span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [j</span><span class="id"> _|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ger0_norm</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/big_fset_subset=&gt;</span><span class="id"> //</span><span class="id"> j</span><span class="id"> jJ;</span><span class="id"> rewrite</span><span class="id"> in_fset</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">mem_iota</span><span class="id"> _</span><span class="id"> k</span>.<span class="id">+1</span>)<span class="id"> /=</span><span class="id"> add0n</span><span class="id"> ltnS</span> (<span class="id">leq_bigmax</span> (<span class="id">FSetSub</span><span class="id"> jJ</span>)).<br/>
<span class="id">have</span><span class="id"> /=</span><span class="id"> :=</span><span class="id"> ncvg_homo_le</span><span class="id"> ptsum_homo</span><span class="id"> cvux</span><span class="id"> k</span>.<span class="id">+1;</span><span class="id"> rewrite</span><span class="id"> -/</span>(<span class="id">u</span><span class="id"> _</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> lee_fin</span><span class="id"> =&gt;</span><span class="id"> /le_lt_trans/</span>(_<span class="id"> lt_x_uSk</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ltxx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sum_ncvg</span><span class="id"> l</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">ncvg</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> S</span><span class="id"> i</span>)<span class="id"> l%:E</span><span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> S</span>.<br/>
<span class="vernacular">Proof</span><span class="gallina-kwd"> using</span><span class="id"> ge0_S</span>.<span class="vernacular">End</span><span class="id"> PSumCnv</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PSumAsLim</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span>.<br/>
<br/>
<span class="vernacular">Variable</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> {fset</span><span class="id"> T}</span>).<br/>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> ge0_S</span>  <span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> S</span><span class="id"> x</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> smS</span>    <span class="id"> :</span><span class="id"> summable</span><span class="id"> S</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> homo_P</span> <span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> n</span><span class="id"> m,</span> (<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> m</span>)<span class="id">%N</span><span class="id"> -&gt;</span> (<span class="id">P</span><span class="id"> n</span><span class="id"> `&lt;=`</span><span class="id"> P</span><span class="id"> m</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> cover_P</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> S</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> n,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> P</span><span class="id"> n</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum_as_lim</span><span class="id"> :</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> =</span><span class="id"> fine</span> (<span class="id">nlim</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> :</span><span class="id"> P</span><span class="id"> n</span>) (<span class="id">S</span> (<span class="id">val</span><span class="id"> j</span>)))).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">set</span><span class="id"> v</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> _;</span><span class="id"> have</span><span class="id"> hm_v</span><span class="id"> m</span><span class="id"> n:</span> (<span class="id">m</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> v</span><span class="id"> m</span><span class="id"> &lt;=</span><span class="id"> v</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> le_mn;</span><span class="id"> apply/big_fset_subset/fsubsetP/homo_P</span>.<br/>
<span class="id">have</span><span class="id"> bd_v</span><span class="id"> n</span><span class="id"> :</span><span class="id"> v</span><span class="id"> n</span><span class="id"> &lt;=</span><span class="id"> psum</span><span class="id"> S</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">gerfin_psum</span><span class="id"> _</span><span class="id"> smS</span>))<span class="id">/ler_sum</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> J</span><span class="id"> _;</span><span class="id"> apply/ler_norm</span>.<br/>
<span class="id">case:</span> (<span class="id">ncvg_mono_bnd</span><span class="id"> hm_v</span>)<span class="id"> =&gt;</span><span class="id"> [|l</span><span class="id"> cv]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/asboolP/nboundedP;</span><span class="gallina-kwd"> exists</span> (<span class="id">psum</span><span class="id"> S</span><span class="id"> +</span><span class="id"> 1</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">le_lt_trans</span> (<span class="id">ge0_psum</span><span class="id"> S</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ltrDl</span><span class="id"> ltr01</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> ger0_norm</span><span class="id"> ?sumr_ge0</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_lt_trans</span> (<span class="id">bd_v</span><span class="id"> n</span>))<span class="id"> //</span><span class="id"> ltrDl</span><span class="id"> ltr01</span>.<br/>
<span class="id">have</span><span class="id"> le_lS:</span><span class="id"> l</span><span class="id"> &lt;=</span><span class="id"> psum</span><span class="id"> S</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -lee_fin</span> (<span class="id">ncvg_leC</span><span class="id"> _</span><span class="id"> cv</span>).<br/>
<span class="id">rewrite</span> (<span class="id">nlimE</span><span class="id"> cv</span>)<span class="id"> /=</span> (<span class="id">rwP</span><span class="id"> eqP</span>)<span class="id"> eq_le</span><span class="id"> le_lS</span><span class="id"> andbT</span>.<br/>
<span class="id">rewrite</span><span class="id"> leNgt;</span><span class="id"> apply/negP=&gt;</span><span class="id"> {le_lS}</span><span class="id"> /</span>(<span class="id">lt_psum</span><span class="id"> smS</span>)<span class="id">[J]</span>.<br/>
<span class="id">rewrite</span> (<span class="id">big_fset_seq</span><span class="id"> \`|_|</span>)<span class="id"> /=;</span><span class="id"> case:</span><span class="id"> J</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> J</span>.<br/>
<span class="id">move/canonical_uniq=&gt;</span><span class="id"> uqJ</span><span class="id"> lt_jS;</span><span class="id"> pose</span><span class="id"> K</span><span class="id"> :=</span><span class="id"> [seq</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> J</span><span class="id"> |</span><span class="id"> S</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> 0]</span>.<br/>
<span class="id">have</span><span class="id"> [n]:</span><span class="gallina-kwd"> exists</span><span class="id"> n,</span><span class="id"> {subset</span><span class="id"> K</span><span class="id"> &lt;=</span><span class="id"> P</span><span class="id"> n};</span><span class="id"> first</span><span class="id"> rewrite</span><span class="id"> {}/K</span>.<br/>
&nbsp;&nbsp;<span class="id">elim:</span><span class="id"> {uqJ</span><span class="id"> lt_jS}</span><span class="id"> J</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [|x</span><span class="id"> J</span><span class="id"> [n</span><span class="id"> ih]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 0%N</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">S</span><span class="id"> x</span><span class="id"> =P</span><span class="id"> 0</span>)<span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">move/eqP/cover_P=&gt;</span><span class="id"> [k</span><span class="id"> Pk_x];</span><span class="gallina-kwd"> exists</span> (<span class="id">maxn</span><span class="id"> n</span><span class="id"> k</span>)<span class="id">=&gt;</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /orP[/eqP-&gt;|/=]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/fsubsetP/homo_P/leq_maxr:</span><span class="id"> x</span><span class="id"> Pk_x</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/ih;</span><span class="id"> apply/fsubsetP/homo_P/leq_maxl:</span><span class="id"> y</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> le_K_Pn;</span><span class="id"> have:</span><span class="id"> l</span><span class="id"> &lt;</span><span class="id"> v</span><span class="id"> n;</span><span class="id"> first</span><span class="id"> apply/</span>(<span class="id">lt_le_trans</span><span class="id"> lt_jS</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">eq_bigr</span><span class="id"> S</span>)<span class="id"> =&gt;</span><span class="id"> [x</span><span class="id"> _|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ger0_norm</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /v</span> (<span class="id">bigID</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> S</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> 0</span>))<span class="id"> /=</span><span class="id"> big1</span><span class="id"> =&gt;</span><span class="id"> [x</span><span class="id"> /eqP|]</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> add0r</span><span class="id"> -big_filter</span><span class="id"> -/K</span><span class="id"> -big_seq_fset</span><span class="id"> ?filter_uniq</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/big_fset_subset</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> in_fset</span><span class="id"> =&gt;</span><span class="id"> /le_K_Pn</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/negP;</span><span class="id"> rewrite</span><span class="id"> -leNgt</span><span class="id"> -lee_fin</span><span class="id"> ncvg_homo_le</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> PSumAsLim</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> SummableAlg</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">I</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_addrC</span> (<span class="id">S1</span><span class="id"> S2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span> (<span class="id">S1</span><span class="id"> \+</span><span class="id"> S2</span>)<span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="id">S2</span><span class="id"> \+</span><span class="id"> S1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/eq_summable</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> addrC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_mulrC</span> (<span class="id">S1</span><span class="id"> S2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span> (<span class="id">S1</span><span class="id"> \*</span><span class="id"> S2</span>)<span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="id">S2</span><span class="id"> \*</span><span class="id"> S1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/eq_summable</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> mulrC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_abs</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> summable</span><span class="id"> \`|S|</span><span class="id"> &lt;-&gt;</span><span class="id"> summable</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> h</span><span class="id"> J:</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> &lt;-</span><span class="id"> J</span>)<span class="id"> `|</span><span class="id"> `|S</span><span class="id"> j|</span><span class="id"> |</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> &lt;-</span><span class="id"> J</span>)<span class="id"> `|S</span><span class="id"> j|</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eq_bigr=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> normr_id</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> /summable_seqP[M</span><span class="id"> ge0_M</span><span class="id"> leM];</span><span class="id"> apply/summable_seqP;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> M=&gt;</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> J</span><span class="id"> /leM;</span><span class="id"> rewrite</span><span class="id"> h</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable0</span><span class="id"> :</span><span class="id"> summable</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> :</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> 0</span><span class="id"> :</span><span class="id"> R</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 0</span><span class="id"> =&gt;</span><span class="id"> J;</span><span class="id"> rewrite</span><span class="id"> big1</span><span class="id"> ?normr0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summableD</span> (<span class="id">S1</span><span class="id"> S2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> S1</span><span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> S2</span><span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="id">S1</span><span class="id"> \+</span><span class="id"> S2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case=&gt;</span><span class="id"> [M1</span><span class="id"> h1]</span><span class="id"> [M2</span><span class="id"> h2];</span><span class="gallina-kwd"> exists</span> (<span class="id">M1</span><span class="id"> +</span><span class="id"> M2</span>)<span class="id"> =&gt;</span><span class="id"> J</span><span class="id"> /=</span>.<br/>
<span class="id">pose</span><span class="id"> M</span><span class="id"> :=</span><span class="id"> \sum_</span>(<span class="id">x</span><span class="id"> :</span><span class="id"> J</span>) (<span class="id">`|S1</span> (<span class="id">val</span><span class="id"> x</span>)<span class="id">|</span><span class="id"> +</span><span class="id"> `|S2</span> (<span class="id">val</span><span class="id"> x</span>)<span class="id">|</span>).<br/>
<span class="id">rewrite</span> (<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span><span class="id"> M</span>)<span class="id"> //</span><span class="id"> ?ler_sum</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> [K</span><span class="id"> _|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ler_normD</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /M</span><span class="id"> big_split</span><span class="id"> lerD</span><span class="id"> ?</span>(<span class="id">h1,</span><span class="id"> h2</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summableN</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="id">-</span><span class="id"> S</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case=&gt;</span><span class="id"> [M</span><span class="id"> h];</span><span class="gallina-kwd"> exists</span><span class="id"> M</span><span class="id"> =&gt;</span><span class="id"> J;</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">h</span><span class="id"> J</span>))<span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> le_eqVlt;</span><span class="id"> apply/orP;</span><span class="id"> left;</span><span class="id"> apply/eqP/eq_bigr</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /=</span><span class="id"> K</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> normrN</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summablebN</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">`[&lt;</span><span class="id"> summable</span> (<span class="id">-</span><span class="id"> S</span>)<span class="id">&gt;]</span><span class="id"> =</span><span class="id"> `[&lt;</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> &gt;]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/asboolP/asboolP</span><span class="id"> =&gt;</span><span class="id"> /summableN</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_summable</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> opprK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summablebDl</span> (<span class="id">S1</span><span class="id"> S2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> summable</span><span class="id"> S1</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">`[&lt;</span><span class="id"> summable</span> (<span class="id">S1</span><span class="id"> \+</span><span class="id"> S2</span>)<span class="id"> &gt;]</span><span class="id"> =</span><span class="id"> `[&lt;</span><span class="id"> summable</span><span class="id"> S2</span><span class="id"> &gt;]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sm1;</span><span class="id"> apply/asboolP/asboolP;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/</span>(<span class="id">summableD</span><span class="id"> sm1</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> sm12;</span><span class="id"> apply/</span>(<span class="id">@eq_summable</span><span class="id"> _</span><span class="id"> _</span> ((<span class="id">S1</span><span class="id"> \+</span><span class="id"> S2</span>)<span class="id"> \-</span><span class="id"> S1</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> addrC</span><span class="id"> addKr</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/summableD/summableN</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summablebDr</span> (<span class="id">S1</span><span class="id"> S2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> summable</span><span class="id"> S2</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">`[&lt;</span><span class="id"> summable</span> (<span class="id">S1</span><span class="id"> \+</span><span class="id"> S2</span>)<span class="id"> &gt;]</span><span class="id"> =</span><span class="id"> `[&lt;</span><span class="id"> summable</span><span class="id"> S1</span><span class="id"> &gt;]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sm1;</span><span class="id"> rewrite</span> (<span class="id">@eq_summableb</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">S2</span><span class="id"> \+</span><span class="id"> S1</span>))<span class="id"> ?summablebDl</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> addrC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summableZ</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> c</span><span class="id"> :</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="id">c</span><span class="id"> \*o</span><span class="id"> S</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case=&gt;</span><span class="id"> [M</span><span class="id"> h];</span><span class="gallina-kwd"> exists</span> (<span class="id">`|c|</span><span class="id"> *</span><span class="id"> M</span>)<span class="id"> =&gt;</span><span class="id"> J;</span><span class="id"> move/</span>(_<span class="id"> J</span>)<span class="id">:</span><span class="id"> h</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="id">move/</span>(<span class="id">ler_wpM2l</span> (<span class="id">normr_ge0</span><span class="id"> c</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> mulr_sumr</span>.<br/>
<span class="id">move/</span>(<span class="id">le_trans</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply;</span><span class="id"> rewrite</span><span class="id"> le_eqVlt;</span><span class="id"> apply/orP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> left;</span><span class="id"> apply/eqP/eq_bigr=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> normrM</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summableZr</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">c</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="id">c</span><span class="id"> \o*</span><span class="id"> S</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> smS;</span><span class="id"> apply/summable_mulrC/summableZ</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summableMl</span> (<span class="id">S1</span><span class="id"> S2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">exists</span><span class="id"> M,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> `|S1</span><span class="id"> x|</span><span class="id"> &lt;=</span><span class="id"> M</span>)<span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> S2</span><span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="id">S1</span><span class="id"> \*</span><span class="id"> S2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case=&gt;</span><span class="id"> M</span><span class="id"> leM</span><span class="id"> smS2;</span><span class="id"> apply/summable_abs</span>.<br/>
<span class="id">apply/</span>(<span class="id">le_summable</span> (<span class="id">F2</span><span class="id"> :=</span><span class="id"> M</span><span class="id"> \*o</span><span class="id"> \`|S2|</span>)).<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> normr_ge0</span><span class="id"> /=</span><span class="id"> normrM</span><span class="id"> ler_wpM2r</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply/summableZ/summable_abs</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summableMr</span> (<span class="id">S1</span><span class="id"> S2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">exists</span><span class="id"> M,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> `|S2</span><span class="id"> x|</span><span class="id"> &lt;=</span><span class="id"> M</span>)<span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> S1</span><span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="id">S1</span><span class="id"> \*</span><span class="id"> S2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> bd</span><span class="id"> sm;</span><span class="id"> apply/summable_mulrC/summableMl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summableM</span> (<span class="id">S1</span><span class="id"> S2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> S1</span><span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> S2</span><span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="id">S1</span><span class="id"> \*</span><span class="id"> S2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> smS1</span><span class="id"> smS2;</span><span class="id"> apply/summableMl</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span> (<span class="id">psum</span><span class="id"> S1</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> apply/ger1_psum</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_fpos</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="id">fpos</span><span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/summable_abs;</span><span class="id"> apply/le_summable=&gt;</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ge0_fpos</span><span class="id"> /=</span><span class="id"> le_fpos_norm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_fneg</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="id">fneg</span><span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/summableN/summable_fpos/</span>(<span class="id">eq_summable</span> (<span class="id">fposN</span><span class="id"> _</span>)). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_condl</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">P</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> S</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case/summable_seqP=&gt;</span><span class="id"> M</span><span class="id"> ge0_M</span><span class="id"> leM;</span><span class="id"> apply/summable_seqP</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> M</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> move=&gt;</span><span class="id"> J</span><span class="id"> /leM</span><span class="id"> /</span>(<span class="id">le_trans</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply</span>.<br/>
<span class="id">apply/ler_sum=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> case:</span> (<span class="id">P</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> rewrite</span> (<span class="id">mul1r,</span><span class="id"> mul0r</span>)<span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> normr0</span><span class="id"> normr_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_condr</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> S</span><span class="id"> x</span><span class="id"> *</span> (<span class="id">P</span><span class="id"> x</span>)<span class="id">%:R</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /</span>(<span class="id">summable_condl</span><span class="id"> P</span>)<span class="id"> /eq_summable;</span><span class="id"> apply</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> mulrC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_of_bd</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">d</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> J,</span><span class="id"> uniq</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> \sum_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> J</span>)<span class="id"> `|S</span><span class="id"> x|</span><span class="id"> &lt;=</span><span class="id"> d</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">summable</span><span class="id"> S</span><span class="id"> /\</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> &lt;=</span><span class="id"> d</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> leS;</span><span class="id"> have</span><span class="id"> ge0_d:</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> d</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">leS</span><span class="id"> [::]</span><span class="id"> _</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> big_nil</span>.<br/>
<span class="id">have</span><span class="id"> smS:</span><span class="id"> summable</span><span class="id"> S</span><span class="gallina-kwd"> by</span><span class="id"> apply/summable_seqP;</span><span class="gallina-kwd"> exists</span><span class="id"> d</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> /psum</span> (<span class="id">asboolT</span><span class="id"> smS</span>)<span class="id">;</span><span class="id"> apply/sup_le_ub</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> 0,</span><span class="id"> fset0;</span><span class="id"> rewrite</span><span class="id"> big_fset0</span>.<br/>
<span class="id">apply/ubP=&gt;</span><span class="id"> _</span><span class="id"> [J</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span> (<span class="id">big_fset_seq</span><span class="id"> \`|_|</span>)<span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/leS;</span><span class="id"> case:</span><span class="id"> J</span><span class="id"> =&gt;</span><span class="id"> J</span><span class="id"> /=</span><span class="id"> /canonical_uniq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_sum</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> I</span>)<span class="id"> r</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="id">F</span><span class="id"> i</span>))<br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> summable</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> r</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sm_F;</span><span class="id"> elim:</span><span class="id"> r</span><span class="id"> =&gt;</span><span class="id"> [|i</span><span class="id"> r</span><span class="id"> ih]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">eq_summable</span><span class="id"> _</span><span class="id"> summable0</span>)<span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> big_nil</span>.<br/>
<span class="id">pose</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :=</span> (<span class="id">F</span><span class="id"> i</span><span class="id"> x</span>)<span class="id"> *</span> (<span class="id">P</span><span class="id"> i</span>)<span class="id">%:R</span><span class="id"> +</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> r</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> x</span>.<br/>
<span class="id">apply/</span>(<span class="id">eq_summable</span> (<span class="id">S1</span><span class="id"> :=</span><span class="id"> G</span>))<span class="id"> =&gt;</span><span class="id"> [x|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> {}/G</span><span class="id"> big_cons;</span><span class="id"> case:</span><span class="id"> ifP=&gt;</span><span class="id"> Pi;</span><span class="id"> rewrite</span><span class="id"> !Monoid</span>.<span class="id">simpm</span>.<br/>
<span class="id">apply/summableD</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> case/boolP:</span> (<span class="id">P</span><span class="id"> i</span>)<span class="id"> =&gt;</span><span class="id"> [|_]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/sm_F;</span><span class="id"> apply/eq_summable</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">eq_summable</span><span class="id"> _</span><span class="id"> summable0</span>)<span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> SummableAlg</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> StdSum</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">I</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>).<br/>
<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum0</span><span class="id"> :</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> :</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> 0</span>)<span class="id"> =</span><span class="id"> 0</span><span class="id"> :&gt;</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /psum</span><span class="id"> asboolT;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/summable0</span>.<br/>
<span class="id">set</span><span class="id"> S</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> |</span><span class="id"> _]%classic;</span><span class="id"> suff:</span><span class="id"> S</span><span class="id"> =</span> (<span class="id">set1</span><span class="id"> 0</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> sup1</span>.<br/>
<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> big1</span><span class="id"> //</span><span class="id"> normr0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> -&gt;;</span><span class="gallina-kwd"> exists</span><span class="id"> fset0;</span><span class="id"> rewrite</span><span class="id"> big_fset0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum_eq0</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> =</span><span class="id"> 0</span>)<span class="id"> -&gt;</span><span class="id"> psum</span><span class="id"> f</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq;</span><span class="id"> rewrite</span> (<span class="id">eq_psum</span><span class="id"> eq</span>)<span class="id"> psum0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq0_psum</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> psum</span><span class="id"> f</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> =</span><span class="id"> 0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sm</span><span class="id"> psum_eq0</span><span class="id"> x;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -normr_eq0</span>.<br/>
<span class="id">rewrite</span><span class="id"> eq_le</span><span class="id"> normr_ge0</span><span class="id"> andbT</span><span class="id"> -psum_eq0</span>.<br/>
<span class="id">apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">gerfinseq_psum</span> (<span class="id">r</span><span class="id"> :=</span><span class="id"> [::</span><span class="id"> x]</span>)<span class="id"> _</span><span class="id"> sm</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_seq1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> neq0_psum</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> psum</span><span class="id"> f</span><span class="id"> &lt;&gt;</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> &lt;&gt;</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> nz_psum;</span><span class="id"> apply/existsp_asboolPn/asboolPn</span><span class="id"> =&gt;</span><span class="id"> /psum_eq0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum_abs</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> psum</span><span class="id"> \`|S|</span><span class="id"> =</span><span class="id"> psum</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /psum;</span><span class="id"> do</span><span class="id"> 2!</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move/asboolP/summable_abs/asboolP=&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move/asboolPn/summable_abs/asboolPn=&gt;</span><span class="id"> /negbTE-&gt;</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> congr</span><span class="id"> sup;</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> J</span><span class="id"> -&gt;;</span><span class="gallina-kwd"> exists</span><span class="id"> J</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_bigr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> normr_id</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> J</span><span class="id"> -&gt;;</span><span class="gallina-kwd"> exists</span><span class="id"> J</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> [in</span><span class="id"> RHS]eq_bigr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> normr_id</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_psum_abs</span> (<span class="id">S1</span><span class="id"> S2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\`|S1|</span><span class="id"> =1</span><span class="id"> \`|S2|</span><span class="id"> -&gt;</span><span class="id"> psum</span><span class="id"> S1</span><span class="id"> =</span><span class="id"> psum</span><span class="id"> S2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> eqS;</span><span class="id"> rewrite</span><span class="id"> -[LHS]psum_abs</span><span class="id"> -[RHS]psum_abs;</span><span class="id"> apply/eq_psum</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_psum_abs</span> (<span class="id">S1</span><span class="id"> S2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> `|S1</span><span class="id"> x|</span><span class="id"> &lt;=</span><span class="id"> `|S2</span><span class="id"> x|</span>)<span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> S2</span><span class="id"> -&gt;</span><span class="id"> psum</span><span class="id"> S1</span><span class="id"> &lt;=</span><span class="id"> psum</span><span class="id"> S2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> leS</span><span class="id"> smS2;</span><span class="id"> rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> X&lt;=_]psum_abs</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> _&lt;=X]psum_abs</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/le_psum/summable_abs</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> normr_ge0</span><span class="id"> leS</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_psum_condl</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">P</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> S</span><span class="id"> x</span>)<span class="id"> &lt;=</span><span class="id"> psum</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> smS;</span><span class="id"> apply/le_psum_abs=&gt;</span><span class="id"> //</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> normrM</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/ler_piMl</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> normr_nat</span><span class="id"> lern1</span><span class="id"> leq_b1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_psum_condr</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> S</span><span class="id"> x</span><span class="id"> *</span> (<span class="id">P</span><span class="id"> x</span>)<span class="id">%:R</span>)<span class="id"> &lt;=</span><span class="id"> psum</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> smS;</span><span class="id"> apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">le_psum_condl</span><span class="id"> P</span><span class="id"> smS</span>)).<br/>
<span class="id">rewrite</span><span class="id"> le_eqVlt</span><span class="id"> -</span>(<span class="id">rwP</span><span class="id"> orP</span>)<span class="id">;</span><span class="id"> left;</span><span class="id"> apply/eqP/eq_psum</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> mulrC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psumN</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> psum</span> (<span class="id">-</span><span class="id"> S</span>)<span class="id"> =</span><span class="id"> psum</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case/boolP:</span><span class="id"> `[&lt;</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> &gt;]</span><span class="id"> =&gt;</span><span class="id"> h;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !psum_out</span><span class="id"> ?oppr0</span><span class="id"> //;</span><span class="id"> apply/asboolPn;</span><span class="id"> rewrite</span><span class="id"> ?summablebN</span>.<br/>
<span class="id">rewrite</span><span class="id"> /psum</span><span class="id"> summablebN</span><span class="id"> h;</span><span class="id"> apply/eq_ppsum=&gt;</span><span class="id"> J</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_bigr=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> normrN</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psumD</span><span class="id"> S1</span><span class="id"> S2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> S1</span><span class="id"> x</span>)<span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> S2</span><span class="id"> x</span>)<br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> summable</span><span class="id"> S1</span><span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> S2</span><br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> psum</span> (<span class="id">S1</span><span class="id"> \+</span><span class="id"> S2</span>)<span class="id"> =</span> (<span class="id">psum</span><span class="id"> S1</span><span class="id"> +</span><span class="id"> psum</span><span class="id"> S2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ge0_S1</span><span class="id"> ge0_S2</span><span class="id"> smS1</span><span class="id"> smS2;</span><span class="id"> have</span><span class="id"> smD</span><span class="id"> :=</span><span class="id"> summableD</span><span class="id"> smS1</span><span class="id"> smS2</span>.<br/>
<span class="id">have</span><span class="id"> ge0D:</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> S1</span><span class="id"> x</span><span class="id"> +</span><span class="id"> S2</span><span class="id"> x</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> addr_ge0</span>.<br/>
<span class="id">rewrite</span><span class="id"> !psumE</span><span class="id"> //</span> (<span class="id">rwP</span><span class="id"> eqP</span>)<span class="id"> eq_le</span><span class="id"> -</span>(<span class="id">rwP</span><span class="id"> andP</span>)<span class="id">;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/sup_le_ub</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 0,</span><span class="id"> fset0;</span><span class="id"> rewrite</span><span class="id"> big_fset0</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/ubP=&gt;</span><span class="id"> _</span><span class="id"> [J</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> big_split</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/lerD;</span><span class="id"> rewrite</span><span class="id"> -psumE</span><span class="id"> 1?</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">gerfin_psum</span><span class="id"> J</span><span class="id"> _</span>))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply/ler_sum=&gt;</span><span class="id"> j</span><span class="id"> _</span><span class="id"> /=;</span><span class="id"> apply/ler_norm</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply/ler_sum=&gt;</span><span class="id"> j</span><span class="id"> _</span><span class="id"> /=;</span><span class="id"> apply/ler_norm</span>.<br/>
<span class="id">rewrite</span><span class="id"> -lerBrDr;</span><span class="id"> apply/sup_le_ub</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 0,</span><span class="id"> fset0;</span><span class="id"> rewrite</span><span class="id"> big_fset0</span>.<br/>
<span class="id">apply/ubP=&gt;</span><span class="id"> _</span><span class="id"> [J1</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> lerBrDr</span><span class="id"> addrC</span>.<br/>
<span class="id">rewrite</span><span class="id"> -lerBrDr;</span><span class="id"> apply/sup_le_ub</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 0,</span><span class="id"> fset0;</span><span class="id"> rewrite</span><span class="id"> big_fset0</span>.<br/>
<span class="id">apply/ubP=&gt;</span><span class="id"> _</span><span class="id"> [J2</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> lerBrDr</span><span class="id"> addrC</span>.<br/>
<span class="id">pose</span><span class="id"> J</span><span class="id"> :=</span><span class="id"> J1</span><span class="id"> `|`</span><span class="id"> J2;</span><span class="id"> rewrite</span><span class="id"> -psumE</span><span class="id"> ?</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">gerfin_psum</span><span class="id"> J</span><span class="id"> _</span>))<span class="id"> //</span>.<br/>
<span class="id">pose</span><span class="id"> D</span><span class="id"> :=</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> :</span><span class="id"> J</span>) (<span class="id">S1</span> (<span class="id">val</span><span class="id"> j</span>)<span class="id"> +</span><span class="id"> S2</span> (<span class="id">val</span><span class="id"> j</span>)).<br/>
<span class="id">apply/</span>(<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span><span class="id"> D</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/ler_sum=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> apply/ler_norm</span>.<br/>
<span class="id">rewrite</span><span class="id"> /D</span><span class="id"> big_split</span><span class="id"> /=;</span><span class="id"> apply/lerD;</span><span class="id"> apply/big_fset_subset=&gt;</span><span class="id"> //</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply/fsubsetP/fsubsetUl</span>.<span class="id"> +</span><span class="gallina-kwd"> by</span><span class="id"> apply/fsubsetP/fsubsetUr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __admitted__psumB</span><span class="id"> S1</span><span class="id"> S2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> S2</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> S1</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> S1</span><br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> psum</span> (<span class="id">S1</span><span class="id"> \-</span><span class="id"> S2</span>)<span class="id"> =</span> (<span class="id">psum</span><span class="id"> S1</span><span class="id"> -</span><span class="id"> psum</span><span class="id"> S2</span>).<br/>
<span class="vernacular">Proof</span><span class="gallina-kwd"> using</span><span class="gallina-kwd"> Type</span>.<br/>
<span class="vernacular">Lemma</span><span class="id"> psumZ</span><span class="id"> S</span><span class="id"> c</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> c</span><span class="id"> -&gt;</span><span class="id"> psum</span> (<span class="id">c</span><span class="id"> \*o</span><span class="id"> S</span>)<span class="id"> =</span><span class="id"> c</span><span class="id"> *</span><span class="id"> psum</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> le_eqVlt</span><span class="id"> =&gt;</span><span class="id"> /orP[/eqP&lt;-|gt0_c]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mul0r</span><span class="id"> psum_eq0</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> mul0r</span>.<br/>
<span class="id">case/asboolP:</span> (<span class="id">summable</span><span class="id"> S</span>)<span class="id"> =&gt;</span><span class="id"> [smS|NsmS];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !psum_out</span><span class="id"> ?mulr0</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> smZ;</span><span class="id"> apply/NsmS</span>.<br/>
&nbsp;&nbsp;<span class="id">move/</span>(<span class="id">summableZ</span><span class="id"> c^-1</span>)<span class="id">:</span><span class="id"> smZ;</span><span class="id"> apply/eq_summable=&gt;</span><span class="id"> x</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulKf</span><span class="id"> //</span><span class="id"> gt_eqF</span>.<br/>
<span class="id">have</span><span class="id"> smZ</span><span class="id"> :=</span><span class="id"> summableZ</span><span class="id"> c</span><span class="id"> smS;</span><span class="id"> rewrite</span> (<span class="id">rwP</span><span class="id"> eqP</span>)<span class="id"> eq_le</span>.<br/>
<span class="id">apply/andP;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> rewrite</span><span class="id"> {1}/psum</span><span class="id"> asboolT</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/sup_le_ub</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 0,</span><span class="id"> fset0;</span><span class="id"> rewrite</span><span class="id"> big_fset0</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/ubP=&gt;</span><span class="id"> _</span><span class="id"> [J</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> -ler_pdivrMl</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mulr_sumr</span> (<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">gerfin_psum</span><span class="id"> J</span><span class="id"> _</span>))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/ler_sum=&gt;</span><span class="id"> /=</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> normrM</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> gtr0_norm</span><span class="id"> //</span><span class="id"> mulKf</span><span class="id"> ?gt_eqF</span>.<br/>
<span class="id">rewrite</span><span class="id"> -ler_pdivlMl</span><span class="id"> //</span><span class="id"> {1}/psum</span><span class="id"> asboolT</span><span class="id"> //;</span><span class="id"> apply/sup_le_ub</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 0,</span><span class="id"> fset0;</span><span class="id"> rewrite</span><span class="id"> big_fset0</span>.<br/>
<span class="id">apply/ubP=&gt;</span><span class="id"> _</span><span class="id"> [J</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> ler_pdivlMl</span><span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> mulr_sumr;</span><span class="id"> apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">gerfin_psum</span><span class="id"> J</span><span class="id"> _</span>))<span class="id">=&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/ler_sum=&gt;</span><span class="id"> /=</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> normrM</span> (<span class="id">gtr0_norm</span><span class="id"> gt0_c</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psumZr</span><span class="id"> S</span><span class="id"> c</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> c</span><span class="id"> -&gt;</span><span class="id"> psum</span> (<span class="id">c</span><span class="id"> \o*</span><span class="id"> S</span>)<span class="id"> =</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> *</span><span class="id"> c</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ge0_c;</span><span class="id"> rewrite</span><span class="id"> [RHS]mulrC</span><span class="id"> -psumZ</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_psum</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> mulrC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum_bigop</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> P</span><span class="id"> r</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> F</span><span class="id"> i</span><span class="id"> x</span>)<span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> summable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> r</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> psum</span> (<span class="id">F</span><span class="id"> i</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> r</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ge0_F</span><span class="id"> sm_F;</span><span class="id"> elim:</span><span class="id"> r</span><span class="id"> =&gt;</span><span class="id"> [|i</span><span class="id"> r</span><span class="id"> ih]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_nil;</span><span class="id"> apply/esym/psum_eq0</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> big_nil</span>.<br/>
<span class="id">rewrite</span><span class="id"> big_cons</span><span class="id"> ih;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> Pi;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eq_psum=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> big_cons</span><span class="id"> Pi</span>.<br/>
<span class="id">rewrite</span><span class="id"> -psumD</span><span class="id"> //;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> apply/sumr_ge0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/summable_sum</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_psum=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> big_cons</span><span class="id"> Pi</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psumID</span><span class="id"> S</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">P</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> S</span><span class="id"> x</span>)<span class="id"> +</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">~~P</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> S</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> h</span><span class="id"> x:</span><span class="id"> `|S</span><span class="id"> x|</span><span class="id"> =</span> (<span class="id">P</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> `|S</span><span class="id"> x|</span><span class="id"> +</span> (<span class="id">~~P</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> `|S</span><span class="id"> x|</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">P</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !Monoid</span>.<span class="id">simpm</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> smS;</span><span class="id"> rewrite</span><span class="id"> -[LHS]psum_abs</span> (<span class="id">eq_psum</span><span class="id"> h</span>)<span class="id"> psumD</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span>.<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/summable_condl/summable_abs</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/summable_condl/summable_abs</span>.<br/>
<span class="id">congr</span> (_<span class="id"> +</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply/eq_psum_abs=&gt;</span><span class="id"> x</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !normrM</span><span class="id"> normr_nat</span><span class="id"> normr_id</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !normrM</span><span class="id"> normr_nat</span><span class="id"> normr_id</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum_finseq</span><span class="id"> S</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> seq</span>.<span class="id">seq</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> S</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> 0]</span><span class="id"> &lt;=</span><span class="id"> r}</span><br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> r</span>)<span class="id"> `|S</span><span class="id"> x|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_r</span><span class="id"> ler;</span><span class="id"> set</span><span class="id"> s</span><span class="id"> :=</span><span class="id"> RHS;</span><span class="id"> have</span><span class="id"> h</span><span class="id"> J:</span><span class="id"> uniq</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> \sum_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> J</span>)<span class="id"> `|S</span><span class="id"> x|</span><span class="id"> &lt;=</span><span class="id"> s</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> uqJ;</span><span class="id"> rewrite</span> (<span class="id">bigID</span> (<span class="id">ssrbool</span>.<span class="id">mem</span><span class="id"> r</span>))<span class="id"> /=</span><span class="id"> addrC</span><span class="id"> big1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> xNr;</span><span class="id"> apply/eqP;</span><span class="id"> apply/contraR:</span><span class="id"> xNr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> normr_eq0</span><span class="id"> =&gt;</span><span class="id"> /ler</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> add0r</span><span class="id"> {}/s</span><span class="id"> -big_filter;</span><span class="id"> set</span><span class="id"> s</span><span class="id"> :=</span><span class="id"> seq</span>.<span class="id">filter</span><span class="id"> _</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _&lt;=X]</span>(<span class="id">bigID</span> (<span class="id">ssrbool</span>.<span class="id">mem</span><span class="id"> J</span>))<span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">perm_big</span><span class="id"> [seq</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> r</span><span class="id"> |</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> J]</span>)<span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/uniq_perm;</span><span class="id"> rewrite</span><span class="id"> ?filter_uniq</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !mem_filter</span><span class="id"> andbC</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_filter</span><span class="id"> lerDl</span><span class="id"> sumr_ge0</span>.<br/>
<span class="id">case/summable_of_bd:</span><span class="id"> h</span><span class="id"> =&gt;</span><span class="id"> smS</span><span class="id"> le_psum;</span><span class="id"> apply/eqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eq_le</span><span class="id"> le_psum</span><span class="id"> /=;</span><span class="id"> apply/gerfinseq_psum</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> StdSum</span>.<br/>
<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;lacks proof, use __admitted__psumB explicitly if you really want to&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> psumB</span><span class="id"> :=</span><span class="id"> __admitted__psumB</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PSumReindex</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> choiceType}</span>.<br/>
<span class="vernacular">Context</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>) (<span class="id">h</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> T</span>).<br/>
<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> reindex_psum_onto</span><span class="id"> h'</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> S</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> P</span>)<br/>
&nbsp;&nbsp;<span class="id">-&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> omap</span><span class="id"> h</span> (<span class="id">h'</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> Some</span><span class="id"> i</span>)<br/>
&nbsp;&nbsp;<span class="id">-&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> h</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> h'</span> (<span class="id">h</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> Some</span><span class="id"> i</span>)<br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> =</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> :</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> S</span> (<span class="id">h</span><span class="id"> x</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> PS</span><span class="id"> hO</span><span class="id"> hP;</span><span class="id"> rewrite</span><span class="id"> !psum_sup_seq;</span><span class="id"> congr</span><span class="id"> sup;</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> -[J</span><span class="id"> uqJ</span><span class="id"> -&gt;]</span><span class="id"> {x};</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> [seq</span><span class="id"> h</span><span class="id"> j</span><span class="id"> |</span><span class="id"> j</span><span class="id"> &lt;-</span><span class="id"> J</span><span class="id"> &amp;</span><span class="id"> S</span> (<span class="id">h</span><span class="id"> j</span>)<span class="id"> !=</span><span class="id"> 0]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> map_inj_in_uniq</span><span class="id"> ?filter_uniq</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> y1</span><span class="id"> y2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !mem_filter</span><span class="id"> =&gt;</span><span class="id"> /andP[nz_S1</span><span class="id"> _]</span><span class="id"> /andP[nz_S2</span><span class="id"> _]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/</span>(<span class="id">congr1</span><span class="id"> h'</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !hP</span><span class="id"> ?PS</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> -[]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> big_map</span><span class="id"> big_filter</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">bigID</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> S</span> (<span class="id">h</span><span class="id"> i</span>)<span class="id"> ==</span><span class="id"> 0</span>))<span class="id"> /=</span><span class="id"> big1</span><span class="id"> ?add0r</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> /eqP-&gt;;</span><span class="id"> rewrite</span><span class="id"> normr0</span>.<br/>
<span class="id">have</span><span class="id"> uqpJ:</span><span class="id"> uniq</span> (<span class="id">pmap</span><span class="id"> h'</span><span class="id"> [seq</span><span class="id"> j</span><span class="id"> |</span><span class="id"> j</span><span class="id"> &lt;-</span><span class="id"> J</span><span class="id"> &amp;</span><span class="id"> S</span><span class="id"> j</span><span class="id"> !=</span><span class="id"> 0]</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/</span>(<span class="id">map_uniq</span> (<span class="id">f</span><span class="id"> :=</span><span class="id"> some</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> pmapS_filter</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> map_inj_in_uniq</span><span class="id"> ?filter_uniq</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> [y1</span><span class="id"> y2|];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> map_id</span><span class="id"> filter_uniq</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !map_id</span><span class="id"> !mem_filter</span><span class="id"> =&gt;</span><span class="id"> /andP[h'1</span><span class="id"> h1]</span><span class="id"> /andP[h'2</span><span class="id"> h2]</span>.<br/>
&nbsp;&nbsp;<span class="id">case/andP:</span><span class="id"> h1</span><span class="id"> =&gt;</span><span class="id"> h1</span><span class="id"> _;</span><span class="id"> case/andP:</span><span class="id"> h2</span><span class="id"> =&gt;</span><span class="id"> h2</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/</span>(<span class="id">congr1</span> (<span class="id">omap</span><span class="id"> h</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !hO</span><span class="id"> ?PS</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> -[]</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">pmap</span><span class="id"> h'</span><span class="id"> [seq</span><span class="id"> j</span><span class="id"> |</span><span class="id"> j</span><span class="id"> &lt;-</span><span class="id"> J</span><span class="id"> &amp;</span><span class="id"> S</span><span class="id"> j</span><span class="id"> !=</span><span class="id"> 0]</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">big_map</span><span class="id"> h</span><span class="id"> predT</span><span class="id"> \`|S|</span>) (<span class="id">bigID</span><span class="id"> [pred</span><span class="id"> j</span><span class="id"> |</span><span class="id"> S</span><span class="id"> j</span><span class="id"> ==</span><span class="id"> 0]</span>)<span class="id"> /=</span>.<br/>
<span class="id">rewrite</span><span class="id"> big1</span><span class="id"> ?add0r</span><span class="id"> =&gt;</span><span class="id"> [i</span><span class="id"> /eqP-&gt;|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> normr0</span>.<br/>
<span class="id">rewrite</span><span class="id"> -big_filter;</span><span class="id"> apply/eqP;</span><span class="id"> apply/perm_big/uniq_perm</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> filter_uniq</span>.<br/>
<span class="id">+</span><span class="id"> rewrite</span><span class="id"> map_inj_in_uniq</span><span class="id"> //</span><span class="id"> !map_id</span><span class="id"> =&gt;</span><span class="id"> y1</span><span class="id"> y2</span><span class="id"> h1</span><span class="id"> h2</span>.<br/>
&nbsp;&nbsp;<span class="id">move/</span>(<span class="id">congr1</span><span class="id"> h'</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !hP</span><span class="id"> ?PS</span><span class="id"> //;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> case</span>.<br/>
&nbsp;&nbsp;<span class="id">*</span><span class="id"> move:</span><span class="id"> h1;</span><span class="id"> rewrite</span><span class="id"> mem_pmap</span><span class="id"> =&gt;</span><span class="id"> /mapP[x1]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mem_filter</span><span class="id"> =&gt;</span><span class="id"> /andP[nz_Sx1</span><span class="id"> _]</span><span class="id"> /</span>(<span class="id">congr1</span> (<span class="id">omap</span><span class="id"> h</span>))<span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> hO</span><span class="id"> ?PS</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> -[-&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="id">*</span><span class="id"> move:</span><span class="id"> h2;</span><span class="id"> rewrite</span><span class="id"> mem_pmap</span><span class="id"> =&gt;</span><span class="id"> /mapP[x2]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mem_filter</span><span class="id"> =&gt;</span><span class="id"> /andP[nz_Sx2</span><span class="id"> _]</span><span class="id"> /</span>(<span class="id">congr1</span> (<span class="id">omap</span><span class="id"> h</span>))<span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> hO</span><span class="id"> ?PS</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> -[-&gt;]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !mem_filter;</span><span class="id"> apply/andP/idP</span>.<br/>
<span class="id">+</span><span class="id"> case=&gt;</span><span class="id"> nzSx</span><span class="id"> Jx;</span><span class="id"> apply/mapP;</span><span class="id"> move/</span>(_<span class="id"> x</span> (<span class="id">PS</span><span class="id"> _</span><span class="id"> nzSx</span>))<span class="id">:</span><span class="id"> hO</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> E:</span> (<span class="id">h'</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> [u|]</span><span class="id"> //=</span><span class="id"> -[xE];</span><span class="gallina-kwd"> exists</span><span class="id"> u</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mem_pmap;</span><span class="id"> apply/mapP;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> map_id</span><span class="id"> mem_filter</span><span class="id"> nzSx</span>.<br/>
<span class="id">+</span><span class="id"> case/mapP=&gt;</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> mem_pmap</span><span class="id"> =&gt;</span><span class="id"> /mapP[t];</span><span class="id"> rewrite</span><span class="id"> map_id</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mem_filter=&gt;</span><span class="id"> /andP[h1</span><span class="id"> h2]</span><span class="id"> /</span>(<span class="id">congr1</span> (<span class="id">omap</span><span class="id"> h</span>))<span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> hO</span><span class="id"> ?PS</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> -[-&gt;]</span><span class="id"> -&gt;;</span><span class="id"> split</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> reindex_psum</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> S</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> P</span>)<br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> {on</span><span class="id"> P,</span><span class="id"> bijective</span><span class="id"> h}</span><br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> =</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> :</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> S</span> (<span class="id">h</span><span class="id"> x</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> hP</span><span class="id"> [hI</span><span class="id"> h1</span><span class="id"> h2];</span><span class="id"> apply/</span>(<span class="id">@reindex_psum_onto</span> (<span class="id">some</span><span class="id"> \o</span><span class="id"> hI</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> Px</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> h2</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> Px</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> h1</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> PSumReindex</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PSumPartition</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> C</span><span class="id"> y</span><span class="id"> :=</span><span class="id"> `[&lt;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> y</span><span class="id"> &gt;]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> partition_psum</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">psum</span><span class="id"> S</span><span class="id"> =</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> S</span><span class="id"> x</span><span class="id"> *</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id">%:R</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
                          <span class="comment">(*&nbsp;FIXME:&nbsp;this&nbsp;proof&nbsp;is&nbsp;a&nbsp;joke&nbsp;*)</span><br/>
<span class="id">move=&gt;</span><span class="id"> smS;</span><span class="id"> rewrite</span> (<span class="id">rwP</span><span class="id"> eqP</span>)<span class="id"> eq_le</span><span class="id"> -</span>(<span class="id">rwP</span><span class="id"> andP</span>)<span class="id">;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> F</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :=</span><span class="id"> `|S</span><span class="id"> x|</span><span class="id"> *</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> y</span><span class="id"> :&gt;</span><span class="id"> U</span>)<span class="id">%:R</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> smFy</span><span class="id"> y:</span><span class="id"> summable</span> (<span class="id">F^~</span><span class="id"> y</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/summable_condr/summable_abs</span>.<br/>
&nbsp;&nbsp;<span class="id">set</span><span class="id"> G</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> y</span><span class="id"> :</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> _;</span><span class="id"> have:</span><span class="id"> summable</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case/summable_seqP:</span><span class="id"> smS</span><span class="id"> =&gt;</span><span class="id"> M</span><span class="id"> ge0_M</span><span class="id"> leM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/summable_seqP;</span><span class="gallina-kwd"> exists</span><span class="id"> M</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> J</span><span class="id"> uqJ;</span><span class="id"> rewrite</span><span class="id"> {}/G</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">eq_bigr</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> psum</span> (<span class="id">F^~</span><span class="id"> y</span>)))<span class="id"> =&gt;</span><span class="id"> [y</span><span class="id"> _|]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ger0_norm</span><span class="id"> ?ge0_psum</span><span class="id"> //;</span><span class="id"> apply/eq_psum_abs</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !normrM</span><span class="id"> [</span><span class="id"> `|_%:R|]ger0_norm</span><span class="id"> ?</span>(<span class="id">normr_id,</span><span class="id"> ler0n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> psum_bigop</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> [y</span><span class="id"> x|]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> ?</span>(<span class="id">normr_ge0,</span><span class="id"> ler0n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/psum_le=&gt;</span><span class="id"> L</span><span class="id"> uqL;</span><span class="id"> pose</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> &lt;-</span><span class="id"> J</span><span class="id"> |</span><span class="id"> f</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> j</span>)<span class="id"> `|S</span><span class="id"> x|</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">eq_bigr</span><span class="id"> G</span>)<span class="id"> =&gt;</span><span class="id"> [x</span><span class="id"> _|];</span><span class="id"> first</span><span class="id"> rewrite</span><span class="id"> ger0_norm</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> sumr_ge0</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="id"> rewrite</span><span class="id"> /G</span><span class="id"> [RHS]big_mkcond</span><span class="id"> /F</span><span class="id"> /=;</span><span class="id"> apply/eq_bigr=&gt;</span><span class="id"> y</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> !simpm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> {}/G</span><span class="id"> /F;</span><span class="id"> pose</span><span class="id"> K</span><span class="id"> :=</span><span class="id"> [seq</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> L</span><span class="id"> |</span><span class="id"> f</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> J]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">leM</span><span class="id"> K</span><span class="id"> _</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?filter_uniq</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> le_eqVlt</span><span class="id"> -</span>(<span class="id">rwP</span><span class="id"> orP</span>)<span class="id">;</span><span class="id"> left;</span><span class="id"> apply/eqP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /K</span><span class="id"> big_filter</span><span class="id"> [RHS]big_mkcond</span><span class="id"> /=;</span><span class="id"> apply/eq_bigr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> [fxJ|fxNJ]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> big_mkcond</span> (<span class="id">bigD1_seq</span><span class="id"> _</span><span class="id"> fxJ</span><span class="id"> uqJ</span>)<span class="id"> /=</span><span class="id"> eqxx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big1</span><span class="id"> ?addr0</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> =&gt;</span><span class="id"> /negbTE=&gt;</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> big_seq_cond</span><span class="id"> big1</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> andbC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/andP=&gt;</span><span class="id"> /eqP&lt;-;</span><span class="id"> rewrite</span> (<span class="id">negbTE</span><span class="id"> fxNJ</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> smG;</span><span class="id"> apply/psum_le</span><span class="id"> =&gt;</span><span class="id"> J</span><span class="id"> uqJ;</span><span class="id"> pose</span><span class="id"> K</span><span class="id"> :=</span><span class="id"> undup</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> J</span>).<br/>
&nbsp;&nbsp;<span class="id">move/gerfinseq_psum:</span><span class="id"> smG</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> K</span> (<span class="id">undup_uniq</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;<span class="id">move/</span>(<span class="id">le_trans</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply;</span><span class="id"> rewrite</span><span class="id"> {}/G</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> G</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :=</span><span class="id"> `|S</span><span class="id"> x|</span><span class="id"> *</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id">%:R</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">eq_bigr</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> psum</span> (<span class="id">G^~</span><span class="id"> y</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> y</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> ger0_norm</span><span class="id"> ?ge0_psum</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -psum_abs;</span><span class="id"> apply/eq_psum=&gt;</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> normrM</span><span class="id"> [</span><span class="id"> `|_%:R|]ger0_norm</span><span class="id"> ?ler0n</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> psum_bigop</span><span class="id"> =&gt;</span><span class="id"> [y</span><span class="id"> x|y|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/summable_condr/summable_abs</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">eq_psum</span> (<span class="id">F2</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> `|S</span><span class="id"> x</span><span class="id"> *</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> K</span>)<span class="id">%:R|</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> {}/G</span><span class="id"> normrM</span>. <span class="comment">(*[&nbsp;`|_%:R|]ger0_norm&nbsp;//.*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case/boolP:</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> K</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> fxNK</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [</span><span class="id"> `|_%:R|]ger0_norm</span><span class="id"> //</span><span class="id"> mulr0</span><span class="id"> big_seq</span><span class="id"> big1</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/contraTeq;</span><span class="id"> rewrite</span><span class="id"> mulf_eq0</span><span class="id"> pnatr_eq0</span><span class="id"> eqb0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> negb_or</span><span class="id"> negbK</span><span class="id"> =&gt;</span><span class="id"> /andP[_</span><span class="id"> /eqP&lt;-]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> fxK;</span><span class="id"> rewrite</span> (<span class="id">bigD1_seq</span> (<span class="id">f</span><span class="id"> x</span>))<span class="id"> ?undup_uniq</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [</span><span class="id"> `|_%:R|]ger0_norm</span><span class="id"> //</span><span class="id"> ?ler01</span><span class="id"> //</span><span class="id"> eqxx</span><span class="id"> !mulr1</span><span class="id"> big1</span><span class="id"> ?addr0</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/negbTE=&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> mulr0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> big_seq</span> (<span class="id">eq_bigr</span> (<span class="gallina-kwd">fun</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> `|S</span><span class="id"> j</span><span class="id"> *</span> (<span class="id">f</span><span class="id"> j</span><span class="id"> \in</span><span class="id"> K</span>)<span class="id">%:R|</span>))<span class="id"> {}/G</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> /</span>(<span class="id">map_f</span><span class="id"> f</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -mem_undup</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> mulr1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> psum_abs;</span><span class="id"> set</span><span class="id"> G</span><span class="id"> :=</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="gallina-kwd"> in</span><span class="id"> _&lt;=X</span>).<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> summable</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> apply/summable_condr</span>.<br/>
&nbsp;&nbsp;<span class="id">move/gerfinseq_psum</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> uqJ</span>)<span class="id"> /</span>(<span class="id">le_trans</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -big_seq;</span><span class="id"> apply/ler_sum</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> normrM</span>.<br/>
<span class="id">apply/psum_le=&gt;</span><span class="id"> J</span><span class="id"> uqJ;</span><span class="id"> pose</span><span class="id"> F</span><span class="id"> j</span><span class="id"> :=</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> `|S</span><span class="id"> x|</span><span class="id"> *</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> j</span>)<span class="id">%:R</span>).<br/>
<span class="id">rewrite</span> (<span class="id">eq_bigr</span><span class="id"> F</span>)<span class="id"> =&gt;</span><span class="id"> [y</span><span class="id"> _|];</span><span class="id"> first</span><span class="id"> rewrite</span><span class="id"> ger0_norm</span><span class="id"> ?ge0_psum</span><span class="id"> //</span>.<br/>
<span class="id">+</span><span class="id"> rewrite</span><span class="id"> -psum_abs;</span><span class="id"> apply/eq_psum</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> normrM</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [</span><span class="id"> `|_%:R|]ger0_norm</span><span class="id"> ?ler0n</span>.<br/>
<span class="id">rewrite</span><span class="id"> psum_bigop</span><span class="id"> =&gt;</span><span class="id"> [y</span><span class="id"> x|y|]</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> ?</span>(<span class="id">normr_ge0,</span><span class="id"> ler0n</span>).<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply/summable_condr/summable_abs</span>.<br/>
<span class="id">apply/psum_le=&gt;</span><span class="id"> L</span><span class="id"> uqL;</span><span class="id"> pose</span><span class="id"> K</span><span class="id"> :=</span><span class="id"> [seq</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> L</span><span class="id"> |</span><span class="id"> f</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> J]</span>.<br/>
<span class="id">have</span><span class="id"> /gerfinseq_psum:</span><span class="id"> uniq</span><span class="id"> K</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> filter_uniq</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> _</span><span class="id"> smS</span>)<span class="id"> /</span>(<span class="id">le_trans</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply;</span><span class="id"> rewrite</span><span class="id"> big_filter</span>.<br/>
<span class="id">rewrite</span><span class="id"> le_eqVlt</span><span class="id"> -</span>(<span class="id">rwP</span><span class="id"> orP</span>)<span class="id">;</span><span class="id"> left;</span><span class="id"> apply/eqP</span>.<br/>
<span class="id">rewrite</span><span class="id"> [RHS]big_mkcond</span><span class="id"> /=;</span><span class="id"> apply/eq_bigr=&gt;</span><span class="id"> x</span><span class="id"> _</span>.<br/>
<span class="id">rewrite</span><span class="id"> big_seq;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> [fx_in_J|fx_Nin_J]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -big_seq</span> (<span class="id">bigD1_seq</span><span class="id"> _</span><span class="id"> fx_in_J</span><span class="id"> uqJ</span>)<span class="id"> /=</span><span class="id"> eqxx</span><span class="id"> mulr1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> big1</span><span class="id"> ?addr0</span><span class="id"> ?normr_id</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/negbTE=&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> mulr0</span>.<br/>
<span class="id">rewrite</span><span class="id"> big1</span><span class="id"> ?normr0</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> y;</span><span class="id"> apply/contraTeq</span>.<br/>
<span class="id">rewrite</span><span class="id"> mulf_eq0</span><span class="id"> pnatr_eq0</span><span class="id"> eqb0</span><span class="id"> negb_or</span><span class="id"> negbK</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case/andP</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /eqP&lt;-</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> partition_psum_cond</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">psum</span><span class="id"> S</span><span class="id"> =</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span> (<span class="id">C</span><span class="id"> y</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> S</span><span class="id"> x</span><span class="id"> *</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id">%:R</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> smS;</span><span class="id"> apply/</span>(<span class="id">eq_trans</span> (<span class="id">partition_psum</span><span class="id"> smS</span>)).<br/>
<span class="id">apply/eq_psum</span><span class="id"> =&gt;</span><span class="id"> y;</span><span class="id"> case/boolP:</span> (<span class="id">C</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !simpm</span><span class="id"> //</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> NCy;</span><span class="id"> rewrite</span><span class="id"> psum_eq0</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> case:</span> (_<span class="id"> =P</span><span class="id"> y</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/eqP=&gt;</span><span class="id"> fxE;</span><span class="id"> move/asboolP:</span><span class="id"> NCy;</span><span class="id"> case;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulr0</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> PSumPartition</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PSumPair</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> choiceType}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum_pair</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> *</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">psum</span><span class="id"> S</span><span class="id"> =</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> S</span> (<span class="id">x,</span><span class="id"> y</span>))).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sblS;</span><span class="id"> rewrite</span> (<span class="id">partition_psum</span><span class="id"> fst</span>)<span class="id"> //;</span><span class="id"> apply/eq_psum</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> pose</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> [pred</span><span class="id"> xy</span><span class="id"> :</span><span class="id"> T</span><span class="id"> *</span><span class="id"> U</span><span class="id"> |</span><span class="id"> xy</span>.<span class="id">1</span><span class="id"> ==</span><span class="id"> x]</span>.<br/>
<span class="id">rewrite</span> (<span class="id">reindex_psum</span> (<span class="id">h</span><span class="id"> :=</span><span class="id"> [eta</span><span class="id"> pair</span><span class="id"> x]</span>) (<span class="id">P</span><span class="id"> :=</span><span class="id"> P</span>))<span class="id"> //=</span>.<br/>
<span class="id">+</span><span class="id"> case=&gt;</span><span class="id"> x'</span><span class="id"> y'</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> mulf_eq0</span><span class="id"> =&gt;</span><span class="id"> /norP[_]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> pnatr_eq0</span><span class="id"> eqb0</span><span class="id"> negbK</span><span class="id"> /P</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /eqP-&gt;</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> snd</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[x'</span><span class="id"> y']</span><span class="id"> /eqP</span><span class="id"> /=</span><span class="id"> &lt;-</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_psum=&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> eqxx</span><span class="id"> mulr1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum_pair_swap</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> *</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> summable</span><span class="id"> S</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">psum</span><span class="id"> S</span><span class="id"> =</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> S</span> (<span class="id">x,</span><span class="id"> y</span>))).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sblS;</span><span class="id"> rewrite</span> (<span class="id">partition_psum</span><span class="id"> snd</span>)<span class="id"> //;</span><span class="id"> apply/eq_psum</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> pose</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> [pred</span><span class="id"> xy</span><span class="id"> :</span><span class="id"> T</span><span class="id"> *</span><span class="id"> U</span><span class="id"> |</span><span class="id"> xy</span>.<span class="id">2</span><span class="id"> ==</span><span class="id"> y]</span>.<br/>
<span class="id">rewrite</span> (<span class="id">reindex_psum</span> (<span class="id">h</span><span class="id"> :=</span><span class="id"> [eta</span><span class="id"> pair^~</span><span class="id"> y]</span>) (<span class="id">P</span><span class="id"> :=</span><span class="id"> P</span>))<span class="id"> //=</span>.<br/>
<span class="id">+</span><span class="id"> case=&gt;</span><span class="id"> x'</span><span class="id"> y'</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> mulf_eq0</span><span class="id"> =&gt;</span><span class="id"> /norP[_]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> pnatr_eq0</span><span class="id"> eqb0</span><span class="id"> negbK</span><span class="id"> /P</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /eqP-&gt;</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> fst</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[x'</span><span class="id"> y']</span><span class="id"> /eqP</span><span class="id"> /=</span><span class="id"> &lt;-</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_psum=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> eqxx</span><span class="id"> mulr1</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> PSumPair</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> SupInterchange</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> Type}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __admitted__interchange_sup</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> has_sup</span><span class="id"> [set</span><span class="id"> r</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> y,</span><span class="id"> r</span><span class="id"> =</span><span class="id"> S</span><span class="id"> x</span><span class="id"> y]</span>)<br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> has_sup</span><span class="id"> [set</span><span class="id"> r</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> r</span><span class="id"> =</span><span class="id"> sup</span><span class="id"> [set</span><span class="id"> r</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> y,</span><span class="id"> r</span><span class="id"> =</span><span class="id"> S</span><span class="id"> x</span><span class="id"> y]]</span><br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> sup</span><span class="id"> [set</span><span class="id"> r</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> r</span><span class="id"> =</span><span class="id"> sup</span><span class="id"> [set</span><span class="id"> r</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> y,</span><span class="id"> r</span><span class="id"> =</span><span class="id"> S</span><span class="id"> x</span><span class="id"> y]]</span><br/>
&nbsp;&nbsp;<span class="id">=</span><span class="id"> sup</span><span class="id"> [set</span><span class="id"> r</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> y,</span><span class="id"> r</span><span class="id"> ==</span><span class="id"> sup</span><span class="id"> [set</span><span class="id"> r</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> r</span><span class="id"> =</span><span class="id"> S</span><span class="id"> x</span><span class="id"> y]]</span>.<br/>
<span class="vernacular">Proof</span><span class="gallina-kwd"> using</span><span class="gallina-kwd"> Type</span>.<span class="vernacular">End</span><span class="id"> SupInterchange</span>.<br/>
<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;lacks proof, use __admitted__interchange_sup explicitly if you really want to use this lemma&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> interchange_sup</span><span class="id"> :=</span><span class="id"> __admitted__interchange_sup</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PSumInterchange</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> choiceType}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __admitted__interchange_psum</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> summable</span> (<span class="id">S</span><span class="id"> x</span>))<br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> summable</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> S</span><span class="id"> x</span><span class="id"> y</span>))<br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> S</span><span class="id"> x</span><span class="id"> y</span>))<span class="id"> =</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> S</span><span class="id"> x</span><span class="id"> y</span>)).<br/>
<span class="vernacular">Proof</span><span class="gallina-kwd"> using</span><span class="gallina-kwd"> Type</span>.<span class="vernacular">End</span><span class="id"> PSumInterchange</span>.<br/>
<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;lacks proof, use __admitted__interchange_psum explicitly if you really want to use this lemma&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> interchange_psum</span><span class="id"> :=</span><span class="id"> __admitted__interchange_psum</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> SumTheory</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> psum_sum</span><span class="id"> S</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> S</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> psum</span><span class="id"> S</span><span class="id"> =</span><span class="id"> sum</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ge0_S;</span><span class="id"> rewrite</span><span class="id"> /sum</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _-X]psum_eq0</span><span class="id"> ?subr0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> fneg_ge0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_psum=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> fpos_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_sum</span><span class="id"> S1</span><span class="id"> S2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> S1</span><span class="id"> -&gt;</span><span class="id"> summable</span><span class="id"> S2</span><span class="id"> -&gt;</span> (<span class="id">S1</span><span class="id"> &lt;=1</span><span class="id"> S2</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sum</span><span class="id"> S1</span><span class="id"> &lt;=</span><span class="id"> sum</span><span class="id"> S2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> smS1</span><span class="id"> smS2</span><span class="id"> leS;</span><span class="id"> rewrite</span><span class="id"> /sum</span><span class="id"> lerB</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/le_psum/summable_fpos</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ge0_fpos</span><span class="id"> /=</span><span class="id"> le_fpos</span>.<br/>
<span class="id">apply/le_psum/summable_fneg</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span>.<br/>
<span class="id">rewrite</span><span class="id"> -!fposN</span><span class="id"> ge0_fpos</span><span class="id"> le_fpos</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> y</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> lerN2</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sum0</span><span class="id"> :</span><span class="id"> sum</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> :</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> 0</span>)<span class="id"> =</span><span class="id"> 0</span><span class="id"> :&gt;</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /sum</span><span class="id"> !</span>(<span class="id">eq_psum</span><span class="id"> fpos0,</span><span class="id"> eq_psum</span><span class="id"> fneg0</span>)<span class="id"> !psum0</span><span class="id"> subr0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sumN</span><span class="id"> S</span><span class="id"> :</span><span class="id"> sum</span> (<span class="id">-</span><span class="id"> S</span>)<span class="id"> =</span><span class="id"> -</span><span class="id"> sum</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /sum</span> (<span class="id">eq_psum</span> (<span class="id">fnegN</span><span class="id"> _</span>)) (<span class="id">eq_psum</span> (<span class="id">fposN</span><span class="id"> _</span>))<span class="id"> opprB</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sumZ</span><span class="id"> S</span><span class="id"> c</span><span class="id"> :</span><span class="id"> sum</span> (<span class="id">c</span><span class="id"> \*o</span><span class="id"> S</span>)<span class="id"> =</span><span class="id"> c</span><span class="id"> *</span><span class="id"> sum</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span> (<span class="id">eq_sum</span> (<span class="id">F2</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> Num</span>.<span class="id">sg</span><span class="id"> c</span><span class="id"> *</span> (<span class="id">`|c|</span><span class="id"> *</span><span class="id"> S</span><span class="id"> x</span>))).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulrA</span><span class="id"> -numEsg</span>.<br/>
<span class="id">transitivity</span> (<span class="id">Num</span>.<span class="id">sg</span><span class="id"> c</span><span class="id"> *</span><span class="id"> sum</span> (<span class="id">`|c|</span><span class="id"> \*o</span><span class="id"> S</span>)).<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> sgrP</span><span class="id"> =&gt;</span><span class="id"> [_|gt0_c|lt0_c];</span><span class="id"> rewrite</span><span class="id"> ?Monoid</span>.<span class="id">simpm</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">eq_sum</span> (<span class="id">F2</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> 0</span>))<span class="id"> ?sum0</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !mul0r</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply/eq_sum=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mul1r</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulN1r</span><span class="id"> -sumN;</span><span class="id"> apply/eq_sum=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !mulN1r</span>.<br/>
<span class="id">rewrite</span><span class="id"> {1}/sum</span><span class="id"> !</span>(<span class="id">eq_psum</span> (<span class="id">fposZ</span><span class="id"> _</span><span class="id"> _</span>)<span class="id">,</span><span class="id"> eq_psum</span> (<span class="id">fnegZ</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !psumZ</span><span class="id"> //</span><span class="id"> -mulrBr</span><span class="id"> mulrA</span><span class="id"> -numEsg</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sumID</span><span class="id"> S</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> sum</span><span class="id"> S</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">P</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> S</span><span class="id"> x</span>)<span class="id"> +</span><span class="id"> sum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">~~</span><span class="id"> P</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> S</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sm_S;</span><span class="id"> rewrite</span><span class="id"> /sum</span><span class="id"> addrACA</span><span class="id"> -[in</span><span class="id"> RHS]opprD;</span><span class="id"> congr</span> (_<span class="id"> -</span><span class="id"> _</span>).<br/>
<span class="id">+</span><span class="id"> rewrite</span> (<span class="id">psumID</span><span class="id"> P</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/summable_fpos</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> congr</span> (_<span class="id"> +</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply/eq_psum</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> fpos_natrM</span>.<br/>
<span class="id">+</span><span class="id"> rewrite</span> (<span class="id">psumID</span><span class="id"> P</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/summable_fneg</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> congr</span> (_<span class="id"> +</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply/eq_psum</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> fneg_natrM</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sum_finseq</span><span class="id"> S</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> S</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> 0]</span><span class="id"> &lt;=</span><span class="id"> r}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sum</span><span class="id"> S</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> r</span>)<span class="id"> S</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eqr</span><span class="id"> domS;</span><span class="id"> rewrite</span><span class="id"> /sum</span><span class="id"> !</span>(<span class="id">psum_finseq</span><span class="id"> eqr</span>).<br/>
<span class="id">+</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> =&gt;</span><span class="id"> xPS;</span><span class="id"> apply/domS;</span><span class="id"> rewrite</span><span class="id"> !inE</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> xPS;</span><span class="id"> rewrite</span><span class="id"> /fpos</span><span class="id"> normr_eq0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> maxxx</span>.<br/>
<span class="id">+</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> =&gt;</span><span class="id"> xPS;</span><span class="id"> apply/domS;</span><span class="id"> rewrite</span><span class="id"> !inE</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> xPS;</span><span class="id"> rewrite</span><span class="id"> /fneg</span><span class="id"> normr_eq0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> minxx</span>.<br/>
<span class="id">rewrite</span><span class="id"> -sumrB;</span><span class="id"> apply/eq_bigr=&gt;</span><span class="id"> i</span><span class="id"> _</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !ger0_norm</span><span class="id"> ?</span>(<span class="id">ge0_fpos,</span><span class="id"> ge0_fneg</span>)<span class="id"> ?fposBfneg</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sum_seq1</span><span class="id"> S</span><span class="id"> x</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> y,</span><span class="id"> S</span><span class="id"> y</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id"> -&gt;</span><span class="id"> sum</span><span class="id"> S</span><span class="id"> =</span><span class="id"> S</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> domS;</span><span class="id"> rewrite</span> (<span class="id">sum_finseq</span> (<span class="id">r</span><span class="id"> :=</span><span class="id"> [::</span><span class="id"> x]</span>))<span class="id"> ?big_seq1//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> =&gt;</span><span class="id"> /domS</span><span class="id"> /eqP-&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> SumTheory</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> sum_seq1</span><span class="id"> {R</span><span class="id"> T}</span><span class="id"> [S]</span><span class="id"> x</span><span class="id"> _</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
