
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.classical.set_interval</title>
<meta name="description" content="Documentation of Coq module mathcomp.classical.set_interval" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.classical.set_interval</h1>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> all_ssreflect</span><span class="id"> ssralg</span><span class="id"> ssrnum</span><span class="id"> interval</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> mathcomp_extra</span><span class="id"> boolp</span><span class="id"> classical_sets</span>.<br/>
<span class="vernacular">From</span><span class="id"> HB</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> structures</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> functions</span>.<br/>
<br/>
<div class="ssrdoc md">
# Sets and Intervals

This files contains lemmas about sets and intervals.

```
             neitv i == the interval i is non-empty
                        when the support type is a numFieldType, this
                        is equivalent to (i.1 &lt; i.2)%O (lemma neitvE)
  set_itv_infty_set0 == multirule to simplify empty intervals
     line_path a b t := (1 - t) * a + t * b, convexity operator over a
                        numDomainType
         ndline_path == line_path a b with the constraint that a &lt; b
        factor a b x := (x - a) / (b - a)
            set_itvE == multirule to turn intervals into inequalities
    disjoint_itv i j == intervals i and j are disjoint
        itv_is_ray i == i is either `]x,+oo[ or `]-oo,x[
    itv_is_bd_open i == i is `]x,y[
     itv_open_ends i == i has open endpoints, E.G. is one of the two above
       is_open_itv A == the set A can be written as an open interval
    open_itv_cover A == the set A can be covered by open intervals
```

</div>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<span class="vernacular">Import</span><span class="id"> Order</span>.<span class="id">TTheory</span><span class="id"> GRing</span>.<span class="id">Theory</span><span class="id"> Num</span>.<span class="id">Def</span><span class="id"> Num</span>.<span class="id">Theory</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<br/>
<div class="doc">definitions and lemmas to make a bridge between MathComp intervals and
    classical sets </div>
<span class="vernacular">Section</span><span class="id"> set_itv_porderType</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">d</span><span class="id"> :</span><span class="id"> Order</span>.<span class="id">disp_t</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> porderType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">i</span><span class="id"> j</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> T</span>) (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">a</span><span class="id"> :</span><span class="id"> itv_bound</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> neitv</span><span class="id"> i</span><span class="id"> :=</span><span class="id"> [set`</span><span class="id"> i]</span><span class="id"> !=</span><span class="id"> set0</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> neitv_lt_bnd</span><span class="id"> i</span><span class="id"> :</span><span class="id"> neitv</span><span class="id"> i</span><span class="id"> -&gt;</span> (<span class="id">i</span>.<span class="id">1</span><span class="id"> &lt;</span><span class="id"> i</span>.<span class="id">2</span>)<span class="id">%O</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case:</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> a</span><span class="id"> b;</span><span class="id"> apply:</span><span class="id"> contraNT</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> /itv_ge</span><span class="id"> ab0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> t;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> ab0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itvP</span><span class="id"> i</span><span class="id"> j</span><span class="id"> :</span><span class="id"> [set`</span><span class="id"> i]</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> j]</span><span class="id"> :&gt;</span><span class="id"> set</span><span class="id"> _</span><span class="id"> &lt;-&gt;</span><span class="id"> i</span><span class="id"> =i</span><span class="id"> j</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> [ij</span><span class="id"> x|ij];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> /</span>(<span class="id">congr1</span> (<span class="id">@^~</span><span class="id"> x</span>))<span class="id">/=/is_true_inj</span><span class="id"> :=</span><span class="id"> ij</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> r</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> ij</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subset_itvP</span><span class="id"> i</span><span class="id"> j</span><span class="id"> :</span><span class="id"> {subset</span><span class="id"> i</span><span class="id"> &lt;=</span><span class="id"> j}</span><span class="id"> &lt;-&gt;</span><span class="id"> [set`</span><span class="id"> i]</span><span class="id"> `&lt;=`</span><span class="id"> [set`</span><span class="id"> j]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> in1_subset_itv</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> i</span><span class="id"> j</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> j]</span><span class="id"> `&lt;=`</span><span class="id"> [set`</span><span class="id"> i]</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> i,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x}</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> j,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /subset_itvP</span><span class="id"> ji</span><span class="id"> iP</span><span class="id"> z</span><span class="id"> zB;</span><span class="id"> apply:</span><span class="id"> iP;</span><span class="id"> exact:</span><span class="id"> ji</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subset_itvW</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> u</span><span class="id"> b0</span><span class="id"> b1</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">x</span><span class="id"> &lt;=</span><span class="id"> y</span>)<span class="id">%O</span><span class="id"> -&gt;</span> (<span class="id">z</span><span class="id"> &lt;=</span><span class="id"> u</span>)<span class="id">%O</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">`]y,</span><span class="id"> z[</span><span class="id"> `&lt;=`</span><span class="id"> [set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> b0</span><span class="id"> x</span>) (<span class="id">BSide</span><span class="id"> b1</span><span class="id"> u</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> xy</span><span class="id"> zu;</span><span class="id"> apply:</span> (<span class="id">@subset_trans</span><span class="id"> _</span><span class="id"> `]x,</span><span class="id"> u[%classic</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x0/=;</span><span class="id"> rewrite</span><span class="id"> 2!in_itv/=</span><span class="id"> =&gt;</span><span class="id"> /andP[]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /</span>(<span class="id">le_lt_trans</span><span class="id"> xy</span>)<span class="id"> -&gt;/=</span><span class="id"> /lt_le_trans;</span><span class="id"> exact</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> b0</span><span class="id"> b1</span><span class="id"> =&gt;</span><span class="id"> []</span><span class="id"> []</span><span class="id"> /=;</span><span class="id"> [exact:</span><span class="id"> subset_itv_oo_co|exact:</span><span class="id"> subset_itv_oo_cc|</span><br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> subset_refl|exact:</span><span class="id"> subset_itv_oo_oc]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subset_itvl</span> (<span class="id">a</span><span class="id"> b</span><span class="id"> c</span><span class="id"> :</span><span class="id"> itv_bound</span><span class="id"> T</span>)<span class="id"> :</span> (<span class="id">b</span><span class="id"> &lt;=</span><span class="id"> c</span>)<span class="id">%O</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span><span class="id"> a</span><span class="id"> b]</span><span class="id"> `&lt;=`</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> a</span><span class="id"> c]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case:</span><span class="id"> c</span><span class="id"> =&gt;</span><span class="id"> [[|]</span><span class="id"> c</span><span class="id"> bc</span><span class="id"> x/=|[//|_]</span><span class="id"> x/=]</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> !in_itv/=</span><span class="id"> =&gt;</span><span class="id"> /andP[-&gt;/=]</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> b</span><span class="id"> bc</span><span class="id"> =&gt;</span><span class="id"> [[|]/=|[|]//]</span><span class="id"> b</span><span class="id"> bc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /lt_le_trans;</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /le_lt_trans;</span><span class="id"> exact</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> !in_itv/=</span><span class="id"> =&gt;</span><span class="id"> /andP[-&gt;/=]</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> b</span><span class="id"> bc</span><span class="id"> =&gt;</span><span class="id"> [[|]/=|[|]//]</span><span class="id"> b</span><span class="id"> bc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /ltW</span><span class="id"> /le_trans;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /le_trans;</span><span class="id"> apply</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> le_ninfty</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !in_itv/=;</span><span class="id"> case:</span><span class="id"> a</span><span class="id"> =&gt;</span><span class="id"> [[|]/=|[|]//]</span><span class="id"> a</span><span class="id"> /andP[-&gt;]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subset_itvr</span> (<span class="id">a</span><span class="id"> b</span><span class="id"> c</span><span class="id"> :</span><span class="id"> itv_bound</span><span class="id"> T</span>)<span class="id"> :</span> (<span class="id">c</span><span class="id"> &lt;=</span><span class="id"> a</span>)<span class="id">%O</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span><span class="id"> a</span><span class="id"> b]</span><span class="id"> `&lt;=`</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> c</span><span class="id"> b]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ac</span><span class="id"> x/=;</span><span class="id"> rewrite</span><span class="id"> !in_itv/=</span><span class="id"> =&gt;</span><span class="id"> /andP[ax</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> andbT</span>.<br/>
<span class="id">move:</span><span class="id"> c</span><span class="id"> a</span><span class="id"> ax</span><span class="id"> ac</span><span class="id"> =&gt;</span><span class="id"> [[|]</span><span class="id"> c</span><span class="id"> [[|]/=</span><span class="id"> a</span><span class="id"> ax|[|]//=]|[//|]];</span><span class="id"> rewrite</span><span class="id"> ?bnd_simp</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /le_trans;</span><span class="id"> exact</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /le_trans;</span><span class="id"> apply;</span><span class="id"> exact/ltW</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /lt_le_trans;</span><span class="id"> exact</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /le_lt_trans;</span><span class="id"> exact</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [[|]|[|]//]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subset_itvScc</span> (<span class="id">a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> itv_bound</span><span class="id"> T</span>) (<span class="id">c</span><span class="id"> e</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">BLeft</span><span class="id"> c</span><span class="id"> &lt;=</span><span class="id"> a</span>)<span class="id">%O</span><span class="id"> -&gt;</span> (<span class="id">b</span><span class="id"> &lt;=</span><span class="id"> BRight</span><span class="id"> e</span>)<span class="id">%O</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span><span class="id"> a</span><span class="id"> b]</span><span class="id"> `&lt;=`</span><span class="id"> [set`</span><span class="id"> `[c,</span><span class="id"> e]]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ca</span><span class="id"> be</span><span class="id"> z/=;</span><span class="id"> rewrite</span><span class="id"> !in_itv/==&gt;</span><span class="id"> /andP[az</span><span class="id"> zb]</span>.<br/>
<span class="id">case:</span><span class="id"> a</span><span class="id"> ca</span><span class="id"> az</span><span class="id"> =&gt;</span><span class="id"> [[|]/=|[|]//]</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> bnd_simp</span><span class="id"> =&gt;</span><span class="id"> ca</span><span class="id"> az</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> ca</span><span class="id"> az</span>)<span class="id">/=</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> b</span><span class="id"> be</span><span class="id"> zb</span><span class="id"> =&gt;</span><span class="id"> [[|]/=</span><span class="id"> b|[|]//];</span><span class="id"> rewrite</span><span class="id"> bnd_simp</span><span class="id"> =&gt;</span><span class="id"> be</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /ltW/le_trans;</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /le_trans;</span><span class="id"> exact</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> ca</span> (<span class="id">ltW</span><span class="id"> az</span>))<span class="id">/=</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> b</span><span class="id"> be</span><span class="id"> zb</span><span class="id"> =&gt;</span><span class="id"> [[|]/=</span><span class="id"> b|[|]//];</span><span class="id"> rewrite</span><span class="id"> bnd_simp</span><span class="id"> =&gt;</span><span class="id"> be</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /ltW/le_trans;</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /le_trans;</span><span class="id"> exact</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subset_itvSoo</span> (<span class="id">a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> itv_bound</span><span class="id"> T</span>) (<span class="id">c</span><span class="id"> e</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">BLeft</span><span class="id"> c</span><span class="id"> &lt;</span><span class="id"> a</span>)<span class="id">%O</span><span class="id"> -&gt;</span> (<span class="id">b</span><span class="id"> &lt;</span><span class="id"> BRight</span><span class="id"> e</span>)<span class="id">%O</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span><span class="id"> a</span><span class="id"> b]</span><span class="id"> `&lt;=`</span><span class="id"> [set`</span><span class="id"> `]c,</span><span class="id"> e[]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ca</span><span class="id"> be</span><span class="id"> z/=;</span><span class="id"> rewrite</span><span class="id"> !in_itv/=</span><span class="id"> =&gt;</span><span class="id"> /andP[az</span><span class="id"> zb]</span>.<br/>
<span class="id">case:</span><span class="id"> a</span><span class="id"> ca</span><span class="id"> az</span><span class="id"> =&gt;</span><span class="id"> [[|]/=|[|]//]</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> bnd_simp</span><span class="id"> =&gt;</span><span class="id"> ca</span><span class="id"> az</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">lt_le_trans</span><span class="id"> ca</span><span class="id"> az</span>)<span class="id">/=</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> b</span><span class="id"> be</span><span class="id"> zb</span><span class="id"> =&gt;</span><span class="id"> [[|]/=</span><span class="id"> b|[|]//];</span><span class="id"> rewrite</span><span class="id"> bnd_simp</span><span class="id"> =&gt;</span><span class="id"> be</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /lt_le_trans;</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /le_lt_trans;</span><span class="id"> exact</span>.<br/>
<span class="id">rewrite</span> (<span class="id">le_lt_trans</span><span class="id"> ca</span><span class="id"> az</span>)<span class="id">/=</span>.<br/>
<span class="id">move:</span><span class="id"> b</span><span class="id"> be</span><span class="id"> zb</span><span class="id"> =&gt;</span><span class="id"> [[|]/=</span><span class="id"> b|[|]//];</span><span class="id"> rewrite</span><span class="id"> bnd_simp</span><span class="id"> =&gt;</span><span class="id"> be</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /lt_le_trans;</span><span class="id"> exact</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /le_lt_trans;</span><span class="id"> exact</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> interval_set1</span><span class="id"> x</span><span class="id"> :</span><span class="id"> `[x,</span><span class="id"> x]%classic</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> x]</span><span class="id"> :&gt;</span><span class="id"> set</span><span class="id"> T</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [y/=|y</span><span class="id"> &lt;-];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> in_itv/=</span><span class="id"> lexx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> in_itv/=</span><span class="id"> =&gt;</span><span class="id"> /andP[yx</span><span class="id"> xy];</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le</span><span class="id"> yx</span><span class="id"> xy</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itvoo</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> `]x,</span><span class="id"> y[%classic</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> z</span><span class="id"> |</span> (<span class="id">x</span><span class="id"> &lt;</span><span class="id"> z</span><span class="id"> &lt;</span><span class="id"> y</span>)<span class="id">%O]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itvco</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> `[x,</span><span class="id"> y[%classic</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> z</span><span class="id"> |</span> (<span class="id">x</span><span class="id"> &lt;=</span><span class="id"> z</span><span class="id"> &lt;</span><span class="id"> y</span>)<span class="id">%O]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itvcc</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> `[x,</span><span class="id"> y]%classic</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> z</span><span class="id"> |</span> (<span class="id">x</span><span class="id"> &lt;=</span><span class="id"> z</span><span class="id"> &lt;=</span><span class="id"> y</span>)<span class="id">%O]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itvoc</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> `]x,</span><span class="id"> y]%classic</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> z</span><span class="id"> |</span> (<span class="id">x</span><span class="id"> &lt;</span><span class="id"> z</span><span class="id"> &lt;=</span><span class="id"> y</span>)<span class="id">%O]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itv1</span><span class="id"> x</span><span class="id"> :</span><span class="id"> `[x,</span><span class="id"> x]%classic</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> itvxx</span><span class="id"> ?inE</span> (<span class="id">rwP</span><span class="id"> eqP</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itvoo0</span><span class="id"> x</span><span class="id"> :</span><span class="id"> `]x,</span><span class="id"> x[%classic</span><span class="id"> =</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -subset0</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> itv_ge//=</span><span class="id"> bnd_simp</span><span class="id"> ltxx</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itvoc0</span><span class="id"> x</span><span class="id"> :</span><span class="id"> `]x,</span><span class="id"> x]%classic</span><span class="id"> =</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -subset0</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> itv_ge//=</span><span class="id"> bnd_simp</span><span class="id"> ltxx</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itvco0</span><span class="id"> x</span><span class="id"> :</span><span class="id"> `[x,</span><span class="id"> x[%classic</span><span class="id"> =</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -subset0</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> itv_ge//=</span><span class="id"> bnd_simp</span><span class="id"> ltxx</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itv_infty_infty</span><span class="id"> :</span><span class="id"> `]-oo,</span><span class="id"> +oo[%classic</span><span class="id"> =</span><span class="id"> @setT</span><span class="id"> T</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> predeqE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itv_o_infty</span><span class="id"> x</span><span class="id"> :</span><span class="id"> `]x,</span><span class="id"> +oo[%classic</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> z</span><span class="id"> |</span> (<span class="id">x</span><span class="id"> &lt;</span><span class="id"> z</span>)<span class="id">%O]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> r</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> in_itv</span><span class="id"> andbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itv_c_infty</span><span class="id"> x</span><span class="id"> :</span><span class="id"> `[x,</span><span class="id"> +oo[%classic</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> z</span><span class="id"> |</span> (<span class="id">x</span><span class="id"> &lt;=</span><span class="id"> z</span>)<span class="id">%O]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> /mkset</span><span class="id"> =&gt;</span><span class="id"> r;</span><span class="id"> rewrite</span><span class="id"> in_itv</span><span class="id"> andbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itv_infty_o</span><span class="id"> x</span><span class="id"> :</span><span class="id"> `]-oo,</span><span class="id"> x[%classic</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> z</span><span class="id"> |</span> (<span class="id">z</span><span class="id"> &lt;</span><span class="id"> x</span>)<span class="id">%O]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> /mkset</span><span class="id"> =&gt;</span><span class="id"> r;</span><span class="id"> rewrite</span><span class="id"> in_itv</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itv_infty_c</span><span class="id"> x</span><span class="id"> :</span><span class="id"> `]-oo,</span><span class="id"> x]%classic</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> z</span><span class="id"> |</span> (<span class="id">z</span><span class="id"> &lt;=</span><span class="id"> x</span>)<span class="id">%O]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> /mkset</span><span class="id"> =&gt;</span><span class="id"> r;</span><span class="id"> rewrite</span><span class="id"> in_itv</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itv_pinfty_bnd</span><span class="id"> a</span><span class="id"> :</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> +oo%O</span><span class="id"> a]</span><span class="id"> =</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/eqP/negPn/negP</span><span class="id"> =&gt;</span><span class="id"> /neitv_lt_bnd</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itv_bnd_ninfty</span><span class="id"> a</span><span class="id"> :</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> a</span><span class="id"> -oo%O]</span><span class="id"> =</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/eqP/negPn/negP</span><span class="id"> =&gt;</span><span class="id"> /neitv_lt_bnd</span><span class="id"> /=;</span><span class="id"> case:</span><span class="id"> a</span><span class="id"> =&gt;</span><span class="id"> [[]a|[]]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> set_itv_infty_set0</span><span class="id"> :=</span> (<span class="id">set_itv_bnd_ninfty,</span><span class="id"> set_itv_pinfty_bnd</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> set_itvE</span><span class="id"> :=</span> (<span class="id">set_itv1,</span><span class="id"> set_itvoo0,</span><span class="id"> set_itvoc0,</span><span class="id"> set_itvco0,</span><span class="id"> set_itvoo,</span><br/>
&nbsp;&nbsp;<span class="id">set_itvcc,</span><span class="id"> set_itvoc,</span><span class="id"> set_itvco,</span><span class="id"> set_itv_infty_infty,</span><span class="id"> set_itv_o_infty,</span><br/>
&nbsp;&nbsp;<span class="id">set_itv_c_infty,</span><span class="id"> set_itv_infty_o,</span><span class="id"> set_itv_infty_c,</span><span class="id"> set_itv_infty_set0</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itvxx</span><span class="id"> a</span><span class="id"> :</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> a</span><span class="id"> a]</span><span class="id"> =</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> a</span><span class="id"> =&gt;</span><span class="id"> [[|]</span><span class="id"> a</span><span class="id"> |[|]];</span><span class="id"> rewrite</span><span class="id"> !set_itvE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setUitv1</span><span class="id"> a</span><span class="id"> x</span><span class="id"> :</span> (<span class="id">a</span><span class="id"> &lt;=</span><span class="id"> BLeft</span><span class="id"> x</span>)<span class="id">%O</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span><span class="id"> a</span> (<span class="id">BLeft</span><span class="id"> x</span>)<span class="id">]</span><span class="id"> `|`</span><span class="id"> [set</span><span class="id"> x]</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> a</span> (<span class="id">BRight</span><span class="id"> x</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ax;</span><span class="id"> apply/predeqP</span><span class="id"> =&gt;</span><span class="id"> z</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> itv_splitU1//</span><span class="id"> [in</span><span class="id"> X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> &lt;-&gt;</span><span class="id"> X]inE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">rwP</span><span class="id"> eqP</span>) (<span class="id">rwP</span><span class="id"> orP</span>)<span class="id"> orbC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setU1itv</span><span class="id"> a</span><span class="id"> x</span><span class="id"> :</span> (<span class="id">BRight</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> a</span>)<span class="id">%O</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">x</span><span class="id"> |`</span><span class="id"> [set`</span><span class="id"> Interval</span> (<span class="id">BRight</span><span class="id"> x</span>)<span class="id"> a]</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> Interval</span> (<span class="id">BLeft</span><span class="id"> x</span>)<span class="id"> a]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ax;</span><span class="id"> apply/predeqP</span><span class="id"> =&gt;</span><span class="id"> z</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> itv_split1U//</span><span class="id"> [in</span><span class="id"> X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> &lt;-&gt;</span><span class="id"> X]inE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">rwP</span><span class="id"> eqP</span>) (<span class="id">rwP</span><span class="id"> orP</span>)<span class="id"> orbC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setDitv1r</span><span class="id"> a</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span><span class="id"> a</span> (<span class="id">BRight</span><span class="id"> x</span>)<span class="id">]</span><span class="id"> `\</span><span class="id"> x</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> a</span> (<span class="id">BLeft</span><span class="id"> x</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [z|z]</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> !in_itv/=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [/andP[-&gt;</span><span class="id"> /=</span><span class="id"> zx]</span><span class="id"> /eqP</span><span class="id"> xz];</span><span class="id"> rewrite</span><span class="id"> lt_neqAle</span><span class="id"> xz</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> lt_neqAle</span><span class="id"> =&gt;</span><span class="id"> /andP[-&gt;</span><span class="id"> /andP[/eqP</span><span class="id"> ?</span><span class="id"> -&gt;]]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setDitv1l</span><span class="id"> a</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span> (<span class="id">BLeft</span><span class="id"> x</span>)<span class="id"> a]</span><span class="id"> `\</span><span class="id"> x</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> Interval</span> (<span class="id">BRight</span><span class="id"> x</span>)<span class="id"> a]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [z|z]</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> !in_itv/=</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> [/andP[xz</span><span class="id"> -&gt;]];</span><span class="id"> rewrite</span><span class="id"> andbT</span><span class="id"> =&gt;</span><span class="id"> /eqP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> lt_neqAle</span><span class="id"> eq_sym</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /andP[];</span><span class="id"> rewrite</span><span class="id"> lt_neqAle</span><span class="id"> =&gt;</span><span class="id"> /andP[xz</span><span class="id"> zx</span><span class="id"> -&gt;]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> andbT;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact/nesym/eqP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> set_itv_porderType</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> neitv</span><span class="id"> {d</span><span class="id"> T}</span><span class="id"> _</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.4.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed to subset_itvScc&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> subset_itvS</span><span class="id"> :=</span><span class="id"> subset_itvScc</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> set_itv_orderType</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">d</span><span class="id"> :</span><span class="id"> Order</span>.<span class="id">disp_t</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> orderType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> a</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> itv_bound</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> itv_bndbnd_setU</span><span class="id"> a</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span> (<span class="id">a</span><span class="id"> &lt;=</span><span class="id"> x</span>)<span class="id">%O</span><span class="id"> -&gt;</span> (<span class="id">x</span><span class="id"> &lt;=</span><span class="id"> y</span>)<span class="id">%O</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">[set`</span><span class="id"> Interval</span><span class="id"> a</span><span class="id"> y]</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> a</span><span class="id"> x]</span><span class="id"> `|`</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> x</span><span class="id"> y]</span>)<span class="id">%classic</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> le_eqVlt</span><span class="id"> =&gt;</span><span class="id"> /predU1P[&lt;-{x}</span><span class="id"> ay|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> set_itvxx</span><span class="id"> set0U</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /[swap]</span>.<br/>
<span class="id">rewrite</span><span class="id"> le_eqVlt</span><span class="id"> =&gt;</span><span class="id"> /predU1P[-&gt;</span><span class="id"> ay|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> set_itvxx</span><span class="id"> setU0</span>.<br/>
<span class="id">move:</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> [yb</span><span class="id"> y/=|[|]];</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [|[|]]</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> ax;</span><span class="id"> apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [z|z]</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !in_itv/=</span><span class="id"> !andbT</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span><span class="id"> /=;</span><span class="id"> apply/orP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[|]</span><span class="id"> x/=|[|]//]</span><span class="gallina-kwd"> in</span><span class="id"> ax</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> leNgt</span><span class="id"> ?</span>(<span class="id">orbN,orNb</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !in_itv/=</span><span class="id"> !andbT</span><span class="id"> =&gt;</span><span class="id"> -[/andP[]|]//</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[|]</span><span class="id"> x/=|[|]//]</span><span class="gallina-kwd"> in</span><span class="id"> ax</span><span class="id"> *;</span><span class="id"> move:</span><span class="id"> a</span><span class="id"> =&gt;</span><span class="id"> [[|]</span><span class="id"> a/=|[|]//]</span><span class="gallina-kwd"> in</span><span class="id"> ax</span><span class="id"> *</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply/le_trans;</span><span class="id"> exact/ltW</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact/lt_le_trans</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /</span>(<span class="id">le_lt_trans</span><span class="id"> ax</span>)<span class="id"> /ltW</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact/lt_trans</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> xy</span><span class="id"> ax;</span><span class="id"> apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [z|z]</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !in_itv</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> /andP[]</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> a</span><span class="id"> ax</span><span class="id"> =&gt;</span><span class="id"> [b</span><span class="id"> t</span><span class="id"> /=|[]//=</span><span class="id"> oox</span><span class="id"> _]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> tx</span><span class="id"> -&gt;</span><span class="id"> zxy</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> zxy</span><span class="id"> andbT/=;</span><span class="id"> apply/orP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> x</span><span class="id"> xy</span><span class="id"> tx</span><span class="id"> =&gt;</span><span class="id"> [[|]</span><span class="id"> x/=|[|]//]</span><span class="id"> xy</span><span class="id"> tx;</span><span class="id"> rewrite</span><span class="id"> leNgt</span><span class="id"> ?</span>(<span class="id">orbN,orNb</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> andbT;</span><span class="id"> apply/orP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[|]</span><span class="id"> x/=|[|]//]</span><span class="gallina-kwd"> in</span><span class="id"> oox</span><span class="id"> xy</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> leNgt</span><span class="id"> ?</span>(<span class="id">orbN,orNb</span>).<br/>
<span class="id">rewrite</span><span class="id"> !in_itv/=</span>.<br/>
<span class="id">move:</span><span class="id"> a</span><span class="id"> ax</span><span class="id"> =&gt;</span><span class="id"> [b</span><span class="id"> t</span><span class="id"> /=</span><span class="id"> tx|</span><span class="id"> [/=</span><span class="id"> oox|/=</span><span class="id"> oox]]</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> [/andP[-&gt;</span><span class="id"> zx]|]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[|]</span><span class="id"> x|[|]//]/=</span><span class="gallina-kwd"> in</span><span class="id"> xy</span><span class="id"> tx</span><span class="id"> zx</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case:</span><span class="id"> yb</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="gallina-kwd"> in</span><span class="id"> xy</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">lt_trans</span><span class="id"> zx</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">ltW</span> (<span class="id">lt_le_trans</span><span class="id"> zx</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> bnd_simp</span><span class="gallina-kwd"> in</span><span class="id"> xy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case:</span><span class="id"> yb</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_lt_trans</span><span class="id"> zx</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">ltW</span> (<span class="id">le_lt_trans</span><span class="id"> zx</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[|]</span><span class="id"> x|[|]//]/=</span><span class="gallina-kwd"> in</span><span class="id"> xy</span><span class="id"> tx</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> bnd_simp</span><span class="gallina-kwd"> in</span><span class="id"> xy</span><span class="id"> tx</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> move=&gt;</span><span class="id"> /andP[xz</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> andbT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case:</span><span class="id"> b</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span><span class="id"> xz</span>)<span class="id">//</span><span class="id"> ltW</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">lt_le_trans</span><span class="id"> tx</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /andP[xz</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> andbT</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> b</span><span class="id"> tx</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> tx;</span><span class="id"> rewrite</span><span class="id"> bnd_simp</span><span class="gallina-kwd"> in</span><span class="id"> tx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ltW//</span> (<span class="id">le_lt_trans</span><span class="id"> _</span><span class="id"> xz</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">lt_trans</span><span class="id"> tx</span>).<br/>
<span class="id">-</span><span class="id"> move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[|]</span><span class="id"> x|[|]//]/=</span><span class="gallina-kwd"> in</span><span class="id"> xy</span><span class="id"> oox</span><span class="id"> *;</span><span class="id"> move=&gt;</span><span class="id"> [|]</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> case:</span><span class="id"> yb</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="gallina-kwd"> in</span><span class="id"> xy</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /lt_trans;</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> bnd_simp</span><span class="gallina-kwd"> in</span><span class="id"> xy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /lt_le_trans</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> xy</span>)<span class="id">/ltW</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /andP[]</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> case:</span><span class="id"> yb</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="gallina-kwd"> in</span><span class="id"> xy</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /le_lt_trans;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /le_trans;</span><span class="id"> apply;</span><span class="id"> exact/ltW</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /andP[]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[|]</span><span class="id"> x|[|]//]/=</span><span class="gallina-kwd"> in</span><span class="id"> xy</span><span class="id"> oox</span><span class="id"> *</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> set_itv_orderType</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itv_ge</span><span class="id"> disp</span><span class="id"> [T</span><span class="id"> :</span><span class="id"> porderType</span><span class="id"> disp]</span><span class="id"> [b1</span><span class="id"> b2</span><span class="id"> :</span><span class="id"> itv_bound</span><span class="id"> T]</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">~~</span> (<span class="id">b1</span><span class="id"> &lt;</span><span class="id"> b2</span>)<span class="id">%O</span><span class="id"> -&gt;</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> b1</span><span class="id"> b2]</span><span class="id"> =</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Nb12;</span><span class="id"> rewrite</span><span class="id"> -subset0</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> itv_ge</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> set_itv_latticeType</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">d</span><span class="id"> :</span><span class="id"> Order</span>.<span class="id">disp_t</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> latticeType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">i</span><span class="id"> j</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> T</span>) (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">a</span><span class="id"> :</span><span class="id"> itv_bound</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itvI</span><span class="id"> i</span><span class="id"> j</span><span class="id"> :</span> <span class="id"> [set`</span> (<span class="id">i</span><span class="id"> `&amp;`</span><span class="id"> j</span>)<span class="id">%O]</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> i]</span><span class="id"> `&amp;`</span><span class="id"> [set`</span><span class="id"> j]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> in_itvI</span> (<span class="id">rwP</span><span class="id"> andP</span>). Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> set_itv_latticeType</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> set_itv_numFieldType</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> R</span><span class="id"> :</span><span class="id"> numFieldType</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> i</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> neitvE</span><span class="id"> i</span><span class="id"> :</span><span class="id"> neitv</span><span class="id"> i</span><span class="id"> =</span> (<span class="id">i</span>.<span class="id">1</span><span class="id"> &lt;</span><span class="id"> i</span>.<span class="id">2</span>)<span class="id">%O</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/idP/idP;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> neitv_lt_bnd</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /mem_miditv</span><span class="id"> ii;</span><span class="id"> apply/set0P;</span><span class="gallina-kwd"> exists</span> (<span class="id">miditv</span><span class="id"> i</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> neitvP</span><span class="id"> i</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">i</span>.<span class="id">1</span><span class="id"> &lt;</span><span class="id"> i</span>.<span class="id">2</span>)<span class="id">%O</span> (<span class="id">neitv</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -neitvE</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> set_itv_numFieldType</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setitv0</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realDomainType</span>)<span class="id"> :</span><span class="id"> [set`</span> (<span class="id">\bot%O</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> R</span>)<span class="id">]</span><span class="id"> =</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> predeqE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> interval_has_bound</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> R</span><span class="id"> :</span><span class="id"> numDomainType</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_lbound_itv</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> b</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> itv_bound</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">has_lbound</span><span class="id"> [set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> b</span><span class="id"> x</span>)<span class="id"> a]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> b;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> r</span><span class="id"> /andP[];</span><span class="id"> rewrite</span><span class="id"> bnd_simp</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> /ltW</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_ubound_itv</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> b</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> itv_bound</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">has_ubound</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> a</span> (<span class="id">BSide</span><span class="id"> b</span><span class="id"> x</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> b;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> r</span><span class="id"> /andP[];</span><span class="id"> rewrite</span><span class="id"> bnd_simp</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /ltW</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> interval_has_bound</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> subr_image</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> R</span><span class="id"> :</span><span class="id"> numDomainType</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> E</span><span class="id"> :</span><span class="id"> set</span><span class="id"> R</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> x</span><span class="id"> :</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setNK</span><span class="id"> :</span><span class="id"> involutive</span> (<span class="gallina-kwd">fun</span><span class="id"> E</span><span class="id"> =&gt;</span><span class="id"> -%R</span><span class="id"> @`</span><span class="id"> E</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> A;</span><span class="id"> rewrite</span><span class="id"> image_comp</span> (_<span class="id"> :</span><span class="id"> _</span><span class="id"> \o</span><span class="id"> _</span><span class="id"> =</span><span class="id"> id</span>)<span class="id"> ?image_id//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> funeqE</span><span class="id"> =&gt;</span><span class="id"> r</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> opprK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lb_ubN</span><span class="id"> E</span><span class="id"> x</span><span class="id"> :</span><span class="id"> lbound</span><span class="id"> E</span><span class="id"> x</span><span class="id"> &lt;-&gt;</span><span class="id"> ubound</span> (<span class="id">-%R</span><span class="id"> @`</span><span class="id"> E</span>) (<span class="id">-</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [/lbP</span><span class="id"> xlbE|/ubP</span><span class="id"> xlbE]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> [z</span><span class="id"> Ez</span><span class="id"> &lt;-];</span><span class="id"> rewrite</span><span class="id"> lerNr</span><span class="id"> opprK;</span><span class="id"> apply</span><span class="id"> xlbE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> Ey;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">opprK</span><span class="id"> x</span>)<span class="id"> lerNl;</span><span class="id"> apply</span><span class="id"> xlbE;</span><span class="gallina-kwd"> exists</span><span class="id"> y</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ub_lbN</span><span class="id"> E</span><span class="id"> x</span><span class="id"> :</span><span class="id"> ubound</span><span class="id"> E</span><span class="id"> x</span><span class="id"> &lt;-&gt;</span><span class="id"> lbound</span> (<span class="id">-%R</span><span class="id"> @`</span><span class="id"> E</span>) (<span class="id">-</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [?</span><span class="id"> |</span><span class="id"> /lb_ubN];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/lb_ubN;</span><span class="id"> rewrite</span><span class="id"> opprK</span><span class="id"> setNK</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> opprK</span><span class="id"> setNK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> memNE</span><span class="id"> E</span><span class="id"> x</span><span class="id"> :</span><span class="id"> E</span><span class="id"> x</span><span class="id"> =</span> (<span class="id">-%R</span><span class="id"> @`</span><span class="id"> E</span>) (<span class="id">-</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> image_inj</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> oppr_inj</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nonemptyN</span><span class="id"> E</span><span class="id"> :</span><span class="id"> nonempty</span> (<span class="id">-%R</span><span class="id"> @`</span><span class="id"> E</span>)<span class="id"> &lt;-&gt;</span><span class="id"> nonempty</span><span class="id"> E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [[x</span><span class="id"> ENx]|[x</span><span class="id"> Ex]];</span><span class="gallina-kwd"> exists</span> (<span class="id">-</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -memNE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> memNE</span><span class="id"> opprK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> opp_set_eq0</span><span class="id"> E</span><span class="id"> :</span> (<span class="id">-%R</span><span class="id"> @`</span><span class="id"> E</span>)<span class="id"> =</span><span class="id"> set0</span><span class="id"> &lt;-&gt;</span><span class="id"> E</span><span class="id"> =</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split;</span><span class="id"> apply:</span><span class="id"> contraPP</span><span class="id"> =&gt;</span><span class="id"> /eqP/set0P/nonemptyN/set0P/eqP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_lb_ubN</span><span class="id"> E</span><span class="id"> :</span><span class="id"> has_lbound</span><span class="id"> E</span><span class="id"> &lt;-&gt;</span><span class="id"> has_ubound</span> (<span class="id">-%R</span><span class="id"> @`</span><span class="id"> E</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> [[x</span><span class="id"> /lb_ubN]</span><span class="id"> |</span><span class="id"> [x</span><span class="id"> /ub_lbN]];</span><span class="id"> [|rewrite</span><span class="id"> setNK];</span><span class="gallina-kwd"> exists</span> (<span class="id">-</span><span class="id"> x</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> subr_image</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> interval_hasNbound</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> R</span><span class="id"> :</span><span class="id"> realDomainType</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> E</span><span class="id"> :</span><span class="id"> set</span><span class="id"> R</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> x</span><span class="id"> :</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_ubPn</span><span class="id"> {E}</span><span class="id"> :</span><span class="id"> ~</span><span class="id"> has_ubound</span><span class="id"> E</span><span class="id"> &lt;-&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="gallina-kwd"> exists2</span><span class="id"> y,</span><span class="id"> E</span><span class="id"> y</span><span class="id"> &amp;</span><span class="id"> x</span><span class="id"> &lt;</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> h</span><span class="id"> [x]</span><span class="id"> /ubP</span><span class="id"> hle;</span><span class="id"> case/</span>(_<span class="id"> x</span>)<span class="id">:</span><span class="id"> h</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> /hle</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> leNgt</span><span class="id"> =&gt;</span><span class="id"> /negbTE</span><span class="id"> -&gt;</span>.<br/>
<span class="id">move/forallNP</span><span class="id"> =&gt;</span><span class="id"> h</span><span class="id"> x;</span><span class="id"> have</span><span class="id"> {h}</span><span class="id"> :=</span><span class="id"> h</span><span class="id"> x</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /ubP</span><span class="id"> /existsNP</span><span class="id"> =&gt;</span><span class="id"> -[y</span><span class="id"> /not_implyP[Ey</span><span class="id"> /negP]]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -ltNge</span><span class="id"> =&gt;</span><span class="id"> ltx;</span><span class="gallina-kwd"> exists</span><span class="id"> y</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_lbPn</span><span class="id"> E</span><span class="id"> :</span><span class="id"> ~</span><span class="id"> has_lbound</span><span class="id"> E</span><span class="id"> &lt;-&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="gallina-kwd"> exists2</span><span class="id"> y,</span><span class="id"> E</span><span class="id"> y</span><span class="id"> &amp;</span><span class="id"> y</span><span class="id"> &lt;</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [/has_lb_ubN</span><span class="id"> /has_ubPn</span><span class="id"> NEnub</span><span class="id"> x|Enlb</span><span class="id"> /has_lb_ubN]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [y</span><span class="id"> ENy</span><span class="id"> ltxy]</span><span class="id"> :=</span><span class="id"> NEnub</span> (<span class="id">-</span><span class="id"> x</span>)<span class="id">;</span><span class="gallina-kwd"> exists</span> (<span class="id">-</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> 1?ltrNl</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ENy</span><span class="id"> =&gt;</span><span class="id"> z</span><span class="id"> Ez</span><span class="id"> &lt;-;</span><span class="id"> rewrite</span><span class="id"> opprK</span>.<br/>
<span class="id">apply/has_ubPn</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> have</span><span class="id"> [y</span><span class="id"> Ey</span><span class="id"> ltyx]</span><span class="id"> :=</span><span class="id"> Enlb</span> (<span class="id">-</span><span class="id"> x</span>).<br/>
<span class="gallina-kwd">exists</span> (<span class="id">-</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ltrNr</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> opprK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> hasNlbound_itv</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> itv_bound</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> a</span><span class="id"> !=</span><span class="id"> -oo%O</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">~</span><span class="id"> has_lbound</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> -oo%O</span><span class="id"> a]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move:</span><span class="id"> a</span><span class="id"> =&gt;</span><span class="id"> [b</span><span class="id"> r|[|]]</span><span class="id"> _</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">suff:</span><span class="id"> ~</span><span class="id"> has_lbound</span><span class="id"> `]-oo,</span><span class="id"> r[%classic</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> b</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply/contra_not/subset_has_lbound</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /ltW</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/has_lbPn</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="gallina-kwd"> exists</span> (<span class="id">minr</span> (<span class="id">r</span><span class="id"> -</span><span class="id"> 1</span>) (<span class="id">x</span><span class="id"> -</span><span class="id"> 1</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !set_itvE/=</span><span class="id"> gt_min</span><span class="id"> ltrBlDr</span><span class="id"> ltrDl</span><span class="id"> ltr01</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> gt_min</span><span class="id"> orbC</span><span class="id"> ltrBlDr</span><span class="id"> ltrDl</span><span class="id"> ltr01</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> r</span><span class="id"> /</span>(_ (<span class="id">r</span><span class="id"> -</span><span class="id"> 1</span>))<span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> in_itv</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> erefl</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/negP;</span><span class="id"> rewrite</span><span class="id"> -ltNge</span><span class="id"> ltrBlDr</span><span class="id"> ltrDl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> hasNubound_itv</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> itv_bound</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> a</span><span class="id"> !=</span><span class="id"> +oo%O</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">~</span><span class="id"> has_ubound</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> a</span><span class="id"> +oo%O]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move:</span><span class="id"> a</span><span class="id"> =&gt;</span><span class="id"> [b</span><span class="id"> r|[|]]</span><span class="id"> _</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">suff:</span><span class="id"> ~</span><span class="id"> has_ubound</span><span class="id"> `]r,</span><span class="id"> +oo[%classic</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case:</span><span class="id"> b</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply/contra_not/subset_has_ubound</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !set_itvE</span><span class="id"> =&gt;</span><span class="id"> /ltW</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/has_ubPn</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !set_itvE;</span><span class="gallina-kwd"> exists</span> (<span class="id">maxr</span> (<span class="id">r</span><span class="id"> +</span><span class="id"> 1</span>) (<span class="id">x</span><span class="id"> +</span><span class="id"> 1</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ?in_itv</span><span class="id"> /=</span><span class="id"> ?andbT</span><span class="id"> lt_max</span><span class="id"> ltrDl</span><span class="id"> ltr01</span><span class="id"> //</span><span class="id"> orbT</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> r</span><span class="id"> /</span>(_ (<span class="id">r</span><span class="id"> +</span><span class="id"> 1</span>))<span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> in_itv</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> erefl</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/negP;</span><span class="id"> rewrite</span><span class="id"> -ltNge</span><span class="id"> ltrDl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> interval_hasNbound</span>.<br/>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">has_lbound</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> solve[apply:</span><span class="id"> has_lbound_itv]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">has_ubound</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> solve[apply:</span><span class="id"> has_ubound_itv]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[global]</span><br/>
<span class="vernacular">Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">~</span><span class="id"> has_lbound</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> solve[by</span><span class="id"> apply:</span><span class="id"> hasNlbound_itv]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[global]</span><br/>
<span class="vernacular">Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">~</span><span class="id"> has_ubound</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> solve[by</span><span class="id"> apply:</span><span class="id"> hasNubound_itv]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> opp_itv_bnd_infty</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numDomainType</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> b</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">-%R</span><span class="id"> @`</span><span class="id"> [set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> b</span><span class="id"> x</span>)<span class="id"> +oo%O]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span><span class="id"> -oo%O</span> (<span class="id">BSide</span> (<span class="id">negb</span><span class="id"> b</span>) (<span class="id">-</span><span class="id"> x</span>))<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> r;</span><span class="id"> split=&gt;</span><span class="id"> [[y</span><span class="id"> xy</span><span class="id"> &lt;-]|xr]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> b</span><span class="id"> xy;</span><span class="id"> rewrite</span><span class="id"> !in_itv/=</span><span class="id"> andbT</span> (<span class="id">lerN2,</span><span class="id"> ltrN2</span>).<br/>
<span class="gallina-kwd">exists</span> (<span class="id">-</span><span class="id"> r</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?opprK</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> b</span><span class="id"> xr;</span><span class="id"> rewrite</span><span class="id"> !in_itv/=</span><span class="id"> andbT</span> (<span class="id">lerNr,</span><span class="id"> ltrNr</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> opp_itv_infty_bnd</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numDomainType</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> b</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">-%R</span><span class="id"> @`</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> -oo%O</span> (<span class="id">BSide</span><span class="id"> b</span><span class="id"> x</span>)<span class="id">]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span> (<span class="id">BSide</span> (<span class="id">negb</span><span class="id"> b</span>) (<span class="id">-</span><span class="id"> x</span>))<span class="id"> +oo%O]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> r;</span><span class="id"> split=&gt;</span><span class="id"> [[y</span><span class="id"> xy</span><span class="id"> &lt;-]|xr]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> b</span><span class="id"> xy;</span><span class="id"> rewrite</span><span class="id"> !in_itv/=</span><span class="id"> andbT</span> (<span class="id">lerN2,</span><span class="id"> ltrN2</span>).<br/>
<span class="gallina-kwd">exists</span> (<span class="id">-</span><span class="id"> r</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?opprK</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> b</span><span class="id"> xr;</span><span class="id"> rewrite</span><span class="id"> !in_itv/=</span><span class="id"> andbT</span> (<span class="id">lerNl,</span><span class="id"> ltrNl</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> opp_itv_bnd_bnd</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numDomainType</span>)<span class="id"> a</span><span class="id"> b</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">-%R</span><span class="id"> @`</span><span class="id"> [set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> a</span><span class="id"> x</span>) (<span class="id">BSide</span><span class="id"> b</span><span class="id"> y</span>)<span class="id">]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span> (<span class="id">BSide</span> (<span class="id">~~</span><span class="id"> b</span>) (<span class="id">-</span><span class="id"> y</span>)) (<span class="id">BSide</span> (<span class="id">~~</span><span class="id"> a</span>) (<span class="id">-</span><span class="id"> x</span>))<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> r;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [[{}r</span><span class="id"> +</span><span class="id"> &lt;-]|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !in_itv/=</span><span class="id"> 2!lteifN2</span><span class="id"> negbK</span><span class="id"> andbC</span>.<br/>
<span class="id">rewrite</span><span class="id"> in_itv/=</span><span class="id"> negbK</span><span class="id"> =&gt;</span><span class="id"> yrab</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">-</span><span class="id"> r</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?opprK//</span><span class="id"> !in_itv</span><span class="id"> lteifNr</span><span class="id"> andbC</span><span class="id"> lteifNl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> opp_itvoo</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numDomainType</span>) (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">-%R</span><span class="id"> @`</span><span class="id"> `]x,</span><span class="id"> y[%classic</span><span class="id"> =</span><span class="id"> `]</span>(<span class="id">-</span><span class="id"> y</span>)<span class="id">,</span> (<span class="id">-</span><span class="id"> x</span>)<span class="id">[%classic</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> r;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [[{}r</span><span class="id"> +</span><span class="id"> &lt;-]|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !in_itv/=</span><span class="id"> !ltrN2</span><span class="id"> andbC</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">-</span><span class="id"> r</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?opprK//</span><span class="id"> !in_itv/=</span><span class="id"> ltrNl</span><span class="id"> ltrNr</span><span class="id"> andbC</span>.<br/>
Qed.</div></details>
<br/>
<div class="doc">lemmas between itv and set-theoretic operations </div>
<span class="vernacular">Section</span><span class="id"> set_itv_porderType</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">d</span><span class="id"> :</span><span class="id"> Order</span>.<span class="id">disp_t</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> orderType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> itv_bound</span><span class="id"> T</span>) (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">i</span><span class="id"> j</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> T</span>) (<span class="id">b</span><span class="id"> :</span><span class="id"> bool</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setCitvl</span><span class="id"> a</span><span class="id"> :</span><span class="id"> ~`</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> -oo%O</span><span class="id"> a]</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> a</span><span class="id"> +oo%O]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/predeqP</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -predC_itvl</span> (<span class="id">rwP</span><span class="id"> negP</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setCitvr</span><span class="id"> a</span><span class="id"> :</span><span class="id"> ~`</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> a</span><span class="id"> +oo%O]</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> -oo%O</span><span class="id"> a]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setCitvl</span><span class="id"> setCK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itv_splitI</span><span class="id"> i</span><span class="id"> :</span><span class="id"> [set`</span><span class="id"> i]</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> i</span>.<span class="id">1</span><span class="id"> +oo%O]</span><span class="id"> `&amp;`</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> -oo%O</span><span class="id"> i</span>.<span class="id">2]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case:</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> [a</span><span class="id"> a'];</span><span class="id"> apply/predeqP=&gt;</span><span class="id"> x/=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [in</span><span class="id"> X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> &lt;-&gt;</span><span class="id"> _]itv_splitI</span> (<span class="id">rwP</span><span class="id"> andP</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setCitv</span><span class="id"> i</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">~`</span><span class="id"> [set`</span><span class="id"> i]</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> -oo%O</span><span class="id"> i</span>.<span class="id">1]</span><span class="id"> `|`</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> i</span>.<span class="id">2</span><span class="id"> +oo%O]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply/predeqP</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span> (<span class="id">rwP</span><span class="id"> orP</span>) (<span class="id">rwP</span><span class="id"> negP</span>)<span class="id"> [x</span><span class="id"> \notin</span><span class="id"> i]predC_itv</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_itv_splitD</span><span class="id"> i</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> i]</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> i</span>.<span class="id">1</span><span class="id"> +oo%O]</span><span class="id"> `\`</span><span class="id"> [set`</span><span class="id"> Interval</span><span class="id"> i</span>.<span class="id">2</span><span class="id"> +oo%O]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> set_itv_splitI/=</span><span class="id"> setDE</span><span class="id"> setCitvr</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> set_itv_porderType</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> line_path_factor_numDomainType</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> R</span><span class="id"> :</span><span class="id"> numDomainType</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">a</span><span class="id"> b</span><span class="id"> t</span><span class="id"> r</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_1B_itvcc</span><span class="id"> t</span><span class="id"> :</span> (<span class="id">1</span><span class="id"> -</span><span class="id"> t</span><span class="id"> \in</span><span class="id"> `[0,</span><span class="id"> 1]</span>)<span class="id"> =</span> (<span class="id">t</span><span class="id"> \in</span><span class="id"> `[0,</span><span class="id"> 1]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !in_itv/=</span><span class="id"> subr_ge0</span><span class="id"> gerDl</span><span class="id"> oppr_le0</span><span class="id"> andbC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> line_path</span><span class="id"> a</span><span class="id"> b</span><span class="id"> t</span><span class="id"> :</span><span class="id"> R</span><span class="id"> :=</span> (<span class="id">1</span><span class="id"> -</span><span class="id"> t</span>)<span class="id"> *</span><span class="id"> a</span><span class="id"> +</span><span class="id"> t</span><span class="id"> *</span><span class="id"> b</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> line_path_id</span><span class="id"> :</span><span class="id"> line_path</span><span class="id"> 0</span><span class="id"> 1</span><span class="id"> =</span><span class="id"> id</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/funext</span><span class="id"> =&gt;</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> /line_path</span><span class="id"> mulr0</span><span class="id"> add0r</span><span class="id"> mulr1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> line_pathEl</span><span class="id"> a</span><span class="id"> b</span><span class="id"> t</span><span class="id"> :</span><span class="id"> line_path</span><span class="id"> a</span><span class="id"> b</span><span class="id"> t</span><span class="id"> =</span><span class="id"> t</span><span class="id"> *</span> (<span class="id">b</span><span class="id"> -</span><span class="id"> a</span>)<span class="id"> +</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /line_path</span><span class="id"> mulrBl</span><span class="id"> mul1r</span><span class="id"> mulrBr</span><span class="id"> addrAC</span><span class="id"> [RHS]addrC</span><span class="id"> addrA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> line_pathEr</span><span class="id"> a</span><span class="id"> b</span><span class="id"> t</span><span class="id"> :</span><span class="id"> line_path</span><span class="id"> a</span><span class="id"> b</span><span class="id"> t</span><span class="id"> =</span> (<span class="id">1</span><span class="id"> -</span><span class="id"> t</span>)<span class="id"> *</span> (<span class="id">a</span><span class="id"> -</span><span class="id"> b</span>)<span class="id"> +</span><span class="id"> b</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /line_path</span><span class="id"> mulrBr</span><span class="id"> -addrA;</span><span class="id"> congr</span> (_<span class="id"> +</span><span class="id"> _</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulrBl</span><span class="id"> opprB</span><span class="id"> mul1r</span><span class="id"> addrNK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> line_path10</span><span class="id"> t</span><span class="id"> :</span><span class="id"> line_path</span><span class="id"> 1</span><span class="id"> 0</span><span class="id"> t</span><span class="id"> =</span><span class="id"> 1</span><span class="id"> -</span><span class="id"> t</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /line_path</span><span class="id"> mulr0</span><span class="id"> addr0</span><span class="id"> mulr1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> line_path0</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> line_path</span><span class="id"> a</span><span class="id"> b</span><span class="id"> 0</span><span class="id"> =</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /line_path</span><span class="id"> subr0</span><span class="id"> mul1r</span><span class="id"> mul0r</span><span class="id"> addr0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> line_path1</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> line_path</span><span class="id"> a</span><span class="id"> b</span><span class="id"> 1</span><span class="id"> =</span><span class="id"> b</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /line_path</span><span class="id"> subrr</span><span class="id"> mul0r</span><span class="id"> add0r</span><span class="id"> mul1r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> line_path_sym</span><span class="id"> a</span><span class="id"> b</span><span class="id"> t</span><span class="id"> :</span><span class="id"> line_path</span><span class="id"> a</span><span class="id"> b</span><span class="id"> t</span><span class="id"> =</span><span class="id"> line_path</span><span class="id"> b</span><span class="id"> a</span> (<span class="id">1</span><span class="id"> -</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /line_path</span><span class="id"> subKr</span><span class="id"> addrC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> line_path_flat</span><span class="id"> a</span><span class="id"> :</span><span class="id"> line_path</span><span class="id"> a</span><span class="id"> a</span><span class="id"> =</span><span class="id"> cst</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/funext</span><span class="id"> =&gt;</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> line_pathEl</span><span class="id"> subrr</span><span class="id"> mulr0</span><span class="id"> add0r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> leW_line_path</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;=</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> {homo</span><span class="id"> line_path</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> y}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> !line_pathEl</span><span class="id"> lerD</span><span class="id"> ?ler_wpM2r//</span><span class="id"> subr_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> factor</span><span class="id"> a</span><span class="id"> b</span><span class="id"> x</span><span class="id"> :=</span> (<span class="id">x</span><span class="id"> -</span><span class="id"> a</span>)<span class="id"> /</span> (<span class="id">b</span><span class="id"> -</span><span class="id"> a</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> leW_factor</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;=</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> {homo</span><span class="id"> factor</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> y}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> /factor</span><span class="id"> ler_wpM2r</span><span class="id"> ?lerD//</span><span class="id"> invr_ge0</span><span class="id"> subr_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> factor_flat</span><span class="id"> a</span><span class="id"> :</span><span class="id"> factor</span><span class="id"> a</span><span class="id"> a</span><span class="id"> =</span><span class="id"> cst</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/funext</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /factor</span><span class="id"> subrr</span><span class="id"> invr0</span><span class="id"> mulr0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> factorl</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> factor</span><span class="id"> a</span><span class="id"> b</span><span class="id"> a</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /factor</span><span class="id"> subrr</span><span class="id"> mul0r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> ndline_path</span><span class="id"> a</span><span class="id"> b</span><span class="id"> of</span><span class="id"> a</span><span class="id"> &lt;</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> line_path</span><span class="id"> a</span><span class="id"> b</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ndline_pathE</span><span class="id"> a</span><span class="id"> b</span> (<span class="id">ab</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;</span><span class="id"> b</span>)<span class="id"> :</span><span class="id"> ndline_path</span><span class="id"> ab</span><span class="id"> =</span><span class="id"> line_path</span><span class="id"> a</span><span class="id"> b</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> line_path_factor_numDomainType</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> line_path_factor_numFieldType</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> R</span><span class="id"> :</span><span class="id"> numFieldType</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">a</span><span class="id"> b</span><span class="id"> t</span><span class="id"> r</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> factorr</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> !=</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> factor</span><span class="id"> a</span><span class="id"> b</span><span class="id"> b</span><span class="id"> =</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Nab;</span><span class="id"> rewrite</span><span class="id"> /factor</span><span class="id"> divff//</span><span class="id"> subr_eq0</span><span class="id"> eq_sym</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> factorK</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> !=</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> cancel</span> (<span class="id">factor</span><span class="id"> a</span><span class="id"> b</span>) (<span class="id">line_path</span><span class="id"> a</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> line_pathEl</span><span class="id"> mulfVK</span><span class="id"> ?addrNK//</span><span class="id"> subr_eq0</span><span class="id"> eq_sym</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> line_pathK</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> !=</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> cancel</span> (<span class="id">line_path</span><span class="id"> a</span><span class="id"> b</span>) (<span class="id">factor</span><span class="id"> a</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /factor</span><span class="id"> line_pathEl</span><span class="id"> addrK</span><span class="id"> mulfK//</span><span class="id"> subr_eq0</span><span class="id"> eq_sym</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> line_path_inj</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> !=</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> injective</span> (<span class="id">line_path</span><span class="id"> a</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/line_pathK/can_inj</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> factor_inj</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> !=</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> injective</span> (<span class="id">factor</span><span class="id"> a</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/factorK/can_inj</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> line_path_bij</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> !=</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> bijective</span> (<span class="id">line_path</span><span class="id"> a</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ab;</span><span class="id"> apply:</span><span class="id"> Bijective</span> (<span class="id">line_pathK</span><span class="id"> ab</span>) (<span class="id">factorK</span><span class="id"> ab</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> factor_bij</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> !=</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> bijective</span> (<span class="id">factor</span><span class="id"> a</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ab;</span><span class="id"> apply:</span><span class="id"> Bijective</span> (<span class="id">factorK</span><span class="id"> ab</span>) (<span class="id">line_pathK</span><span class="id"> ab</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_line_path</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> {mono</span><span class="id"> line_path</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> y}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ltab;</span><span class="id"> have</span><span class="id"> leab</span><span class="id"> :=</span><span class="id"> ltW</span><span class="id"> ltab</span>.<br/>
<span class="id">apply:</span><span class="id"> homo_mono</span> (<span class="id">line_pathK</span><span class="id"> _</span>) (<span class="id">leW_factor</span><span class="id"> _</span>) (<span class="id">leW_line_path</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> lt_eqF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_factor</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> {mono</span><span class="id"> factor</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> y}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ltab;</span><span class="id"> have</span><span class="id"> leab</span><span class="id"> :=</span><span class="id"> ltW</span><span class="id"> ltab</span>.<br/>
<span class="id">apply:</span><span class="id"> homo_mono</span> (<span class="id">factorK</span><span class="id"> _</span>) (<span class="id">leW_line_path</span><span class="id"> _</span>) (<span class="id">leW_factor</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> lt_eqF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lt_line_path</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> {mono</span><span class="id"> line_path</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /</span><span class="id"> x</span><span class="id"> &lt;</span><span class="id"> y}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/le_line_path/leW_mono</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lt_factor</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> {mono</span><span class="id"> factor</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /</span><span class="id"> x</span><span class="id"> &lt;</span><span class="id"> y}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/le_factor/leW_mono</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> ltNeq</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> a</span><span class="id"> !=</span><span class="id"> b</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /lt_eqF-&gt;</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> a</span><span class="id"> b</span> (<span class="id">ab</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;</span><span class="id"> b</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@Can2</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> setT</span><span class="id"> setT</span> (<span class="id">ndline_path</span><span class="id"> ab</span>) (<span class="id">factor</span><span class="id"> a</span><span class="id"> b</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> I</span>) (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">in1W</span> (<span class="id">line_pathK</span> (<span class="id">ltNeq</span><span class="id"> ab</span>))) (<span class="id">in1W</span> (<span class="id">factorK</span> (<span class="id">ltNeq</span><span class="id"> ab</span>))).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> line_path_itv_bij</span><span class="id"> ba</span><span class="id"> bb</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;</span><span class="id"> b</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">set_bij</span><span class="id"> [set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> ba</span><span class="id"> 0</span>) (<span class="id">BSide</span><span class="id"> bb</span><span class="id"> 1</span>)<span class="id">]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> ba</span><span class="id"> a</span>) (<span class="id">BSide</span><span class="id"> bb</span><span class="id"> b</span>)<span class="id">]</span> (<span class="id">line_path</span><span class="id"> a</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ltab;</span><span class="id"> rewrite</span><span class="id"> -ndline_pathE</span>.<br/>
<span class="id">apply:</span><span class="id"> bij_subr</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> setTI</span><span class="id"> ?ndline_pathE</span>.<br/>
<span class="id">apply/predeqP</span><span class="id"> =&gt;</span><span class="id"> t</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> !in_itv/=</span><span class="id"> {1}line_pathEl</span><span class="id"> line_pathEr</span>.<br/>
<span class="id">rewrite</span><span class="id"> -lteifBlDr</span><span class="id"> subrr</span><span class="id"> -lteif_pdivrMr</span><span class="id"> ?subr_gt0//</span><span class="id"> mul0r</span>.<br/>
<span class="id">rewrite</span><span class="id"> -lteifBrDr</span><span class="id"> subrr</span><span class="id"> -lteif_ndivrMr</span><span class="id"> ?subr_lt0//</span><span class="id"> mul0r</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> lteifBrDl</span><span class="id"> addr0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> factor_itv_bij</span><span class="id"> ba</span><span class="id"> bb</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;</span><span class="id"> b</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">set_bij</span><span class="id"> [set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> ba</span><span class="id"> a</span>) (<span class="id">BSide</span><span class="id"> bb</span><span class="id"> b</span>)<span class="id">]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> ba</span><span class="id"> 0</span>) (<span class="id">BSide</span><span class="id"> bb</span><span class="id"> 1</span>)<span class="id">]</span> (<span class="id">factor</span><span class="id"> a</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ltab;</span><span class="id"> have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> factor</span><span class="id"> a</span><span class="id"> b</span><span class="id"> =</span> (<span class="id">ndline_path</span><span class="id"> ltab</span>)<span class="id">^-1%FUN</span><span class="gallina-kwd"> by</span><span class="id"> []</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/splitbij_sub_sym</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> line_path_itv_bij</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_line_path_itv</span><span class="id"> ba</span><span class="id"> bb</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;</span><span class="id"> b</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">set_fun</span><span class="id"> [set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> ba</span><span class="id"> 0</span>) (<span class="id">BSide</span><span class="id"> bb</span><span class="id"> 1</span>)<span class="id">]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> ba</span><span class="id"> a</span>) (<span class="id">BSide</span><span class="id"> bb</span><span class="id"> b</span>)<span class="id">]</span> (<span class="id">line_path</span><span class="id"> a</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case/</span>(<span class="id">line_path_itv_bij</span><span class="id"> ba</span><span class="id"> bb</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_line_path_itvcc</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;=</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> set_fun</span><span class="id"> `[0,</span><span class="id"> 1]</span><span class="id"> `[a,</span><span class="id"> b]</span> (<span class="id">line_path</span><span class="id"> a</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> le_eqVlt</span><span class="id"> =&gt;</span><span class="id"> /predU1P[&lt;-|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> set_itv1</span><span class="id"> line_path_flat</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> lt_ab;</span><span class="id"> case:</span> (<span class="id">line_path_itv_bij</span><span class="id"> true</span><span class="id"> false</span><span class="id"> lt_ab</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> range_line_path</span><span class="id"> ba</span><span class="id"> bb</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;</span><span class="id"> b</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">line_path</span><span class="id"> a</span><span class="id"> b</span><span class="id"> @`</span><span class="id"> [set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> ba</span><span class="id"> 0</span>) (<span class="id">BSide</span><span class="id"> bb</span><span class="id"> 1</span>)<span class="id">]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> ba</span><span class="id"> a</span>) (<span class="id">BSide</span><span class="id"> bb</span><span class="id"> b</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /</span>(<span class="id">line_path_itv_bij</span><span class="id"> ba</span><span class="id"> bb</span>)<span class="id">/Pbij[f</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> image_eq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> range_factor</span><span class="id"> ba</span><span class="id"> bb</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> a</span><span class="id"> &lt;</span><span class="id"> b</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">factor</span><span class="id"> a</span><span class="id"> b</span><span class="id"> @`</span><span class="id"> [set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> ba</span><span class="id"> a</span>) (<span class="id">BSide</span><span class="id"> bb</span><span class="id"> b</span>)<span class="id">]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> ba</span><span class="id"> 0</span>) (<span class="id">BSide</span><span class="id"> bb</span><span class="id"> 1</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /</span>(<span class="id">factor_itv_bij</span><span class="id"> ba</span><span class="id"> bb</span>)<span class="id">/Pbij[f</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> image_eq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> onem_factor</span><span class="id"> a</span><span class="id"> b</span><span class="id"> x</span><span class="id"> :</span><span class="id"> a</span><span class="id"> !=</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> `1-</span>(<span class="id">factor</span><span class="id"> a</span><span class="id"> b</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> factor</span><span class="id"> b</span><span class="id"> a</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> eq_sym</span><span class="id"> -subr_eq0</span><span class="id"> =&gt;</span><span class="id"> ab;</span><span class="id"> rewrite</span><span class="id"> /onem</span><span class="id"> /factor</span><span class="id"> -</span>(<span class="id">divff</span><span class="id"> ab</span>)<span class="id"> -mulrBl</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> opprB</span><span class="id"> addrA</span><span class="id"> subrK</span><span class="id"> -mulrNN</span><span class="id"> opprB</span><span class="id"> -invrN</span><span class="id"> opprB</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> line_path_factor_numFieldType</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_factor_itv</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<span class="id"> ba</span><span class="id"> bb</span> (<span class="id">a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">set_fun</span><span class="id"> [set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> ba</span><span class="id"> a</span>) (<span class="id">BSide</span><span class="id"> bb</span><span class="id"> b</span>)<span class="id">]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> Interval</span> (<span class="id">BSide</span><span class="id"> ba</span><span class="id"> 0</span>) (<span class="id">BSide</span><span class="id"> bb</span><span class="id"> 1</span>)<span class="id">]</span> (<span class="id">factor</span><span class="id"> a</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [|leba]</span><span class="id"> :=</span><span class="id"> ltP</span><span class="id"> a</span><span class="id"> b;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> case/</span>(<span class="id">factor_itv_bij</span><span class="id"> ba</span><span class="id"> bb</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> have</span><span class="id"> [|/itv_ge-&gt;//]</span><span class="id"> :=</span> (<span class="id">boolP</span> (<span class="id">BSide</span><span class="id"> ba</span><span class="id"> a</span><span class="id"> &lt;</span><span class="id"> BSide</span><span class="id"> bb</span><span class="id"> b</span>)<span class="id">%O</span>).<br/>
<span class="id">rewrite</span><span class="id"> lteBSide;</span><span class="id"> case:</span><span class="id"> ba</span><span class="id"> bb</span><span class="id"> =&gt;</span><span class="id"> []</span><span class="id"> []//=;</span><span class="id"> rewrite</span><span class="id"> ?le_gtF//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ltgtP</span><span class="id"> leba</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> factor_flat</span><span class="id"> in_itv/=</span><span class="id"> lexx</span><span class="id"> ler01</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> neitv_bnd1</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span> (<span class="id">interval</span><span class="id"> R</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">all</span><span class="id"> neitv</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> i</span>.<span class="id">1</span><span class="id"> !=</span><span class="id"> +oo%O</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /allP</span><span class="id"> sne</span><span class="id"> [a</span><span class="id"> b]</span><span class="id"> si</span><span class="id"> /=;</span><span class="id"> apply/negP</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> boo;</span><span class="id"> move:</span><span class="id"> si</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> boo</span><span class="id"> =&gt;</span><span class="id"> /sne</span><span class="id"> /negP;</span><span class="id"> apply;</span><span class="id"> rewrite</span><span class="id"> set_itv_infty_set0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> neitv_bnd2</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span> (<span class="id">interval</span><span class="id"> R</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">all</span><span class="id"> neitv</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> i</span>.<span class="id">2</span><span class="id"> !=</span><span class="id"> -oo%O</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /allP</span><span class="id"> sne</span><span class="id"> [a</span><span class="id"> b]</span><span class="id"> si</span><span class="id"> /=;</span><span class="id"> apply/negP</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> boo;</span><span class="id"> move:</span><span class="id"> si</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> boo</span><span class="id"> =&gt;</span><span class="id"> /sne</span><span class="id"> /negP;</span><span class="id"> apply;</span><span class="id"> rewrite</span><span class="id"> set_itv_infty_set0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> trivIset_set_itv_nth</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numDomainType</span>)<span class="id"> def</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span> (<span class="id">interval</span><span class="id"> R</span>))<br/>
&nbsp;&nbsp;(<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> nat</span>)<span class="id"> :</span><span class="id"> [set`</span><span class="id"> def]</span><span class="id"> =</span><span class="id"> set0</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">trivIset</span><span class="id"> D</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> [set`</span><span class="id"> nth</span><span class="id"> def</span><span class="id"> s</span><span class="id"> i]</span>)<span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">trivIset</span><span class="id"> D</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> nth</span><span class="id"> set0</span><span class="id"> [seq</span><span class="id"> [set`</span><span class="id"> j]</span><span class="id"> |</span><span class="id"> j</span><span class="id"> &lt;-</span><span class="id"> s]</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> def0;</span><span class="id"> split=&gt;</span><span class="id"> /trivIsetP</span><span class="id"> ss;</span><span class="id"> apply/trivIsetP</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> Di</span><span class="id"> Dj</span><span class="id"> ij</span>.<br/>
<span class="id">-</span><span class="id"> have</span><span class="id"> [si|si]</span><span class="id"> :=</span><span class="id"> ltP</span><span class="id"> i</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">nth_default</span><span class="id"> set0</span>)<span class="id"> ?size_map//</span><span class="id"> set0I</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [sj|sj]</span><span class="id"> :=</span><span class="id"> ltP</span><span class="id"> j</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIC</span> (<span class="id">nth_default</span><span class="id"> set0</span>)<span class="id"> ?size_map//</span><span class="id"> set0I</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">nth_map</span><span class="id"> def</span>)<span class="id"> //</span> (<span class="id">nth_map</span><span class="id"> def</span>)<span class="id"> //</span><span class="id"> ss</span>.<br/>
<span class="id">-</span><span class="id"> have</span><span class="id"> [?|h]</span><span class="id"> :=</span><span class="id"> ltP</span><span class="id"> i</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">nth_default</span><span class="id"> def</span><span class="id"> h</span>)<span class="id"> def0</span><span class="id"> set0I</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [?|h]</span><span class="id"> :=</span><span class="id"> ltP</span><span class="id"> j</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">nth_default</span><span class="id"> def</span><span class="id"> h</span>)<span class="id"> def0</span><span class="id"> setI0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> ss</span><span class="id"> _</span><span class="id"> _</span><span class="id"> Di</span><span class="id"> Dj</span><span class="id"> ij;</span><span class="id"> rewrite</span> (<span class="id">nth_map</span><span class="id"> def</span>)<span class="id"> //</span> (<span class="id">nth_map</span><span class="id"> def</span>).<br/>
Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> trivIset_set_itv_nth</span><span class="id"> {R}</span><span class="id"> _</span><span class="id"> {s}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> disjoint_itv</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> numDomainType}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> disjoint_itv</span><span class="id"> :</span><span class="id"> rel</span> (<span class="id">interval</span><span class="id"> R</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> a</span><span class="id"> b</span><span class="id"> =&gt;</span><span class="id"> [disjoint</span><span class="id"> [set`</span><span class="id"> a]</span><span class="id"> &amp;</span><span class="id"> [set`</span><span class="id"> b]]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> disjoint_itvxx</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> neitv</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> ~~</span><span class="id"> disjoint_itv</span><span class="id"> i</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> i0;</span><span class="id"> rewrite</span><span class="id"> /disjoint_itv/=</span><span class="id"> /disj_set</span><span class="id"> /=</span><span class="id"> setIid</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lt_disjoint</span> (<span class="id">i</span><span class="id"> j</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> j</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> &lt;</span><span class="id"> y</span>)<span class="id"> -&gt;</span><span class="id"> disjoint_itv</span><span class="id"> i</span><span class="id"> j</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ij;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[xi</span><span class="id"> xj]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> ij</span><span class="id"> _</span><span class="id"> _</span><span class="id"> xi</span><span class="id"> xj;</span><span class="id"> rewrite</span><span class="id"> ltxx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> disjoint_itv</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> disjoint_neitv</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realFieldType}</span> (<span class="id">i</span><span class="id"> j</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">disjoint_itv</span><span class="id"> i</span><span class="id"> j</span><span class="id"> &lt;-&gt;</span><span class="id"> ~~</span><span class="id"> neitv</span> (<span class="id">itv_meet</span><span class="id"> i</span><span class="id"> j</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case:</span><span class="id"> i</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> [a</span><span class="id"> b]</span><span class="id"> [c</span><span class="id"> d];</span><span class="id"> rewrite</span><span class="id"> /disjoint_itv/disj_set</span><span class="id"> /=</span><span class="id"> -set_itvI</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [/negPn//|?];</span><span class="id"> apply/negPn</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> open_endpoints</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {d}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> porderType</span><span class="id"> d}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> is_open_itv</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><span class="gallina-kwd"> exists</span><span class="id"> ab,</span><span class="id"> A</span><span class="id"> =</span><span class="id"> `]ab</span>.<span class="id">1,</span><span class="id"> ab</span>.<span class="id">2[%classic</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> open_itv_cover</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><span class="id"> [set</span><span class="id"> F</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span><span class="id"> |</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> is_open_itv</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> /\</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> \bigcup_k</span> (<span class="id">F</span><span class="id"> k</span>)<span class="id">]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> itv_is_ray</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> T</span>)<span class="id"> :</span><span class="gallina-kwd"> Prop</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span><span class="id"> i</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> Interval</span><span class="id"> -oo%O</span> (<span class="id">BLeft</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> True</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> Interval</span> (<span class="id">BRight</span><span class="id"> _</span>)<span class="id"> +oo%O</span><span class="id"> =&gt;</span><span class="id"> True</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> Interval</span><span class="id"> -oo%O</span><span class="id"> +oo%O</span><span class="id"> =&gt;</span><span class="id"> True</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> False</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> itv_is_bd_open</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> T</span>)<span class="id"> :</span><span class="gallina-kwd"> Prop</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span><span class="id"> i</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> Interval</span> (<span class="id">BRight</span><span class="id"> _</span>) (<span class="id">BLeft</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> True</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> False</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> itv_open_ends</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> T</span>)<span class="id"> :</span><span class="gallina-kwd"> Prop</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">itv_is_ray</span><span class="id"> i</span><span class="id"> \/</span><span class="id"> itv_is_bd_open</span><span class="id"> i</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> itv_open_ends_rside</span><span class="id"> l</span><span class="id"> b</span> (<span class="id">t</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">itv_open_ends</span> (<span class="id">Interval</span><span class="id"> l</span> (<span class="id">BSide</span><span class="id"> b</span><span class="id"> t</span>))<span class="id"> -&gt;</span><span class="id"> b</span><span class="id"> =</span><span class="id"> true</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> b;</span><span class="id"> move:</span><span class="id"> l</span><span class="id"> =&gt;</span><span class="id"> [[]?|[]]</span><span class="id"> //</span><span class="id"> []</span><span class="id"> //</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> itv_open_ends_rinfty</span><span class="id"> l</span><span class="id"> b</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">itv_open_ends</span> (<span class="id">Interval</span><span class="id"> l</span> (<span class="id">BInfty</span><span class="id"> T</span><span class="id"> b</span>))<span class="id"> -&gt;</span><span class="id"> b</span><span class="id"> =</span><span class="id"> false</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> b</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> move:</span><span class="id"> l</span><span class="id"> =&gt;</span><span class="id"> [[]?|[]]</span><span class="id"> //</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> itv_open_ends_lside</span><span class="id"> l</span><span class="id"> b</span> (<span class="id">t</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">itv_open_ends</span> (<span class="id">Interval</span> (<span class="id">BSide</span><span class="id"> b</span><span class="id"> t</span>)<span class="id"> l</span>)<span class="id"> -&gt;</span><span class="id"> b</span><span class="id"> =</span><span class="id"> false</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> b;</span><span class="id"> move:</span><span class="id"> l</span><span class="id"> =&gt;</span><span class="id"> [[]?|[]]</span><span class="id"> //</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> itv_open_ends_linfty</span><span class="id"> l</span><span class="id"> b</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">itv_open_ends</span> (<span class="id">Interval</span> (<span class="id">BInfty</span><span class="id"> T</span><span class="id"> b</span>)<span class="id"> l</span>)<span class="id"> -&gt;</span><span class="id"> b</span><span class="id"> =</span><span class="id"> true</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> b</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> move:</span><span class="id"> l</span><span class="id"> =&gt;</span><span class="id"> [[]?|[]]</span><span class="id"> //</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> is_open_itv_itv_is_bd_openP</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">itv_is_bd_open</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> is_open_itv</span><span class="id"> [set`</span><span class="id"> i]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> i=&gt;</span><span class="id"> []</span><span class="id"> [[]l|[]]</span><span class="id"> //</span><span class="id"> [[]r|[]]</span><span class="id"> //</span><span class="id"> ?;</span><span class="gallina-kwd"> exists</span> (<span class="id">l,r</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> open_endpoints</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> itv_open_endsI</span><span class="id"> {d}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> orderType</span><span class="id"> d}</span> (<span class="id">i</span><span class="id"> j</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">itv_open_ends</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> itv_open_ends</span><span class="id"> j</span><span class="id"> -&gt;</span><span class="id"> itv_open_ends</span> (<span class="id">i</span><span class="id"> `&amp;`</span><span class="id"> j</span>)<span class="id">%O</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move:</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> [][[]a|[]]</span><span class="id"> [[]b|[]]</span><span class="id"> []//=</span><span class="id"> _;</span><span class="id"> move:</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> [][[]x|[]]</span><span class="id"> [[]y|[]]</span><span class="id"> []//=</span><span class="id"> _;</span><br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /itv_open_ends/=</span><span class="id"> ?orbF</span><span class="id"> ?andbT</span><span class="id"> -?negb_or</span><span class="id"> ?le_total//=;</span><br/>
&nbsp;&nbsp;<span class="id">try</span> ((<span class="gallina-kwd">by</span><span class="id"> left</span>)<span class="id">||</span>(<span class="gallina-kwd">by</span><span class="id"> right</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> itv_setU</span><span class="id"> {d}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> orderType</span><span class="id"> d}</span> (<span class="id">i</span><span class="id"> j</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> i]</span><span class="id"> `&amp;`</span><span class="id"> [set`</span><span class="id"> j]</span><span class="id"> !=set0</span><span class="id"> -&gt;</span><span class="id"> [set`</span> (<span class="id">i</span><span class="id"> `|`</span><span class="id"> j</span>)<span class="id">%O]</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> i]</span><span class="id"> `|`</span><span class="id"> [set`</span><span class="id"> j]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case=&gt;</span><span class="id"> p</span><span class="id"> [ip</span><span class="id"> jp];</span><span class="id"> have</span><span class="id"> pij</span><span class="id"> :</span><span class="id"> p</span><span class="id"> \in</span> (<span class="id">i</span><span class="id"> `|`</span><span class="id"> j</span>)<span class="id">%O</span><span class="gallina-kwd"> by</span><span class="id"> exact/</span>(<span class="id">le_trans</span><span class="id"> ip</span>)<span class="id">/leUl</span>.<br/>
<span class="id">move:</span><span class="id"> i</span><span class="id"> j</span><span class="id"> ip</span><span class="id"> jp</span><span class="id"> pij</span><span class="id"> =&gt;</span><span class="id"> [x</span><span class="id"> y]</span><span class="id"> [a</span><span class="id"> b]</span><span class="id"> /andP[xp</span><span class="id"> py]</span><span class="id"> /andP[ap</span><span class="id"> pb]</span><span class="id"> pab</span>.<br/>
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> r</span><span class="id"> /=;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> -[ra|rb];</span><span class="id"> [exact/</span>(<span class="id">le_trans</span><span class="id"> ra</span>)<span class="id">/leUl|exact/</span>(<span class="id">le_trans</span><span class="id"> rb</span>)<span class="id">/leUr]</span>.<br/>
<span class="id">rewrite</span> (<span class="id">@itv_splitUeq</span><span class="id"> _</span><span class="id"> T</span><span class="id"> p</span> (<span class="id">x</span><span class="id"> `&amp;`</span><span class="id"> a</span>)<span class="id">%O</span>)<span class="id">//</span><span class="id"> =&gt;</span><span class="id"> /orP[]</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> /andP[xar</span><span class="id"> rp];</span><span class="id"> have</span><span class="id"> /orP[ax|xa]</span><span class="id"> :=</span><span class="id"> le_total</span><span class="id"> a</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> right;</span><span class="id"> apply/andP;</span><span class="id"> split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span><span class="id"> xar</span>)<span class="id">//</span><span class="id"> leIidr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> rp</span>)<span class="id">//</span> (<span class="id">le_trans</span><span class="id"> _</span><span class="id"> pb</span>)<span class="id">//</span><span class="id"> bnd_simp</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> left;</span><span class="id"> apply/andP;</span><span class="id"> split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span><span class="id"> xar</span>)<span class="id">//</span><span class="id"> leIidl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> rp</span>)<span class="id">//</span> (<span class="id">le_trans</span><span class="id"> _</span><span class="id"> py</span>)<span class="id">//=</span><span class="id"> bnd_simp</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> /predU1P[-&gt;|/andP[pr</span><span class="id"> ryb]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> left;</span><span class="id"> apply/andP</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /orP[bly|ylb]</span><span class="id"> :=</span><span class="id"> le_total</span><span class="id"> b</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> left;</span><span class="id"> apply/andP;</span><span class="id"> split;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> ryb</span>)<span class="id">//</span><span class="id"> leUidr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span><span class="id"> pr</span>)<span class="id">//</span> (<span class="id">le_trans</span><span class="id"> xp</span>)<span class="id">//=</span><span class="id"> bnd_simp</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> right;</span><span class="id"> apply/andP;</span><span class="id"> split;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> ryb</span>)<span class="id">//</span><span class="id"> leUidl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> ap</span>)<span class="id">//</span> (<span class="id">le_trans</span><span class="id"> _</span><span class="id"> pr</span>)<span class="id">//=</span><span class="id"> bnd_simp</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> itv_setI</span><span class="id"> {d}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> orderType</span><span class="id"> d}</span> (<span class="id">i</span><span class="id"> j</span><span class="id"> :</span><span class="id"> interval</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span> (<span class="id">i</span><span class="id"> `&amp;`</span><span class="id"> j</span>)<span class="id">%O]</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> i]</span><span class="id"> `&amp;`</span><span class="id"> [set`</span><span class="id"> j]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> z;</span><span class="id"> rewrite</span><span class="id"> /in_mem/=</span><span class="id"> /pred_of_itv/=</span><span class="id"> lexI=&gt;</span><span class="id"> /andP</span>.<br/>
Qed.</div></details>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
