
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.analysis.charge</title>
<meta name="description" content="Documentation of Coq module mathcomp.analysis.charge" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.analysis.charge</h1>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> all_ssreflect</span><span class="id"> ssralg</span><span class="id"> ssrnum</span><span class="id"> ssrint</span><span class="id"> interval</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> finmap</span><span class="id"> fingroup</span><span class="id"> perm</span><span class="id"> rat</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> mathcomp_extra</span><span class="id"> boolp</span><span class="id"> classical_sets</span><span class="id"> cardinality</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> functions</span><span class="id"> fsbigop</span><span class="id"> set_interval</span>.<br/>
<span class="vernacular">From</span><span class="id"> HB</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> structures</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> reals</span><span class="id"> ereal</span><span class="id"> signed</span><span class="id"> topology</span><span class="id"> numfun</span><span class="id"> normedtype</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> sequences</span><span class="id"> esum</span><span class="id"> measure</span><span class="id"> realfun</span><span class="id"> lebesgue_measure</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> lebesgue_integral</span>.<br/>
<br/>
<div class="ssrdoc md">
# Charges

NB: See CONTRIBUTING.md for an introduction to HB concepts and commands.

This file contains a formalization of charges (a.k.a. signed measures) and
their theory (Hahn decomposition theorem, Radon-Nikodym derivative, etc.).

Reference:
- Y. Ishiguro, R. Affeldt. The Radon-Nikodym Theorem and the Lebesgue-
  Stieltjes measure in Coq. Computer Software 41(2) 2024

## Structures for functions on classes of sets
```
{additive_charge set T -&gt; \bar R} == notation for additive charges where
                             T is a semiring of sets and R is a
                             numFieldType
                             The HB class is AdditiveCharge.
 {charge set T -&gt; \bar R} == type of charges over T a semiring of sets
                             where R is a numFieldType
                             The HB class is Charge.
                 isCharge == factory corresponding to the "textbook
                             definition" of charges
```

## Instances of mathematical structures
```
 measure_of_charge nu nu0 == measure corresponding to the charge nu, nu0
                             is a proof that nu is non-negative
             crestr nu mD == restriction of the charge nu to the domain D
                             where mD is a proof that D is measurable
            crestr0 nu mD == csrestr nu mD that returns 0 for
                             non-measurable sets
                    czero == zero charge
              cscale r nu == charge nu scaled by a factor r : R
         charge_add n1 n2 == the charge corresponding to the sum of
                             charges n1 and n2
charge_of_finite_measure mu == charge corresponding to a finite measure mu
```

## Theory
```
        nu.-positive_set P == P is a positive set with nu a charge
        nu.-negative_set N == N is a negative set with nu a charge
hahn_decomposition nu P N == the full set can be decomposed in P and N,
                             a positive set and a negative set for the
                             charge nu
          jordan_pos nuPN == the charge obtained by restricting the charge
                             nu to the positive set P of the Hahn
                             decomposition nuPN: hahn_decomposition nu P N
          jordan_neg nuPN == the charge obtained by restricting the charge
                             nu to the positive set N of the Hahn
                             decomposition nuPN: hahn_decomposition nu P N
    charge_variation nuPN == variation of the charge nu
                          := jordan_pos nuPN \+ jordan_neg nuPN
             induced intf == charge induced by a function f : T -&gt; \bar R
                             R has type realType; T is a measurableType.
                             intf is a proof that f is integrable over
                             [set: T]
             'd nu '/d mu == Radon-Nikodym derivative of nu w.r.t. mu
                             (the scope is charge_scope)
```

</div>
<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'additive_charge' 'set' T '-&gt;' '\bar' R }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> T,</span><span class="id"> R</span><span class="gallina-kwd"> at</span><span class="id"> next</span><span class="id"> level,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;{ 'additive_charge'  'set'  T  '-&gt;'  '\bar'  R }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'charge' 'set' T '-&gt;' '\bar' R }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> T,</span><span class="id"> R</span><span class="gallina-kwd"> at</span><span class="id"> next</span><span class="id"> level,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;{ 'charge'  'set'  T  '-&gt;'  '\bar'  R }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'d nu '/d mu&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 10,</span><span class="id"> nu,</span><span class="id"> mu</span><span class="gallina-kwd"> at</span><span class="id"> next</span><span class="id"> level,</span><br/>
&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;''d'  nu  ''/d'  mu&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;nu .-negative_set&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;nu .-negative_set&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;nu .-positive_set&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;nu .-positive_set&quot;</span>).<br/>
<br/>
<span class="vernacular">Declare</span><span class="vernacular"> Scope</span><span class="id"> charge_scope</span>.<br/>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> Order</span>.<span class="id">TTheory</span><span class="id"> GRing</span>.<span class="id">Theory</span><span class="id"> Num</span>.<span class="id">Def</span><span class="id"> Num</span>.<span class="id">Theory</span>.<br/>
<span class="vernacular">Import</span><span class="id"> numFieldNormedType</span>.<span class="vernacular">Exports</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> isAdditiveCharge</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> {</span><span class="id"> charge_semi_additive</span><span class="id"> :</span><span class="id"> measure</span>.<span class="id">semi_additive</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=additive_charge</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> AdditiveCharge</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>)<span class="id"> :=</span><span class="id"> {</span><span class="id"> mu</span><span class="id"> of</span><span class="id"> isAdditiveCharge</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> &amp;</span><span class="id"> FinNumFun</span><span class="id"> d</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'additive_charge' 'set' T '-&gt;' '\bar' R }&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">additive_charge</span><span class="id"> T</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="id">#[export]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> charge_semi_additive</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> isSemiSigmaAdditive</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">charge_semi_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=charge</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> Charge</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>)<br/>
&nbsp;&nbsp;<span class="id">:=</span><span class="id"> {</span><span class="id"> mu</span><span class="id"> of</span><span class="id"> isSemiSigmaAdditive</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> &amp;</span><span class="id"> AdditiveCharge</span><span class="id"> d</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'charge' 'set' T '-&gt;' '\bar' R }&quot;</span><span class="id"> :=</span> (<span class="id">charge</span><span class="id"> T</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> isCharge</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">charge0</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">charge_finite</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> d</span>.<span class="id">-measurable</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">charge_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> mu</span><br/>
<span class="id">}</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> of</span><span class="id"> isCharge</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> finite</span><span class="id"> :</span><span class="id"> fin_num_fun</span><span class="id"> mu</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> charge_finite</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isFinite</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> finite</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> semi_additive</span><span class="id"> :</span><span class="id"> measure</span>.<span class="id">semi_additive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> I</span><span class="id"> n</span><span class="id"> mI</span><span class="id"> trivI</span><span class="id"> mUI</span>.<br/>
<span class="id">rewrite</span> (<span class="id">semi_sigma_additive_is_additive</span><span class="id"> charge0</span>)<span class="id">//</span>.<br/>
<span class="id">exact:</span><span class="id"> charge_sigma_additive</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isAdditiveCharge</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> semi_additive</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> semi_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> charge_sigma_additive</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">isSemiSigmaAdditive</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> semi_sigma_additive</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> charge_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>).<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> charge0</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> /[!big_ord0]</span><span class="id"> -&gt;//</span><span class="id"> :=</span><span class="id"> @charge_semi_additive</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> nu</span> (<span class="id">fun=&gt;</span><span class="id"> set0</span>)<span class="id"> 0%N</span>.<br/>
<span class="id">exact:</span><span class="id"> trivIset_set0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> charge0</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> charge_semi_additiveW</span><span class="id"> nu</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">nu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> measure</span>.<span class="id">semi_additive</span><span class="id"> nu</span><span class="id"> -&gt;</span><span class="id"> semi_additive2</span><span class="id"> nu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nu0</span><span class="id"> anu</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mA</span><span class="id"> mB</span><span class="id"> +</span><span class="id"> AB;</span><span class="id"> rewrite</span><span class="id"> -bigcup2inE</span><span class="id"> bigcup_mkord</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /</span>(<span class="id">anu</span> (<span class="id">bigcup2</span><span class="id"> A</span><span class="id"> B</span>))<span class="id"> -&gt;</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">big_ord_recl,</span><span class="id"> big_ord0</span>)<span class="id">/=</span><span class="id"> adde0</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [|[|[]]]//=</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> [|[|i]]</span><span class="id"> [|[|j]]/=</span><span class="id"> _</span><span class="id"> _</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> AB</span><span class="id"> =&gt;</span><span class="id"> -[]</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setI0</span><span class="id"> =&gt;</span><span class="id"> -[]</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIC</span><span class="id"> AB</span><span class="id"> =&gt;</span><span class="id"> -[]</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setI0</span><span class="id"> =&gt;</span><span class="id"> -[]</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> set0I</span><span class="id"> =&gt;</span><span class="id"> -[]</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> set0I</span><span class="id"> =&gt;</span><span class="id"> -[]</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setI0</span><span class="id"> =&gt;</span><span class="id"> -[]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> charge_semi_additive2E</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> semi_additive2</span><span class="id"> nu</span><span class="id"> =</span><span class="id"> additive2</span><span class="id"> nu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> propeqE;</span><span class="id"> split=&gt;</span><span class="id"> [anu</span><span class="id"> A</span><span class="id"> B</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?|anu</span><span class="id"> A</span><span class="id"> B</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> _</span><span class="id"> ?];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> anu</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> anu</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurableU</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> charge_semi_additive2</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> semi_additive2</span><span class="id"> nu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> charge_semi_additiveW</span>. Qed.</div></details>
<br/>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> charge_semi_additive2</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> chargeU</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> additive2</span><span class="id"> nu</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -charge_semi_additive2E</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> chargeDI</span><span class="id"> nu</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">nu</span><span class="id"> A</span><span class="id"> =</span><span class="id"> nu</span> (<span class="id">A</span><span class="id"> `\`</span><span class="id"> B</span>)<span class="id"> +</span><span class="id"> nu</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span><span class="id"> mB;</span><span class="id"> rewrite</span><span class="id"> -charge_semi_additive2</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setDDr</span><span class="id"> setDv</span><span class="id"> setD0</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurableD</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measurableU;</span><span class="id"> [exact:</span><span class="id"> measurableD</span><span class="id"> |exact:</span><span class="id"> measurableI]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> setIACA</span><span class="id"> setICl</span><span class="id"> setI0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> charge_partition</span><span class="id"> nu</span><span class="id"> S</span><span class="id"> P</span><span class="id"> N</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> N</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">P</span><span class="id"> `|`</span><span class="id"> N</span><span class="id"> =</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> `&amp;`</span><span class="id"> N</span><span class="id"> =</span><span class="id"> set0</span><span class="id"> -&gt;</span><span class="id"> nu</span><span class="id"> S</span><span class="id"> =</span><span class="id"> nu</span> (<span class="id">S</span><span class="id"> `&amp;`</span><span class="id"> P</span>)<span class="id"> +</span><span class="id"> nu</span> (<span class="id">S</span><span class="id"> `&amp;`</span><span class="id"> N</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mS</span><span class="id"> mP</span><span class="id"> mN</span><span class="id"> PNT</span><span class="id"> PN0;</span><span class="id"> rewrite</span><span class="id"> -{1}</span>(<span class="id">setIT</span><span class="id"> S</span>)<span class="id"> -PNT</span><span class="id"> setIUr</span><span class="id"> chargeU//</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setICA</span><span class="id"> -</span>(<span class="id">setIA</span><span class="id"> S</span><span class="id"> P</span><span class="id"> N</span>)<span class="id"> PN0</span><span class="id"> setIA</span><span class="id"> setI0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> charge_lemmas</span>.<br/>
<span class="id">#[export]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> charge0</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[export]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> charge_semi_additive2</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> measure_of_charge</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">nu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> of</span> (<span class="gallina-kwd">forall</span><span class="id"> E,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> nu</span><span class="id"> E</span>)<span class="id"> :=</span><span class="id"> nu</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_of_charge</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">nupos</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> E,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> nu</span><span class="id"> E</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> mu</span><span class="id"> :=</span> (<span class="id">measure_of_charge</span><span class="id"> nupos</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> mu0</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> charge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mu_ge0</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> S</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> nupos</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mu_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> charge_semi_sigma_additive</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> T</span><span class="id"> R</span> (<span class="id">measure_of_charge</span><span class="id"> nupos</span>)<br/>
&nbsp;&nbsp;<span class="id">mu0</span><span class="id"> mu_ge0</span><span class="id"> mu_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> measure_of_charge</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> measure_of_charge</span><span class="id"> {d</span><span class="id"> T</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> charge_of_finite_measure</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> charge_of_finite_measure</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> mu</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> nu</span><span class="id"> :=</span><span class="id"> charge_of_finite_measure</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> nu0</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> measure0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> nu_finite</span><span class="id"> S</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> nu</span><span class="id"> S</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> fin_num_measure</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> nu_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> nu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> measure_semi_sigma_additive</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isCharge</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> T</span><span class="id"> R</span><span class="id"> nu</span><br/>
&nbsp;&nbsp;<span class="id">nu0</span><span class="id"> nu_finite</span><span class="id"> nu_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> charge_of_finite_measure</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> charge_of_finite_measure</span><span class="id"> {d</span><span class="id"> T</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> charge_lemmas_realFieldType</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> chargeD</span><span class="id"> nu</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">nu</span> (<span class="id">A</span><span class="id"> `\`</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> nu</span><span class="id"> A</span><span class="id"> -</span><span class="id"> nu</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span><span class="id"> mB</span>.<br/>
<span class="id">rewrite</span> (<span class="id">chargeDI</span><span class="id"> nu</span><span class="id"> mA</span><span class="id"> mB</span>)<span class="id"> addeK//</span><span class="id"> fin_numE</span><span class="id"> 1?gt_eqF</span><span class="id"> 1?lt_eqF//</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ltey_eq</span><span class="id"> fin_num_measure//;</span><span class="id"> exact:measurableI</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ltNye_eq</span><span class="id"> fin_num_measure//;</span><span class="id"> exact:measurableI</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> charge_lemmas_realFieldType</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> crestr</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numDomainType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> of</span><span class="id"> measurable</span><span class="id"> D</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> X</span><span class="id"> =&gt;</span><span class="id"> f</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> D</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> charge_restriction</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">mD</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> restr</span><span class="id"> :=</span> (<span class="id">crestr</span><span class="id"> nu</span><span class="id"> mD</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> crestr_finite_measure_function</span><span class="id"> U</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> restr</span><span class="id"> U</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mU</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /</span>(<span class="id">fin_num_measure</span><span class="id"> nu</span>)<span class="id"> :</span><span class="id"> measurable</span> (<span class="id">U</span><span class="id"> `&amp;`</span><span class="id"> D</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isFinite</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><br/>
&nbsp;&nbsp;<span class="id">restr</span><span class="id"> crestr_finite_measure_function</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> crestr_semi_additive</span><span class="id"> :</span><span class="id"> measure</span>.<span class="id">semi_additive</span><span class="id"> restr</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> n</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mU;</span><span class="id"> pose</span><span class="id"> FD</span><span class="id"> i</span><span class="id"> :=</span><span class="id"> F</span><span class="id"> i</span><span class="id"> `&amp;`</span><span class="id"> D</span>.<br/>
<span class="id">have</span><span class="id"> mFD</span><span class="id"> i</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">FD</span><span class="id"> i</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">have</span><span class="id"> tFD</span><span class="id"> :</span><span class="id"> trivIset</span><span class="id"> setT</span><span class="id"> FD</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/trivIsetP</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _</span><span class="id"> ij</span>.<br/>
&nbsp;&nbsp;<span class="id">move/trivIsetP</span><span class="id"> :</span><span class="id"> tF</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> i</span><span class="id"> j</span><span class="id"> Logic</span>.<span class="id">I</span><span class="id"> Logic</span>.<span class="id">I</span><span class="id"> ij</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /FD</span><span class="id"> setIACA</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> set0I</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">charge_semi_additive</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mFD</span>)<span class="id">//;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> bigsetU_measurable</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /crestr</span><span class="id"> /FD</span><span class="id"> big_distrl</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">isAdditiveCharge</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> restr</span><span class="id"> crestr_semi_additive</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> crestr_semi_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> restr</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mU;</span><span class="id"> pose</span><span class="id"> FD</span><span class="id"> i</span><span class="id"> :=</span><span class="id"> F</span><span class="id"> i</span><span class="id"> `&amp;`</span><span class="id"> D</span>.<br/>
<span class="id">have</span><span class="id"> mFD</span><span class="id"> i</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">FD</span><span class="id"> i</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">have</span><span class="id"> tFD</span><span class="id"> :</span><span class="id"> trivIset</span><span class="id"> setT</span><span class="id"> FD</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/trivIsetP</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _</span><span class="id"> ij</span>.<br/>
&nbsp;&nbsp;<span class="id">move/trivIsetP</span><span class="id"> :</span><span class="id"> tF</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> i</span><span class="id"> j</span><span class="id"> Logic</span>.<span class="id">I</span><span class="id"> Logic</span>.<span class="id">I</span><span class="id"> ij</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /FD</span><span class="id"> setIACA</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> set0I</span>.<br/>
<span class="id">rewrite</span><span class="id"> /restr</span><span class="id"> setI_bigcupl;</span><span class="id"> apply:</span><span class="id"> charge_semi_sigma_additive</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_measurable</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">isSemiSigmaAdditive</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> restr</span><span class="id"> crestr_semi_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> charge_restriction</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> crestr0</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>) (<span class="id">mD</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> X</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> X</span><span class="id"> \in</span><span class="id"> measurable</span><span class="gallina-kwd"> then</span><span class="id"> crestr</span><span class="id"> f</span><span class="id"> mD</span><span class="id"> X</span><span class="gallina-kwd"> else</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> charge_restriction0</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">mD</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> restr</span><span class="id"> :=</span> (<span class="id">crestr0</span><span class="id"> nu</span><span class="id"> mD</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> crestr00</span><span class="id"> :</span><span class="id"> restr</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite/crestr0</span><span class="id"> ifT</span><span class="id"> ?inE</span><span class="id"> //</span><span class="id"> /crestr</span><span class="id"> set0I</span>.<br/>
<span class="id">exact:</span><span class="id"> charge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> crestr0_fin_num_fun</span><span class="id"> :</span><span class="id"> fin_num_fun</span><span class="id"> restr</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> U</span><span class="id"> mU;</span><span class="id"> rewrite</span><span class="id"> /crestr0</span><span class="id"> mem_set//</span><span class="id"> fin_num_measure</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> crestr0_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> restr</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mU;</span><span class="id"> rewrite</span><span class="id"> /crestr0</span><span class="id"> mem_set//</span>.<br/>
<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> @</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> crestr</span><span class="id"> nu</span><span class="id"> mD</span> (<span class="id">F</span><span class="id"> i</span>))).<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> charge_semi_sigma_additive</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/funext</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> mem_set</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isCharge</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">restr</span><span class="id"> crestr00</span><span class="id"> crestr0_fin_num_fun</span><span class="id"> crestr0_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> charge_restriction0</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> charge_zero</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> czero</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> czero0</span><span class="id"> :</span><span class="id"> czero</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> czero_finite_measure_function</span><span class="id"> B</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> czero</span><span class="id"> B</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> czero_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> czero</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> @</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> cst</span><span class="id"> 0</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> cvg_cst</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/funext</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> big1</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isCharge</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> czero</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">czero0</span><span class="id"> czero_finite_measure_function</span><span class="id"> czero_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> charge_zero</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> czero</span><span class="id"> {d</span><span class="id"> T</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> charge_scale</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> cscale</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> r%:E</span><span class="id"> *</span><span class="id"> nu</span><span class="id"> A</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> cscale0</span><span class="id"> :</span><span class="id"> cscale</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /cscale</span><span class="id"> charge0</span><span class="id"> mule0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> cscale_finite_measure_function</span><span class="id"> U</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> cscale</span><span class="id"> U</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> mU;</span><span class="id"> apply:</span><span class="id"> fin_numM</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> fin_num_measure</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isFinite</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><br/>
&nbsp;&nbsp;<span class="id">cscale</span><span class="id"> cscale_finite_measure_function</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> cscale_semi_additive</span><span class="id"> :</span><span class="id"> measure</span>.<span class="id">semi_additive</span><span class="id"> cscale</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> n</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mU;</span><span class="id"> rewrite</span><span class="id"> /cscale</span><span class="id"> charge_semi_additive//</span>.<br/>
<span class="id">rewrite</span><span class="id"> fin_num_sume_distrr//</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> fin_num_adde_defl//</span><span class="id"> fin_num_measure</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">isAdditiveCharge</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> cscale</span><span class="id"> cscale_semi_additive</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> cscale_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> cscale</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> rewrite</span><span class="id"> /cscale;</span><span class="id"> rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> @</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> r%:E</span><span class="id"> *</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> nu</span> (<span class="id">F</span><span class="id"> i</span>)))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/funext</span><span class="id"> =&gt;</span><span class="id"> k;</span><span class="id"> rewrite</span><span class="id"> fin_num_sume_distrr//</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> fin_num_adde_defl//</span><span class="id"> fin_num_measure</span>.<br/>
<span class="id">rewrite</span><span class="id"> /mscale;</span><span class="id"> have</span><span class="id"> [-&gt;|r0]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> r</span><span class="id"> 0%R</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mul0e</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> @</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span> (<span class="id">fun=&gt;</span><span class="id"> 0</span>))<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> cvg_cst</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> mul0e</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> cvgeMl</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> charge_semi_sigma_additive</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isCharge</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> cscale</span><br/>
&nbsp;&nbsp;<span class="id">cscale0</span><span class="id"> cscale_finite_measure_function</span><span class="id"> cscale_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> charge_scale</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dominates_cscalel</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<br/>
&nbsp;&nbsp;(<span class="id">nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<br/>
&nbsp;&nbsp;(<span class="id">c</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> cscale</span><span class="id"> c</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> numu</span><span class="id"> E</span><span class="id"> mE</span><span class="id"> /numu;</span><span class="id"> rewrite</span><span class="id"> /cscale</span><span class="id"> =&gt;</span><span class="id"> -&gt;//;</span><span class="id"> rewrite</span><span class="id"> mule0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dominates_cscaler</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;(<span class="id">nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<br/>
&nbsp;&nbsp;(<span class="id">c</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> c</span><span class="id"> !=</span><span class="id"> 0%R</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> `&lt;&lt;</span><span class="id"> nu</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> `&lt;&lt;</span><span class="id"> cscale</span><span class="id"> c</span><span class="id"> nu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /negbTE</span><span class="id"> c0</span><span class="id"> munu</span><span class="id"> E</span><span class="id"> mE</span><span class="id"> /eqP;</span><span class="id"> rewrite</span><span class="id"> /cscale</span><span class="id"> mule_eq0</span><span class="id"> eqe</span><span class="id"> c0/=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /eqP/munu;</span><span class="id"> exact</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> charge_add</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">n1</span><span class="id"> n2</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> cadd</span><span class="id"> :=</span><span class="id"> n1</span><span class="id"> \+</span><span class="id"> n2</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> cadd0</span><span class="id"> :</span><span class="id"> cadd</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /cadd</span><span class="id"> 2!charge0</span><span class="id"> adde0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> cadd_finite</span><span class="id"> A</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> cadd</span><span class="id"> A</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> mA;</span><span class="id"> rewrite</span><span class="id"> fin_numD</span><span class="id"> !fin_num_measure</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> cadd_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> cadd</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> rewrite</span><span class="id"> /cadd</span>.<br/>
<span class="id">under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> big_split;</span><span class="id"> apply:</span><span class="id"> cvg_trans</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;TODO:&nbsp;IIRC&nbsp;explicit&nbsp;arguments&nbsp;were&nbsp;added&nbsp;to&nbsp;please&nbsp;Coq&nbsp;8.14,&nbsp;rm&nbsp;if&nbsp;not&nbsp;needed&nbsp;anymore&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">@cvgeD</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> R</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> x</span>) (<span class="id">n1</span> (<span class="id">F</span><span class="id"> i</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> x</span>) (<span class="id">n2</span> (<span class="id">F</span><span class="id"> i</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">n1</span> (<span class="id">\bigcup_n</span><span class="id"> F</span><span class="id"> n</span>)) (<span class="id">n2</span> (<span class="id">\bigcup_n</span><span class="id"> F</span><span class="id"> n</span>))).<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> fin_num_adde_defr//</span><span class="id"> fin_num_measure</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> charge_semi_sigma_additive</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> charge_semi_sigma_additive</span>.<br/>
<span class="id">exact:</span><span class="id"> cvg_id</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isCharge</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> cadd</span><br/>
&nbsp;&nbsp;<span class="id">cadd0</span><span class="id"> cadd_finite</span><span class="id"> cadd_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> charge_add</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dominates_cadd</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {sigma_finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<br/>
&nbsp;&nbsp;(<span class="id">nu0</span><span class="id"> nu1</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">nu0</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> nu1</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">cadd</span><span class="id"> nu0</span><span class="id"> nu1</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> nu0mu</span><span class="id"> nu1mu</span><span class="id"> A</span><span class="id"> mA</span><span class="id"> A0;</span><span class="id"> rewrite</span><span class="id"> /cadd</span><span class="id"> nu0mu//</span><span class="id"> nu1mu//</span><span class="id"> adde0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> pushforward_charge</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d1</span><span class="id"> d2</span> (<span class="id">T1</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d1</span>) (<span class="id">T2</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d2</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> mf</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> setT</span><span class="id"> f</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> pushforward0</span><span class="id"> :</span><span class="id"> pushforward</span><span class="id"> nu</span><span class="id"> mf</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /pushforward</span><span class="id"> preimage_set0</span><span class="id"> charge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> pushforward_finite</span><span class="id"> A</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> pushforward</span><span class="id"> nu</span><span class="id"> mf</span><span class="id"> A</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA;</span><span class="id"> apply:</span><span class="id"> fin_num_measure</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> X]setTI;</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> pushforward_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span> (<span class="id">pushforward</span><span class="id"> nu</span><span class="id"> mf</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> rewrite</span><span class="id"> /pushforward</span><span class="id"> preimage_bigcup</span>.<br/>
<span class="id">apply:</span><span class="id"> charge_semi_sigma_additive</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> X]setTI;</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
<span class="id">-</span><span class="id"> apply/trivIsetP</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _</span><span class="id"> ij;</span><span class="id"> rewrite</span><span class="id"> -preimage_setI</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/trivIsetP</span><span class="id"> :</span><span class="id"> tF</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> ij</span>)<span class="id"> -&gt;//;</span><span class="id"> rewrite</span><span class="id"> preimage_set0</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -preimage_bigcup</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> X]setTI;</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isCharge</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">pushforward</span><span class="id"> nu</span><span class="id"> mf</span>)<br/>
&nbsp;&nbsp;<span class="id">pushforward0</span><span class="id"> pushforward_finite</span><span class="id"> pushforward_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> pushforward_charge</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> of</span><span class="id"> Measure_isFinite</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> mu0</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measure0</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isCharge</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">measure0</span><span class="id"> [the</span><span class="id"> content</span><span class="id"> _</span><span class="id"> _</span><span class="id"> of</span><span class="id"> mu]</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fin_num_measure</span><span class="id"> measure_semi_sigma_additive</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> dominates_pushforward</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dominates_pushforward</span><span class="id"> d</span><span class="id"> d'</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">T'</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d'</span>)<br/>
&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<br/>
&nbsp;&nbsp;(<span class="id">nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T'</span>) (<span class="id">mf</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> setT</span><span class="id"> f</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> pushforward</span><span class="id"> nu</span><span class="id"> mf</span><span class="id"> `&lt;&lt;</span><span class="id"> pushforward</span><span class="id"> mu</span><span class="id"> mf</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> numu</span><span class="id"> A</span><span class="id"> mA;</span><span class="id"> apply:</span><span class="id"> numu;</span><span class="id"> rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> X]setTI;</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> dominates_pushforward</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> positive_negative_set</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numDomainType</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> positive_set</span><span class="id"> nu</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> P</span><span class="id"> /\</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> nu</span><span class="id"> A</span><span class="id"> &gt;=</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> negative_set</span><span class="id"> nu</span> (<span class="id">N</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> N</span><span class="id"> /\</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> N</span><span class="id"> -&gt;</span><span class="id"> nu</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> positive_negative_set</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;nu .-negative_set&quot;</span><span class="id"> :=</span> (<span class="id">negative_set</span><span class="id"> nu</span>)<span class="id"> :</span><span class="id"> charge_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;nu .-positive_set&quot;</span><span class="id"> :=</span> (<span class="id">positive_set</span><span class="id"> nu</span>)<span class="id"> :</span><span class="id"> charge_scope</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> charge_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> positive_negative_set_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> negative_set_charge_le0</span><span class="id"> nu</span><span class="id"> N</span><span class="id"> :</span><span class="id"> nu</span>.<span class="id">-negative_set</span><span class="id"> N</span><span class="id"> -&gt;</span><span class="id"> nu</span><span class="id"> N</span><span class="id"> &lt;=</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [mN];</span><span class="id"> exact</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> negative_set0</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> nu</span>.<span class="id">-negative_set</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> A</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> subset0</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> charge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> positive_negative0</span><span class="id"> nu</span><span class="id"> P</span><span class="id"> N</span><span class="id"> :</span><span class="id"> nu</span>.<span class="id">-positive_set</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> nu</span>.<span class="id">-negative_set</span><span class="id"> N</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> S,</span><span class="id"> measurable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> nu</span> (<span class="id">S</span><span class="id"> `&amp;`</span><span class="id"> P</span><span class="id"> `&amp;`</span><span class="id"> N</span>)<span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [mP</span><span class="id"> posP]</span><span class="id"> [mN</span><span class="id"> negN]</span><span class="id"> S</span><span class="id"> mS;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le;</span><span class="id"> apply/andP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> negN;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measurableI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/setIidPl;</span><span class="id"> rewrite</span><span class="id"> -setIA</span><span class="id"> setIid</span>.<br/>
<span class="id">rewrite</span><span class="id"> -setIAC</span>.<br/>
<span class="id">apply:</span><span class="id"> posP;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measurableI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/setIidPl;</span><span class="id"> rewrite</span><span class="id"> -setIA</span><span class="id"> setIid</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> positive_negative_set_lemmas</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> positive_negative_set_realFieldType</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigcup_negative_set</span><span class="id"> nu</span> (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> nu</span>.<span class="id">-negative_set</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">nu</span>.<span class="id">-negative_set</span> (<span class="id">\bigcup_i</span><span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> hF;</span><span class="id"> have</span><span class="id"> mUF</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">\bigcup_k</span><span class="id"> F</span><span class="id"> k</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_measurable</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> _;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> hF</span><span class="id"> n</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> [//|S</span><span class="id"> mS</span><span class="id"> SUF]</span>.<br/>
<span class="id">pose</span><span class="id"> SF</span><span class="id"> n</span><span class="id"> :=</span> (<span class="id">S</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> n</span>)<span class="id"> `\`</span><span class="id"> \bigcup_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> k</span>.<br/>
<span class="id">have</span><span class="id"> SSF</span><span class="id"> :</span><span class="id"> S</span><span class="id"> =</span><span class="id"> \bigcup_i</span><span class="id"> SF</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;<span class="id">transitivity</span> (<span class="id">\bigcup_k</span><span class="id"> seqDU</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> S</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> n</span>)<span class="id"> k</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_bigcup</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> seqDUIE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -seqDU_bigcup_eq</span><span class="id"> -setI_bigcupr</span><span class="id"> setIidl</span>.<br/>
<span class="id">have</span><span class="id"> mSF</span><span class="id"> n</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">SF</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> measurableD;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measurableI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> hF</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_measurable</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> hF</span><span class="id"> k</span>.<br/>
<span class="id">have</span><span class="id"> SFS</span><span class="id"> :</span> (<span class="id">\sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> nu</span> (<span class="id">SF</span><span class="id"> i</span>))<span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span><span class="id"> --&gt;</span><span class="id"> nu</span><span class="id"> S</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> SSF;</span><span class="id"> apply:</span><span class="id"> charge_semi_sigma_additive</span><span class="id"> =&gt;</span><span class="id"> //;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[by</span><span class="id"> rewrite</span><span class="id"> /SF</span><span class="id"> -seqDUIE;</span><span class="id"> exact:</span><span class="id"> trivIset_seqDU|exact:</span><span class="id"> bigcup_measurable]</span>.<br/>
<span class="id">have</span><span class="id"> nuS_</span><span class="id"> n</span><span class="id"> :</span><span class="id"> nu</span> (<span class="id">SF</span><span class="id"> n</span>)<span class="id"> &lt;=</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> [_]</span><span class="id"> :=</span><span class="id"> hF</span><span class="id"> n;</span><span class="id"> apply</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> -[[]]</span>.<br/>
<span class="id">move/cvg_lim</span><span class="id"> :</span> (<span class="id">SFS</span>)<span class="id"> =&gt;</span><span class="id"> &lt;-//;</span><span class="id"> apply:</span><span class="id"> lime_le</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/cvg_ex</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> first</span><span class="id"> eexists;</span><span class="id"> exact:</span><span class="id"> SFS</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> exact:</span><span class="id"> sume_le0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> negative_setU</span><span class="id"> nu</span><span class="id"> N</span><span class="id"> M</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">nu</span>.<span class="id">-negative_set</span><span class="id"> N</span><span class="id"> -&gt;</span><span class="id"> nu</span>.<span class="id">-negative_set</span><span class="id"> M</span><span class="id"> -&gt;</span><span class="id"> nu</span>.<span class="id">-negative_set</span> (<span class="id">N</span><span class="id"> `|`</span><span class="id"> M</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nN</span><span class="id"> nM;</span><span class="id"> rewrite</span><span class="id"> -bigcup2E;</span><span class="id"> apply:</span><span class="id"> bigcup_negative_set</span><span class="id"> =&gt;</span><span class="id"> -[//|[//|/=</span><span class="id"> _]]</span>.<br/>
<span class="id">exact:</span><span class="id"> negative_set0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> positive_negative_set_realFieldType</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> hahn_decomposition_lemma</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> elt_prop</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> *</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> [/\</span><span class="id"> measurable</span><span class="id"> x</span>.<span class="id">1,</span><br/>
&nbsp;&nbsp;<span class="id">x</span>.<span class="id">1</span><span class="id"> `&lt;=`</span><span class="id"> D,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> x</span>.<span class="id">2</span><span class="id"> &amp;</span><span class="id"> nu</span><span class="id"> x</span>.<span class="id">1</span><span class="id"> &gt;=</span><span class="id"> mine</span> (<span class="id">x</span>.<span class="id">2</span><span class="id"> *</span><span class="id"> 2^-1%:E</span>)<span class="id"> 1]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> elt_type</span><span class="id"> :=</span><span class="id"> {x</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> *</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> *</span><span class="id"> set</span><span class="id"> T</span><span class="id"> |</span><span class="id"> elt_prop</span><span class="id"> x</span>.<span class="id">1}</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> A_</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> elt_type</span>)<span class="id"> :=</span> (<span class="id">proj1_sig</span><span class="id"> x</span>).<span class="id">1</span>.<span class="id">1</span>.<br/>
<span class="vernacular">Let</span><span class="id"> g_</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> elt_type</span>)<span class="id"> :=</span> (<span class="id">proj1_sig</span><span class="id"> x</span>).<span class="id">1</span>.<span class="id">2</span>.<br/>
<span class="vernacular">Let</span><span class="id"> U_</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> elt_type</span>)<span class="id"> :=</span> (<span class="id">proj1_sig</span><span class="id"> x</span>).<span class="id">2</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> mA_</span><span class="id"> x</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">A_</span><span class="id"> x</span>)<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[[?</span><span class="id"> ?]</span><span class="id"> ?]]</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> A_D</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A_</span><span class="id"> x</span><span class="id"> `&lt;=`</span><span class="id"> D</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[[?</span><span class="id"> ?]</span><span class="id"> ?]]</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> g_ge0</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> g_</span><span class="id"> x</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[[?</span><span class="id"> ?]</span><span class="id"> ?]]</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> nuA_g_</span><span class="id"> x</span><span class="id"> :</span><span class="id"> nu</span> (<span class="id">A_</span><span class="id"> x</span>)<span class="id"> &gt;=</span><span class="id"> mine</span> (<span class="id">g_</span><span class="id"> x</span><span class="id"> *</span><span class="id"> 2^-1%:E</span>)<span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[[?</span><span class="id"> ?]</span><span class="id"> ?]]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> nuA_ge0</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> nu</span> (<span class="id">A_</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">nuA_g_</span><span class="id"> _</span>))<span class="id">//</span><span class="id"> le_min</span><span class="id"> lee01</span><span class="id"> andbT</span><span class="id"> mule_ge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> subDD</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> nu</span><span class="id"> E</span><span class="id"> |</span><span class="id"> E</span><span class="gallina-kwd"> in</span><span class="id"> [set</span><span class="id"> E</span><span class="id"> |</span><span class="id"> measurable</span><span class="id"> E</span><span class="id"> /\</span><span class="id"> E</span><span class="id"> `&lt;=`</span><span class="id"> D</span><span class="id"> `\`</span><span class="id"> A]</span><span class="id"> ]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> d_</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> ereal_sup</span> (<span class="id">subDD</span><span class="id"> A</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> d_ge0</span><span class="id"> X</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> d_</span><span class="id"> X</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> ereal_sup_ubound</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> set0;</span><span class="id"> rewrite</span><span class="id"> ?charge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> elt_rel</span><span class="id"> i</span><span class="id"> j</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> g_</span><span class="id"> j</span><span class="id"> =</span><span class="id"> d_</span> (<span class="id">U_</span><span class="id"> i</span>)<span class="id">,</span> <span class="id"> A_</span><span class="id"> j</span><span class="id"> `&lt;=`</span><span class="id"> D</span><span class="id"> `\`</span><span class="id"> U_</span><span class="id"> i</span><span class="id"> &amp;</span><span class="id"> U_</span><span class="id"> j</span><span class="id"> =</span><span class="id"> U_</span><span class="id"> i</span><span class="id"> `|`</span><span class="id"> A_</span><span class="id"> j</span><span class="id"> ]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> next_elt</span><span class="id"> A</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> B</span><span class="id"> |</span><span class="id"> [/\</span><span class="id"> measurable</span><span class="id"> B,</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> D</span><span class="id"> `\`</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> nu</span><span class="id"> B</span><span class="id"> &gt;=</span><span class="id"> mine</span> (<span class="id">d_</span><span class="id"> A</span><span class="id"> *</span><span class="id"> 2^-1%:E</span>)<span class="id"> 1]</span><span class="id"> }</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> m</span><span class="id"> :=</span><span class="id"> mine</span> (<span class="id">d_</span><span class="id"> A</span><span class="id"> *</span><span class="id"> 2^-1%R%:E</span>)<span class="id"> 1;</span><span class="id"> apply/cid</span>.<br/>
<span class="id">have</span><span class="id"> :=</span><span class="id"> d_ge0</span><span class="id"> A;</span><span class="id"> rewrite</span><span class="id"> le_eqVlt</span><span class="id"> =&gt;</span><span class="id"> /predU1P[&lt;-|d_gt0]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> set0;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> charge0</span><span class="id"> mul0e</span><span class="id"> minEle</span><span class="id"> lee01</span>.<br/>
<span class="id">have</span><span class="id"> /ereal_sup_gt/cid2[_</span><span class="id"> [B/=</span><span class="id"> [mB</span><span class="id"> BDA</span><span class="id"> &lt;-</span><span class="id"> mnuB]]]</span><span class="id"> :</span><span class="id"> m</span><span class="id"> &lt;</span><span class="id"> d_</span><span class="id"> A</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /m;</span><span class="id"> have</span><span class="id"> [-&gt;|dn1oo]</span><span class="id"> :=</span><span class="id"> eqVneq</span> (<span class="id">d_</span><span class="id"> A</span>)<span class="id"> +oo</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> min_r</span><span class="id"> ?ltey</span><span class="id"> ?gt0_mulye</span><span class="id"> ?leey</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">@fineK</span><span class="id"> _</span> (<span class="id">d_</span><span class="id"> A</span>))<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> gt0_fin_numE//</span><span class="id"> ltey</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -EFinM</span><span class="id"> -fine_min//</span><span class="id"> lte_fin</span><span class="id"> gt_min;</span><span class="id"> apply/orP;</span><span class="id"> left</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ltr_pdivrMr//</span><span class="id"> ltr_pMr</span><span class="id"> ?ltr1n//</span><span class="id"> fine_gt0//</span><span class="id"> d_gt0/=</span><span class="id"> ltey</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> B;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">ltW</span><span class="id"> mnuB</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mine2_cvg_0_cvg_0</span> (<span class="id">u</span><span class="id"> :</span> (<span class="id">\bar</span><span class="id"> R</span>)<span class="id">^nat</span>)<span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> u</span><span class="id"> k</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mine</span> (<span class="id">u</span><span class="id"> n</span><span class="id"> *</span><span class="id"> 2^-1%:E</span>)<span class="id"> 1</span><span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span><span class="id"> --&gt;</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> u</span><span class="id"> n</span><span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span><span class="id"> --&gt;</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> u0</span><span class="id"> h</span>.<br/>
<span class="id">have</span><span class="id"> u2</span><span class="id"> n</span><span class="id"> :</span><span class="id"> u</span><span class="id"> n</span><span class="id"> =</span><span class="id"> 2%:E</span><span class="id"> *</span> (<span class="id">u</span><span class="id"> n</span><span class="id"> *</span><span class="id"> 2^-1%:E</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> muleCA</span><span class="id"> -EFinM</span><span class="id"> divff</span><span class="id"> ?mule1</span>.<br/>
<span class="id">rewrite</span> (<span class="id">eq_cvg</span><span class="id"> _</span><span class="id"> _</span><span class="id"> u2</span>)<span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> X]/</span>(<span class="id">nbhs</span><span class="id"> 0</span>).<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">mule0</span><span class="id"> 2%:E</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> cvgeMl</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">mine_cvg_0_cvg_0</span><span class="id"> lte01</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> mule_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> hahn_decomposition_lemma</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{A</span><span class="id"> |</span><span class="id"> [/\</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> D,</span><span class="id"> nu</span>.<span class="id">-negative_set</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> nu</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> nu</span><span class="id"> D]}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mD;</span><span class="id"> have</span><span class="id"> [A0</span><span class="id"> [mA0</span><span class="id"> +</span><span class="id"> A0d0]]</span><span class="id"> :=</span><span class="id"> next_elt</span><span class="id"> set0</span>.<br/>
<span class="id">rewrite</span><span class="id"> setD0</span><span class="id"> =&gt;</span><span class="id"> A0D</span>.<br/>
<span class="id">have</span><span class="id"> [v</span><span class="id"> [v0</span><span class="id"> Pv]]</span><span class="id"> :</span><span class="id"> {v</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> elt_type</span><span class="id"> |</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">v</span><span class="id"> 0%N</span><span class="id"> =</span><span class="id"> exist</span><span class="id"> _</span> (<span class="id">A0,</span><span class="id"> d_</span><span class="id"> set0,</span><span class="id"> A0</span>) (<span class="id">And4</span><span class="id"> mA0</span><span class="id"> A0D</span> (<span class="id">d_ge0</span><span class="id"> set0</span>)<span class="id"> A0d0</span>)<span class="id"> /\</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> elt_rel</span> (<span class="id">v</span><span class="id"> n</span>) (<span class="id">v</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id">}</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> dependent_choice_Type</span><span class="id"> =&gt;</span><span class="id"> -[[[A'</span><span class="id"> ?]</span><span class="id"> U]</span><span class="id"> [/=</span><span class="id"> mA'</span><span class="id"> A'D]]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [A1</span><span class="id"> [mA1</span><span class="id"> A1DU</span><span class="id"> A1t1]]</span><span class="id"> :=</span><span class="id"> next_elt</span><span class="id"> U</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> A1D</span><span class="id"> :</span><span class="id"> A1</span><span class="id"> `&lt;=`</span><span class="id"> D</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">subset_trans</span><span class="id"> A1DU</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> subDsetl</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">exist</span><span class="id"> _</span> (<span class="id">A1,</span><span class="id"> d_</span><span class="id"> U,</span><span class="id"> U</span><span class="id"> `|`</span><span class="id"> A1</span>) (<span class="id">And4</span><span class="id"> mA1</span><span class="id"> A1D</span> (<span class="id">d_ge0</span><span class="id"> U</span>)<span class="id"> A1t1</span>)).<br/>
<span class="id">have</span><span class="id"> Ubig</span><span class="id"> n</span><span class="id"> :</span><span class="id"> U_</span> (<span class="id">v</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> \big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id"> A_</span> (<span class="id">v</span><span class="id"> i</span>).<br/>
&nbsp;&nbsp;<span class="id">elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> ih];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> v0/=</span><span class="id"> big_ord_recr/=</span><span class="id"> big_ord0</span><span class="id"> set0U</span><span class="id"> v0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> -&gt;]</span><span class="id"> :=</span><span class="id"> Pv</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> big_ord_recr/=</span><span class="id"> -ih</span>.<br/>
<span class="id">have</span><span class="id"> tA</span><span class="id"> :</span><span class="id"> trivIset</span><span class="id"> setT</span> (<span class="id">A_</span><span class="id"> \o</span><span class="id"> v</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> subsetC_trivIset</span><span class="id"> =&gt;</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [_</span><span class="id"> +</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> Pv</span><span class="id"> n;</span><span class="id"> move/subset_trans;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -setTD;</span><span class="id"> apply:</span><span class="id"> setDSS</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> Ubig</span><span class="id"> big_ord_recr</span>.<br/>
<span class="id">set</span><span class="id"> Aoo</span><span class="id"> :=</span><span class="id"> \bigcup_k</span><span class="id"> A_</span> (<span class="id">v</span><span class="id"> k</span>).<br/>
<span class="id">have</span><span class="id"> mAoo</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> Aoo</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> bigcup_measurable</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">D</span><span class="id"> `\`</span><span class="id"> Aoo</span>).<br/>
<span class="id">have</span><span class="id"> cvg_nuA</span><span class="id"> :</span> (<span class="id">\sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> nu</span> (<span class="id">A_</span> (<span class="id">v</span><span class="id"> i</span>)))<span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]--&gt;</span><span class="id"> nu</span><span class="id"> Aoo</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> charge_semi_sigma_additive</span>.<br/>
<span class="id">have</span><span class="id"> nuAoo</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> nu</span><span class="id"> Aoo</span>.<br/>
&nbsp;&nbsp;<span class="id">move/cvg_lim</span><span class="id"> :</span><span class="id"> cvg_nuA</span><span class="id"> =&gt;</span><span class="id"> &lt;-//=;</span><span class="id"> apply:</span><span class="id"> nneseries_ge0</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> nuA_ge0</span>.<br/>
<span class="id">have</span><span class="id"> A_cvg_0</span><span class="id"> :</span><span class="id"> nu</span> (<span class="id">A_</span> (<span class="id">v</span><span class="id"> n</span>))<span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span><span class="id"> --&gt;</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> @</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span> (<span class="id">fine</span> (<span class="id">nu</span> (<span class="id">A_</span> (<span class="id">v</span><span class="id"> n</span>))))<span class="id">%:E</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/funext</span><span class="id"> =&gt;</span><span class="id"> n/=;</span><span class="id"> rewrite</span><span class="id"> fineK//</span><span class="id"> fin_num_measure</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> continuous_cvg</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> cvg_series_cvg_0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> series</span><span class="id"> _</span><span class="id"> =</span><span class="id"> fine</span><span class="id"> \o</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> nu</span> (<span class="id">A_</span> (<span class="id">v</span><span class="id"> i</span>))))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/funext</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /series/=</span><span class="id"> sum_fine//=</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> fin_num_measure</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> cvg_nuA;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">@fineK</span><span class="id"> _</span> (<span class="id">nu</span><span class="id"> Aoo</span>))<span class="id"> ?fin_num_measure//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /fine_cvgP[_</span><span class="id"> ?];</span><span class="id"> apply/cvg_ex;</span><span class="gallina-kwd"> exists</span> (<span class="id">fine</span> (<span class="id">nu</span><span class="id"> Aoo</span>)).<br/>
<span class="id">have</span><span class="id"> mine_cvg_0</span><span class="id"> :</span> (<span class="id">mine</span> (<span class="id">g_</span> (<span class="id">v</span><span class="id"> n</span>)<span class="id"> *</span><span class="id"> 2^-1%:E</span>)<span class="id"> 1</span>)<span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span><span class="id"> --&gt;</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">@squeeze_cvge</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> nu</span> (<span class="id">A_</span> (<span class="id">v</span><span class="id"> n</span>))))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[|exact:</span><span class="id"> cvg_cst|by</span><span class="id"> []]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> nuA_g_</span><span class="id"> andbT</span><span class="id"> le_min</span><span class="id"> lee01</span><span class="id"> andbT</span><span class="id"> mule_ge0</span>.<br/>
<span class="id">have</span><span class="id"> g_cvg_0</span><span class="id"> :</span> (<span class="id">g_</span><span class="id"> \o</span><span class="id"> v</span>)<span class="id"> n</span><span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span><span class="id"> --&gt;</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> mine2_cvg_0_cvg_0</span><span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
<span class="id">have</span><span class="id"> nuDAoo</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> D</span><span class="id"> &gt;=</span><span class="id"> nu</span> (<span class="id">D</span><span class="id"> `\`</span><span class="id"> Aoo</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -[in</span><span class="id"> leRHS]</span>(<span class="id">@setDUK</span><span class="id"> _</span><span class="id"> Aoo</span><span class="id"> D</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_sub</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> A_D</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> chargeU//</span><span class="id"> ?leeDr//</span><span class="id"> ?setDIK//;</span><span class="id"> exact:</span><span class="id"> measurableD</span>.<br/>
<span class="id">split;</span><span class="id"> [by</span><span class="id"> []|</span><span class="id"> |by</span><span class="id"> []];</span><span class="id"> split;</span><span class="id"> [exact:</span><span class="id"> measurableD</span><span class="id"> |</span><span class="id"> move=&gt;</span><span class="id"> E</span><span class="id"> mE</span><span class="id"> EDAoo]</span>.<br/>
<span class="id">pose</span><span class="id"> H</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> subDD</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> A_</span> (<span class="id">v</span><span class="id"> i</span>)).<br/>
<span class="id">have</span><span class="id"> EH</span><span class="id"> n</span><span class="id"> :</span><span class="id"> [set</span><span class="id"> nu</span><span class="id"> E]</span><span class="id"> `&lt;=`</span><span class="id"> H</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> E</span><span class="id"> \in</span><span class="id"> subDD</span><span class="id"> Aoo</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="gallina-kwd"> exists</span><span class="id"> E</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -sub1set</span><span class="id"> =&gt;</span><span class="id"> /subset_trans;</span><span class="id"> apply</span><span class="id"> =&gt;</span><span class="id"> x/=</span><span class="id"> [F</span><span class="id"> [mF</span><span class="id"> FDAoo</span><span class="id"> ?]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> F</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">subset_trans</span><span class="id"> FDAoo</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> setDS;</span><span class="id"> exact:</span><span class="id"> bigsetU_bigcup</span>.<br/>
<span class="id">have</span><span class="id"> nudelta</span><span class="id"> n</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> E</span><span class="id"> &lt;=</span><span class="id"> g_</span> (<span class="id">v</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> v0/=;</span><span class="id"> apply:</span><span class="id"> ereal_sup_ubound</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> E;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">subset_trans</span><span class="id"> EDAoo</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> setDS</span>.<br/>
&nbsp;&nbsp;<span class="id">suff</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> E</span><span class="id"> &lt;=</span><span class="id"> d_</span> (<span class="id">U_</span> (<span class="id">v</span><span class="id"> n</span>))<span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> [&lt;-</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> Pv</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /le_ereal_sup</span><span class="id"> :=</span><span class="id"> EH</span><span class="id"> n</span>.<span class="id">+1;</span><span class="id"> rewrite</span><span class="id"> ereal_sup1</span><span class="id"> =&gt;</span><span class="id"> /le_trans;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/le_ereal_sup</span><span class="id"> =&gt;</span><span class="id"> x/=</span><span class="id"> [A'</span><span class="id"> [mA'</span><span class="id"> A'D</span><span class="id"> ?]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> A'</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">subset_trans</span><span class="id"> A'D</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> setDS;</span><span class="id"> rewrite</span><span class="id"> Ubig</span>.<br/>
<span class="id">apply:</span> (<span class="id">@closed_cvg</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> v</span><span class="id"> =&gt;</span><span class="id"> nu</span><span class="id"> E</span><span class="id"> &lt;=</span><span class="id"> v</span>)<span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> g_cvg_0</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> closed_ereal_le_ereal</span>.<br/>
<span class="id">exact:</span><span class="id"> nearW</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> hahn_decomposition_lemma</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> hahn_decomposition</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> P</span><span class="id"> N</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> nu</span>.<span class="id">-positive_set</span><span class="id"> P,</span><span class="id"> nu</span>.<span class="id">-negative_set</span><span class="id"> N,</span><span class="id"> P</span><span class="id"> `|`</span><span class="id"> N</span><span class="id"> =</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> &amp;</span><span class="id"> P</span><span class="id"> `&amp;`</span><span class="id"> N</span><span class="id"> =</span><span class="id"> set0]</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> hahn_decomposition_theorem</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> elt_prop</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> *</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> [/\</span><span class="id"> x</span>.<span class="id">2</span><span class="id"> &lt;=</span><span class="id"> 0,</span><br/>
&nbsp;&nbsp;<span class="id">nu</span>.<span class="id">-negative_set</span><span class="id"> x</span>.<span class="id">1</span><span class="id"> &amp;</span><span class="id"> nu</span><span class="id"> x</span>.<span class="id">1</span><span class="id"> &lt;=</span><span class="id"> maxe</span> (<span class="id">x</span>.<span class="id">2</span><span class="id"> *</span><span class="id"> 2^-1%:E</span>) (<span class="id">-</span><span class="id"> 1%E</span>)<span class="id"> ]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> elt_type</span><span class="id"> :=</span><span class="id"> {AzU</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> *</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> *</span><span class="id"> set</span><span class="id"> T</span><span class="id"> |</span><span class="id"> elt_prop</span><span class="id"> AzU</span>.<span class="id">1}</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> A_</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> elt_type</span>)<span class="id"> :=</span> (<span class="id">proj1_sig</span><span class="id"> x</span>).<span class="id">1</span>.<span class="id">1</span>.<br/>
<span class="vernacular">Let</span><span class="id"> z_</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> elt_type</span>)<span class="id"> :=</span> (<span class="id">proj1_sig</span><span class="id"> x</span>).<span class="id">1</span>.<span class="id">2</span>.<br/>
<span class="vernacular">Let</span><span class="id"> U_</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> elt_type</span>)<span class="id"> :=</span> (<span class="id">proj1_sig</span><span class="id"> x</span>).<span class="id">2</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> mA_</span><span class="id"> x</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">A_</span><span class="id"> x</span>)<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[[?</span><span class="id"> ?]</span><span class="id"> ?]</span><span class="id"> [/=</span><span class="id"> ?</span><span class="id"> []]]</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> negative_set_A_</span><span class="id"> x</span><span class="id"> :</span><span class="id"> nu</span>.<span class="id">-negative_set</span> (<span class="id">A_</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[[?</span><span class="id"> ?]</span><span class="id"> ?]]</span><span class="id"> -[]</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> nuA_z_</span><span class="id"> x</span><span class="id"> :</span><span class="id"> nu</span> (<span class="id">A_</span><span class="id"> x</span>)<span class="id"> &lt;=</span><span class="id"> maxe</span> (<span class="id">z_</span><span class="id"> x</span><span class="id"> *</span><span class="id"> 2^-1%:E</span>) (<span class="id">-</span><span class="id"> 1%E</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[[?</span><span class="id"> ?]</span><span class="id"> ?]]</span><span class="id"> -[]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> nuA_le0</span><span class="id"> x</span><span class="id"> :</span><span class="id"> nu</span> (<span class="id">A_</span><span class="id"> x</span>)<span class="id"> &lt;=</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[[?</span><span class="id"> ?]</span><span class="id"> ?]]</span><span class="id"> [?</span><span class="id"> h</span><span class="id"> ?];</span><span class="id"> exact:</span><span class="id"> negative_set_charge_le0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> z_le0</span><span class="id"> x</span><span class="id"> :</span><span class="id"> z_</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [[[?</span><span class="id"> ?]</span><span class="id"> ?]]</span><span class="id"> -[]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> subC</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> nu</span><span class="id"> E</span><span class="id"> |</span><span class="id"> E</span><span class="gallina-kwd"> in</span><span class="id"> [set</span><span class="id"> E</span><span class="id"> |</span><span class="id"> measurable</span><span class="id"> E</span><span class="id"> /\</span><span class="id"> E</span><span class="id"> `&lt;=`</span><span class="id"> ~`</span><span class="id"> A]</span><span class="id"> ]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> s_</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> ereal_inf</span> (<span class="id">subC</span><span class="id"> A</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> s_le0</span><span class="id"> X</span><span class="id"> :</span><span class="id"> s_</span><span class="id"> X</span><span class="id"> &lt;=</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> ereal_inf_lbound</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> set0;</span><span class="id"> rewrite</span><span class="id"> ?charge0//=;</span><span class="id"> split</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> elt_rel</span><span class="id"> i</span><span class="id"> j</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> z_</span><span class="id"> j</span><span class="id"> =</span><span class="id"> s_</span> (<span class="id">U_</span><span class="id"> i</span>)<span class="id">,</span><span class="id"> A_</span><span class="id"> j</span><span class="id"> `&lt;=`</span><span class="id"> ~`</span><span class="id"> U_</span><span class="id"> i</span><span class="id"> &amp;</span><span class="id"> U_</span><span class="id"> j</span><span class="id"> =</span><span class="id"> U_</span><span class="id"> i</span><span class="id"> `|`</span><span class="id"> A_</span><span class="id"> j]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> next_elt</span><span class="id"> U</span><span class="id"> :</span><span class="id"> {</span><span class="id"> A</span><span class="id"> |</span><span class="id"> [/\</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> ~`</span><span class="id"> U,</span><br/>
&nbsp;&nbsp;<span class="id">negative_set</span><span class="id"> nu</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> nu</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> maxe</span> (<span class="id">s_</span><span class="id"> U</span><span class="id"> *</span><span class="id"> 2^-1%R%:E</span>) (<span class="id">-</span><span class="id"> 1%E</span>)<span class="id">]</span><span class="id"> }</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> m</span><span class="id"> :=</span><span class="id"> maxe</span> (<span class="id">s_</span><span class="id"> U</span><span class="id"> *</span><span class="id"> 2^-1%R%:E</span>) (<span class="id">-</span><span class="id"> 1%E</span>)<span class="id">;</span><span class="id"> apply/cid</span>.<br/>
<span class="id">have</span><span class="id"> :=</span><span class="id"> s_le0</span><span class="id"> U;</span><span class="id"> rewrite</span><span class="id"> le_eqVlt</span><span class="id"> =&gt;</span><span class="id"> /predU1P[-&gt;|s_lt0]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> set0;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> ?charge0</span><span class="id"> ?mul0e</span><span class="id"> ?maxEle</span><span class="id"> ?lee0N1//</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> negative_set0</span>.<br/>
<span class="id">have</span><span class="id"> /ereal_inf_lt/cid2[_</span><span class="id"> [B/=</span><span class="id"> [mB</span><span class="id"> BU]</span><span class="id"> &lt;-]</span><span class="id"> nuBm]</span><span class="id"> :</span><span class="id"> s_</span><span class="id"> U</span><span class="id"> &lt;</span><span class="id"> m</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /m;</span><span class="id"> have</span><span class="id"> [-&gt;|s0oo]</span><span class="id"> :=</span><span class="id"> eqVneq</span> (<span class="id">s_</span><span class="id"> U</span>)<span class="id"> -oo</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> max_r</span><span class="id"> ?ltNye//</span><span class="id"> gt0_mulNye//</span><span class="id"> leNye</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">@fineK</span><span class="id"> _</span> (<span class="id">s_</span><span class="id"> U</span>))<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> lt0_fin_numE//</span><span class="id"> ltNye</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -EFinM</span><span class="id"> -fine_max//</span><span class="id"> lte_fin</span><span class="id"> lt_max;</span><span class="id"> apply/orP;</span><span class="id"> left</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ltr_pdivlMr//</span><span class="id"> gtr_nMr</span><span class="id"> ?ltr1n//</span><span class="id"> fine_lt0//</span><span class="id"> s_lt0/=</span><span class="id"> ltNye</span><span class="id"> andbT</span>.<br/>
<span class="id">have</span><span class="id"> [C</span><span class="id"> [CB</span><span class="id"> nsC</span><span class="id"> nuCB]]</span><span class="id"> :=</span><span class="id"> hahn_decomposition_lemma</span><span class="id"> nu</span><span class="id"> mB</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> C;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> exact:</span> (<span class="id">subset_trans</span><span class="id"> CB</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> nuCB</span>)<span class="id">//</span> (<span class="id">le_trans</span> (<span class="id">ltW</span><span class="id"> nuBm</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Theorem</span><span class="id"> Hahn_decomposition</span><span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> P</span><span class="id"> N,</span><span class="id"> hahn_decomposition</span><span class="id"> nu</span><span class="id"> P</span><span class="id"> N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [A0</span><span class="id"> [_</span><span class="id"> negA0</span><span class="id"> A0s0]]</span><span class="id"> :=</span><span class="id"> next_elt</span><span class="id"> set0</span>.<br/>
<span class="id">have</span><span class="id"> [v</span><span class="id"> [v0</span><span class="id"> Pv]]</span><span class="id"> :</span><span class="id"> {v</span><span class="id"> |</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">v</span><span class="id"> 0%N</span><span class="id"> =</span><span class="id"> exist</span><span class="id"> _</span> (<span class="id">A0,</span><span class="id"> s_</span><span class="id"> set0,</span><span class="id"> A0</span>) (<span class="id">And3</span> (<span class="id">s_le0</span><span class="id"> set0</span>)<span class="id"> negA0</span><span class="id"> A0s0</span>)<span class="id"> /\</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> elt_rel</span> (<span class="id">v</span><span class="id"> n</span>) (<span class="id">v</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id">}</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> dependent_choice_Type</span><span class="id"> =&gt;</span><span class="id"> -[[[A</span><span class="id"> s]</span><span class="id"> U]</span><span class="id"> [/=</span><span class="id"> s_le0'</span><span class="id"> nsA]]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [A'</span><span class="id"> [?</span><span class="id"> nsA'</span><span class="id"> A's']</span><span class="id"> ]</span><span class="id"> :=</span><span class="id"> next_elt</span><span class="id"> U</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">exist</span><span class="id"> _</span> (<span class="id">A',</span><span class="id"> s_</span><span class="id"> U,</span><span class="id"> U</span><span class="id"> `|`</span><span class="id"> A'</span>) (<span class="id">And3</span> (<span class="id">s_le0</span><span class="id"> U</span>)<span class="id"> nsA'</span><span class="id"> A's'</span>)).<br/>
<span class="id">have</span><span class="id"> Ubig</span><span class="id"> n</span><span class="id"> :</span><span class="id"> U_</span> (<span class="id">v</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> \big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id"> A_</span> (<span class="id">v</span><span class="id"> i</span>).<br/>
&nbsp;&nbsp;<span class="id">elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> ih];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> v0/=</span><span class="id"> big_ord_recr/=</span><span class="id"> big_ord0</span><span class="id"> set0U</span><span class="id"> v0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> -&gt;]</span><span class="id"> :=</span><span class="id"> Pv</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> big_ord_recr/=</span><span class="id"> -ih</span>.<br/>
<span class="id">have</span><span class="id"> tA</span><span class="id"> :</span><span class="id"> trivIset</span><span class="id"> setT</span> (<span class="id">A_</span><span class="id"> \o</span><span class="id"> v</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> subsetC_trivIset</span><span class="id"> =&gt;</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [_</span><span class="id"> +</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> Pv</span><span class="id"> n;</span><span class="id"> move/subset_trans;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subsetC;</span><span class="id"> rewrite</span><span class="id"> Ubig</span><span class="id"> big_ord_recr</span>.<br/>
<span class="id">set</span><span class="id"> N</span><span class="id"> :=</span><span class="id"> \bigcup_k</span> (<span class="id">A_</span> (<span class="id">v</span><span class="id"> k</span>)).<br/>
<span class="id">have</span><span class="id"> mN</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> N</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> bigcup_measurable</span>.<br/>
<span class="id">have</span><span class="id"> neg_set_N</span><span class="id"> :</span><span class="id"> negative_set</span><span class="id"> nu</span><span class="id"> N</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_negative_set</span><span class="id"> =&gt;</span><span class="id"> i;</span><span class="id"> exact:</span><span class="id"> negative_set_A_</span>.<br/>
<span class="id">pose</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> ~`</span><span class="id"> N</span>.<br/>
<span class="id">have</span><span class="id"> mP</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> P</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> measurableC</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> P,</span><span class="id"> N;</span><span class="id"> split;</span><span class="id"> [|exact:</span><span class="id"> neg_set_N|by</span><span class="id"> rewrite</span><span class="id"> /P</span><span class="id"> setvU|by</span><span class="id"> rewrite</span><span class="id"> /P</span><span class="id"> setICl]</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> //</span><span class="id"> D</span><span class="id"> mD</span><span class="id"> DP;</span><span class="id"> rewrite</span><span class="id"> leNgt;</span><span class="id"> apply/negP</span><span class="id"> =&gt;</span><span class="id"> nuD0</span>.<br/>
<span class="id">have</span><span class="id"> znuD</span><span class="id"> n</span><span class="id"> :</span><span class="id"> z_</span> (<span class="id">v</span><span class="id"> n</span>)<span class="id"> &lt;=</span><span class="id"> nu</span><span class="id"> D</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> v0</span><span class="id"> /=;</span><span class="id"> apply:</span><span class="id"> ereal_inf_lbound;</span><span class="gallina-kwd"> exists</span><span class="id"> D;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setC0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [-&gt;</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> Pv</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> ereal_inf_lbound</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> D;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">subset_trans</span><span class="id"> DP</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> subsetC;</span><span class="id"> rewrite</span><span class="id"> Ubig</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> bigsetU_bigcup</span>.<br/>
<span class="id">have</span><span class="id"> max_le0</span><span class="id"> n</span><span class="id"> :</span><span class="id"> maxe</span> (<span class="id">z_</span> (<span class="id">v</span><span class="id"> n</span>)<span class="id"> *</span><span class="id"> 2^-1%:E</span>) (<span class="id">-</span><span class="id"> 1%E</span>)<span class="id"> &lt;=</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ge_max</span><span class="id"> leeN10</span><span class="id"> andbT</span><span class="id"> pmule_lle0</span>.<br/>
<span class="id">have</span><span class="id"> not_s_cvg_0</span><span class="id"> :</span><span class="id"> ~</span> (<span class="id">z_</span><span class="id"> \o</span><span class="id"> v</span>)<span class="id"> n</span><span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span> <span class="id"> --&gt;</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;<span class="id">move/fine_cvgP</span><span class="id"> =&gt;</span><span class="id"> -[zfin]</span><span class="id"> /cvgrPdist_lt</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /[swap]</span><span class="id"> /[apply]</span><span class="id"> -[M</span><span class="id"> _</span><span class="id"> hM]</span><span class="id"> :</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> `|fine</span> (<span class="id">nu</span><span class="id"> D</span>)<span class="id">|</span>)<span class="id">%R</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> normr_gt0//</span><span class="id"> fine_eq0//</span><span class="id"> ?lt_eqF//</span><span class="id"> fin_num_measure</span>.<br/>
&nbsp;&nbsp;<span class="id">near</span><span class="id"> \oo</span><span class="id"> =&gt;</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /hM</span><span class="id"> :</span> (<span class="id">M</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> near:</span><span class="id"> n;</span><span class="gallina-kwd"> exists</span><span class="id"> M</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> sub0r</span><span class="id"> normrN</span><span class="id"> /=</span><span class="id"> ler0_norm</span><span class="id"> ?fine_le0//</span><span class="id"> ltr0_norm//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> fine_lt0//</span><span class="id"> nuD0</span><span class="id"> andbT</span><span class="id"> ltNye_eq</span><span class="id"> fin_num_measure</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ltrN2;</span><span class="id"> apply/negP;</span><span class="id"> rewrite</span><span class="id"> -leNgt</span><span class="id"> fine_le</span><span class="id"> ?fin_num_measure//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> near:</span><span class="id"> n;</span><span class="id"> exact</span>.<br/>
<span class="id">have</span><span class="id"> nuN</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> N</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">n</span><span class="id"> &lt;oo</span>)<span class="id"> nu</span> (<span class="id">A_</span> (<span class="id">v</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply/esym/cvg_lim</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> charge_semi_sigma_additive;</span><span class="id"> [|exact:</span><span class="id"> tA|exact:</span><span class="id"> bigcup_measurable]</span>.<br/>
<span class="id">have</span><span class="id"> sum_A_maxe</span><span class="id"> :</span><span class="id"> \sum_</span>(<span class="id">n</span><span class="id"> &lt;oo</span>)<span class="id"> nu</span> (<span class="id">A_</span> (<span class="id">v</span><span class="id"> n</span>))<span class="id"> &lt;=</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">n</span><span class="id"> &lt;oo</span>)<span class="id"> maxe</span> (<span class="id">z_</span> (<span class="id">v</span><span class="id"> n</span>)<span class="id"> *</span><span class="id"> 2^-1%:E</span>) (<span class="id">-</span><span class="id"> 1%E</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> lee_npeseries</span>.<br/>
<span class="id">have</span><span class="id"> :</span><span class="id"> cvg</span> (<span class="id">\sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> maxe</span> (<span class="id">z_</span> (<span class="id">v</span><span class="id"> k</span>)<span class="id"> *</span><span class="id"> 2^-1%:E</span>) (<span class="id">-</span><span class="id"> 1%E</span>)<span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> is_cvg_ereal_npos_natsum_cond</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> max_le0</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /cvg_ex[[l|</span><span class="id"> |]];</span><span class="id"> first</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> move/cvg_lim</span><span class="id"> =&gt;</span><span class="id"> limNoo</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> N</span><span class="id"> &lt;=</span><span class="id"> -oo</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -limNoo//</span><span class="id"> nuN</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> leNgt</span><span class="id"> =&gt;</span><span class="id"> /negP;</span><span class="id"> apply;</span><span class="id"> rewrite</span><span class="id"> ltNye_eq</span><span class="id"> fin_num_measure</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> move/cvg_lim</span><span class="id"> =&gt;</span><span class="id"> limoo</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> :=</span><span class="id"> @npeseries_le0</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> maxe</span> (<span class="id">z_</span> (<span class="id">v</span><span class="id"> n</span>)<span class="id"> *</span><span class="id"> 2^-1%:E</span>) (<span class="id">-</span><span class="id"> 1%E</span>))<span class="id"> xpredT</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> limoo//</span><span class="id"> leNgt</span><span class="id"> =&gt;</span><span class="id"> /</span>(_ (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> max_le0</span><span class="id"> n</span>))<span class="id">/negP;</span><span class="id"> apply</span>.<br/>
<span class="id">move/fine_cvgP</span><span class="id"> =&gt;</span><span class="id"> [Hfin</span><span class="id"> cvgl]</span>.<br/>
<span class="id">have</span><span class="id"> :</span><span class="id"> cvg</span> (<span class="id">series</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> fine</span> (<span class="id">maxe</span> (<span class="id">z_</span> (<span class="id">v</span><span class="id"> n</span>)<span class="id"> *</span><span class="id"> 2^-1%:E</span>) (<span class="id">-</span><span class="id"> 1%E</span>)))<span class="id"> n</span><span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/cvg_ex;</span><span class="gallina-kwd"> exists</span><span class="id"> l;</span><span class="id"> move:</span><span class="id"> cvgl</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> _</span><span class="id"> \o</span><span class="id"> _</span><span class="id"> =</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> fine</span> (<span class="id">maxe</span> (<span class="id">z_</span> (<span class="id">v</span><span class="id"> k</span>)<span class="id"> *</span><span class="id"> 2^-1%:E</span>)<span class="id">%E</span> (<span class="id">-</span><span class="id"> 1%E</span>)<span class="id">%E</span>))<span class="id">%R</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/funext</span><span class="id"> =&gt;</span><span class="id"> n/=;</span><span class="id"> rewrite</span><span class="id"> sum_fine//</span><span class="id"> =&gt;</span><span class="id"> m</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> le0_fin_numE;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> lt_max</span><span class="id"> ltNyr</span><span class="id"> orbT</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /maxe;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> mule_le0_ge0</span>.<br/>
<span class="id">move/cvg_series_cvg_0</span><span class="id"> =&gt;</span><span class="id"> maxe_cvg_0</span>.<br/>
<span class="id">apply:</span><span class="id"> not_s_cvg_0</span>.<br/>
<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> _</span><span class="id"> \o</span><span class="id"> _</span><span class="id"> =</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> z_</span> (<span class="id">v</span><span class="id"> n</span>)<span class="id"> *</span><span class="id"> 2^-1%:E</span>)<span class="id"> \*</span><span class="id"> cst</span><span class="id"> 2%:E</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/funext</span><span class="id"> =&gt;</span><span class="id"> n/=;</span><span class="id"> rewrite</span><span class="id"> -muleA</span><span class="id"> -EFinM</span><span class="id"> mulVr</span><span class="id"> ?mule1//</span><span class="id"> unitfE</span>.<br/>
<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> 0</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> *</span><span class="id"> 2%:E</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mul0e</span>.<br/>
<span class="id">apply:</span><span class="id"> cvgeM;</span><span class="id"> [by</span><span class="id"> rewrite</span><span class="id"> mule_def_fin|</span><span class="id"> |exact:</span><span class="id"> cvg_cst]</span>.<br/>
<span class="id">apply/fine_cvgP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">move/cvgrPdist_lt</span><span class="id"> :</span><span class="id"> maxe_cvg_0</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> ltr01</span>)<span class="id">[M</span><span class="id"> _</span><span class="id"> hM];</span><span class="id"> near=&gt;</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /hM</span><span class="id"> :</span> (<span class="id">M</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> near:</span><span class="id"> n;</span><span class="gallina-kwd"> exists</span><span class="id"> M</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> sub0r</span><span class="id"> normrN</span><span class="id"> ltNge</span><span class="id"> =&gt;</span><span class="id"> maxe_lt1;</span><span class="id"> rewrite</span><span class="id"> fin_numE;</span><span class="id"> apply/andP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> maxe_lt1</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> max_r</span><span class="id"> ?leNye//=</span><span class="id"> normrN1</span><span class="id"> lexx</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> lt_eqF//</span> (<span class="id">@le_lt_trans</span><span class="id"> _</span><span class="id"> _</span><span class="id"> 0</span>)<span class="id">//</span><span class="id"> mule_le0_ge0</span>.<br/>
<span class="id">apply/cvgrPdist_lt</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /posnumP[e]</span>.<br/>
<span class="id">have</span><span class="id"> :</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> minr</span><span class="id"> e%:num</span><span class="id"> 1</span>)<span class="id">%R</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> lt_min//</span><span class="id"> ltr01</span><span class="id"> andbT</span>.<br/>
<span class="id">move/cvgrPdist_lt</span><span class="id"> :</span><span class="id"> maxe_cvg_0</span><span class="id"> =&gt;</span><span class="id"> /[apply]</span><span class="id"> -[M</span><span class="id"> _</span><span class="id"> hM]</span>.<br/>
<span class="id">near=&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> sub0r</span><span class="id"> normrN</span>.<br/>
<span class="id">have</span><span class="id"> /hM</span><span class="id"> :</span> (<span class="id">M</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> near:</span><span class="id"> n;</span><span class="gallina-kwd"> exists</span><span class="id"> M</span>.<br/>
<span class="id">rewrite</span><span class="id"> sub0r</span><span class="id"> normrN</span><span class="id"> /maxe/=;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> [_|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> normrN</span><span class="id"> normr1</span><span class="id"> lt_min</span><span class="id"> ltxx</span><span class="id"> andbF</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -leNgt</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> /lt_le_trans;</span><span class="id"> apply;</span><span class="id"> rewrite</span><span class="id"> ge_min</span><span class="id"> lexx</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Hahn_decomposition_uniq</span><span class="id"> P1</span><span class="id"> N1</span><span class="id"> P2</span><span class="id"> N2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">hahn_decomposition</span><span class="id"> nu</span><span class="id"> P1</span><span class="id"> N1</span><span class="id"> -&gt;</span><span class="id"> hahn_decomposition</span><span class="id"> nu</span><span class="id"> P2</span><span class="id"> N2</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> S,</span><span class="id"> measurable</span><span class="id"> S</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">nu</span> (<span class="id">S</span><span class="id"> `&amp;`</span><span class="id"> P1</span>)<span class="id"> =</span><span class="id"> nu</span> (<span class="id">S</span><span class="id"> `&amp;`</span><span class="id"> P2</span>)<span class="id"> /\</span><span class="id"> nu</span> (<span class="id">S</span><span class="id"> `&amp;`</span><span class="id"> N1</span>)<span class="id"> =</span><span class="id"> nu</span> (<span class="id">S</span><span class="id"> `&amp;`</span><span class="id"> N2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [psP1</span><span class="id"> nsN1</span><span class="id"> PN1T</span><span class="id"> PN10]</span><span class="id"> [psP2</span><span class="id"> nsN2</span><span class="id"> PN2T</span><span class="id"> PN20]</span><span class="id"> S</span><span class="id"> mS</span>.<br/>
<span class="id">move:</span> (<span class="id">psP1</span>) (<span class="id">nsN1</span>) (<span class="id">psP2</span>) (<span class="id">nsN2</span>)<span class="id"> =&gt;</span><span class="id"> [mP1</span><span class="id"> _]</span><span class="id"> [mN1</span><span class="id"> _]</span><span class="id"> [mP2</span><span class="id"> _]</span><span class="id"> [mN2</span><span class="id"> _]</span>.<br/>
<span class="id">split</span>.<br/>
<span class="id">-</span><span class="id"> transitivity</span> (<span class="id">nu</span> (<span class="id">S</span><span class="id"> `&amp;`</span><span class="id"> P1</span><span class="id"> `&amp;`</span><span class="id"> P2</span>)).<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> rewrite</span> (<span class="id">charge_partition</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mP2</span><span class="id"> mN2</span>)<span class="id">//;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">positive_negative0</span><span class="id"> psP1</span><span class="id"> nsN2</span><span class="id"> mS</span>)<span class="id"> adde0</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> rewrite</span><span class="id"> [RHS]</span>(<span class="id">charge_partition</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mP1</span><span class="id"> mN1</span>)<span class="id">//;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">positive_negative0</span><span class="id"> psP2</span><span class="id"> nsN1</span><span class="id"> mS</span>)<span class="id"> adde0</span><span class="id"> setIAC</span>.<br/>
<span class="id">-</span><span class="id"> transitivity</span> (<span class="id">nu</span> (<span class="id">S</span><span class="id"> `&amp;`</span><span class="id"> N1</span><span class="id"> `&amp;`</span><span class="id"> N2</span>)).<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> rewrite</span> (<span class="id">charge_partition</span><span class="id"> nu</span><span class="id"> _</span><span class="id"> mP2</span><span class="id"> mN2</span>)<span class="id">//;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> :=</span><span class="id"> positive_negative0</span><span class="id"> psP2</span><span class="id"> nsN1</span><span class="id"> mS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIAC</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> add0e</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> rewrite</span><span class="id"> [RHS]</span>(<span class="id">charge_partition</span><span class="id"> nu</span><span class="id"> _</span><span class="id"> mP1</span><span class="id"> mN1</span>)<span class="id">//;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">setIAC</span><span class="id"> _</span><span class="id"> _</span><span class="id"> P1</span>) (<span class="id">positive_negative0</span><span class="id"> psP1</span><span class="id"> nsN2</span><span class="id"> mS</span>)<span class="id"> add0e</span><span class="id"> setIAC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> hahn_decomposition_theorem</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> jordan_decomposition</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">P</span><span class="id"> N</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">nuPN</span><span class="id"> :</span><span class="id"> hahn_decomposition</span><span class="id"> nu</span><span class="id"> P</span><span class="id"> N</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> mP</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> P</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> [[mP</span><span class="id"> _]</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> nuPN</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mN</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> N</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> [mN</span><span class="id"> _]</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> nuPN</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Definition</span><span class="id"> cjordan_pos</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[the</span><span class="id"> charge</span><span class="id"> _</span><span class="id"> _</span><span class="id"> of</span><span class="id"> crestr0</span><span class="id"> nu</span><span class="id"> mP]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cjordan_posE</span><span class="id"> A</span><span class="id"> :</span><span class="id"> cjordan_pos</span><span class="id"> A</span><span class="id"> =</span><span class="id"> crestr0</span><span class="id"> nu</span><span class="id"> mP</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> positive_set_cjordan_pos</span><span class="id"> E</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> cjordan_pos</span><span class="id"> E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [posP</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> nuPN</span>.<br/>
<span class="id">rewrite</span><span class="id"> cjordan_posE</span><span class="id"> /crestr0/=;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> /[1!inE]</span><span class="id"> mE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply</span><span class="id"> posP;</span><span class="id"> [apply:</span><span class="id"> measurableI|apply:</span><span class="id"> subIsetr]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> jordan_pos</span><span class="id"> :=</span><span class="id"> measure_of_charge</span><span class="id"> _</span><span class="id"> positive_set_cjordan_pos</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> jordan_posE</span><span class="id"> A</span><span class="id"> :</span><span class="id"> jordan_pos</span><span class="id"> A</span><span class="id"> =</span><span class="id"> cjordan_pos</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Measure</span>.<span class="id">on</span><span class="id"> jordan_pos</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> finite_jordan_pos</span><span class="id"> :</span><span class="id"> fin_num_fun</span><span class="id"> jordan_pos</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> U</span><span class="id"> mU;</span><span class="id"> rewrite</span><span class="id"> fin_num_measure</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @Measure_isFinite</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><br/>
&nbsp;&nbsp;<span class="id">jordan_pos</span><span class="id"> finite_jordan_pos</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Definition</span><span class="id"> cjordan_neg</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[the</span><span class="id"> charge</span><span class="id"> _</span><span class="id"> _</span><span class="id"> of</span><span class="id"> cscale</span> (<span class="id">-1</span>)<span class="id"> [the</span><span class="id"> charge</span><span class="id"> _</span><span class="id"> _</span><span class="id"> of</span><span class="id"> crestr0</span><span class="id"> nu</span><span class="id"> mN]]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cjordan_negE</span><span class="id"> A</span><span class="id"> :</span><span class="id"> cjordan_neg</span><span class="id"> A</span><span class="id"> =</span><span class="id"> -</span><span class="id"> crestr0</span><span class="id"> nu</span><span class="id"> mN</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> /cscale/=</span><span class="id"> EFinN</span><span class="id"> mulN1e</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> positive_set_cjordan_neg</span><span class="id"> E</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> cjordan_neg</span><span class="id"> E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> cjordan_negE</span><span class="id"> /crestr0/=;</span><span class="id"> case:</span><span class="id"> ifPn;</span><span class="id"> rewrite</span><span class="id"> ?oppe0//</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /[!inE]</span><span class="id"> mE;</span><span class="id"> rewrite</span><span class="id"> /crestr</span><span class="id"> leeNr</span><span class="id"> oppe0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> nuPN</span><span class="id"> =&gt;</span><span class="id"> [_</span><span class="id"> [_</span><span class="id"> +]</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> jordan_neg</span><span class="id"> :=</span><span class="id"> measure_of_charge</span><span class="id"> _</span><span class="id"> positive_set_cjordan_neg</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> jordan_negE</span><span class="id"> A</span><span class="id"> :</span><span class="id"> jordan_neg</span><span class="id"> A</span><span class="id"> =</span><span class="id"> cjordan_neg</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Measure</span>.<span class="id">on</span><span class="id"> jordan_neg</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> finite_jordan_neg</span><span class="id"> :</span><span class="id"> fin_num_fun</span><span class="id"> jordan_neg</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> U</span><span class="id"> mU;</span><span class="id"> rewrite</span><span class="id"> fin_num_measure</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @Measure_isFinite</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><br/>
&nbsp;&nbsp;<span class="id">jordan_neg</span><span class="id"> finite_jordan_neg</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> jordan_decomp</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">nu</span><span class="id"> A</span><span class="id"> =</span> (<span class="id">cadd</span><span class="id"> [the</span><span class="id"> charge</span><span class="id"> _</span><span class="id"> _</span><span class="id"> of</span><span class="id"> jordan_pos]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">[the</span><span class="id"> charge</span><span class="id"> _</span><span class="id"> _</span><span class="id"> of</span><span class="id"> cscale</span> (<span class="id">-1</span>)<span class="id"> [the</span><span class="id"> charge</span><span class="id"> _</span><span class="id"> _</span><span class="id"> of</span><span class="id"> jordan_neg]]</span>))<span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span>.<br/>
<span class="id">rewrite</span><span class="id"> /cadd</span><span class="id"> cjordan_posE</span><span class="id"> /=</span><span class="id"> /cscale</span><span class="id"> EFinN</span><span class="id"> mulN1e</span><span class="id"> cjordan_negE</span><span class="id"> oppeK</span>.<br/>
<span class="id">rewrite</span><span class="id"> /crestr0</span><span class="id"> mem_set//</span><span class="id"> -[in</span><span class="id"> LHS]</span>(<span class="id">setIT</span><span class="id"> A</span>).<br/>
<span class="id">case:</span><span class="id"> nuPN</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> &lt;-</span><span class="id"> PN0;</span><span class="id"> rewrite</span><span class="id"> setIUr</span><span class="id"> chargeU//</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIACA</span><span class="id"> PN0</span><span class="id"> setI0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> jordan_pos_dominates</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> jordan_pos</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nu_mu</span><span class="id"> A</span><span class="id"> mA</span><span class="id"> muA0;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> nu_mu</span><span class="id"> A</span><span class="id"> mA</span><span class="id"> muA0</span>.<br/>
<span class="id">rewrite</span><span class="id"> jordan_posE//</span><span class="id"> cjordan_posE</span><span class="id"> /crestr0</span><span class="id"> mem_set//</span><span class="id"> /crestr/=</span>.<br/>
<span class="id">have</span><span class="id"> mAP</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> P</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">suff</span><span class="id"> :</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> P</span>)<span class="id"> =</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> move/</span>(<span class="id">nu_mu</span><span class="id"> _</span><span class="id"> mAP</span>)<span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le</span><span class="id"> measure_ge0//</span><span class="id"> andbT</span><span class="id"> -muA0</span><span class="id"> le_measure//</span><span class="id"> inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> jordan_neg_dominates</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> jordan_neg</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nu_mu</span><span class="id"> A</span><span class="id"> mA</span><span class="id"> muA0;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> nu_mu</span><span class="id"> A</span><span class="id"> mA</span><span class="id"> muA0</span>.<br/>
<span class="id">rewrite</span><span class="id"> jordan_negE//</span><span class="id"> cjordan_negE</span><span class="id"> /crestr0</span><span class="id"> mem_set//</span><span class="id"> /crestr/=</span>.<br/>
<span class="id">have</span><span class="id"> mAN</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> N</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">suff</span><span class="id"> :</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> N</span>)<span class="id"> =</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /</span>(<span class="id">nu_mu</span><span class="id"> _</span><span class="id"> mAN</span>)<span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> oppe0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le</span><span class="id"> measure_ge0//</span><span class="id"> andbT</span><span class="id"> -muA0</span><span class="id"> le_measure//</span><span class="id"> inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> jordan_decomposition</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> charge_variation</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">P</span><span class="id"> N</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">nuPN</span><span class="id"> :</span><span class="id"> hahn_decomposition</span><span class="id"> nu</span><span class="id"> P</span><span class="id"> N</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> charge_variation</span><span class="id"> :=</span><span class="id"> jordan_pos</span><span class="id"> nuPN</span><span class="id"> \+</span><span class="id"> jordan_neg</span><span class="id"> nuPN</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> charge_variation</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> charge_variation</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">P</span><span class="id"> N</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">nuPN</span><span class="id"> :</span><span class="id"> hahn_decomposition</span><span class="id"> nu</span><span class="id"> P</span><span class="id"> N</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> mu</span><span class="id"> :=</span> (<span class="id">charge_variation</span><span class="id"> nuPN</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> mu0</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /mu</span><span class="id"> !charge0</span><span class="id"> add0e</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mu_ge0</span><span class="id"> x</span><span class="id"> :</span> (<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> x</span>)<span class="id">%E</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> adde_ge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mu_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> big_split;</span><span class="id"> apply:</span><span class="id"> cvgeD</span><span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ge0_adde_def//</span><span class="id"> inE</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measure_semi_sigma_additive</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measure_semi_sigma_additive</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mu</span><br/>
&nbsp;&nbsp;<span class="id">mu0</span><span class="id"> mu_ge0</span><span class="id"> mu_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> mu_fin</span><span class="id"> A</span><span class="id"> :</span><span class="id"> d</span>.<span class="id">-measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> mA;</span><span class="id"> rewrite</span><span class="id"> /mu</span><span class="id"> fin_numD</span><span class="id"> !fin_num_measure</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isCharge</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mu</span><br/>
&nbsp;&nbsp;<span class="id">mu0</span><span class="id"> mu_fin</span><span class="id"> mu_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> charge_variation</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> abse_charge_variation</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> P</span><span class="id"> N</span> (<span class="id">PN</span><span class="id"> :</span><span class="id"> hahn_decomposition</span><span class="id"> nu</span><span class="id"> P</span><span class="id"> N</span>)<span class="id"> A</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> `|nu</span><span class="id"> A|</span><span class="id"> &lt;=</span><span class="id"> charge_variation</span><span class="id"> PN</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span>.<br/>
<span class="id">rewrite</span> (<span class="id">jordan_decomp</span><span class="id"> PN</span><span class="id"> mA</span>)<span class="id"> /cadd/=</span><span class="id"> /cscale/=</span><span class="id"> mulN1e</span><span class="id"> /charge_variation</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span> (<span class="id">lee_abs_sub</span><span class="id"> _</span><span class="id"> _</span>))<span class="id">//</span><span class="id"> !gee0_abs</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> charge_variation_continuous</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">P</span><span class="id"> N</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">nuPN</span><span class="id"> :</span><span class="id"> hahn_decomposition</span><span class="id"> nu</span><span class="id"> P</span><span class="id"> N</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dominates_charge_variation</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> charge_variation</span><span class="id"> nuPN</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> numu</span><span class="id"> A</span><span class="id"> mA</span><span class="id"> muA0</span>.<br/>
<span class="id">rewrite</span><span class="id"> /charge_variation/=</span> (<span class="id">jordan_pos_dominates</span><span class="id"> nuPN</span><span class="id"> numu</span>)<span class="id">//</span><span class="id"> add0e</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">jordan_neg_dominates</span><span class="id"> nuPN</span><span class="id"> numu</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> charge_variation_continuous</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> e</span><span class="id"> :</span><span class="id"> R,</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> e</span>)<span class="id">%R</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> d</span><span class="id"> :</span><span class="id"> R,</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> d</span>)<span class="id">%R</span><span class="id"> /\</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> A,</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> &lt;</span><span class="id"> d%:E</span><span class="id"> -&gt;</span><span class="id"> charge_variation</span><span class="id"> nuPN</span><span class="id"> A</span><span class="id"> &lt;</span><span class="id"> e%:E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> numu;</span><span class="id"> apply/not_forallP</span><span class="id"> =&gt;</span><span class="id"> -[e]</span><span class="id"> /not_implyP[e0]</span><span class="id"> /forallNP</span><span class="id"> H</span>.<br/>
<span class="id">have</span><span class="id"> {H}</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> n,</span><span class="gallina-kwd"> exists</span><span class="id"> A,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> measurable</span><span class="id"> A,</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> &lt;</span> (<span class="id">2</span><span class="id"> ^-</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id">%:E</span><span class="id"> &amp;</span><span class="id"> charge_variation</span><span class="id"> nuPN</span><span class="id"> A</span><span class="id"> &gt;=</span><span class="id"> e%:E]</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> n;</span><span class="id"> have</span><span class="id"> /not_andP[|]</span><span class="id"> :=</span><span class="id"> H</span> (<span class="id">2</span><span class="id"> ^-</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> invr_gt0</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /existsNP[A]</span><span class="id"> /not_implyP[mA]</span><span class="id"> /not_implyP[Aab]</span><span class="id"> /negP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -leNgt</span><span class="id"> =&gt;</span><span class="id"> eint;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /choice[F</span><span class="id"> /=</span><span class="id"> H]</span>.<br/>
<span class="id">have</span><span class="id"> mF</span><span class="id"> i</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>)<span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> H</span><span class="id"> i</span>.<br/>
<span class="id">have</span><span class="id"> :</span><span class="id"> mu</span> (<span class="id">lim_sup_set</span><span class="id"> F</span>)<span class="id"> =</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> lim_sup_set_cvg0</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> h</span><span class="id"> :</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> k</span>) (<span class="id">1</span><span class="id"> /</span><span class="id"> 2</span><span class="id"> ^+</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id">%:E</span><span class="id"> @[k</span><span class="id"> --&gt;</span><span class="id"> \oo]</span><span class="id"> --&gt;</span> (<span class="id">1%E</span><span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/fine_cvgP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> sum_fin_num//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/allP</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> r</span><span class="id"> /mapP[/=</span><span class="id"> k</span><span class="id"> _]</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> :=</span><span class="id"> @cvg_geometric_series_half</span><span class="id"> R</span><span class="id"> 1</span><span class="id"> 0;</span><span class="id"> rewrite</span><span class="id"> {1}/series/=</span><span class="id"> expr0</span><span class="id"> divr1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">under</span><span class="id"> [in</span><span class="id"> X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> X]eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> sumEFin</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> under</span><span class="id"> eq_bigr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> addn1</span><span class="id"> natrX</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">@le_lt_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">\sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> &lt;oo</span>) (<span class="id">1</span><span class="id"> /</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">+1</span>))<span class="id">%:E</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> lee_lim</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> is_cvg_ereal_nneg_natsum_cond</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply/cvg_ex;</span><span class="gallina-kwd"> exists</span><span class="id"> 1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> lee_sum</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> /ltW</span><span class="id"> +</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> H</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> div1r</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/cvg_lim</span><span class="id"> :</span><span class="id"> h</span><span class="id"> =&gt;</span><span class="id"> -&gt;//;</span><span class="id"> rewrite</span><span class="id"> ltry</span>.<br/>
<span class="id">have</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">lim_sup_set</span><span class="id"> F</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcap_measurable</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> bigcup_measurable</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /</span>(<span class="id">dominates_charge_variation</span><span class="id"> numu</span>)<span class="id"> /[apply]</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> neq_lt//</span><span class="id"> ltNge</span><span class="id"> measure_ge0//=</span>.<br/>
<span class="id">suff</span><span class="id"> :</span><span class="id"> charge_variation</span><span class="id"> nuPN</span> (<span class="id">lim_sup_set</span><span class="id"> F</span>)<span class="id"> &gt;=</span><span class="id"> e%:E</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> lt_le_trans</span>.<br/>
<span class="id">have</span><span class="id"> echarge</span><span class="id"> n</span><span class="id"> :</span><span class="id"> e%:E</span><span class="id"> &lt;=</span><span class="id"> charge_variation</span><span class="id"> nuPN</span> (<span class="id">\bigcup_</span>(<span class="id">j</span><span class="id"> &gt;=</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> j</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> /le_trans]</span><span class="id"> :=</span><span class="id"> H</span><span class="id"> n;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> le_measure//</span><span class="id"> ?inE//;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> bigcup_measurable</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_sup</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="id">have</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> _</span>)<span class="id">/cvg_lim</span><span class="id"> &lt;-//</span><span class="id"> :=</span><span class="id"> lim_sup_set_cvg</span> (<span class="id">charge_variation</span><span class="id"> nuPN</span>)<span class="id"> F</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> lime_ge</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> ereal_nonincreasing_is_cvgn</span><span class="id"> =&gt;</span><span class="id"> a</span><span class="id"> b</span><span class="id"> ab</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> le_measure</span><span class="id"> ?inE//;</span><span class="id"> [exact:</span><span class="id"> bigcup_measurable|</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> bigcup_measurable|]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_subset</span><span class="id"> =&gt;</span><span class="id"> n/=;</span><span class="id"> exact:</span><span class="id"> leq_trans</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> k;</span><span class="id"> exact:</span><span class="id"> echarge</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -ge0_fin_numE//</span><span class="id"> fin_num_measure//;</span><span class="id"> exact:</span><span class="id"> bigcup_measurable</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> charge_variation_continuous</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> induced</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>)<span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">intf</span><span class="id"> :</span><span class="id"> mu</span>.<span class="id">-integrable</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> f</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> A</span><span class="id"> =&gt;</span> (<span class="id">\int[mu]_</span>(<span class="id">t</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> f</span><span class="id"> t</span>)<span class="id">%E</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> induced_charge</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>)<span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> semi_sigma_additive_nng_induced</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> setT</span><span class="id"> f</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> f</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">semi_sigma_additive</span> (<span class="gallina-kwd">fun</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> \int[mu]_</span>(<span class="id">t</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> f</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mf</span><span class="id"> f0</span><span class="id"> /=</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> rewrite</span><span class="id"> ge0_integral_bigcup//=;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> measurable_funTS</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> is_cvg_ereal_nneg_natsum_cond</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> integral_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Variable</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> intf</span><span class="id"> :</span><span class="id"> mu</span>.<span class="id">-integrable</span><span class="id"> setT</span><span class="id"> f</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> nu</span><span class="id"> :=</span> (<span class="id">induced</span><span class="id"> intf</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> nu0</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /nu</span><span class="id"> integral_set0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> finnu</span><span class="id"> A</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> nu</span><span class="id"> A</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> mA;</span><span class="id"> apply:</span><span class="id"> integral_fune_fin_num</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> exact:</span><span class="id"> integrableS</span><span class="id"> intf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> snu</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> nu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /=</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> set</span><span class="id"> SF</span><span class="id"> :=</span> (<span class="id">f</span><span class="gallina-kwd"> in</span><span class="id"> f</span><span class="id"> n</span><span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span><span class="id"> --&gt;</span><span class="id"> _</span>).<br/>
<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> SF</span><span class="id"> =</span><span class="gallina-kwd"> fun</span><span class="id"> n</span><span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>) (<span class="id">\int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> F</span><span class="id"> i</span>)<span class="id"> f^\+</span><span class="id"> x</span>)<span class="id"> -</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>) (<span class="id">\int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> F</span><span class="id"> i</span>)<span class="id"> f^\-</span><span class="id"> x</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/funext</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> /SF;</span><span class="id"> under</span><span class="id"> eq_bigr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> /nu</span><span class="id"> integralE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> big_split/=</span><span class="id"> sumeN//=</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> fin_num_adde_defl//</span><span class="id"> integral_fune_fin_num//=</span><span class="id"> integrable_funeneg//=</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> integrableS</span><span class="id"> intf</span>.<br/>
<span class="id">rewrite</span><span class="id"> /nu</span><span class="id"> integralE;</span><span class="id"> apply:</span><span class="id"> cvgeD</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> fin_num_adde_defr//</span><span class="id"> integral_fune_fin_num//=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> integrable_funepos</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> exact:</span><span class="id"> integrableS</span><span class="id"> intf</span>.<br/>
<span class="id">-</span><span class="id"> apply/semi_sigma_additive_nng_induced</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurable_funepos;</span><span class="id"> exact:</span> (<span class="id">measurable_int</span><span class="id"> mu</span>).<br/>
<span class="id">-</span><span class="id"> apply/cvgeN/semi_sigma_additive_nng_induced</span><span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurable_funeneg;</span><span class="id"> exact:</span> (<span class="id">measurable_int</span><span class="id"> mu</span>).<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isCharge</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> nu</span><span class="id"> nu0</span><span class="id"> finnu</span><span class="id"> snu</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> induced_charge</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> dominates_induced</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>)<span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> intf</span><span class="id"> :</span><span class="id"> mu</span>.<span class="id">-integrable</span><span class="id"> setT</span><span class="id"> f</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> intnf</span><span class="id"> :</span><span class="id"> mu</span>.<span class="id">-integrable</span><span class="id"> [set:</span><span class="id"> T]</span> (<span class="id">abse</span><span class="id"> \o</span><span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> integrable_abse</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dominates_induced</span><span class="id"> :</span><span class="id"> induced</span><span class="id"> intnf</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /=</span><span class="id"> A</span><span class="id"> mA</span><span class="id"> muA</span>.<br/>
<span class="id">rewrite</span><span class="id"> /induced;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -abse_eq0</span><span class="id"> eq_le</span><span class="id"> abse_ge0</span><span class="id"> andbT</span>.<br/>
<span class="id">rewrite</span> (<span class="id">le_trans</span> (<span class="id">le_abse_integral</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>))<span class="id">//=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/integrableP</span><span class="id"> :</span><span class="id"> intnf</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> +</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> measurable_funTS</span>.<br/>
<span class="id">rewrite</span><span class="id"> le_eqVlt;</span><span class="id"> apply/orP;</span><span class="id"> left;</span><span class="id"> apply/eqP</span>.<br/>
<span class="id">under</span><span class="id"> eq_integral</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> abse_id</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> null_set_integral</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> exact:</span><span class="id"> integrableS</span><span class="id"> intnf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> dominates_induced</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> integral_normr_continuous</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>)<span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> intf</span><span class="id"> :</span><span class="id"> mu</span>.<span class="id">-integrable</span><span class="id"> setT</span> (<span class="id">EFin</span><span class="id"> \o</span><span class="id"> f</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> intnf</span><span class="id"> :</span><span class="id"> mu</span>.<span class="id">-integrable</span><span class="id"> setT</span> (<span class="id">abse</span><span class="id"> \o</span><span class="id"> EFin</span><span class="id"> \o</span><span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> integrable_abse</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> integral_normr_continuous</span> (<span class="id">e</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> e</span>)<span class="id">%R</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> d</span><span class="id"> :</span><span class="id"> R,</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> d</span>)<span class="id">%R</span><span class="id"> /\</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> A,</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> &lt;</span><span class="id"> d%:E</span><span class="id"> -&gt;</span> (<span class="id">\int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> `|f</span><span class="id"> x|</span><span class="id"> &lt;</span><span class="id"> e</span>)<span class="id">%R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> e0;</span><span class="id"> have</span><span class="id"> [P</span><span class="id"> [N</span><span class="id"> pn]]</span><span class="id"> :=</span><span class="id"> Hahn_decomposition</span> (<span class="id">induced</span><span class="id"> intnf</span>).<br/>
<span class="id">have</span><span class="id"> [r</span><span class="id"> [r0</span><span class="id"> re]]</span><span class="id"> :=</span><span class="id"> charge_variation_continuous</span><span class="id"> pn</span> (<span class="id">dominates_induced</span><span class="id"> intf</span>)<span class="id"> e0</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> r;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> A</span><span class="id"> mA</span><span class="id"> Ad</span>.<br/>
<span class="id">have</span><span class="id"> {re}</span><span class="id"> :=</span><span class="id"> re</span><span class="id"> _</span><span class="id"> mA</span><span class="id"> Ad</span>.<br/>
<span class="id">rewrite</span><span class="id"> -lte_fin;</span><span class="id"> apply:</span><span class="id"> le_lt_trans</span>.<br/>
<span class="id">rewrite</span><span class="id"> /Rintegral</span><span class="id"> fineK;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> :</span><span class="id"> mu</span>.<span class="id">-integrable</span><span class="id"> A</span> (<span class="id">abse</span><span class="id"> \o</span><span class="id"> EFin</span><span class="id"> \o</span><span class="id"> f</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> integrableS</span><span class="id"> intnf</span>.<br/>
&nbsp;&nbsp;<span class="id">move/integrableP</span><span class="id"> :</span><span class="id"> intf</span><span class="id"> =&gt;</span><span class="id"> -[_</span><span class="id"> intfoo</span><span class="id"> _]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ge0_fin_numE//=;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> integral_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> le_lt_trans</span><span class="id"> intfoo</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> ge0_subset_integral</span><span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> measurableT_comp</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/integrableP</span><span class="id"> :</span><span class="id"> intnf</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> /measurable_EFinP</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[leLHS]</span>(<span class="id">gee0_abs</span>)<span class="id">//;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> integral_ge0</span>.<br/>
<span class="id">exact:</span> (<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">abse_charge_variation</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> integral_normr_continuous</span>.<br/>
<br/>
<span class="vernacular">Module</span><span class="id"> approxRN</span>.<br/>
<span class="vernacular">Section</span><span class="id"> approxRN</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span><span class="id"> mu</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> approxRN</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> |</span><span class="id"> [/\</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> g</span><span class="id"> x,</span><span class="id"> mu</span>.<span class="id">-integrable</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> g</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> E,</span><span class="id"> measurable</span><span class="id"> E</span><span class="id"> -&gt;</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> E</span>)<span class="id"> g</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> nu</span><span class="id"> E]</span><span class="id"> ]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> approxRN_neq0</span><span class="id"> :</span><span class="id"> approxRN</span><span class="id"> !=set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">exists</span> (<span class="id">cst</span><span class="id"> 0</span>)<span class="id">;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> integrable0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> E</span><span class="id"> mE;</span><span class="id"> rewrite</span><span class="id"> integral0</span><span class="id"> measure_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> int_approxRN</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> \int[mu]_x</span><span class="id"> g</span><span class="id"> x</span><span class="id"> |</span><span class="id"> g</span><span class="gallina-kwd"> in</span><span class="id"> approxRN]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> sup_int_approxRN</span><span class="id"> :=</span><span class="id"> ereal_sup</span><span class="id"> int_approxRN</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sup_int_approxRN_ge0</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> sup_int_approxRN</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">ereal_sup1</span><span class="id"> 0</span>)<span class="id"> le_ereal_sup//</span><span class="id"> sub1set</span><span class="id"> inE</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">fun=&gt;</span><span class="id"> 0</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> integral0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> [exact:</span><span class="id"> integrable0|move=&gt;</span><span class="id"> E;</span><span class="id"> rewrite</span><span class="id"> integral0]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> approxRN</span>.<br/>
<span class="vernacular">End</span><span class="id"> approxRN</span>.<br/>
<br/>
<span class="vernacular">Module</span><span class="id"> approxRN_seq</span>.<br/>
<span class="vernacular">Section</span><span class="id"> approxRN_seq</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> approxRN</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> approxRN</span><span class="id"> :=</span><span class="id"> approxRN</span><span class="id"> mu</span><span class="id"> nu</span>.<br/>
<span class="vernacular">Let</span><span class="id"> int_approxRN</span><span class="id"> :=</span><span class="id"> int_approxRN</span><span class="id"> mu</span><span class="id"> nu</span>.<br/>
<span class="vernacular">Let</span><span class="id"> M</span><span class="id"> :=</span><span class="id"> sup_int_approxRN</span><span class="id"> mu</span><span class="id"> nu</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> int_approxRN_ub</span><span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> M,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> int_approxRN</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> M%:E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">exists</span> (<span class="id">fine</span> (<span class="id">nu</span><span class="id"> setT</span>))<span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /[1!inE]</span><span class="id"> -[g</span><span class="id"> [g0</span><span class="id"> g1</span><span class="id"> g2]</span><span class="id"> &lt;-{x}]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> fineK</span><span class="id"> ?fin_num_measure//</span> (<span class="id">le_trans</span> (<span class="id">g2</span><span class="id"> setT</span><span class="id"> _</span>))<span class="id">//</span><span class="id"> inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sup_int_approxRN_lty</span><span class="id"> :</span><span class="id"> M</span><span class="id"> &lt;</span><span class="id"> +oo</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /sup_int_approxRN;</span><span class="id"> have</span><span class="id"> [m</span><span class="id"> hm]</span><span class="id"> :=</span><span class="id"> int_approxRN_ub</span>.<br/>
<span class="id">rewrite</span> (<span class="id">@le_lt_trans</span><span class="id"> _</span><span class="id"> _</span><span class="id"> m%:E</span>)<span class="id">//</span><span class="id"> ?ltey//</span><span class="id"> ub_ereal_sup//</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> IGx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> hm;</span><span class="id"> rewrite</span><span class="id"> inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sup_int_approxRN_fin_num</span><span class="id"> :</span><span class="id"> M</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> ge0_fin_numE//;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> sup_int_approxRN_lty</span>.<br/>
<span class="id">exact:</span><span class="id"> sup_int_approxRN_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> approxRN_seq_ex</span><span class="id"> :</span><span class="id"> {</span><span class="id"> g</span><span class="id"> :</span> (<span class="id">T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id">^nat</span><span class="id"> |</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> g</span><span class="id"> k</span><span class="id"> \in</span><span class="id"> approxRN</span><span class="id"> /\</span><span class="id"> \int[mu]_x</span><span class="id"> g</span><span class="id"> k</span><span class="id"> x</span><span class="id"> &gt;</span><span class="id"> M</span><span class="id"> -</span><span class="id"> k</span>.<span class="id">+1%:R^-1%:E</span><span class="id"> }</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> P</span><span class="id"> m</span><span class="id"> g</span><span class="id"> :=</span><span class="id"> g</span><span class="id"> \in</span><span class="id"> approxRN</span><span class="id"> /\</span><span class="id"> M</span><span class="id"> -</span><span class="id"> m</span>.<span class="id">+1%:R^-1%:E</span><span class="id"> &lt;</span><span class="id"> \int[mu]_x</span><span class="id"> g</span><span class="id"> x</span>.<br/>
<span class="id">suff</span><span class="id"> :</span><span class="id"> {</span><span class="id"> g</span><span class="id"> :</span> (<span class="id">T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> ^nat</span><span class="id"> &amp;</span><span class="gallina-kwd"> forall</span><span class="id"> m,</span><span class="id"> P</span><span class="id"> m</span> (<span class="id">g</span><span class="id"> m</span>)<span class="id">}</span><span class="gallina-kwd"> by</span><span class="id"> case</span><span class="id"> =&gt;</span><span class="id"> g</span><span class="id"> ?;</span><span class="gallina-kwd"> exists</span><span class="id"> g</span>.<br/>
<span class="id">apply:</span> (<span class="id">@choice</span><span class="id"> _</span><span class="id"> _</span><span class="id"> P</span>)<span class="id"> =&gt;</span><span class="id"> m</span>.<br/>
<span class="id">rewrite</span><span class="id"> /P</span>.<br/>
<span class="id">have</span><span class="id"> /</span>(<span class="id">@ub_ereal_sup_adherent</span><span class="id"> _</span><span class="id"> int_approxRN</span>)<span class="id"> :</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> m</span>.<span class="id">+1%:R^-1</span><span class="id"> :&gt;</span><span class="id"> R</span>)<span class="id">%R</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> invr_gt0</span>.<br/>
<span class="id">move/</span>(_<span class="id"> sup_int_approxRN_fin_num</span>)<span class="id"> =&gt;</span><span class="id"> [_</span><span class="id"> [h</span><span class="id"> Gh</span><span class="id"> &lt;-]]</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> h;</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> -/M</span><span class="gallina-kwd"> in</span><span class="id"> q</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> approxRN_seq</span><span class="id"> :</span> (<span class="id">T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id">^nat</span><span class="id"> :=</span><span class="id"> sval</span><span class="id"> approxRN_seq_ex</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> g_</span><span class="id"> :=</span><span class="id"> approxRN_seq</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> approxRN_seq_prop</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> m,</span><br/>
&nbsp;&nbsp;<span class="id">g_</span><span class="id"> m</span><span class="id"> \in</span><span class="id"> approxRN</span><span class="id"> /\</span><span class="id"> \int[mu]_x</span> (<span class="id">g_</span><span class="id"> m</span><span class="id"> x</span>)<span class="id"> &gt;</span><span class="id"> M</span><span class="id"> -</span><span class="id"> m</span>.<span class="id">+1%:R^-1%:E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span> (<span class="id">projT2</span><span class="id"> approxRN_seq_ex</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> approxRN_seq_ge0</span><span class="id"> x</span><span class="id"> n</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> g_</span><span class="id"> n</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> [+</span><span class="id"> _]:=</span><span class="id"> approxRN_seq_prop</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> -[]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_approxRN_seq</span><span class="id"> n</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> setT</span> (<span class="id">g_</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> approxRN_seq_prop</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;-[[_</span><span class="id"> /integrableP[]]]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> max_approxRN_seq</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> \big[maxe/-oo]_</span>(<span class="id">j</span><span class="id"> &lt;</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id"> g_</span><span class="id"> j</span><span class="id"> x</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> F_</span><span class="id"> :=</span><span class="id"> max_approxRN_seq</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_max_approxRN_seq</span><span class="id"> n</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T]</span> (<span class="id">F_</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> ih]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /F_</span><span class="id"> /max_approxRN_seq</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> big_ord_recr/=;</span><span class="id"> rewrite</span><span class="id"> -/</span>(<span class="id">measurable_fun</span><span class="id"> _</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> big_ord0;</span><span class="id"> rewrite</span><span class="id"> -/</span>(<span class="id">measurable_fun</span><span class="id"> _</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> maxNye;</span><span class="id"> rewrite</span><span class="id"> -/</span>(<span class="id">measurable_fun</span><span class="id"> _</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [+</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> approxRN_seq_prop</span><span class="id"> 0%N</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> -[]//</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> measurable_approxRN_seq</span>.<br/>
<span class="id">rewrite</span><span class="id"> /F_</span><span class="id"> /max_approxRN_seq</span><span class="id"> =&gt;</span><span class="id"> m</span>.<br/>
<span class="id">under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> big_ord_recr</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurable_maxe</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurable_approxRN_seq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> max_approxRN_seq_ge0</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> F_</span><span class="id"> n</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply/bigmax_geP;</span><span class="id"> right</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> ord0</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> approxRN_seq_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> max_approxRN_seq_ge</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> F_</span><span class="id"> n</span><span class="id"> x</span><span class="id"> &gt;=</span><span class="id"> g_</span><span class="id"> n</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/bigmax_geP;</span><span class="id"> right</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> ord_max</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> max_approxRN_seq_nd</span><span class="id"> x</span><span class="id"> :</span><span class="id"> nondecreasing_seq</span> (<span class="id">F_</span><span class="id"> ^~</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> b</span><span class="id"> ab;</span><span class="id"> rewrite</span> (<span class="id">le_bigmax_ord</span><span class="id"> xpredT</span> (<span class="id">g_</span><span class="id"> ^~</span><span class="id"> x</span>)). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> is_cvg_max_approxRN_seq</span><span class="id"> n</span><span class="id"> :</span><span class="id"> cvg</span> (<span class="id">F_</span><span class="id"> ^~</span><span class="id"> n</span><span class="id"> @</span><span class="id"> \oo</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> ereal_nondecreasing_is_cvgn;</span><span class="id"> exact:</span><span class="id"> max_approxRN_seq_nd</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> is_cvg_int_max_approxRN_seq</span><span class="id"> A</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> cvg</span> ((<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> F_</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> @</span><span class="id"> \oo</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA;</span><span class="id"> apply:</span><span class="id"> ereal_nondecreasing_is_cvgn</span><span class="id"> =&gt;</span><span class="id"> a</span><span class="id"> b</span><span class="id"> ab</span>.<br/>
<span class="id">apply:</span><span class="id"> ge0_le_integral</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> max_approxRN_seq_ge0</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measurable_funS</span> (<span class="id">measurable_max_approxRN_seq</span><span class="id"> a</span>).<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> max_approxRN_seq_ge0</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurable_funS</span> (<span class="id">measurable_max_approxRN_seq</span><span class="id"> b</span>).<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> max_approxRN_seq_nd</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> is_max_approxRN</span><span class="id"> m</span><span class="id"> j</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> x</span><span class="id"> |</span><span class="id"> F_</span><span class="id"> m</span><span class="id"> x</span><span class="id"> =</span><span class="id"> g_</span><span class="id"> j</span><span class="id"> x</span><span class="id"> /\</span><span class="gallina-kwd"> forall</span><span class="id"> k,</span> (<span class="id">k</span><span class="id"> &lt;</span><span class="id"> j</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> g_</span><span class="id"> k</span><span class="id"> x</span><span class="id"> &lt;</span><span class="id"> g_</span><span class="id"> j</span><span class="id"> x]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> E</span><span class="id"> :=</span><span class="id"> is_max_approxRN</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> is_max_approxRNE</span><span class="id"> m</span><span class="id"> j</span><span class="id"> :</span><span class="id"> E</span><span class="id"> m</span><span class="id"> j</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> x|</span><span class="id"> F_</span><span class="id"> m</span><span class="id"> x</span><span class="id"> =</span><span class="id"> g_</span><span class="id"> j</span><span class="id"> x]</span><span class="id"> `&amp;`</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set</span><span class="id"> x</span><span class="id"> |forall</span><span class="id"> k,</span> (<span class="id">k</span><span class="id"> &lt;</span><span class="id"> j</span>)<span class="id">%nat</span><span class="id"> -&gt;</span><span class="id"> g_</span><span class="id"> k</span><span class="id"> x</span><span class="id"> &lt;</span><span class="id"> g_</span><span class="id"> j</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/seteqP;</span><span class="id"> split</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> trivIset_is_max_approxRN</span><span class="id"> n</span><span class="id"> :</span><span class="id"> trivIset</span><span class="id"> [set:</span><span class="id"> nat]</span> (<span class="id">E</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/trivIsetP</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _</span><span class="id"> ij</span>.<br/>
<span class="id">apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> [];</span><span class="id"> rewrite</span><span class="id"> /E/=</span><span class="id"> =&gt;</span><span class="id"> -[+</span><span class="id"> +</span><span class="id"> [+</span><span class="id"> +]]</span>.<br/>
<span class="id">wlog</span><span class="id"> :</span><span class="id"> i</span><span class="id"> j</span><span class="id"> ij</span><span class="id"> /</span> (<span class="id">i</span><span class="id"> &lt;</span><span class="id"> j</span>)<span class="id">%N</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> h</span><span class="id"> Fmgi</span><span class="id"> iFm</span><span class="id"> Fmgj</span><span class="id"> jFm</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> :=</span><span class="id"> ij;</span><span class="id"> rewrite</span><span class="id"> neq_lt</span><span class="id"> =&gt;</span><span class="id"> /orP[ji|ji];</span><span class="id"> first</span><span class="id"> exact:</span> (<span class="id">h</span><span class="id"> i</span><span class="id"> j</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">h</span><span class="id"> j</span><span class="id"> i</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> {}ij</span><span class="id"> Fmgi</span><span class="id"> h</span><span class="id"> Fmgj</span> <span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> ij</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -Fmgi</span><span class="id"> -Fmgj</span><span class="id"> ltxx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigsetU_is_max_approxRN</span><span class="id"> m</span><span class="id"> :</span><span class="id"> \big[setU/set0]_</span>(<span class="id">j</span><span class="id"> &lt;</span><span class="id"> m</span>.<span class="id">+1</span>)<span class="id"> E</span><span class="id"> m</span><span class="id"> j</span><span class="id"> =</span><span class="id"> [set:</span><span class="id"> T]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -bigcup_mkord</span>.<br/>
<span class="id">pose</span><span class="id"> j</span><span class="id"> :=</span><span class="id"> [arg</span><span class="id"> max_</span>(<span class="id">j</span><span class="id"> &gt;</span><span class="id"> @ord0</span><span class="id"> m</span>)<span class="id"> g_</span><span class="id"> j</span><span class="id"> x]%O</span>.<br/>
<span class="id">have</span><span class="id"> j0_proof</span><span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> k,</span> (<span class="id">k</span><span class="id"> &lt;</span><span class="id"> m</span>.<span class="id">+1</span>)<span class="id">%N</span><span class="id"> &amp;&amp;</span> (<span class="id">g_</span><span class="id"> k</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> g_</span><span class="id"> j</span><span class="id"> x</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> eqxx</span><span class="id"> andbT</span>.<br/>
<span class="id">pose</span><span class="id"> j0</span><span class="id"> :=</span><span class="id"> ex_minn</span><span class="id"> j0_proof</span>.<br/>
<span class="id">have</span><span class="id"> j0m</span><span class="id"> :</span> (<span class="id">j0</span><span class="id"> &lt;</span><span class="id"> m</span>.<span class="id">+1</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /j0;</span><span class="id"> case:</span><span class="id"> ex_minnP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?</span><span class="id"> /andP[]</span>.<br/>
<span class="id">have</span><span class="id"> j0max</span><span class="id"> k</span><span class="id"> :</span> (<span class="id">k</span><span class="id"> &lt;</span><span class="id"> j0</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> g_</span><span class="id"> k</span><span class="id"> x</span><span class="id"> &lt;</span><span class="id"> g_</span><span class="id"> j0</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /j0;</span><span class="id"> case:</span><span class="id"> ex_minnP</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> j'</span><span class="id"> /andP[j'm</span><span class="id"> j'j]</span><span class="id"> h</span><span class="id"> kj'</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> lt_neqAle;</span><span class="id"> apply/andP;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">eqP</span><span class="id"> j'j</span>)<span class="id"> /j;</span><span class="id"> case:</span><span class="id"> arg_maxP</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> i</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/</span>(_ (<span class="id">Ordinal</span> (<span class="id">ltn_trans</span><span class="id"> kj'</span><span class="id"> j'm</span>)))<span class="id">;</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/negP</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> gkj'</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> :=</span><span class="id"> h</span><span class="id"> k;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">eqP</span><span class="id"> j'j</span>)<span class="id"> -gkj'</span><span class="id"> eqxx</span><span class="id"> andbT</span> (<span class="id">ltn_trans</span><span class="id"> kj'</span><span class="id"> j'm</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /</span>(_<span class="id"> erefl</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> leqNgt</span><span class="id"> kj'</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> j0</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /F_</span><span class="id"> /max_approxRN_seq</span> (<span class="id">bigmax_eq_arg</span><span class="id"> _</span><span class="id"> ord0</span>)<span class="id">//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> leNye</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /j0/=;</span><span class="id"> case:</span><span class="id"> ex_minnP</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> j'</span><span class="id"> /andP[j'm</span><span class="id"> /eqP]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /g_</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span><span class="id"> h</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> k</span><span class="id"> kj;</span><span class="id"> exact:</span><span class="id"> j0max</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_is_max_approxRN</span><span class="id"> m</span><span class="id"> j</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">E</span><span class="id"> m</span><span class="id"> j</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> is_max_approxRNE;</span><span class="id"> apply:</span><span class="id"> measurableI</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> X]setTI</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> emeasurable_fun_eq</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> [exact:</span><span class="id"> measurable_max_approxRN_seq|</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> measurable_approxRN_seq]</span>.<br/>
<span class="id">rewrite</span><span class="id"> [T</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> T]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">\bigcap_</span>(<span class="id">k</span><span class="gallina-kwd"> in</span><span class="id"> `I_j</span>)<span class="id"> [set</span><span class="id"> x</span><span class="id"> |</span><span class="id"> g_</span><span class="id"> k</span><span class="id"> x</span><span class="id"> &lt;</span><span class="id"> g_</span><span class="id"> j</span><span class="id"> x]</span>)<span class="id">//</span>.<br/>
<span class="id">apply:</span><span class="id"> bigcap_measurableType</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> _</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> X]setTI;</span><span class="id"> apply:</span><span class="id"> emeasurable_fun_lt</span><span class="id"> =&gt;</span><span class="id"> //;</span><br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> measurable_approxRN_seq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> approxRN_seq</span>.<br/>
<span class="vernacular">End</span><span class="id"> approxRN_seq</span>.<br/>
<br/>
<span class="vernacular">Module</span><span class="id"> lim_max_approxRN_seq</span>.<br/>
<span class="vernacular">Section</span><span class="id"> lim_max_approxRN_seq</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span><span class="id"> mu</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> approxRN</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> G</span><span class="id"> :=</span><span class="id"> approxRN</span><span class="id"> mu</span><span class="id"> nu</span>.<br/>
<span class="vernacular">Let</span><span class="id"> M</span><span class="id"> :=</span><span class="id"> sup_int_approxRN</span><span class="id"> mu</span><span class="id"> nu</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> approxRN_seq</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> g</span><span class="id"> :=</span><span class="id"> approxRN_seq</span><span class="id"> mu</span><span class="id"> nu</span>.<br/>
<span class="vernacular">Let</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> max_approxRN_seq</span><span class="id"> mu</span><span class="id"> nu</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> fRN</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> lim</span> (<span class="id">F</span><span class="id"> ^~</span><span class="id"> x</span><span class="id"> @</span><span class="id"> \oo</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_fun_fRN</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> fRN</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> fRN</span><span class="id"> =</span><span class="gallina-kwd"> fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> limn_esup</span> (<span class="id">F</span><span class="id"> ^~</span><span class="id"> x</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> measurable_fun_limn_esup</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> measurable_max_approxRN_seq</span>.<br/>
<span class="id">apply/funext=&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> is_cvg_limn_esupE//</span>.<br/>
<span class="id">exact:</span><span class="id"> is_cvg_max_approxRN_seq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fRN_ge0</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> fRN</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> lime_ge</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> is_cvg_max_approxRN_seq</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> max_approxRN_seq_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> int_fRN_lim</span><span class="id"> A</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> fRN</span><span class="id"> x</span><span class="id"> =</span><span class="id"> lim</span> (<span class="id">\int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> n</span><span class="id"> x</span><span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA;</span><span class="id"> rewrite</span><span class="id"> monotone_convergence//</span><span class="id"> =&gt;</span><span class="id"> n</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurable_funS</span> (<span class="id">measurable_max_approxRN_seq</span><span class="id"> mu</span><span class="id"> nu</span><span class="id"> n</span>).<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> max_approxRN_seq_ge0</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> max_approxRN_seq_nd</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> E</span><span class="id"> m</span><span class="id"> j</span><span class="id"> :=</span><span class="id"> is_max_approxRN</span><span class="id"> mu</span><span class="id"> nu</span><span class="id"> m</span><span class="id"> j</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> int_F_nu</span><span class="id"> m</span><span class="id"> A</span> (<span class="id">mA</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span>)<span class="id"> :</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> m</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> nu</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> [leLHS]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">j</span><span class="id"> &lt;</span><span class="id"> m</span>.<span class="id">+1</span>)<span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> E</span><span class="id"> m</span><span class="id"> j</span>))<span class="id"> F</span><span class="id"> m</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -[in</span><span class="id"> LHS]</span>(<span class="id">setIT</span><span class="id"> A</span>)<span class="id"> -</span>(<span class="id">bigsetU_is_max_approxRN</span><span class="id"> mu</span><span class="id"> nu</span><span class="id"> m</span>)<span class="id"> big_distrr/=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">@big_mkord</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> m</span>.<span class="id">+1</span><span class="id"> xpredT</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> is_max_approxRN</span><span class="id"> mu</span><span class="id"> nu</span><span class="id"> m</span><span class="id"> i</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ge0_integral_bigsetU</span><span class="id"> ?big_mkord//</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> measurableI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurable_is_max_approxRN</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> iota_uniq</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> apply:</span><span class="id"> trivIset_setIl;</span><span class="id"> apply:</span> (<span class="id">@sub_trivIset</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> setT</span> (<span class="id">E</span><span class="id"> m</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> trivIset_is_max_approxRN</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measurable_funTS</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurable_max_approxRN_seq</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> max_approxRN_seq_ge0</span>.<br/>
<span class="id">rewrite</span><span class="id"> [leLHS]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">j</span><span class="id"> &lt;</span><span class="id"> m</span>.<span class="id">+1</span>) (<span class="id">\int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span> (<span class="id">A</span><span class="id"> `&amp;`</span> (<span class="id">E</span><span class="id"> m</span><span class="id"> j</span>)))<span class="id"> g</span><span class="id"> j</span><span class="id"> x</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> apply:eq_integral</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> -[?]</span><span class="id"> []</span><span class="id"> Fmgi</span><span class="id"> h</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le;</span><span class="id"> rewrite</span><span class="id"> /F</span><span class="id"> Fmgi</span><span class="id"> lexx</span>.<br/>
<span class="id">rewrite</span><span class="id"> [leRHS]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> &lt;</span><span class="id"> m</span>.<span class="id">+1</span>) (<span class="id">nu</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> E</span><span class="id"> m</span><span class="id"> j</span>)))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">@measure_semi_additive</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> nu</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> E</span><span class="id"> m</span><span class="id"> i</span>))<span class="id">//</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -big_distrr/=</span><span class="id"> bigsetU_is_max_approxRN//</span><span class="id"> setIT</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> k;</span><span class="id"> apply:</span><span class="id"> measurableI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurable_is_max_approxRN</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> trivIset_setIl</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> trivIset_is_max_approxRN</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> measurableI</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> measurable_is_max_approxRN</span>.<br/>
<span class="id">apply:</span><span class="id"> lee_sum</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> i</span><span class="id"> _</span>.<br/>
<span class="id">have</span><span class="id"> [+</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> approxRN_seq_prop</span><span class="id"> mu</span><span class="id"> nu</span><span class="id"> i</span>.<br/>
<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> /G/=</span><span class="id"> =&gt;</span><span class="id"> -[_</span><span class="id"> _];</span><span class="id"> apply</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurableI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurable_is_max_approxRN</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> F_G</span><span class="id"> m</span><span class="id"> :</span><span class="id"> F</span><span class="id"> m</span><span class="id"> \in</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> /G/=;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> max_approxRN_seq_ge0</span>.<br/>
<span class="id">-</span><span class="id"> apply/integrableP;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> measurable_max_approxRN_seq</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_integral</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> gee0_abs;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> max_approxRN_seq_ge0;</span><span class="id"> over</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /le_lt_trans</span><span class="id"> :=</span><span class="id"> int_F_nu</span><span class="id"> m</span><span class="id"> measurableT;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> fin_num_fun_lty;</span><span class="id"> exact:</span><span class="id"> fin_num_measure</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A;</span><span class="id"> exact:</span><span class="id"> int_F_nu</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> M_g_F</span><span class="id"> m</span><span class="id"> :</span><span class="id"> M</span><span class="id"> -</span><span class="id"> m</span>.<span class="id">+1%:R^-1%:E</span><span class="id"> &lt;</span><span class="id"> \int[mu]_x</span><span class="id"> g</span><span class="id"> m</span><span class="id"> x</span><span class="id"> /\</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\int[mu]_x</span><span class="id"> g</span><span class="id"> m</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> \int[mu]_x</span><span class="id"> F</span><span class="id"> m</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> M</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> approxRN_seq_prop</span><span class="id"> mu</span><span class="id"> nu</span><span class="id"> m</span>.<br/>
<span class="id">apply/andP;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> ereal_sup_ubound;</span><span class="gallina-kwd"> exists</span> (<span class="id">F</span><span class="id"> m</span>) <span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> F_G</span><span class="id"> m;</span><span class="id"> rewrite</span><span class="id"> inE</span>.<br/>
<span class="id">apply:</span><span class="id"> ge0_le_integral</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> approxRN_seq_ge0</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurable_approxRN_seq</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> *;</span><span class="id"> exact:</span><span class="id"> max_approxRN_seq_ge0</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurable_max_approxRN_seq</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> max_approxRN_seq_ge</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> int_fRN_lty</span><span class="id"> :</span><span class="id"> \int[mu]_x</span><span class="id"> `|fRN</span><span class="id"> x|</span><span class="id"> &lt;</span><span class="id"> +oo</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span> (<span class="id">@le_lt_trans</span><span class="id"> _</span><span class="id"> _</span><span class="id"> M</span>)<span class="id">//;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> sup_int_approxRN_lty</span>.<br/>
<span class="id">under</span><span class="id"> eq_integral</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> gee0_abs;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> fRN_ge0;</span><span class="id"> over</span>.<br/>
<span class="id">rewrite</span><span class="id"> int_fRN_lim//</span><span class="id"> lime_le//;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> is_cvg_int_max_approxRN_seq</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> /andP[_</span><span class="id"> ]]</span><span class="id"> :=</span><span class="id"> M_g_F</span><span class="id"> n</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> int_fRN_ub</span><span class="id"> A</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> fRN</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> nu</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA;</span><span class="id"> rewrite</span><span class="id"> int_fRN_lim//</span><span class="id"> lime_le</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> is_cvg_int_max_approxRN_seq</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> exact:</span><span class="id"> int_F_nu</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> int_fRNE</span><span class="id"> :</span><span class="id"> \int[mu]_x</span><span class="id"> fRN</span><span class="id"> x</span><span class="id"> =</span><span class="id"> M</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le;</span><span class="id"> apply/andP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> int_fRN_lim//</span><span class="id"> lime_le//;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> is_cvg_int_max_approxRN_seq</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> /andP[_]]</span><span class="id"> :=</span><span class="id"> M_g_F</span><span class="id"> n</span>.<br/>
<span class="id">rewrite</span><span class="id"> int_fRN_lim//</span>.<br/>
<span class="id">have</span><span class="id"> cvgM</span><span class="id"> :</span> (<span class="id">M</span><span class="id"> -</span><span class="id"> m</span>.<span class="id">+1%:R^-1%:E</span>)<span class="id"> @[m</span><span class="id"> --&gt;</span><span class="id"> \oo]</span><span class="id"> --&gt;</span><span class="id"> M</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> X]sube0;</span><span class="id"> apply:</span><span class="id"> cvgeB</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> fin_num_adde_defl</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> exact:</span><span class="id"> cvg_cst</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> apply/fine_cvgP;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> nearW</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> @</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> x</span>.<span class="id">+1%:R^-1</span>))<span class="id">//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/gtr0_cvgV0;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> nearW</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/cvgrnyP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> @</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="gallina-kwd"> fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> +</span><span class="id"> 1</span>)<span class="id">%N;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> cvg_addnr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/funext</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> addn1</span>.<br/>
<span class="id">apply:</span> (<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">lim</span> (<span class="id">M</span><span class="id"> -</span><span class="id"> m</span>.<span class="id">+1%:R^-1%:E</span><span class="id"> @[m</span><span class="id"> --&gt;</span><span class="id"> \oo]</span>))).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/cvg_lim</span><span class="id"> :</span><span class="id"> cvgM</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="id">apply:</span><span class="id"> lee_lim;</span><span class="id"> [by</span><span class="id"> apply/cvg_ex;</span><span class="gallina-kwd"> exists</span><span class="id"> M|exact:</span><span class="id"> is_cvg_int_max_approxRN_seq|]</span>.<br/>
<span class="id">apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> m</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [/[swap]</span><span class="id"> /andP[?</span><span class="id"> _]</span><span class="id"> /ltW/le_trans]</span><span class="id"> :=</span><span class="id"> M_g_F</span><span class="id"> m;</span><span class="id"> exact</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> ab_absurdo</span>.<br/>
<span class="vernacular">Context</span><span class="id"> A</span> (<span class="id">mA</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span>) (<span class="id">h</span><span class="id"> :</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> fRN</span><span class="id"> x</span><span class="id"> &lt;</span><span class="id"> nu</span><span class="id"> A</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> epsRN_ex</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{eps</span><span class="id"> :</span><span class="id"> {posnum</span><span class="id"> R}</span><span class="id"> |</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>) (<span class="id">fRN</span><span class="id"> x</span><span class="id"> +</span><span class="id"> eps%:num%:E</span>)<span class="id"> &lt;</span><span class="id"> nu</span><span class="id"> A}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [muA0|]</span><span class="id"> :=</span><span class="id"> eqVneq</span> (<span class="id">mu</span><span class="id"> A</span>)<span class="id"> 0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">PosNum</span><span class="id"> ltr01</span>).<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_integral</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">@gee0_abs</span><span class="id"> _</span> (_<span class="id"> +</span><span class="id"> _</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> adde_ge0//</span><span class="id"> fRN_ge0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">over</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">@integral_abs_eq0</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> setT</span>)<span class="id">//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_lt_trans</span><span class="id"> _</span><span class="id"> h</span>)<span class="id">//</span><span class="id"> integral_ge0//</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> Ax;</span><span class="id"> exact:</span><span class="id"> fRN_ge0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> emeasurable_funD</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurable_fun_fRN</span>.<br/>
<span class="id">rewrite</span><span class="id"> neq_lt</span><span class="id"> ltNge</span><span class="id"> measure_ge0//=</span><span class="id"> =&gt;</span><span class="id"> muA_gt0</span>.<br/>
<span class="id">pose</span><span class="id"> mid</span><span class="id"> :=</span> ((<span class="id">fine</span> (<span class="id">nu</span><span class="id"> A</span>)<span class="id"> -</span><span class="id"> fine</span> (<span class="id">\int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> fRN</span><span class="id"> x</span>))<span class="id"> /</span><span class="id"> 2</span>)<span class="id">%R</span>.<br/>
<span class="id">pose</span><span class="id"> e</span><span class="id"> :=</span> (<span class="id">mid</span><span class="id"> /</span><span class="id"> fine</span> (<span class="id">mu</span><span class="id"> A</span>))<span class="id">%R</span>.<br/>
<span class="id">have</span><span class="id"> ?</span><span class="id"> :</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> fRN</span><span class="id"> x</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ge0_fin_numE//</span><span class="id"> ?</span>(<span class="id">lt_le_trans</span><span class="id"> h</span>)<span class="id">//</span><span class="id"> ?leey//</span><span class="id"> integral_ge0//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> Ax;</span><span class="id"> exact:</span><span class="id"> fRN_ge0</span>.<br/>
<span class="id">have</span><span class="id"> e_gt0</span><span class="id"> :</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> e</span>)<span class="id">%R</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /e</span><span class="id"> divr_gt0//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> fine_gt0//</span><span class="id"> muA_gt0/=</span><span class="id"> ltey_eq</span><span class="id"> fin_num_measure</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> divr_gt0//</span><span class="id"> subr_gt0//</span><span class="id"> fine_lt//</span><span class="id"> fin_num_measure</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">PosNum</span><span class="id"> e_gt0</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ge0_integralD//;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> Ax;</span><span class="id"> exact:</span><span class="id"> fRN_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> measurable_funS</span><span class="id"> measurable_fun_fRN</span>.<br/>
<span class="id">rewrite</span><span class="id"> integral_cst//</span><span class="id"> -lteBrDr//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> fin_numM//</span><span class="id"> fin_num_measure</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> *</span><span class="id"> X]</span>(<span class="id">@fineK</span><span class="id"> _</span> (<span class="id">mu</span><span class="id"> A</span>))<span class="id"> ?fin_num_measure//</span>.<br/>
<span class="id">rewrite</span><span class="id"> -EFinM</span><span class="id"> -mulrA</span><span class="id"> mulVr</span><span class="id"> ?mulr1;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> unitfE</span><span class="id"> gt_eqF//</span><span class="id"> fine_gt0//</span><span class="id"> muA_gt0/=</span><span class="id"> ltey_eq</span><span class="id"> fin_num_measure</span>.<br/>
<span class="id">rewrite</span><span class="id"> lteBrDl//</span><span class="id"> addeC</span><span class="id"> -lteBrDl//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">@fineK</span><span class="id"> _</span> (<span class="id">nu</span><span class="id"> A</span>))<span class="id">//</span><span class="id"> ?fin_num_measure//</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> -</span><span class="id"> X]</span>(<span class="id">@fineK</span><span class="id"> _</span>)<span class="id">//</span>.<br/>
<span class="id">rewrite</span><span class="id"> -EFinB</span><span class="id"> lte_fin</span><span class="id"> /mid</span><span class="id"> ltr_pdivrMr//</span><span class="id"> ltr_pMr//</span><span class="id"> ?ltr1n//</span><span class="id"> subr_gt0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> fine_lt//</span><span class="id"> fin_num_measure</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> epsRN</span><span class="id"> :=</span><span class="id"> sval</span><span class="id"> epsRN_ex</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> sigmaRN</span><span class="id"> B</span><span class="id"> :=</span><span class="id"> nu</span><span class="id"> B</span><span class="id"> -</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> B</span>) (<span class="id">fRN</span><span class="id"> x</span><span class="id"> +</span><span class="id"> epsRN%:num%:E</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> sigmaRN0</span><span class="id"> :</span><span class="id"> sigmaRN</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /sigmaRN</span><span class="id"> measure0</span><span class="id"> integral_set0</span><span class="id"> subee</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> fin_num_int_fRN_eps</span><span class="id"> B</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> B</span>) (<span class="id">fRN</span><span class="id"> x</span><span class="id"> +</span><span class="id"> epsRN%:num%:E</span>)<span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mB;</span><span class="id"> rewrite</span><span class="id"> ge0_integralD//;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> Bx;</span><span class="id"> exact:</span><span class="id"> fRN_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> measurable_funS</span><span class="id"> measurable_fun_fRN</span>.<br/>
<span class="id">rewrite</span><span class="id"> fin_numD</span><span class="id"> integral_cst//</span><span class="id"> fin_numM</span><span class="id"> ?fin_num_measure//</span><span class="id"> andbT</span>.<br/>
<span class="id">rewrite</span><span class="id"> ge0_fin_numE</span><span class="id"> ?measure_ge0//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> integral_ge0</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> Bx;</span><span class="id"> exact:</span><span class="id"> fRN_ge0</span>.<br/>
<span class="id">rewrite</span> (<span class="id">le_lt_trans</span><span class="id"> _</span><span class="id"> int_fRN_lty</span>)<span class="id">//</span>.<br/>
<span class="id">under</span><span class="id"> [in</span><span class="id"> leRHS]eq_integral</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> gee0_abs;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> fRN_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">over</span>.<br/>
<span class="id">apply:</span><span class="id"> ge0_subset_integral</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> measurable_fun_fRN</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> fRN_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> fin_num_sigmaRN</span><span class="id"> B</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> sigmaRN</span><span class="id"> B</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mB;</span><span class="id"> rewrite</span><span class="id"> /sigmaRN</span><span class="id"> fin_numB</span><span class="id"> fin_num_measure//=</span>.<br/>
<span class="id">exact:</span><span class="id"> fin_num_int_fRN_eps</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> sigmaRN_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> sigmaRN</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> H</span><span class="id"> mH</span><span class="id"> tH</span><span class="id"> mUH</span>.<br/>
<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> @</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> nu</span> (<span class="id">H</span><span class="id"> i</span>)<span class="id"> -</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> H</span><span class="id"> i</span>) (<span class="id">fRN</span><span class="id"> x</span><span class="id"> +</span><span class="id"> epsRN%:num%:E</span>)))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/funext</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> big_split/=</span><span class="id"> fin_num_sumeN//</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> fin_num_int_fRN_eps</span>.<br/>
<span class="id">apply:</span><span class="id"> cvgeB</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> adde_defC</span><span class="id"> fin_num_adde_defl//</span><span class="id"> fin_num_measure</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measure_semi_sigma_additive</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span> (<span class="id">ge0_integral_bigcup</span><span class="id"> _</span><span class="id"> mH</span><span class="id"> _</span><span class="id"> _</span><span class="id"> tH</span>).<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> have</span><span class="id"> /cvg_ex[/=</span><span class="id"> l</span><span class="id"> hl]</span><span class="id"> :</span><span class="id"> cvg</span> ((<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> \int[mu]_</span>(<span class="id">y</span><span class="gallina-kwd"> in</span><span class="id"> H</span><span class="id"> i</span>) (<span class="id">fRN</span><span class="id"> y</span><span class="id"> +</span><span class="id"> epsRN%:num%:E</span>))<span class="id"> @</span><span class="id"> \oo</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> is_cvg_ereal_nneg_natsum</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> integral_ge0</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> adde_ge0//;</span><span class="id"> exact:</span><span class="id"> fRN_ge0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">@cvg_lim</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> l</span>).<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> apply:</span><span class="id"> emeasurable_funD</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> apply:</span><span class="id"> measurable_funTS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> measurable_fun_fRN</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> adde_ge0//;</span><span class="id"> exact:</span><span class="id"> fRN_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @isCharge</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> sigmaRN</span><br/>
&nbsp;&nbsp;<span class="id">sigmaRN0</span><span class="id"> fin_num_sigmaRN</span><span class="id"> sigmaRN_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> ab_absurdo</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> lim_max_approxRN_seq</span>.<br/>
<span class="vernacular">End</span><span class="id"> lim_max_approxRN_seq</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> radon_nikodym_finite</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span><span class="id"> mu</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> approxRN</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> G</span><span class="id"> :=</span><span class="id"> approxRN</span><span class="id"> mu</span><span class="id"> nu</span>.<br/>
<span class="vernacular">Let</span><span class="id"> M</span><span class="id"> :=</span><span class="id"> sup_int_approxRN</span><span class="id"> mu</span><span class="id"> nu</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> lim_max_approxRN_seq</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> f</span><span class="id"> :=</span><span class="id"> fRN</span><span class="id"> mu</span><span class="id"> nu</span>.<br/>
<span class="vernacular">Let</span><span class="id"> mf</span><span class="id"> :=</span><span class="id"> measurable_fun_fRN</span>.<br/>
<span class="vernacular">Let</span><span class="id"> f_ge0</span><span class="id"> :=</span><span class="id"> fRN_ge0</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> radon_nikodym_finite</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R,</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> &gt;=</span><span class="id"> 0,</span><span class="id"> mu</span>.<span class="id">-integrable</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> f</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> E,</span><span class="id"> measurable</span><span class="id"> E</span><span class="id"> -&gt;</span><span class="id"> nu</span><span class="id"> E</span><span class="id"> =</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> E</span>)<span class="id"> f</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nu_mu;</span><span class="gallina-kwd"> exists</span><span class="id"> f;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> exact:</span><span class="id"> f_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply/integrableP;</span><span class="id"> split;</span><span class="id"> [exact:</span><span class="id"> mf|exact:</span><span class="id"> int_fRN_lty]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> //</span><span class="id"> A</span><span class="id"> mA</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le</span><span class="id"> int_fRN_ub//</span><span class="id"> andbT</span><span class="id"> leNgt;</span><span class="id"> apply/negP</span><span class="id"> =&gt;</span><span class="id"> abs</span>.<br/>
<span class="id">pose</span><span class="id"> sigma</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[the</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span><span class="id"> of</span><span class="id"> sigmaRN</span><span class="id"> mA</span><span class="id"> abs]</span>.<br/>
<span class="id">have</span><span class="id"> [P</span><span class="id"> [N</span><span class="id"> [[mP</span><span class="id"> posP]</span><span class="id"> [mN</span><span class="id"> negN]</span><span class="id"> PNX</span><span class="id"> PN0]]]</span><span class="id"> :=</span><span class="id"> Hahn_decomposition</span><span class="id"> sigma</span>.<br/>
<span class="id">pose</span><span class="id"> AP</span><span class="id"> :=</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> P</span>.<br/>
<span class="id">have</span><span class="id"> mAP</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> AP</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">have</span><span class="id"> muAP_gt0</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> mu</span><span class="id"> AP</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> lt0e</span><span class="id"> measure_ge0//</span><span class="id"> andbT</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP/</span>(<span class="id">contra_not</span> (<span class="id">nu_mu</span><span class="id"> _</span><span class="id"> mAP</span>))<span class="id">/eqP;</span><span class="id"> rewrite</span><span class="id"> gt_eqF//</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">@lt_le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">sigma</span><span class="id"> AP</span>))<span class="id">//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">@lt_le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">sigma</span><span class="id"> A</span>))<span class="id">//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">charge_partition</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mP</span><span class="id"> mN</span>)<span class="id">//</span><span class="id"> geeDl//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> negN</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> sube_gt0//</span> (<span class="id">proj2_sig</span> (<span class="id">epsRN_ex</span><span class="id"> mA</span><span class="id"> abs</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /sigma/=</span><span class="id"> /sigmaRN</span><span class="id"> lee_subel_addl</span><span class="id"> ?fin_num_measure//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> lee_paddl//</span><span class="id"> integral_ge0//</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> adde_ge0//;</span><span class="id"> exact:</span><span class="id"> f_ge0</span>.<br/>
<span class="id">pose</span><span class="id"> h</span><span class="id"> x</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> AP</span><span class="gallina-kwd"> then</span><span class="id"> f</span><span class="id"> x</span><span class="id"> +</span> (<span class="id">epsRN</span><span class="id"> mA</span><span class="id"> abs</span>)<span class="id">%:num%:E</span><span class="gallina-kwd"> else</span><span class="id"> f</span><span class="id"> x</span>.<br/>
<span class="id">have</span><span class="id"> mh</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> setT</span><span class="id"> h</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> measurable_fun_if</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">measurable_fun_bool</span><span class="id"> true</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> setTI</span><span class="id"> preimage_mem_true</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measurable_funTS;</span><span class="id"> apply:</span><span class="id"> emeasurable_funD</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measurable_funTS;</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
<span class="id">have</span><span class="id"> hge0</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> h</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /h;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> [_|?];</span><span class="id"> [rewrite</span><span class="id"> adde_ge0//</span><span class="id"> f_ge0|exact:</span><span class="id"> f_ge0]</span>.<br/>
<span class="id">have</span><span class="id"> hnuP</span><span class="id"> S</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> `&lt;=`</span><span class="id"> AP</span><span class="id"> -&gt;</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> S</span>)<span class="id"> h</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> nu</span><span class="id"> S</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> mS</span><span class="id"> SAP</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> sigma</span><span class="id"> S</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> posP</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span> (<span class="id">subset_trans</span><span class="id"> SAP</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> subIsetr</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> sube_ge0;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> fin_num_measure//</span><span class="id"> orbT</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> le_trans;</span><span class="id"> rewrite</span><span class="id"> le_eqVlt;</span><span class="id"> apply/orP;</span><span class="id"> left;</span><span class="id"> apply/eqP</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -{1}</span>(<span class="id">setIid</span><span class="id"> S</span>)<span class="id"> integral_mkcondr;</span><span class="id"> apply/eq_integral</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /[!inE]</span><span class="id"> Sx</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /restrict</span><span class="id"> /h</span><span class="id"> !ifT//</span><span class="id"> inE//;</span><span class="id"> exact:</span><span class="id"> SAP</span>.<br/>
<span class="id">have</span><span class="id"> hnuN</span><span class="id"> S</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> `&lt;=`</span><span class="id"> ~`</span><span class="id"> AP</span><span class="id"> -&gt;</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> S</span>)<span class="id"> h</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> nu</span><span class="id"> S</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> mS</span><span class="id"> ScAP;</span><span class="id"> rewrite</span><span class="id"> /h;</span><span class="id"> under</span><span class="id"> eq_integral</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> xS;</span><span class="id"> rewrite</span><span class="id"> ifF;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/negbTE;</span><span class="id"> rewrite</span><span class="id"> notin_setE;</span><span class="id"> apply:</span><span class="id"> ScAP;</span><span class="id"> apply:</span><span class="id"> set_mem</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">over</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> int_fRN_ub</span>.<br/>
<span class="id">have</span><span class="id"> hnu</span><span class="id"> S</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> S</span>)<span class="id"> h</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> nu</span><span class="id"> S</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> mS</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">setD0</span><span class="id"> S</span>)<span class="id"> -</span>(<span class="id">setDv</span><span class="id"> AP</span>)<span class="id"> setDDr</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> mSIAP</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">S</span><span class="id"> `&amp;`</span><span class="id"> AP</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> mSDAP</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">S</span><span class="id"> `\`</span><span class="id"> AP</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> measurableD</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ge0_integral_setU</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> measureU//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> leeD;</span><span class="id"> [exact:</span><span class="id"> hnuN|exact:</span><span class="id"> hnuP]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> setIACA</span><span class="id"> setICl</span><span class="id"> setI0</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurable_funTS</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> disj_set2E</span><span class="id"> setDE</span><span class="id"> setIACA</span><span class="id"> setICl</span><span class="id"> setI0</span>.<br/>
<span class="id">have</span><span class="id"> int_h_M</span><span class="id"> :</span><span class="id"> \int[mu]_x</span><span class="id"> h</span><span class="id"> x</span><span class="id"> &gt;</span><span class="id"> M</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> mCAP</span><span class="id"> :=</span><span class="id"> measurableC</span><span class="id"> mAP</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> disj_AP</span><span class="id"> :</span><span class="id"> [disjoint</span><span class="id"> AP</span><span class="id"> &amp;</span><span class="id"> ~`</span><span class="id"> AP]</span><span class="gallina-kwd"> by</span><span class="id"> exact/disj_set2P/setICr</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">setUv</span><span class="id"> AP</span>)<span class="id"> ge0_integral_setU</span><span class="id"> ?setUv//</span><span class="id"> /h</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_integral</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> ifT//</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> &lt;</span><span class="id"> _</span><span class="id"> +</span><span class="id"> X]eq_integral</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> xE0p;</span><span class="id"> rewrite</span><span class="id"> memNset//;</span><span class="id"> over</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ge0_integralD//;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> f_ge0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measurable_funTS;</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> integral_cst</span><span class="id"> //</span><span class="id"> addeAC</span><span class="id"> -ge0_integral_setU//;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setUv//;</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> f_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setUv</span><span class="id"> int_fRNE</span><span class="id"> -lte_subel_addl;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ge0_fin_numE//</span><span class="id"> ?sup_int_approxRN_lty//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> approxRN_seq</span>.<span class="id">sup_int_approxRN_lty</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> sup_int_approxRN_ge0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /M</span><span class="id"> subee</span><span class="id"> ?mule_gt0//</span><span class="id"> approxRN_seq</span>.<span class="id">sup_int_approxRN_fin_num</span>.<br/>
<span class="id">have</span><span class="id"> Gh</span><span class="id"> :</span><span class="id"> G</span><span class="id"> h</span>.<br/>
&nbsp;&nbsp;<span class="id">split=&gt;</span><span class="id"> //;</span><span class="id"> apply/integrableP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_integral</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> gee0_abs//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_lt_trans</span> (<span class="id">hnu</span><span class="id"> _</span><span class="id"> measurableT</span>))<span class="id">//</span><span class="id"> ltey_eq</span><span class="id"> fin_num_measure</span>.<br/>
<span class="id">have</span><span class="id"> :</span><span class="id"> \int[mu]_x</span><span class="id"> h</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> M</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">ereal_sup1</span> (<span class="id">\int[mu]_x</span><span class="id"> h</span><span class="id"> x</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">@le_ereal_sup</span><span class="id"> _</span><span class="id"> [set</span><span class="id"> \int[mu]_x</span><span class="id"> h</span><span class="id"> x]</span> (<span class="id">int_approxRN</span><span class="id"> mu</span><span class="id"> nu</span>))<span class="id">//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> sub1set</span><span class="id"> inE;</span><span class="gallina-kwd"> exists</span><span class="id"> h</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> leNgt</span><span class="id"> int_h_M</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> radon_nikodym_finite</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> radon_nikodym_sigma_finite</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {sigma_finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">nu</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> radon_nikodym_sigma_finite</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R,</span><span class="id"> [/\</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> &gt;=</span><span class="id"> 0,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mu</span>.<span class="id">-integrable</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> f</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> A,</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> nu</span><span class="id"> A</span><span class="id"> =</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> f</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nu_mu;</span><span class="id"> have</span><span class="id"> [F</span><span class="id"> TF</span><span class="id"> /all_and2[mF</span><span class="id"> muFoo]]</span><span class="id"> :=</span><span class="id"> sigma_finiteT</span><span class="id"> mu</span>.<br/>
<span class="id">pose</span><span class="id"> E</span><span class="id"> :=</span><span class="id"> seqDU</span><span class="id"> F</span>.<br/>
<span class="id">have</span><span class="id"> mE</span><span class="id"> k</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">E</span><span class="id"> k</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurableD</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> bigsetU_measurable</span>.<br/>
<span class="id">have</span><span class="id"> muEoo</span><span class="id"> k</span><span class="id"> :</span><span class="id"> mu</span> (<span class="id">E</span><span class="id"> k</span>)<span class="id"> &lt;</span><span class="id"> +oo</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_lt_trans</span><span class="id"> _</span> (<span class="id">muFoo</span><span class="id"> k</span>))<span class="id">//</span><span class="id"> le_measure</span><span class="id"> ?inE//;</span><span class="id"> exact:</span><span class="id"> subDsetl</span>.<br/>
<span class="id">have</span><span class="id"> UET</span><span class="id"> :</span><span class="id"> \bigcup_i</span><span class="id"> E</span><span class="id"> i</span><span class="id"> =</span><span class="id"> [set:</span><span class="id"> T]</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> TF</span><span class="id"> [RHS]seqDU_bigcup_eq</span>.<br/>
<span class="id">have</span><span class="id"> tE</span><span class="id"> :=</span><span class="id"> trivIset_seqDU</span><span class="id"> F</span>.<br/>
<span class="id">pose</span><span class="id"> mu_</span><span class="id"> j</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[the</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> _}</span><span class="id"> of</span><span class="id"> mfrestr</span> (<span class="id">mE</span><span class="id"> j</span>) (<span class="id">muEoo</span><span class="id"> j</span>)<span class="id">]</span>.<br/>
<span class="id">have</span><span class="id"> nuEoo</span><span class="id"> i</span><span class="id"> :</span><span class="id"> nu</span> (<span class="id">E</span><span class="id"> i</span>)<span class="id"> &lt;</span><span class="id"> +oo</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ltey_eq</span><span class="id"> fin_num_measure</span>.<br/>
<span class="id">pose</span><span class="id"> nu_</span><span class="id"> j</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[the</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> _}</span><span class="id"> of</span><span class="id"> mfrestr</span> (<span class="id">mE</span><span class="id"> j</span>) (<span class="id">nuEoo</span><span class="id"> j</span>)<span class="id">]</span>.<br/>
<span class="id">have</span><span class="id"> nu_mu_</span><span class="id"> k</span><span class="id"> :</span><span class="id"> nu_</span><span class="id"> k</span><span class="id"> `&lt;&lt;</span><span class="id"> mu_</span><span class="id"> k</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> S</span><span class="id"> mS</span><span class="id"> mu_kS0;</span><span class="id"> apply:</span><span class="id"> nu_mu</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">have</span><span class="id"> [g_]</span><span class="id"> :=</span><span class="id"> choice</span> (<span class="gallina-kwd">fun</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> radon_nikodym_finite</span> (<span class="id">nu_mu_</span><span class="id"> j</span>)).<br/>
<span class="id">move=&gt;</span><span class="id"> /all_and3[g_ge0</span><span class="id"> ig_</span><span class="id"> int_gE]</span>.<br/>
<span class="id">pose</span><span class="id"> f_</span><span class="id"> j</span><span class="id"> x</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> E</span><span class="id"> j</span><span class="gallina-kwd"> then</span><span class="id"> g_</span><span class="id"> j</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> 0</span>.<br/>
<span class="id">have</span><span class="id"> f_ge0</span><span class="id"> k</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> f_</span><span class="id"> k</span><span class="id"> x</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /f_;</span><span class="id"> case:</span><span class="id"> ifP</span>.<br/>
<span class="id">have</span><span class="id"> mf_</span><span class="id"> k</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> setT</span> (<span class="id">f_</span><span class="id"> k</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> measurable_fun_if</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">measurable_fun_bool</span><span class="id"> true</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> setTI</span><span class="id"> preimage_mem_true</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> preimage_mem_true</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurable_funTS</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> have</span><span class="id"> /integrableP[]</span><span class="id"> :=</span><span class="id"> ig_</span><span class="id"> k</span>.<br/>
<span class="id">have</span><span class="id"> if_T</span><span class="id"> k</span><span class="id"> :</span><span class="id"> integrable</span><span class="id"> mu</span><span class="id"> setT</span> (<span class="id">f_</span><span class="id"> k</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/integrableP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_integral</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> gee0_abs//</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">setUv</span> (<span class="id">E</span><span class="id"> k</span>))<span class="id"> ge0_integral_setU</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> 3</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurableC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setUv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact/disj_set2P/subsets_disjoint</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /f_;</span><span class="id"> under</span><span class="id"> eq_integral</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> ifT//</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">@eq_measure_integral</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">E</span><span class="id"> k</span>) (<span class="id">mu_</span><span class="id"> k</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> mA</span><span class="id"> AEj;</span><span class="id"> rewrite</span><span class="id"> /mu_</span><span class="id"> /=</span><span class="id"> /mfrestr</span><span class="id"> /mrestr</span><span class="id"> setIidl</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -int_gE</span><span class="id"> ?inE//</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_integral</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> /[!inE]</span><span class="id"> /=</span><span class="id"> Ekx;</span><span class="id"> rewrite</span><span class="id"> ifF;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> memNset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">over</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> integral0</span><span class="id"> ?adde0</span><span class="id"> ltey_eq</span><span class="id"> fin_num_measure</span>.<br/>
<span class="id">have</span><span class="id"> int_f_E</span><span class="id"> j</span><span class="id"> S</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> S</span>)<span class="id"> f_</span><span class="id"> j</span><span class="id"> x</span><span class="id"> =</span><span class="id"> nu</span> (<span class="id">S</span><span class="id"> `&amp;`</span><span class="id"> E</span><span class="id"> j</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> mS</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> mSIEj</span><span class="id"> :=</span><span class="id"> measurableI</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mS</span> (<span class="id">mE</span><span class="id"> j</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> mSDEj</span><span class="id"> :=</span><span class="id"> measurableD</span><span class="id"> mS</span> (<span class="id">mE</span><span class="id"> j</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -{1}</span>(<span class="id">setUIDK</span><span class="id"> S</span> (<span class="id">E</span><span class="id"> j</span>)) (<span class="id">ge0_integral_setU</span><span class="id"> _</span><span class="id"> mSIEj</span><span class="id"> mSDEj</span>)<span class="id">//;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setUIDK;</span><span class="id"> exact:</span> (<span class="id">measurable_funS</span><span class="id"> measurableT</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply/disj_set2P;</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> setIACA</span><span class="id"> setICr</span><span class="id"> setI0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /f_</span><span class="id"> -</span>(<span class="id">eq_integral</span><span class="id"> _</span> (<span class="id">g_</span><span class="id"> j</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> /[!inE]</span><span class="id"> SIEjx;</span><span class="id"> rewrite</span><span class="id"> /f_</span><span class="id"> ifT//</span><span class="id"> inE;</span><span class="id"> exact:</span> (<span class="id">@subIsetr</span><span class="id"> _</span><span class="id"> S</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">@eq_measure_integral</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">S</span><span class="id"> `&amp;`</span><span class="id"> E</span><span class="id"> j</span>) (<span class="id">mu_</span><span class="id"> j</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> mA;</span><span class="id"> rewrite</span><span class="id"> subsetI</span><span class="id"> =&gt;</span><span class="id"> -[_</span><span class="id"> ?];</span><span class="id"> rewrite</span><span class="id"> /mu_</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /mfrestr</span><span class="id"> /mrestr</span><span class="id"> setIidl</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -int_gE;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_integral</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> setDE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> -[_</span><span class="id"> Ejx]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ifF;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> memNset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">over</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> integral0</span><span class="id"> adde0</span><span class="id"> /nu_/=</span><span class="id"> /mfrestr</span><span class="id"> /mrestr</span><span class="id"> -setIA</span><span class="id"> setIid</span>.<br/>
<span class="id">pose</span><span class="id"> f</span><span class="id"> x</span><span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> &lt;oo</span>)<span class="id"> f_</span><span class="id"> j</span><span class="id"> x</span>.<br/>
<span class="id">have</span><span class="id"> int_f_nuT</span><span class="id"> :</span><span class="id"> \int[mu]_x</span><span class="id"> f</span><span class="id"> x</span><span class="id"> =</span><span class="id"> nu</span><span class="id"> setT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> integral_nneseries//</span>.<br/>
&nbsp;&nbsp;<span class="id">transitivity</span> (<span class="id">\sum_</span>(<span class="id">n</span><span class="id"> &lt;oo</span>)<span class="id"> nu</span> (<span class="id">E</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_eseriesr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> int_f_E//</span><span class="id"> setTI</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -UET</span><span class="id"> measure_bigcup//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_eseriesl</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> in_setT</span>.<br/>
<span class="id">have</span><span class="id"> mf</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> setT</span><span class="id"> f</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> ge0_emeasurable_fun_sum</span>.<br/>
<span class="id">have</span><span class="id"> fi</span><span class="id"> :</span><span class="id"> mu</span>.<span class="id">-integrable</span><span class="id"> setT</span><span class="id"> f</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/integrableP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_integral</span><span class="id"> do</span> (<span class="id">rewrite</span><span class="id"> gee0_abs;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> nneseries_ge0</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> int_f_nuT</span><span class="id"> ltey_eq</span><span class="id"> fin_num_measure</span>.<br/>
<span class="id">have</span><span class="id"> ae_f</span><span class="id"> :=</span><span class="id"> integrable_ae</span><span class="id"> measurableT</span><span class="id"> fi</span>.<br/>
<span class="id">pose</span><span class="id"> f'</span><span class="id"> x</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> f</span><span class="id"> x</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span><span class="gallina-kwd"> then</span><span class="id"> f</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> 0</span>.<br/>
<span class="id">have</span><span class="id"> ff'</span><span class="id"> :</span><span class="id"> ae_eq</span><span class="id"> mu</span><span class="id"> setT</span><span class="id"> f</span><span class="id"> f'</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> ae_f</span><span class="id"> =&gt;</span><span class="id"> N</span><span class="id"> [mN</span><span class="id"> N0</span><span class="id"> fN];</span><span class="gallina-kwd"> exists</span><span class="id"> N;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> subset_trans</span><span class="id"> fN;</span><span class="id"> apply:</span><span class="id"> subsetC</span><span class="id"> =&gt;</span><span class="id"> z/=</span><span class="id"> /</span>(_<span class="id"> I</span>)<span class="id"> fz</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /f'</span><span class="id"> fz</span>.<br/>
<span class="id">have</span><span class="id"> mf'</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> setT</span><span class="id"> f'</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> measurable_fun_ifT</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span> (<span class="id">measurable_fun_bool</span><span class="id"> true</span>)<span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> emeasurable_fin_num</span><span class="id"> measurableT</span><span class="id"> mf;</span><span class="id"> rewrite</span><span class="id"> setTI</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> f';</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> /f';</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> nneseries_ge0</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> /f';</span><span class="id"> case:</span><span class="id"> ifPn</span>.<br/>
<span class="id">-</span><span class="id"> apply/integrableP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply/abse_integralP</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">move/ae_eq_integral</span><span class="id"> :</span> (<span class="id">ff'</span>)<span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> measurableT</span><span class="id"> mf</span>)<span class="id"> &lt;-//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/abse_integralP</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> move/integrableP</span><span class="id"> :</span><span class="id"> fi</span><span class="id"> =&gt;</span><span class="id"> []</span>.<br/>
<span class="id">have</span><span class="id"> nuf</span><span class="id"> A</span><span class="id"> :</span><span class="id"> d</span>.<span class="id">-measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> nu</span><span class="id"> A</span><span class="id"> =</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> f</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> mA;</span><span class="id"> rewrite</span><span class="id"> integral_nneseries//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> exact:</span><span class="id"> measurable_funTS</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> nneseries_esum;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> m</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> integral_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_esum</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> int_f_E//</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -nneseries_esum;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> measure_ge0//;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">@eq_eseriesl</span><span class="id"> _</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> [set:</span><span class="id"> nat]</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> in_setT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -measure_bigcup//</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setI_bigcupr</span><span class="id"> UET</span><span class="id"> setIT</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> trivIset_setIl</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> mA;</span><span class="id"> rewrite</span><span class="id"> nuf</span><span class="id"> ?inE//;</span><span class="id"> apply:</span><span class="id"> ae_eq_integral</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="id"> exact/measurable_funTS</span>.<br/>
<span class="id">-</span><span class="id"> exact/measurable_funTS</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> ae_eq_subset</span><span class="id"> ff'</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> radon_nikodym_sigma_finite</span>.<br/>
<br/>
<span class="vernacular">Module</span><span class="id"> Radon_Nikodym_SigmaFinite</span>.<br/>
<span class="vernacular">Section</span><span class="id"> radon_nikodym_sigma_finite_def</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">nu</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {sigma_finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span><span class="id"> pselect</span> (<span class="id">nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span>)<span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> left</span><span class="id"> nu_mu</span><span class="id"> =&gt;</span><span class="id"> sval</span> (<span class="id">cid</span> (<span class="id">radon_nikodym_sigma_finite</span><span class="id"> nu_mu</span>))<br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> right</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> cst</span><span class="id"> -oo</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> f_ge0</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> f</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /f;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> numu</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> f_fin_num</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /f;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> numu</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> f_integrable</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> mu</span>.<span class="id">-integrable</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /f;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> numu</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> f_integral</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">nu</span><span class="id"> A</span><span class="id"> =</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> f</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /f;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> numu</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> radon_nikodym_sigma_finite_def</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> integrableM</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">nu</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {sigma_finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> numu</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;'d nu '/d mu&quot;</span><span class="id"> :=</span> (<span class="id">f</span><span class="id"> nu</span><span class="id"> mu</span>).<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> HBNNSimple</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> change_of_variables</span><span class="id"> f</span><span class="id"> E</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> f</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> E</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> E</span><span class="id"> f</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> E</span>) (<span class="id">f</span><span class="id"> x</span><span class="id"> *</span> (<span class="id">'d</span><span class="id"> nu</span><span class="id"> '/d</span><span class="id"> mu</span>)<span class="id"> x</span>)<span class="id"> =</span><span class="id"> \int[nu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> E</span>)<span class="id"> f</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> f0</span><span class="id"> mE</span><span class="id"> mf;</span><span class="id"> set</span><span class="id"> g</span><span class="id"> :=</span><span class="id"> 'd</span><span class="id"> nu</span><span class="id"> '/d</span><span class="id"> mu</span>.<br/>
<span class="id">have</span><span class="id"> [h</span><span class="id"> [ndh</span><span class="id"> hf]]</span><span class="id"> :=</span><span class="id"> approximation</span><span class="id"> mE</span><span class="id"> mf</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> f0</span><span class="id"> x</span>).<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> \int[nu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> E</span>)<span class="id"> f</span><span class="id"> x</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lim</span> (<span class="id">\int[nu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> E</span>) (<span class="id">EFin</span><span class="id"> \o</span><span class="id"> h</span><span class="id"> n</span>)<span class="id"> x</span><span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> fE</span><span class="id"> x</span><span class="id"> :</span><span class="id"> E</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> =</span><span class="id"> lim</span> ((<span class="id">EFin</span><span class="id"> \o</span><span class="id"> h</span><span class="id"> n</span>)<span class="id"> x</span><span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Ex;</span><span class="id"> apply/esym/cvg_lim</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> hf</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_integral</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /[!inE]</span><span class="id"> /fE</span><span class="id"> -&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> monotone_convergence</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> apply/measurable_EFinP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">measurable_funS</span><span class="id"> measurableT</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact/measurable_funP</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> x</span><span class="id"> Ex</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> lee_fin</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> Ex</span><span class="id"> a</span><span class="id"> b</span><span class="id"> /ndh</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> lee_fin</span><span class="id"> =&gt;</span><span class="id"> /lefP</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> E</span>) (<span class="id">f</span><span class="id"> \*</span><span class="id"> g</span>)<span class="id"> x</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lim</span> (<span class="id">\int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> E</span>) ((<span class="id">EFin</span><span class="id"> \o</span><span class="id"> h</span><span class="id"> n</span>)<span class="id"> \*</span><span class="id"> g</span>)<span class="id"> x</span><span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> fg</span><span class="id"> x</span><span class="id"> :E</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> *</span><span class="id"> g</span><span class="id"> x</span><span class="id"> =</span><span class="id"> lim</span> (((<span class="id">EFin</span><span class="id"> \o</span><span class="id"> h</span><span class="id"> n</span>)<span class="id"> \*</span><span class="id"> g</span>)<span class="id"> x</span><span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Ex;</span><span class="id"> apply/esym/cvg_lim</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> cvgeMr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[exact:</span><span class="id"> f_fin_num|exact:</span><span class="id"> hf]</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_integral</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /[!inE]</span><span class="id"> /fg</span><span class="id"> -&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> monotone_convergence</span><span class="id"> =&gt;</span><span class="id"> [//|</span><span class="id"> |</span><span class="id"> |]</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> apply/emeasurable_funM;</span><span class="id"> apply/measurable_funTS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact/measurable_EFinP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> measurable_int</span> (<span class="id">f_integrable</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> x</span><span class="id"> Ex</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> mule_ge0</span><span class="id"> ?lee_fin//=;</span><span class="id"> exact:</span><span class="id"> f_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> Ex</span><span class="id"> a</span><span class="id"> b</span><span class="id"> /ndh</span><span class="id"> /=</span><span class="id"> /lefP</span><span class="id"> hahb;</span><span class="id"> rewrite</span><span class="id"> lee_wpmul2r</span><span class="id"> ?lee_fin//</span><span class="id"> f_ge0</span>.<br/>
<span class="id">suff</span><span class="id"> suf</span><span class="id"> n</span><span class="id"> :</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> E</span>) ((<span class="id">EFin</span><span class="id"> \o</span><span class="id"> h</span><span class="id"> n</span>)<span class="id"> x</span><span class="id"> *</span><span class="id"> g</span><span class="id"> x</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\int[nu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> E</span>) (<span class="id">EFin</span><span class="id"> \o</span><span class="id"> h</span><span class="id"> n</span>)<span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> suf</span>.<br/>
<span class="id">transitivity</span> (<span class="id">\int[nu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> E</span>)<br/>
&nbsp;&nbsp;&nbsp;(<span class="id">\sum_</span>(<span class="id">y</span><span class="id"> \in</span><span class="id"> range</span> (<span class="id">h</span><span class="id"> n</span>)) (<span class="id">y</span><span class="id"> *</span><span class="id"> \1_</span>(<span class="id">h</span><span class="id"> n</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> y]</span>)<span class="id"> x</span>)<span class="id">%:E</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_integral</span><span class="id"> =&gt;</span><span class="id"> t</span><span class="id"> tE;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> fimfunE</span><span class="id"> -fsumEFin</span>.<br/>
<span class="id">have</span><span class="id"> indich</span><span class="id"> m</span><span class="id"> r</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> E</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">r</span><span class="id"> *</span><span class="id"> \1_</span>(<span class="id">h</span><span class="id"> m</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> r]</span>)<span class="id"> x</span>)<span class="id">%:E</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">measurable_comp</span><span class="id"> measurableT</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurable_funM</span>.<br/>
<span class="id">rewrite</span><span class="id"> ge0_integral_fsum//;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> m</span><span class="id"> y</span><span class="id"> Ey;</span><span class="id"> exact:</span><span class="id"> nnfun_muleindic_ge0</span>.<br/>
<span class="id">transitivity</span> (<span class="id">\int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> E</span>) (<span class="id">\sum_</span>(<span class="id">y</span><span class="id"> \in</span><span class="id"> range</span> (<span class="id">h</span><span class="id"> n</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">y</span><span class="id"> *</span><span class="id"> \1_</span>(<span class="id">h</span><span class="id"> n</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> y]</span>)<span class="id"> x</span>)<span class="id">%:E</span><span class="id"> *</span><span class="id"> g</span><span class="id"> x</span>)).<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> [RHS]eq_integral</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> xE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -ge0_mule_fsuml</span><span class="id"> =&gt;</span><span class="id"> [|y];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> nnfun_muleindic_ge0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> fsumEFin</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">fimfunE</span><span class="id"> _</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> over</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> []</span>.<br/>
<span class="id">rewrite</span><span class="id"> ge0_integral_fsum//;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> y;</span><span class="id"> apply:</span><span class="id"> emeasurable_funM</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> measurable_funTS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> measurable_int</span> (<span class="id">f_integrable</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> m</span><span class="id"> y</span><span class="id"> Ey;</span><span class="id"> rewrite</span><span class="id"> mule_ge0</span><span class="id"> ?f_ge0//</span><span class="id"> nnfun_muleindic_ge0</span>.<br/>
<span class="id">apply:</span><span class="id"> eq_fsbigr</span><span class="id"> =&gt;</span><span class="id"> r</span><span class="id"> rhn</span>.<br/>
<span class="id">under</span><span class="id"> [RHS]eq_integral</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> EFinM</span>.<br/>
<span class="id">rewrite</span><span class="id"> integralZl_indic_nnsfun</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">under</span><span class="id"> eq_integral</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> EFinM</span><span class="id"> -muleA</span>.<br/>
<span class="id">rewrite</span><span class="id"> ge0_integralZl//</span>.<br/>
<span class="id">-</span><span class="id"> under</span><span class="id"> eq_integral</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> muleC</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">eq_integral</span> (<span class="id">g</span><span class="id"> \_</span> (<span class="id">h</span><span class="id"> n</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> r]</span>)))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> xE;</span><span class="id"> rewrite</span><span class="id"> epatch_indic</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -integral_mkcondr</span><span class="id"> -f_integral//</span><span class="id"> integral_indic//</span><span class="id"> setIC</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> emeasurable_funM;</span><span class="id"> first</span><span class="id"> exact/measurable_EFinP</span>.<br/>
&nbsp;&nbsp;<span class="id">exact/measurable_funTS/</span>(<span class="id">measurable_int</span><span class="id"> _</span> (<span class="id">f_integrable</span><span class="id"> _</span>)).<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> t</span><span class="id"> Et;</span><span class="id"> rewrite</span><span class="id"> mule_ge0//</span><span class="id"> ?lee_fin//;</span><span class="id"> exact:</span><span class="id"> f_ge0</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> rhn;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> -[t</span><span class="id"> _</span><span class="id"> &lt;-];</span><span class="id"> rewrite</span><span class="id"> lee_fin</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> integrableM</span><span class="id"> f</span><span class="id"> E</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> f</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> E</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">nu</span>.<span class="id">-integrable</span><span class="id"> E</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> mu</span>.<span class="id">-integrable</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> \*</span><span class="id"> 'd</span><span class="id"> nu</span><span class="id"> '/d</span><span class="id"> mu</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> f0</span><span class="id"> mE</span><span class="id"> intEf;</span><span class="id"> apply/integrableP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> emeasurable_funM;</span><span class="id"> first</span><span class="id"> exact:</span> (<span class="id">measurable_int</span><span class="id"> nu</span>).<br/>
&nbsp;&nbsp;<span class="id">exact/measurable_funTS/</span>(<span class="id">measurable_int</span><span class="id"> _</span> (<span class="id">f_integrable</span><span class="id"> _</span>)).<br/>
<span class="id">under</span><span class="id"> eq_integral</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> gee0_abs;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> mule_ge0=&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> f_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">over</span>.<br/>
<span class="id">rewrite</span><span class="id"> change_of_variables//;</span><span class="id"> last</span><span class="id"> exact:</span> (<span class="id">measurable_int</span><span class="id"> nu</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> move/integrableP</span><span class="id"> :</span><span class="id"> intEf=&gt;</span><span class="id"> [mf</span><span class="id"> +];</span><span class="id"> under</span><span class="id"> eq_integral</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> gee0_abs//</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> integrableM</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> chain_rule</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">nu</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">la</span><span class="id"> :</span><span class="id"> {sigma_finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;'d nu '/d mu&quot;</span><span class="id"> :=</span> (<span class="id">f</span><span class="id"> nu</span><span class="id"> mu</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> chain_rule</span><span class="id"> E</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> `&lt;&lt;</span><span class="id"> la</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> E</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">ae_eq</span><span class="id"> la</span><span class="id"> E</span> (<span class="id">'d</span><span class="id"> nu</span><span class="id"> '/d</span><span class="id"> la</span>) (<span class="id">'d</span><span class="id"> nu</span><span class="id"> '/d</span><span class="id"> mu</span><span class="id"> \*</span><span class="id"> 'd</span><span class="id"> mu</span><span class="id"> '/d</span><span class="id"> la</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> numu</span><span class="id"> mula</span><span class="id"> mE;</span><span class="id"> have</span><span class="id"> nula</span><span class="id"> :=</span><span class="id"> measure_dominates_trans</span><span class="id"> numu</span><span class="id"> mula</span>.<br/>
<span class="id">have</span><span class="id"> mf</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> E</span> (<span class="id">'d</span><span class="id"> nu</span><span class="id"> '/d</span><span class="id"> mu</span>).<br/>
&nbsp;&nbsp;<span class="id">exact/measurable_funTS/</span>(<span class="id">measurable_int</span><span class="id"> _</span> (<span class="id">f_integrable</span><span class="id"> _</span>)).<br/>
<span class="id">have</span><span class="id"> [h</span><span class="id"> [ndh</span><span class="id"> hf]]</span><span class="id"> :=</span><span class="id"> approximation</span><span class="id"> mE</span><span class="id"> mf</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> f_ge0</span><span class="id"> numu</span><span class="id"> x</span>).<br/>
<span class="id">apply:</span><span class="id"> integral_ae_eq</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span> (<span class="id">integrableS</span><span class="id"> measurableT</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> f_integrable</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">measure_dominates_trans</span><span class="id"> numu</span><span class="id"> mula</span>).<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> emeasurable_funM</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact/measurable_funTS/</span>(<span class="id">measurable_int</span><span class="id"> _</span> (<span class="id">f_integrable</span><span class="id"> _</span>)).<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> AE</span><span class="id"> mA;</span><span class="id"> rewrite</span><span class="id"> change_of_variables//</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -!f_integral</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> exact:</span><span class="id"> f_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> exact:</span><span class="id"> measurable_funS</span><span class="id"> mf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> chain_rule</span>.<br/>
<span class="vernacular">End</span><span class="id"> Radon_Nikodym_SigmaFinite</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> radon_nikodym</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {sigma_finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> Radon_Nikodym0</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R,</span><span class="id"> [/\</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mu</span>.<span class="id">-integrable</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> f</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> A,</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> nu</span><span class="id"> A</span><span class="id"> =</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> f</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nu_mu;</span><span class="id"> have</span><span class="id"> [P</span><span class="id"> [N</span><span class="id"> nuPN]]</span><span class="id"> :=</span><span class="id"> Hahn_decomposition</span><span class="id"> nu</span>.<br/>
<span class="id">have</span><span class="id"> [fp</span><span class="id"> [fp0</span><span class="id"> fpfin</span><span class="id"> intfp</span><span class="id"> fpE]]</span><span class="id"> :=</span><span class="id"> @radon_nikodym_sigma_finite</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mu</span><br/>
&nbsp;&nbsp;<span class="id">[the</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> _}</span><span class="id"> of</span><span class="id"> jordan_pos</span><span class="id"> nuPN]</span><br/>
&nbsp;&nbsp;(<span class="id">jordan_pos_dominates</span><span class="id"> nuPN</span><span class="id"> nu_mu</span>).<br/>
<span class="id">have</span><span class="id"> [fn</span><span class="id"> [fn0</span><span class="id"> fnfin</span><span class="id"> intfn</span><span class="id"> fnE]]</span><span class="id"> :=</span><span class="id"> @radon_nikodym_sigma_finite</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mu</span><br/>
&nbsp;&nbsp;<span class="id">[the</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> _}</span><span class="id"> of</span><span class="id"> jordan_neg</span><span class="id"> nuPN]</span><br/>
&nbsp;&nbsp;(<span class="id">jordan_neg_dominates</span><span class="id"> nuPN</span><span class="id"> nu_mu</span>).<br/>
<span class="gallina-kwd">exists</span> (<span class="id">fp</span><span class="id"> \-</span><span class="id"> fn</span>)<span class="id">;</span><span class="id"> split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> fin_numB//</span><span class="id"> fpfin</span><span class="id"> fnfin</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> integrableB</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> E</span><span class="id"> mE;</span><span class="id"> rewrite</span><span class="id"> [LHS]</span>(<span class="id">jordan_decomp</span><span class="id"> nuPN</span><span class="id"> mE</span>)<span class="id">//</span><span class="id"> integralB//;</span><br/>
&nbsp;&nbsp;<span class="id">[|exact:</span> (<span class="id">integrableS</span><span class="id"> measurableT</span>)..<span class="id">]</span>.<br/>
<span class="id">rewrite</span><span class="id"> -fpE</span><span class="id"> ?inE//</span><span class="id"> -fnE</span><span class="id"> ?inE//=</span><span class="id"> /cadd/=</span><span class="id"> jordan_posE</span><span class="id"> jordan_negE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /cscale</span><span class="id"> EFinN</span><span class="id"> mulN1e</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> Radon_Nikodym</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span><span class="id"> pselect</span> (<span class="id">nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span>)<span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> left</span><span class="id"> nu_mu</span><span class="id"> =&gt;</span><span class="id"> sval</span> (<span class="id">cid</span> (<span class="id">Radon_Nikodym0</span><span class="id"> nu_mu</span>))<br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> right</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> cst</span><span class="id"> -oo</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Radon_NikodymE</span> (<span class="id">numu</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Radon_Nikodym</span><span class="id"> =</span><span class="id"> sval</span> (<span class="id">cid</span> (<span class="id">Radon_Nikodym0</span><span class="id"> numu</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> /Radon_Nikodym;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> numu'</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> congr</span> (<span class="id">sval</span> (<span class="id">cid</span> (<span class="id">Radon_Nikodym0</span><span class="id"> _</span>)))<span class="id">;</span><span class="id"> exact:</span><span class="id"> Prop_irrelevance</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Radon_Nikodym_fin_num</span><span class="id"> x</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">Radon_Nikodym</span><span class="id"> x</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> numu;</span><span class="id"> rewrite</span> (<span class="id">Radon_NikodymE</span><span class="id"> numu</span>)<span class="id">;</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Radon_Nikodym_integrable</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span>.<span class="id">-integrable</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> Radon_Nikodym</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> numu;</span><span class="id"> rewrite</span> (<span class="id">Radon_NikodymE</span><span class="id"> numu</span>)<span class="id">;</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Radon_Nikodym_integral</span><span class="id"> A</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> nu</span><span class="id"> A</span><span class="id"> =</span><span class="id"> \int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> Radon_Nikodym</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> numu;</span><span class="id"> rewrite</span> (<span class="id">Radon_NikodymE</span><span class="id"> numu</span>)<span class="id">;</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> [?</span><span class="id"> ?];</span><span class="id"> exact</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> radon_nikodym</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'d nu '/d mu&quot;</span><span class="id"> :=</span> (<span class="id">Radon_Nikodym</span><span class="id"> nu</span><span class="id"> mu</span>)<span class="id"> :</span><span class="id"> charge_scope</span>.<br/>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (_.<span class="id">-integrable</span><span class="id"> setT</span> (<span class="id">'d</span><span class="id"> _</span><span class="id"> '/d</span><span class="id"> _</span>))<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> Radon_Nikodym_integrable]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">measurable_fun</span><span class="id"> setT</span> (<span class="id">'d</span><span class="id"> _</span><span class="id"> '/d</span><span class="id"> _</span>))<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> measurable_int;</span><span class="id"> exact:</span><span class="id"> Radon_Nikodym_integrable]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Radon_Nikodym_charge_of_finite_measure</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">nu</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {sigma_finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> numu</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ae_eq_Radon_Nikodym_SigmaFinite</span><span class="id"> E</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> E</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">ae_eq</span><span class="id"> mu</span><span class="id"> E</span> (<span class="id">Radon_Nikodym_SigmaFinite</span>.<span class="id">f</span><span class="id"> nu</span><span class="id"> mu</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">'d</span><span class="id"> [the</span><span class="id"> charge</span><span class="id"> _</span><span class="id"> _</span><span class="id"> of</span><span class="id"> charge_of_finite_measure</span><span class="id"> nu]</span><span class="id"> '/d</span><span class="id"> mu</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mE;</span><span class="id"> apply:</span><span class="id"> integral_ae_eq</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span> (<span class="id">integrableS</span><span class="id"> measurableT</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> Radon_Nikodym_SigmaFinite</span>.<span class="id">f_integrable</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurable_funTS</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> AE</span><span class="id"> mA;</span><span class="id"> rewrite</span><span class="id"> -Radon_Nikodym_integral//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -Radon_Nikodym_SigmaFinite</span>.<span class="id">f_integral</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Radon_Nikodym_change_of_variables</span><span class="id"> f</span><span class="id"> E</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> E</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">nu</span>.<span class="id">-integrable</span><span class="id"> E</span><span class="id"> f</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\int[mu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> E</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span><span class="id"> x</span><span class="id"> *</span> (<span class="id">'d</span><span class="id"> [the</span><span class="id"> charge</span><span class="id"> _</span><span class="id"> _</span><span class="id"> of</span><span class="id"> charge_of_finite_measure</span><span class="id"> nu]</span><span class="id"> '/d</span><span class="id"> mu</span>)<span class="id"> x</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">\int[nu]_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> E</span>)<span class="id"> f</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mE</span><span class="id"> mf;</span><span class="id"> rewrite</span><span class="id"> [in</span><span class="id"> RHS]</span>(<span class="id">funeposneg</span><span class="id"> f</span>)<span class="id"> integralB</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> integrable_funepos</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> integrable_funeneg</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">ae_eq_integral</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ae_eq_mul2l</span><span class="id"> f</span> (<span class="id">ae_eq_Radon_Nikodym_SigmaFinite</span><span class="id"> mE</span>)))<span class="id">//;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> emeasurable_funM</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> measurable_int</span><span class="id"> mf</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> measurable_funTS</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> measurable_int</span> (<span class="id">Radon_Nikodym_SigmaFinite</span>.<span class="id">f_integrable</span><span class="id"> _</span>).<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> emeasurable_funM</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> measurable_int</span><span class="id"> mf</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> measurable_funTS</span>.<br/>
<span class="id">rewrite</span><span class="id"> [in</span><span class="id"> LHS]</span>(<span class="id">funeposneg</span><span class="id"> f</span>).<br/>
<span class="id">under</span><span class="id"> [in</span><span class="id"> LHS]eq_integral</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> xE</span>.<span class="id"> rewrite</span><span class="id"> muleBl;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> Radon_Nikodym_SigmaFinite</span>.<span class="id">f_fin_num</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> add_def_funeposneg</span>.<br/>
&nbsp;&nbsp;<span class="id">over</span>.<br/>
<span class="id">rewrite</span><span class="id"> [in</span><span class="id"> LHS]integralB</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> Radon_Nikodym_SigmaFinite</span>.<span class="id">integrableM</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> integrable_funepos</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> Radon_Nikodym_SigmaFinite</span>.<span class="id">integrableM</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> integrable_funeneg</span>.<br/>
<span class="id">congr</span> (_<span class="id"> -</span><span class="id"> _</span>)<span class="id"> ;</span><span class="id"> rewrite</span><span class="id"> Radon_Nikodym_SigmaFinite</span>.<span class="id">change_of_variables//;</span><br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> measurable_int;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> integrable_funepos</span><span class="id"> mf</span>.<br/>
<span class="id">exact:</span><span class="id"> integrable_funeneg</span><span class="id"> mf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Radon_Nikodym_charge_of_finite_measure</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> radon_nikodym_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {sigma_finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Radon_Nikodym_cscale</span><span class="id"> mu</span><span class="id"> nu</span><span class="id"> c</span><span class="id"> E</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> E</span><span class="id"> -&gt;</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">ae_eq</span><span class="id"> mu</span><span class="id"> E</span> (<span class="id">'d</span><span class="id"> [the</span><span class="id"> charge</span><span class="id"> _</span><span class="id"> _</span><span class="id"> of</span><span class="id"> cscale</span><span class="id"> c</span><span class="id"> nu]</span><span class="id"> '/d</span><span class="id"> mu</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> c%:E</span><span class="id"> *</span><span class="id"> 'd</span><span class="id"> nu</span><span class="id"> '/d</span><span class="id"> mu</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mE</span><span class="id"> numu;</span><span class="id"> apply:</span><span class="id"> integral_ae_eq</span><span class="id"> =&gt;</span><span class="id"> [//|</span><span class="id"> |</span><span class="id"> |A</span><span class="id"> AE</span><span class="id"> mA]</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span> (<span class="id">integrableS</span><span class="id"> measurableT</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact/Radon_Nikodym_integrable/dominates_cscalel</span>.<br/>
<span class="id">-</span><span class="id"> exact/measurable_funTS/emeasurable_funM</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> integralZl//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">integrableS</span><span class="id"> measurableT</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> Radon_Nikodym_integrable</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -Radon_Nikodym_integral</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> dominates_cscalel</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -Radon_Nikodym_integral</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Radon_Nikodym_cadd</span><span class="id"> mu</span><span class="id"> nu0</span><span class="id"> nu1</span><span class="id"> E</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> E</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">nu0</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> nu1</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">ae_eq</span><span class="id"> mu</span><span class="id"> E</span> (<span class="id">'d</span><span class="id"> [the</span><span class="id"> charge</span><span class="id"> _</span><span class="id"> _</span><span class="id"> of</span><span class="id"> cadd</span><span class="id"> nu0</span><span class="id"> nu1]</span><span class="id"> '/d</span><span class="id"> mu</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">'d</span><span class="id"> nu0</span><span class="id"> '/d</span><span class="id"> mu</span><span class="id"> \+</span><span class="id"> 'd</span><span class="id"> nu1</span><span class="id"> '/d</span><span class="id"> mu</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mE</span><span class="id"> nu0mu</span><span class="id"> nu1mu;</span><span class="id"> apply:</span><span class="id"> integral_ae_eq</span><span class="id"> =&gt;</span><span class="id"> [//|</span><span class="id"> |</span><span class="id"> |A</span><span class="id"> AE</span><span class="id"> mA]</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span> (<span class="id">integrableS</span><span class="id"> measurableT</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> Radon_Nikodym_integrable</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> exact:</span><span class="id"> dominates_cadd</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measurable_funTS</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> emeasurable_funD</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> integralD</span><span class="id"> //;</span><span class="id"> [|exact:</span><span class="id"> integrableS</span> (<span class="id">Radon_Nikodym_integrable</span><span class="id"> _</span>)..<span class="id">]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -Radon_Nikodym_integral</span><span class="id"> //=;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> dominates_cadd</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -Radon_Nikodym_integral</span><span class="id"> //</span><span class="id"> -Radon_Nikodym_integral</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> radon_nikodym_lemmas</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Radon_Nikodym_chain_rule</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">nu</span><span class="id"> :</span><span class="id"> {charge</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">la</span><span class="id"> :</span><span class="id"> {sigma_finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Radon_Nikodym_chain_rule</span><span class="id"> :</span><span class="id"> nu</span><span class="id"> `&lt;&lt;</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> `&lt;&lt;</span><span class="id"> la</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">ae_eq</span><span class="id"> la</span><span class="id"> setT</span> (<span class="id">'d</span><span class="id"> nu</span><span class="id"> '/d</span><span class="id"> la</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">'d</span><span class="id"> nu</span><span class="id"> '/d</span><span class="id"> mu</span><span class="id"> \*</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">'d</span><span class="id"> [the</span><span class="id"> charge</span><span class="id"> _</span><span class="id"> _</span><span class="id"> of</span><span class="id"> charge_of_finite_measure</span><span class="id"> mu]</span><span class="id"> '/d</span><span class="id"> la</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [Pnu</span><span class="id"> [Nnu</span><span class="id"> nuPN]]</span><span class="id"> :=</span><span class="id"> Hahn_decomposition</span><span class="id"> nu</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> numu</span><span class="id"> mula;</span><span class="id"> have</span><span class="id"> nula</span><span class="id"> :=</span><span class="id"> measure_dominates_trans</span><span class="id"> numu</span><span class="id"> mula</span>.<br/>
<span class="id">apply:</span><span class="id"> integral_ae_eq;</span><span class="id"> [exact:</span><span class="id"> measurableT|</span><span class="id"> |exact:</span><span class="id"> emeasurable_funM|]</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> Radon_Nikodym_integrable</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> E</span><span class="id"> _</span><span class="id"> mE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -Radon_Nikodym_integral//</span><span class="id"> Radon_Nikodym_change_of_variables//</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> exact:</span><span class="id"> Radon_Nikodym_integral</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">integrableS</span><span class="id"> measurableT</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> Radon_Nikodym_integrable</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Radon_Nikodym_chain_rule</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
