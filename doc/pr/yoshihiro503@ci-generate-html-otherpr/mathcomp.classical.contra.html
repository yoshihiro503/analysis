
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.classical.contra</title>
<meta name="description" content="Documentation of Coq module mathcomp.classical.contra" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.classical.contra</h1>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> ssreflect</span><span class="id"> ssrfun</span><span class="id"> ssrbool</span><span class="id"> eqtype</span><span class="id"> ssrnat</span><span class="id"> seq</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> boolp</span>.<br/>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<br/>
<div class="ssrdoc md">
# Contraposition

This file provides tactics to reason by contraposition and contradiction.

## Tactics
```
assume_not == add a goal negation assumption. The tactic also works for
              goals in Type, simplifies the added assumption, and
              exposes its top-level constructive content.
absurd_not == proof by contradiction. Same as assume_not, but the goal is
              erased and replaced by False.
              Caveat: absurd_not cannot be used as a move/ view because
              its conclusion is indeterminate. The more general notP can
              be used instead.
    contra == proof by contraposition. Change a goal of the form
              assumption -&gt; conclusion to ~ conclusion -&gt; ~ assumption.
              As with assume_not, contra allows both assumption and
              conclusion to be in Type, simplifies the negation of both
              assumption and conclusion, and exposes the constructive
              contents of the negated conclusion.
              The contra tactic also supports a limited form of the ':'
              discharge pseudo tactical, whereby contra: &lt;d-items&gt; means
              move: &lt;d-items&gt;; contra.
              The only &lt;d-items&gt; allowed are one term, possibly preceded
              by a clear switch.
    absurd == proof by contradiction. The defective form of the tactic
              simply replaces the entire goal with False (just as the Ltac
              exfalso), leaving the user to derive a contradiction from
              the assumptions.
              The ':' form absurd: &lt;d-items&gt; replaces the goal with the
              negation of the (single) &lt;d-item&gt; (as with contra:, a clear
              switch is also allowed.
              Finally the Ltac absurd term form is also supported.
```
</div>
<br/>
<div class="doc">Hiding module for the internal definitions and lemmas used by the tactics
  defined here. </div>
<span class="vernacular">Module</span><span class="id"> Internals</span>.<br/>
<br/>
<div class="ssrdoc md">
A wrapper for view lemmas with an indeterminate conclusion (of the form
forall ... T ..., pattern -&gt; T), and for which the intended view pattern
may fail to match some assumptions. This wrapper ensures that such views
are only used in the forward direction (as in move/), and only with the
appropriate move_viewP hint, preventing its application to an arbitrary
assumption A by the instatiation to A -&gt; T' of its indeterminate
conclusion T. This is similar to the implies wrapper, except move_viewP
is *NOT* declared as a coercion---it must be used explicitly to apply the
view manually to an assumption (as in, move_viewP my_view some_assumption).
</div>
<br/>
<span class="vernacular">Variant</span><span class="id"> move_view</span><span class="id"> S</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> MoveView</span><span class="id"> of</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> T</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> move_viewP</span><span class="id"> {S</span><span class="id"> T}</span><span class="id"> mv</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> let:</span><span class="id"> MoveView</span><span class="id"> v</span><span class="id"> :=</span><span class="id"> mv</span><span class="gallina-kwd"> in</span><span class="id"> v</span>.<br/>
<span class="vernacular">Hint</span><span class="id"> View</span><span class="gallina-kwd"> for</span><span class="id"> move/</span><span class="id"> move_viewP|2</span>.<br/>
<br/>
<div class="ssrdoc md">
## Type-level equivalence
</div>
<br/>
<span class="vernacular">Variant</span><span class="id"> equivT</span><span class="id"> S</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> EquivT</span><span class="id"> of</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> &amp;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> equivT_refl</span><span class="id"> S</span><span class="id"> :</span><span class="id"> equivT</span><span class="id"> S</span><span class="id"> S</span><span class="id"> :=</span><span class="id"> EquivT</span><span class="id"> id</span><span class="id"> id</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> equivT_transl</span><span class="id"> {S</span><span class="id"> T</span><span class="id"> U}</span><span class="id"> :</span><span class="id"> equivT</span><span class="id"> S</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> equivT</span><span class="id"> S</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> equivT</span><span class="id"> T</span><span class="id"> U</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span> (<span class="id">st</span><span class="id"> :</span><span class="id"> equivT</span><span class="id"> S</span><span class="id"> T</span>) (<span class="id">su</span><span class="id"> :</span><span class="id"> equivT</span><span class="id"> S</span><span class="id"> U</span>)<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">let:</span><span class="id"> EquivT</span><span class="id"> S_T</span><span class="id"> T_S</span><span class="id"> :=</span><span class="id"> st</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">let:</span><span class="id"> EquivT</span><span class="id"> S_U</span><span class="id"> U_S</span><span class="id"> :=</span><span class="id"> su</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">EquivT</span> (<span class="id">S_U</span><span class="id"> \o</span><span class="id"> T_S</span>) (<span class="id">S_T</span><span class="id"> \o</span><span class="id"> U_S</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> equivT_sym</span><span class="id"> {S</span><span class="id"> T}</span><span class="id"> :</span><span class="id"> equivT</span><span class="id"> S</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> equivT</span><span class="id"> T</span><span class="id"> S</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">equivT_transl^~</span> (<span class="id">equivT_refl</span><span class="id"> S</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> equivT_trans</span><span class="id"> {S</span><span class="id"> T</span><span class="id"> U}</span><span class="id"> :</span><span class="id"> equivT</span><span class="id"> S</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> equivT</span><span class="id"> T</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> equivT</span><span class="id"> S</span><span class="id"> U</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">equivT_transl</span><span class="id"> \o</span><span class="id"> equivT_sym</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> equivT_transr</span><span class="id"> {S</span><span class="id"> T</span><span class="id"> U}</span><span class="id"> eqST</span><span class="id"> :</span><span class="id"> equivT</span><span class="id"> U</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> equivT</span><span class="id"> U</span><span class="id"> T</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">equivT_trans^~</span><span class="id"> eqST</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> equivT_Prop</span> (<span class="id">P</span><span class="id"> Q</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span> (<span class="id">equivT</span><span class="id"> P</span><span class="id"> Q</span>)<span class="id"> &lt;-&gt;</span> (<span class="id">equivT</span><span class="id"> P</span><span class="id"> Q</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> split;</span><span class="id"> destruct</span><span class="id"> 1;</span><span class="id"> split;</span><span class="id"> assumption</span>. Defined.</div></details>
<span class="vernacular">Definition</span><span class="id"> equivT_LR</span><span class="id"> {S</span><span class="id"> T}</span> (<span class="id">eq</span><span class="id"> :</span><span class="id"> equivT</span><span class="id"> S</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">let:</span><span class="id"> EquivT</span><span class="id"> S_T</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> eq</span><span class="gallina-kwd"> in</span><span class="id"> S_T</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> equivT_RL</span><span class="id"> {S</span><span class="id"> T}</span> (<span class="id">eq</span><span class="id"> :</span><span class="id"> equivT</span><span class="id"> S</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">let:</span><span class="id"> EquivT</span><span class="id"> _</span><span class="id"> T_S</span><span class="id"> :=</span><span class="id"> eq</span><span class="gallina-kwd"> in</span><span class="id"> T_S</span>.<br/>
<br/>
<span class="vernacular">Hint</span><span class="id"> View</span><span class="gallina-kwd"> for</span><span class="id"> move/</span><span class="id"> equivT_LR|2</span><span class="id"> equivT_RL|2</span>.<br/>
<span class="vernacular">Hint</span><span class="id"> View</span><span class="gallina-kwd"> for</span><span class="id"> apply/</span><span class="id"> equivT_RL|2</span><span class="id"> equivT_LR|2</span>.<br/>
<br/>
<div class="ssrdoc md">
A generic Forall "constructor" for the Gallina forall quantifier, i.e.,
```
  \Forall x, P := Forall (fun x =&gt; P) := forall x, P.
```
The main use of Forall is to apply congruence to a forall equality:
```
   congr1 Forall : forall P Q, P = Q -&gt; Forall P = Forall Q.
```
in particular in a classical setting with function extensionality, where
we can have (forall x, P x = Q x) -&gt; (forall x, P x) = (forall x, Q x).

We use a forallSort structure to factor the ad hoc PTS product formation
rules; forallSort is keyed on the type of the entire forall expression, or
(up to subsumption) the type of the forall body---this is always a sort.

This implementation has two important limitations:
1. It cannot handle the SProp sort and its typing rules. However, its
   main application is extensionality, which is not compatible with
   SProp because an (A : SProp) -&gt; B "function" is not a generic
   (A : Type) -&gt; B function as SProp is not included in Type.
2. The Forall constructor can't be inserted by a straightforward
   unfold (as in, rewrite -[forall x, _]/(Forall _)) because of the
   way Coq unification handles Type constraints. The ForallI tactic
   mitigates this issue, but there are additional issues with its
   implementation---see below.
</div>
<br/>
<span class="vernacular">Structure</span><span class="id"> forallSort</span><span class="id"> A</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ForallSort</span><span class="id"> {forall_sort</span><span class="id"> :&gt;</span><span class="id"> Type;</span><span class="id"> _</span><span class="id"> :</span> (<span class="id">A</span><span class="id"> -&gt;</span><span class="id"> forall_sort</span>)<span class="id"> -&gt;</span><span class="id"> forall_sort}</span>.<br/>
<br/>
<span class="vernacular">Notation</span><span class="id"> mkForallSort</span><span class="id"> A</span><span class="id"> S</span><span class="id"> :=</span> (<span class="id">@ForallSort</span><span class="id"> A</span><span class="id"> S</span> (<span class="gallina-kwd">fun</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> T</span><span class="id"> x</span>)).<br/>
<span class="id">Polymorphic</span><span class="vernacular"> Definition</span><span class="id"> TypeForall</span> (<span class="id">S</span><span class="id"> :=</span><span class="gallina-kwd"> Type</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> S</span>)<span class="id"> :=</span><span class="id"> mkForallSort</span><span class="id"> A</span><span class="id"> S</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> TypeForall</span>.<br/>
<br/>
<span class="vernacular">Canonical</span><span class="id"> PropForall</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> mkForallSort</span><span class="id"> A</span><span class="gallina-kwd"> Prop</span>.<br/>
<br/>
<span class="vernacular">Canonical</span><span class="id"> SetForall</span> (<span class="id">A</span><span class="id"> :</span><span class="gallina-kwd"> Set</span>)<span class="id"> :=</span><span class="id"> mkForallSort</span><span class="id"> A</span><span class="gallina-kwd"> Set</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> Forall</span><span class="id"> {A}</span><span class="id"> {S</span><span class="id"> :</span><span class="id"> forallSort</span><span class="id"> A}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">let:</span><span class="id"> ForallSort</span><span class="id"> _</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> S</span><span class="gallina-kwd"> return</span> (<span class="id">A</span><span class="id"> -&gt;</span><span class="id"> S</span>)<span class="id"> -&gt;</span><span class="id"> S</span><span class="gallina-kwd"> in</span><span class="id"> F</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;\Forall x .. z , T&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="id">Forall</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> .. (<span class="id">Forall</span> (<span class="gallina-kwd">fun</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> T</span>)) ..))<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 200,</span><span class="id"> x</span><span class="id"> binder,</span><span class="id"> z</span><span class="id"> binder,</span><span class="id"> T</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 200,</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;'[hv' '\Forall'  '[' x .. z , ']' '/ '  T ']'&quot;</span>)<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;ForallI&quot;</span><span class="id"> ssrpatternarg</span>(<span class="id">pat</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> fresh</span> <span class="id">&quot;F&quot;</span><span class="gallina-kwd"> in</span><span class="id"> ssrmatching</span>.<span class="id">ssrpattern</span><span class="id"> pat</span><span class="id"> =&gt;</span><span class="id"> F;</span><br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> F</span><span class="id"> /</span> (<span class="id">@erefl</span><span class="id"> _</span><span class="id"> F</span><span class="id"> :</span><span class="id"> Forall</span><span class="id"> _</span><span class="id"> =</span><span class="id"> _</span>).<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;ForallI&quot;</span><span class="id"> :=</span><span class="id"> ForallI</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> _</span>).<br/>
<br/>
<div class="ssrdoc md">
We define specialized copies of the wrapped structure of ssrfun for Prop
and Type, as we need more than two alternative rules (indeed, 3 for Prop
and 4 for Type). We need separate copies for Prop and Type as universe
polymorphism cannot instantiate Type with Prop.
</div>
<br/>
<span class="vernacular">Structure</span><span class="id"> wrappedProp</span><span class="id"> :=</span><span class="id"> WrapProp</span><span class="id"> {unwrap_Prop</span><span class="id"> :&gt;</span><span class="id"> Prop}</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> wrap4Prop</span><span class="id"> :=</span><span class="id"> WrapProp</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> wrap3Prop</span><span class="id"> :=</span><span class="id"> wrap4Prop</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> wrap2Prop</span><span class="id"> :=</span><span class="id"> wrap3Prop</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> wrap1Prop</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> wrap2Prop</span><span class="id"> P</span>.<br/>
<br/>
<span class="id">Polymorphic</span><span class="vernacular"> Structure</span><span class="id"> wrappedType@{i}</span><span class="id"> :=</span><span class="id"> WrapType</span><span class="id"> {unwrap_Type</span><span class="id"> :&gt;</span><span class="id"> Type@{i}}</span>.<br/>
<span class="id">Polymorphic</span><span class="vernacular"> Definition</span><span class="id"> wrap4Type@{i}</span><span class="id"> :=</span><span class="id"> WrapType@{i}</span>.<br/>
<span class="id">Polymorphic</span><span class="vernacular"> Definition</span><span class="id"> wrap3Type@{i}</span><span class="id"> :=</span><span class="id"> wrap4Type@{i}</span>.<br/>
<span class="id">Polymorphic</span><span class="vernacular"> Definition</span><span class="id"> wrap2Type@{i}</span><span class="id"> :=</span><span class="id"> wrap3Type@{i}</span>.<br/>
<span class="id">Polymorphic</span><span class="vernacular"> Definition</span><span class="id"> wrap1Type@{i}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> Type@{i}</span>)<span class="id"> :=</span><span class="id"> wrap2Type</span><span class="id"> T</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> wrap1Type</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> generic_forall_extensionality</span><span class="id"> {A}</span><span class="id"> {S</span><span class="id"> :</span><span class="id"> forallSort</span><span class="id"> A}</span><span class="id"> {P</span><span class="id"> Q</span><span class="id"> :</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> S}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">P</span><span class="id"> =1</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="id"> Forall</span><span class="id"> P</span><span class="id"> =</span><span class="id"> Forall</span><span class="id"> Q</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/funext-&gt;</span>. Qed.</div></details>
<br/>
<div class="ssrdoc md">
A set of tools (tactics, views, and rewrite rules) to facilitate the
handling of classical negation. The core functionality of these tools is
implemented by three sets of canonical structures that provide for the
simplification of negation statements (e.g., using de Morgan laws), the
conversion from constructive statements in Type to purely logical ones in
Prop (equivalently, expansion rules for the statement inhabited T), and
conversely extraction of constructive contents from logical statements.

Except for bool predicates and operators, all definitions are treated
transparently when matching statements for either simplification or
conversion; this is achieved by using the wrapper telescope pattern, first
delegating the matching of specific logical connectives, predicates, or
type constructors to an auxiliary structure that *FAILS* to match unknown
operators, thus triggers the expansion of defined constants. If this
ultimately fails then the wrapper is expanded, and the primary structure
instance for the expanded wrapper provides an alternative default rule:
not simplifying ~ P, not expanding inhabited T, or not extracting any
contents from a proposition P, respectively.

Additional rules, for intermediate wrapper instances, are used to handle
forall statements (for which canonical instances are not yet supported),
as well as addiitonal simplifications, such as inhabited P = P :&gt; Prop.

Finally various tertiary structures are used to match deeper patterns,
such as bounded forall statements of the form forall x, P x -&gt; Q x, or
inequalites x != y (i.e., is_true (~~ (x == y))). As mentioned above,
tertiary rules for bool subexpressions do not try to expand definitions,
as this would lead to the undesirable expansion of some standard
definitions. This is simply achieved by *NOT* using the wrapper telescope
pattern, and just having a default instance alongside those for specific
predicates and connectives.
</div>
<br/>
<div class="ssrdoc md">
The negatedProp structure provides simplification of the Prop negation
(~ _) for standard connectives and predicates. The instances below cover
the pervasive and ssrbool Prop connectives, decidable equality, as well as
bool propositions (i.e., the is_true predicate), together with a few bool
connectives and predicates: negation ~~, equality ==, and nat &lt;= and &lt;.
Others can be added (e.g., Order.le/lt) by declaring appropriate instances
of bool_negation and bool_affirmation, while other Prop connectives and
predicates can be added by declaring instances of proper_negatedProp.
</div>
<br/>
<div class="ssrdoc md">
The implementation follows the wrapper telescope pattern outlined above:
negatedProp instances match on the wrappedProp wrapper to try three
generic matching rules, in succession:
- Rule 1: match a specific connective or predicate with an instance of the
          properNegatedProp secondary structure, expanding definitions
          if needed, but failing if no proper match is found.
- Rule 2: match a forall statement (including (T : Type) -&gt; P statements).
- Rule 3: match any Prop but return the trivial simplification.
The simplified proposition is returned as a projection parameter nP rather
than a Structure member, so that applying the corresponding views or
rewrite rules doesn't expose the inferred structures; properNegatedProp
does similarly. Also, negatedProp similarly returns a 'trivial' bool flag
that is set when Rule 3 is used, but this is actually used in the reverse
direction: views notP and rewrite rule notE force trivial := false, thus
excluding trivial instances.
</div>
<br/>
<span class="vernacular">Structure</span><span class="id"> negatedProp</span> (<span class="id">trivial</span><span class="id"> :</span><span class="id"> bool</span>)<span class="id"> nP</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">NegatedProp</span><span class="id"> {negated_Prop</span><span class="id"> :&gt;</span><span class="id"> wrappedProp;</span><span class="id"> _</span><span class="id"> :</span> (<span class="id">~</span><span class="id"> negated_Prop</span>)<span class="id"> =</span><span class="id"> nP}</span>.<br/>
<br/>
<span class="vernacular">Structure</span><span class="id"> properNegatedProp</span><span class="id"> nP</span><span class="id"> :=</span><span class="id"> ProperNegatedProp</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">proper_negated_Prop</span><span class="id"> :&gt;</span><span class="id"> Prop;</span><span class="id"> _</span><span class="id"> :</span> (<span class="id">~</span><span class="id"> proper_negated_Prop</span>)<span class="id"> =</span><span class="id"> nP}</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> nProp</span><span class="id"> t</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> :=</span> (<span class="id">unwrap_Prop</span> (<span class="id">@negated_Prop</span><span class="id"> t</span><span class="id"> nP</span><span class="id"> P</span>)).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> nPred</span><span class="id"> t</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> x</span><span class="id"> :=</span> (<span class="id">nProp</span><span class="id"> t</span> (<span class="id">nP</span><span class="id"> x</span>) (<span class="id">P</span><span class="id"> x</span>)).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> pnProp</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> :=</span> (<span class="id">@proper_negated_Prop</span><span class="id"> nP</span><span class="id"> P</span>).<br/>
<br/>
<div class="ssrdoc md">
User views and rewrite rules. The plain versions (notP, notE and notI) do
not match trivial instances; lax_XXX versions allow them. In addition,
the negation introduction rewrite rule notI does not match forall or -&gt;
statements---lax_notI must be used for these.
</div>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lax_notE</span><span class="id"> {t</span><span class="id"> nP}</span><span class="id"> P</span><span class="id"> :</span> (<span class="id">~</span><span class="id"> nProp</span><span class="id"> t</span><span class="id"> nP</span><span class="id"> P</span>)<span class="id"> =</span><span class="id"> nP</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> P</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> lax_notP</span><span class="id"> {t</span><span class="id"> nP</span><span class="id"> P}</span><span class="id"> :</span><span class="id"> ~</span><span class="id"> nProp</span><span class="id"> t</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> nP</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> lax_notE</span>. Qed.</div></details>
<span class="vernacular">Definition</span><span class="id"> lax_notI</span><span class="id"> {t</span><span class="id"> nP}</span><span class="id"> P</span><span class="id"> :</span><span class="id"> nProp</span><span class="id"> t</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> =</span> (<span class="id">~</span><span class="id"> nP</span>)<span class="id"> :=</span><span class="id"> canRL</span><span class="id"> notK</span> (<span class="id">lax_notE</span><span class="id"> P</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> notE</span><span class="id"> {nP}</span><span class="id"> P</span><span class="id"> :</span> (<span class="id">~</span><span class="id"> nProp</span><span class="id"> false</span><span class="id"> nP</span><span class="id"> P</span>)<span class="id"> =</span><span class="id"> nP</span><span class="id"> :=</span><span class="id"> lax_notE</span><span class="id"> P</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> notP</span><span class="id"> {nP</span><span class="id"> P}</span><span class="id"> :=</span><span class="id"> MoveView</span> (<span class="id">@lax_notP</span><span class="id"> false</span><span class="id"> nP</span><span class="id"> P</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> proper_nPropP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> :</span> (<span class="id">~</span><span class="id"> pnProp</span><span class="id"> nP</span><span class="id"> P</span>)<span class="id"> =</span><span class="id"> nP</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> P</span>. Qed.</div></details>
<span class="vernacular">Definition</span><span class="id"> notI</span><span class="id"> {nP}</span><span class="id"> P</span><span class="id"> :</span><span class="id"> pnProp</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> =</span><span class="id"> ~</span><span class="id"> nP</span><span class="id"> :=</span><span class="id"> canRL</span><span class="id"> notK</span> (<span class="id">proper_nPropP</span><span class="id"> P</span>).<br/>
<br/>
<div class="doc">Rule 1: proper negation simplification, delegated to properNegatedProp. </div>
<span class="vernacular">Canonical</span><span class="id"> proper_nProp</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@NegatedProp</span><span class="id"> false</span><span class="id"> nP</span> (<span class="id">wrap1Prop</span> (<span class="id">pnProp</span><span class="id"> nP</span><span class="id"> P</span>)) (<span class="id">proper_nPropP</span><span class="id"> P</span>).<br/>
<br/>
<div class="doc">Rule 2: forall_nProp is defined below as it uses exists_nProp. </div>
<br/>
<div class="doc">Rule 3: trivial negation. </div>
<span class="vernacular">Canonical</span><span class="id"> trivial_nProp</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> @NegatedProp</span><span class="id"> true</span> (<span class="id">~</span><span class="id"> P</span>) (<span class="id">wrap3Prop</span><span class="id"> P</span>)<span class="id"> erefl</span>.<br/>
<br/>
<div class="doc">properNegatedProp instances. </div>
<br/>
<span class="vernacular">Canonical</span><span class="id"> True_nProp</span><span class="id"> :=</span><span class="id"> @ProperNegatedProp</span><span class="id"> False</span><span class="id"> True</span><span class="id"> notB</span>.<span class="id">1</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> False_nProp</span><span class="id"> :=</span><span class="id"> @ProperNegatedProp</span><span class="id"> True</span><span class="id"> False</span><span class="id"> notB</span>.<span class="id">2</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> not_nProp</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> @ProperNegatedProp</span><span class="id"> P</span> (<span class="id">~</span><span class="id"> P</span>) (<span class="id">notK</span><span class="id"> P</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> and_nPropP</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> :</span> (<span class="id">~</span> (<span class="id">P</span><span class="id"> /\</span><span class="id"> nProp</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span>))<span class="id"> =</span> (<span class="id">P</span><span class="id"> -&gt;</span><span class="id"> nQ</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -implypN</span><span class="id"> lax_notE</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> and_nProp</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperNegatedProp</span> (<span class="id">@and_nPropP</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> and3_nPropP</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span><span class="id"> :</span> (<span class="id">~</span><span class="id"> [/\</span><span class="id"> P,</span><span class="id"> Q</span><span class="id"> &amp;</span><span class="id"> nProp</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R]</span>)<span class="id"> =</span> (<span class="id">P</span><span class="id"> -&gt;</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="id"> nR</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> hnf;</span><span class="id"> rewrite</span><span class="id"> and3E</span><span class="id"> notE</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> and3_nProp</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperNegatedProp</span> (<span class="id">@and3_nPropP</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> and4_nPropP</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> R</span><span class="id"> tS</span><span class="id"> nS</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">~</span><span class="id"> [/\</span><span class="id"> P,</span><span class="id"> Q,</span><span class="id"> R</span><span class="id"> &amp;</span><span class="id"> nProp</span><span class="id"> tS</span><span class="id"> nS</span><span class="id"> S]</span>)<span class="id"> =</span> (<span class="id">P</span><span class="id"> -&gt;</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> nS</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> hnf;</span><span class="id"> rewrite</span><span class="id"> and4E</span><span class="id"> notE</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> and4_nProp</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> R</span><span class="id"> tS</span><span class="id"> nS</span><span class="id"> S</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperNegatedProp</span> (<span class="id">@and4_nPropP</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> R</span><span class="id"> tS</span><span class="id"> nS</span><span class="id"> S</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> and5_nPropP</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> R</span><span class="id"> S</span><span class="id"> tT</span><span class="id"> nT</span><span class="id"> T</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">~</span><span class="id"> [/\</span><span class="id"> P,</span><span class="id"> Q,</span><span class="id"> R,</span><span class="id"> S</span><span class="id"> &amp;</span><span class="id"> nProp</span><span class="id"> tT</span><span class="id"> nT</span><span class="id"> T]</span>)<span class="id"> =</span> (<span class="id">P</span><span class="id"> -&gt;</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> nT</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> hnf;</span><span class="id"> rewrite</span><span class="id"> and5E</span><span class="id"> notE</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> and5_nProp</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> R</span><span class="id"> S</span><span class="id"> tT</span><span class="id"> nT</span><span class="id"> T</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperNegatedProp</span> (<span class="id">@and5_nPropP</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> R</span><span class="id"> S</span><span class="id"> tT</span><span class="id"> nT</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> or_nPropP</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">~</span> (<span class="id">nProp</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> \/</span><span class="id"> nProp</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span>))<span class="id"> =</span> (<span class="id">nP</span><span class="id"> /\</span><span class="id"> nQ</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> not_orE</span><span class="id"> !lax_notE</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> or_nProp</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperNegatedProp</span> (<span class="id">@or_nPropP</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> or3_nPropP</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">~</span><span class="id"> [\/</span><span class="id"> nProp</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P,</span><span class="id"> nProp</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> |</span><span class="id"> nProp</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R]</span>)<span class="id"> =</span><span class="id"> [/\</span><span class="id"> nP,</span><span class="id"> nQ</span><span class="id"> &amp;</span><span class="id"> nR]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> or3E</span><span class="id"> notE</span><span class="id"> and3E</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> or3_nProp</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperNegatedProp</span> (<span class="id">@or3_nPropP</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> or4_nPropP</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span><span class="id"> tS</span><span class="id"> nS</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">~</span><span class="id"> [\/</span><span class="id"> nProp</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P,</span><span class="id"> nProp</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q,</span><span class="id"> nProp</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span><span class="id"> |</span><span class="id"> nProp</span><span class="id"> tS</span><span class="id"> nS</span><span class="id"> S]</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">=</span><span class="id"> [/\</span><span class="id"> nP,</span><span class="id"> nQ,</span><span class="id"> nR</span><span class="id"> &amp;</span><span class="id"> nS]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> or4E</span><span class="id"> notE</span><span class="id"> and4E</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> or4_nProp</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span><span class="id"> tS</span><span class="id"> nS</span><span class="id"> S</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperNegatedProp</span> (<span class="id">@or4_nPropP</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span><span class="id"> tS</span><span class="id"> nS</span><span class="id"> S</span>).<br/>
<br/>
<div class="ssrdoc md">
The andRHS tertiary structure used to simplify (~ (P -&gt; False)) to P,
both here for the imply_nProp instance and for bounded_forall_nProp below.
Because the andRHS instances match the Prop RETURNED by negatedProp they
do not need to expand definitions, hence do not need to use the wrapper
telescope pattern.
</div>
<br/>
<span class="vernacular">Notation</span><span class="id"> and_def</span><span class="id"> binary</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> PQ</span><span class="id"> :=</span> (<span class="id">PQ</span><span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> binary</span><span class="gallina-kwd"> then</span><span class="id"> P</span><span class="id"> /\</span><span class="id"> Q</span><span class="gallina-kwd"> else</span><span class="id"> Q</span>)<span class="id">%type</span>.<br/>
<span class="vernacular">Structure</span><span class="id"> andRHS</span><span class="id"> binary</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> PQ</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">AndRHS</span><span class="id"> {and_RHS</span><span class="id"> :&gt;</span><span class="id"> Prop;</span><span class="id"> _</span><span class="id"> :</span> (<span class="id">P</span><span class="id"> /\</span><span class="id"> and_RHS</span>)<span class="id"> =</span><span class="id"> PQ;</span><span class="id"> _</span><span class="id"> :</span><span class="id"> and_def</span><span class="id"> binary</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> PQ}</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> unary_and_rhs</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> @AndRHS</span><span class="id"> false</span><span class="id"> P</span><span class="id"> P</span><span class="id"> P</span><span class="id"> True</span> (<span class="id">andB</span>.<span class="id">1</span>.<span class="id">2</span><span class="id"> P</span>)<span class="id"> erefl</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> binary_and_rhs</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> :=</span><span class="id"> @AndRHS</span><span class="id"> true</span><span class="id"> P</span><span class="id"> Q</span> (<span class="id">P</span><span class="id"> /\</span><span class="id"> Q</span>)<span class="id"> Q</span><span class="id"> erefl</span><span class="id"> erefl</span>.<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> imply_nPropP</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> PnQ</span><span class="id"> tR</span> (<span class="id">nR</span><span class="id"> :</span><span class="id"> andRHS</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> PnQ</span>)<span class="id"> R</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">~</span> (<span class="id">P</span><span class="id"> -&gt;</span><span class="id"> nProp</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span>))<span class="id"> =</span><span class="id"> PnQ</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -orNp</span><span class="id"> {R}lax_notE;</span><span class="id"> case:</span><span class="id"> nR</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> imply_nProp</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> PnQ</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperNegatedProp</span> (<span class="id">@imply_nPropP</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> PnQ</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> exists_nPropP</span><span class="id"> A</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">~</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A,</span><span class="id"> nPred</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A,</span><span class="id"> nP</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">eqProp=&gt;</span><span class="id"> [nEP</span><span class="id"> x</span><span class="id"> |</span><span class="id"> AnP</span><span class="id"> [x]];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -/</span>(<span class="id">~</span><span class="id"> _</span>)<span class="id"> lax_notE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">lax_notE</span> (<span class="id">P</span><span class="id"> x</span>))<span class="id"> =&gt;</span><span class="id"> Px;</span><span class="id"> case:</span><span class="id"> nEP;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> exists_nProp</span><span class="id"> A</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperNegatedProp</span> (<span class="id">@exists_nPropP</span><span class="id"> A</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> exists2_nPropP</span><span class="id"> A</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">~</span><span class="gallina-kwd"> exists2</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> nPred</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> nQ</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> exists2E</span><span class="id"> notE</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> exists2_nProp</span><span class="id"> A</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperNegatedProp</span> (<span class="id">@exists2_nPropP</span><span class="id"> A</span><span class="id"> P</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> inhabited_nPropP</span><span class="id"> T</span><span class="id"> :</span> (<span class="id">~</span><span class="id"> inhabited</span><span class="id"> T</span>)<span class="id"> =</span> (<span class="id">T</span><span class="id"> -&gt;</span><span class="id"> False</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inhabitedE</span><span class="id"> notE</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> inhabited_nProp</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> ProperNegatedProp</span> (<span class="id">inhabited_nPropP</span><span class="id"> T</span>).<br/>
<br/>
<div class="ssrdoc md">
Rule 2: forall negation, including (T : Type) -&gt; P statements.

We use tertiary structures to recognize bounded foralls and simplify,
e.g., ~ forall x, P -&gt; Q to exists2 x, P &amp; ~ Q, or even exists x, P when
Q :=  False (as above for imply).

As forall_body_nProp and forall_body_proper_nProp are telescopes
over negatedProp and properNegatedProp, respectively, their instances
match instances declared above without the need to expand definitions,
hence do not need to use the wrapper telescope idiom.
</div>
<br/>
<span class="vernacular">Structure</span><span class="id"> negatedForallBody</span><span class="id"> bounded</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> :=</span><span class="id"> NegatedForallBody</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">negated_forall_body</span><span class="id"> :&gt;</span><span class="id"> negatedProp</span><span class="id"> tR</span><span class="id"> nR;</span><span class="id"> _</span><span class="id"> :</span><span class="id"> and_def</span><span class="id"> bounded</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> nR}</span>.<br/>
<span class="vernacular">Structure</span><span class="id"> properNegatedForallBody</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> nR</span><span class="id"> :=</span><span class="id"> ProperNegatedForallBody</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">proper_negated_forall_body</span><span class="id"> :&gt;</span><span class="id"> properNegatedProp</span><span class="id"> nR;</span><span class="id"> _</span><span class="id"> :</span><span class="id"> and_def</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> nR}</span>.<br/>
<span class="vernacular">Notation</span><span class="id"> nBody</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> t</span><span class="id"> nR</span><span class="id"> x</span><span class="id"> :=</span> (<span class="id">negatedForallBody</span><span class="id"> b</span> (<span class="id">P</span><span class="id"> x</span>) (<span class="id">nQ</span><span class="id"> x</span>)<span class="id"> t</span> (<span class="id">nR</span><span class="id"> x</span>)).<br/>
<br/>
<div class="ssrdoc md">
The explicit argument to fun_if is a workaround for a bug in the Coq
unification code that prevents default instances from ever matching match
constructs. Furthermore rewriting with ifE would not work here, because
the if_expr definition would be expanded by the eta expansion needed to
match the exists_nProp rule.
</div>
<br/>
<span class="vernacular">Fact</span><span class="id"> forall_nPropP</span><span class="id"> A</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> tR</span><span class="id"> nR</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> nBody</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> x</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">~</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A,</span><span class="id"> R</span><span class="id"> x</span>)<span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> b</span><span class="gallina-kwd"> then</span><span class="gallina-kwd"> exists2</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> nQ</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> nQ</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> exists2E</span><span class="id"> -</span>(<span class="id">fun_if</span> (<span class="gallina-kwd">fun</span><span class="id"> P</span><span class="id"> =&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> idfun</span><span class="id"> P</span><span class="id"> x</span>))<span class="id"> notI</span><span class="id"> /=;</span><span class="id"> congr</span><span class="id"> not</span>.<br/>
<span class="id">apply/generic_forall_extensionality=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> if_arg</span><span class="id"> lax_notI</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">R</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> &lt;-</span>.<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> forall_nProp</span><span class="id"> A</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> tR</span><span class="id"> nR</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> nBody</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> x</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@NegatedProp</span><span class="id"> false</span><span class="id"> _</span> (<span class="id">wrap2Prop</span> (<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A,</span><span class="id"> R</span><span class="id"> x</span>)) (<span class="id">forall_nPropP</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> proper_nBodyP</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> nR</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">properNegatedForallBody</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> nR</span><span class="id"> -&gt;</span><span class="id"> and_def</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> nR</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> proper_nBody</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> nR</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> def_nR</span><span class="id"> :=</span><span class="id"> @proper_nBodyP</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> nR</span><span class="id"> R</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="id">@NegatedForallBody</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> false</span><span class="id"> nR</span> (<span class="id">proper_nProp</span><span class="id"> R</span>)<span class="id"> def_nR</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> nonproper_nBody</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@NegatedForallBody</span><span class="id"> false</span><span class="id"> True</span><span class="id"> nP</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> erefl</span>.<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> andRHS_def</span><span class="id"> b</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> PQ</span><span class="id"> :</span><span class="id"> andRHS</span><span class="id"> b</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> PQ</span><span class="id"> -&gt;</span><span class="id"> and_def</span><span class="id"> b</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> PQ</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> bounded_nBody</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> PnQ</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperNegatedForallBody</span> (<span class="id">@imply_nProp</span><span class="id"> b</span><span class="id"> P</span><span class="id"> nQ</span><span class="id"> PnQ</span><span class="id"> tR</span><span class="id"> nR</span><span class="id"> R</span>) (<span class="id">andRHS_def</span><span class="id"> nR</span>).<br/>
<span class="vernacular">Canonical</span><span class="id"> unbounded_nBody</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@ProperNegatedForallBody</span><span class="id"> false</span><span class="id"> True</span><span class="id"> nQ</span><span class="id"> nQ</span><span class="id"> Q</span><span class="id"> erefl</span>.<br/>
<br/>
<div class="ssrdoc md">
The properNegatedProp instance that handles boolean statements. We use
two tertiary structures to handle positive and negative boolean statements
so that the contra tactic below will mostly subsume the collection of
contraXX lemmas in ssrbool and eqtype.

We only match manifest ~~ connectives, the true and false constants, and
the ==, &lt;=%N, and &lt;%N predicates. In particular we do not use de Morgan
laws to push boolean negation into connectives, as we did above for Prop
connectives. It will be up to the user to use rewriting to put the negated
statement in its desired shape.
</div>
<br/>
<span class="vernacular">Structure</span><span class="id"> negatedBool</span><span class="id"> nP</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">NegatedBool</span><span class="id"> {negated_bool</span><span class="id"> :&gt;</span><span class="id"> bool;</span><span class="id"> _</span><span class="id"> :</span> (<span class="id">~</span><span class="id"> negated_bool</span>)<span class="id"> =</span><span class="id"> nP}</span>.<br/>
<span class="vernacular">Structure</span><span class="id"> positedBool</span><span class="id"> P</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">PositedBool</span><span class="id"> {posited_bool</span><span class="id"> :&gt;</span><span class="id"> bool;</span><span class="id"> _</span><span class="id"> :</span><span class="id"> is_true</span><span class="id"> posited_bool</span><span class="id"> =</span><span class="id"> P}</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> is_true_nPropP</span><span class="id"> nP</span> (<span class="id">b</span><span class="id"> :</span><span class="id"> negatedBool</span><span class="id"> nP</span>)<span class="id"> :</span> (<span class="id">~</span><span class="id"> b</span>)<span class="id"> =</span><span class="id"> nP</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> b</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> is_true_nProp</span><span class="id"> nP</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> ProperNegatedProp</span> (<span class="id">@is_true_nPropP</span><span class="id"> nP</span><span class="id"> b</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> true_negP</span><span class="id"> :</span> (<span class="id">~</span><span class="id"> true</span>)<span class="id"> =</span><span class="id"> False</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> eqProp</span>. Qed.</div></details>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> true_posP</span><span class="id"> :</span> (<span class="id">true</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>)<span class="id"> =</span><span class="id"> True</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> eqProp</span>. Qed.</div></details>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> false_negP</span><span class="id"> :</span> (<span class="id">~</span><span class="id"> false</span>)<span class="id"> =</span><span class="id"> True</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> eqProp</span>. Qed.</div></details>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> false_posP</span><span class="id"> :</span> (<span class="id">false</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>)<span class="id"> =</span><span class="id"> False</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> eqProp</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> true_neg</span><span class="id"> :=</span><span class="id"> NegatedBool</span><span class="id"> true_negP</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> true_pos</span><span class="id"> :=</span><span class="id"> PositedBool</span><span class="id"> true_posP</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> false_neg</span><span class="id"> :=</span><span class="id"> NegatedBool</span><span class="id"> false_negP</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> false_pos</span><span class="id"> :=</span><span class="id"> PositedBool</span><span class="id"> false_posP</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> id_negP</span> (<span class="id">b</span><span class="id"> :</span><span class="id"> bool</span>)<span class="id"> :</span> (<span class="id">~</span><span class="id"> b</span>)<span class="id"> =</span><span class="id"> ~~</span><span class="id"> b</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/reflect_eq/negP</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> id_neg</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> NegatedBool</span> (<span class="id">id_negP</span><span class="id"> b</span>).<br/>
<span class="vernacular">Canonical</span><span class="id"> id_pos</span> (<span class="id">b</span><span class="id"> :</span><span class="id"> bool</span>)<span class="id"> :=</span><span class="id"> @PositedBool</span><span class="id"> b</span><span class="id"> b</span><span class="id"> erefl</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> negb_negP</span><span class="id"> P</span> (<span class="id">b</span><span class="id"> :</span><span class="id"> positedBool</span><span class="id"> P</span>)<span class="id"> :</span> (<span class="id">~</span><span class="id"> ~~</span><span class="id"> b</span>)<span class="id"> =</span><span class="id"> P</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">reflect_eq</span><span class="id"> negP</span>)<span class="id"> negbK;</span><span class="id"> case:</span><span class="id"> b</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> negb_neg</span><span class="id"> P</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> NegatedBool</span> (<span class="id">@negb_negP</span><span class="id"> P</span><span class="id"> b</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> negb_posP</span><span class="id"> nP</span> (<span class="id">b</span><span class="id"> :</span><span class="id"> negatedBool</span><span class="id"> nP</span>)<span class="id"> :</span> (<span class="id">~~</span><span class="id"> b</span><span class="id"> =</span><span class="id"> nP</span><span class="id"> :&gt;</span><span class="gallina-kwd"> Prop</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">reflect_eq</span><span class="id"> negP</span>)<span class="id"> notE</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> negb_pos</span><span class="id"> nP</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> PositedBool</span> (<span class="id">@negb_posP</span><span class="id"> nP</span><span class="id"> b</span>).<br/>
<br/>
<div class="ssrdoc md">
We use a tertiary structure to handle the negation of nat comparisons, and
simplify ~ m &lt;= n to n &lt; m, and ~ m &lt; n to n &lt;= m. As m &lt; n is merely
notation for m.+1 &lt;= n, we need to dispatch on the left hand side of the
comparison to perform the latter simplification.
</div>
<br/>
<span class="vernacular">Structure</span><span class="id"> negatedLeqLHS</span><span class="id"> n</span><span class="id"> lt_nm</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">NegatedLeqLHS</span><span class="id"> {negated_leq_LHS</span><span class="id"> :&gt;</span><span class="id"> nat;</span><span class="id"> _</span><span class="id"> :</span> (<span class="id">n</span><span class="id"> &lt;</span><span class="id"> negated_leq_LHS</span>)<span class="id"> =</span><span class="id"> lt_nm}</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> neg_ltn_LHS</span><span class="id"> n</span><span class="id"> m</span><span class="id"> :=</span><span class="id"> @NegatedLeqLHS</span><span class="id"> n</span> (<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> m</span>)<span class="id"> m</span>.<span class="id">+1</span><span class="id"> erefl</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> neg_leq_LHS</span><span class="id"> n</span><span class="id"> m</span><span class="id"> :=</span><span class="id"> @NegatedLeqLHS</span><span class="id"> n</span> (<span class="id">n</span><span class="id"> &lt;</span><span class="id"> m</span>)<span class="id"> m</span><span class="id"> erefl</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> leq_negP</span><span class="id"> n</span><span class="id"> lt_nm</span> (<span class="id">m</span><span class="id"> :</span><span class="id"> negatedLeqLHS</span><span class="id"> n</span><span class="id"> lt_nm</span>)<span class="id"> :</span> (<span class="id">~</span><span class="id"> m</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> lt_nm</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> notE</span><span class="id"> -ltnNge;</span><span class="id"> case:</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> m</span><span class="id"> -&gt;</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> leq_neg</span><span class="id"> n</span><span class="id"> lt_nm</span><span class="id"> m</span><span class="id"> :=</span><span class="id"> NegatedBool</span> (<span class="id">@leq_negP</span><span class="id"> n</span><span class="id"> lt_nm</span><span class="id"> m</span>).<br/>
<br/>
<div class="ssrdoc md">
We use two tertiary structures to simplify negation of boolean constant
and decidable equalities, simplifying b &lt;&gt; true to ~~ b, b &lt;&gt; false to b,
x &lt;&gt; y to x != y, and ~ x != y to x = y. We do need to use the wrapper
telescope pattern here, as we want to simplify instances of x &lt;&gt; y when y
evaluates to true or false. Since we only need two rules (true/false RHS
or generic eqType RHS) we can use the generic wrapped type from ssrfun.
The actual matching of the true and false RHS is delegated to a fourth
level bool_eq_negation_rhs structure. Finally observe that the ~ x != y to
x = y simplification can be handled by a bool_affirmation instance.
</div>
<br/>
<span class="vernacular">Structure</span><span class="id"> neqRHS</span><span class="id"> nP</span><span class="id"> T</span><span class="id"> x</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">NeqRHS</span><span class="id"> {neq_RHS</span><span class="id"> :&gt;</span><span class="id"> wrapped</span><span class="id"> T;</span><span class="id"> _</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> &lt;&gt;</span><span class="id"> unwrap</span><span class="id"> neq_RHS</span>)<span class="id"> =</span><span class="id"> nP}</span>.<br/>
<span class="vernacular">Structure</span><span class="id"> boolNeqRHS</span><span class="id"> nP</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> bool</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">BoolNeqRHS</span><span class="id"> {bool_neq_RHS;</span><span class="id"> _</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> &lt;&gt;</span><span class="id"> bool_neq_RHS</span>)<span class="id"> =</span><span class="id"> nP}</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> eq_nPropP</span><span class="id"> nP</span><span class="id"> T</span><span class="id"> x</span> (<span class="id">y</span><span class="id"> :</span><span class="id"> neqRHS</span><span class="id"> nP</span><span class="id"> x</span>)<span class="id"> :</span> (<span class="id">x</span><span class="id"> &lt;&gt;</span><span class="id"> unwrap</span><span class="id"> y</span><span class="id"> :&gt;</span><span class="id"> T</span>)<span class="id"> =</span><span class="id"> nP</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> y</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> eq_nProp</span><span class="id"> nP</span><span class="id"> T</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :=</span><span class="id"> ProperNegatedProp</span> (<span class="id">@eq_nPropP</span><span class="id"> nP</span><span class="id"> T</span><span class="id"> x</span><span class="id"> y</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> bool_neqP</span><span class="id"> nP</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> &lt;&gt;</span><span class="id"> @bool_neq_RHS</span><span class="id"> nP</span><span class="id"> x</span><span class="id"> y</span>)<span class="id"> =</span><span class="id"> nP</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> y</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> bool_neq</span><span class="id"> nP</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :=</span><span class="id"> @NeqRHS</span><span class="id"> nP</span><span class="id"> bool</span><span class="id"> x</span> (<span class="id">wrap</span><span class="id"> _</span>) (<span class="id">@bool_neqP</span><span class="id"> nP</span><span class="id"> x</span><span class="id"> y</span>).<br/>
<span class="vernacular">Canonical</span><span class="id"> true_neq</span><span class="id"> nP</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> BoolNeqRHS</span> (<span class="id">@is_true_nPropP</span><span class="id"> nP</span><span class="id"> b</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> false_neqP</span><span class="id"> P</span> (<span class="id">b</span><span class="id"> :</span><span class="id"> positedBool</span><span class="id"> P</span>)<span class="id"> :</span> (<span class="id">b</span><span class="id"> &lt;&gt;</span><span class="id"> false</span><span class="id"> :&gt;</span><span class="id"> bool</span>)<span class="id"> =</span><span class="id"> P</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> b</span><span class="id"> =&gt;</span><span class="id"> []</span><span class="id"> []</span><span class="id"> /=</span><span class="id"> &lt;-;</span><span class="id"> exact/propext</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> false_neq</span><span class="id"> P</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> BoolNeqRHS</span> (<span class="id">@false_neqP</span><span class="id"> P</span><span class="id"> b</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> eqType_neqP</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span> (<span class="id">x</span><span class="id"> &lt;&gt;</span><span class="id"> y</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> !=</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">reflect_eq</span><span class="id"> eqP</span>) (<span class="id">reflect_eq</span><span class="id"> negP</span>). Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> eqType_neq</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>)<span class="id"> x</span><span class="id"> y</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@NeqRHS</span> (<span class="id">x</span><span class="id"> !=</span><span class="id"> y</span>)<span class="id"> T</span><span class="id"> x</span> (<span class="id">Wrap</span><span class="id"> y</span>) (<span class="id">eqType_neqP</span><span class="id"> x</span><span class="id"> y</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> eq_op_posP</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>)<span class="id"> x</span><span class="id"> y</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> ==</span><span class="id"> y</span><span class="id"> :&gt;</span><span class="id"> T</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> =</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/esym/reflect_eq/eqP</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> eq_op_pos</span><span class="id"> T</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :=</span><span class="id"> PositedBool</span> (<span class="id">@eq_op_posP</span><span class="id"> T</span><span class="id"> x</span><span class="id"> y</span>).<br/>
<br/>
<div class="ssrdoc md">
The witnessedType structure provides conversion between Type and Prop in
goals; the conversion is mostly used in the Type-to-Prop direction, e.g.,
as a preprocessing step preceding proof by contradiction (see absurd_not
below), but the Prop-to-Type direction is required for contraposition.

Thus witnessedType associates to a type T a "witness" proposition P
equivalent to the existence of an x of type T. As in a `{classical_logic}
context inhabited T is such a proposition, witnessedType can be understood
as providing simplification for inhabited T, much like negatedProp
provides simplification for ~ P for standard connectives and predicates.
</div>
<br/>
<div class="ssrdoc md">
Similarly to negatedProp, witnessedType returns the witness proposition
via a projection argument P, but does not need to signal "trivial"
instances as the default value for P is nontrivial (namely, inhabited T),
while the "trivial" case where P = T is actually desireable and handled
by an extra top-priority rule.
</div>
<br/>
<span class="vernacular">Structure</span><span class="id"> witnessedType</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> WitnessedType</span><span class="id"> {</span><br/>
&nbsp;<span class="id">witnessed_Type</span><span class="id"> :&gt;</span><span class="id"> wrappedType;</span><span class="id"> _</span><span class="id"> :</span><span class="id"> inhabited</span><span class="id"> witnessed_Type</span><span class="id"> =</span><span class="id"> P}</span>.<br/>
<span class="vernacular">Structure</span><span class="id"> properWitnessedType</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> ProperWitnessedType</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">proper_witnessed_Type</span><span class="id"> :&gt;</span><span class="id"> Type;</span><span class="id"> _</span><span class="id"> :</span><span class="id"> inhabited</span><span class="id"> proper_witnessed_Type</span><span class="id"> =</span><span class="id"> P}</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> wType</span><span class="id"> P</span><span class="id"> T</span><span class="id"> :=</span> (<span class="id">unwrap_Type</span> (<span class="id">@witnessed_Type</span><span class="id"> P</span><span class="id"> T</span>)).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> wTycon</span><span class="id"> P</span><span class="id"> T</span><span class="id"> x</span><span class="id"> :=</span> (<span class="id">wType</span> (<span class="id">P</span><span class="id"> x</span>) (<span class="id">T</span><span class="id"> x</span>)).<br/>
<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> witnessedType_intro</span><span class="id"> {P</span><span class="id"> :</span><span class="id"> Prop}</span><span class="id"> T</span><span class="id"> :</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> wType</span><span class="id"> P</span><span class="id"> T</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> T</span><span class="id"> &lt;-</span><span class="id"> /inhabited_witness</span>. Qed.</div></details>
<span class="vernacular">Local</span><span class="vernacular"> Coercion</span><span class="id"> witnessedType_intro</span><span class="id"> :</span><span class="id"> witnessedType</span><span class="id"> &gt;-&gt;</span><span class="id"> Funclass</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> witnessedType_elim</span><span class="id"> {P}</span><span class="id"> T</span><span class="id"> :</span><span class="id"> wType</span><span class="id"> P</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> P</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> T</span><span class="id"> &lt;-</span>. Qed.</div></details>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> wTypeP</span><span class="id"> :=</span><span class="id"> witnessedType_elim</span>.<br/>
<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> eq_inhabited</span><span class="id"> T</span> (<span class="id">P</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span> (<span class="id">T</span><span class="id"> -&gt;</span><span class="id"> P</span>)<span class="id"> -&gt;</span> (<span class="id">P</span><span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> -&gt;</span><span class="id"> inhabited</span><span class="id"> T</span><span class="id"> =</span><span class="id"> P</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> T_P</span><span class="id"> P_T;</span><span class="id"> eqProp=&gt;</span><span class="id"> [[/T_P]</span><span class="id"> |</span><span class="id"> /P_T]</span>. Qed.</div></details>
<span class="vernacular">Ltac</span><span class="id"> eqInh</span><span class="id"> :=</span><span class="id"> apply:</span><span class="id"> eq_inhabited</span>.<br/>
<br/>
<div class="doc">Rule 1: Prop goals are left as is. </div>
<span class="vernacular">Canonical</span><span class="id"> Prop_wType</span><span class="id"> P</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@WitnessedType</span><span class="id"> P</span> (<span class="id">wrap1Type</span><span class="id"> P</span>) (<span class="id">eq_inhabited</span> (<span class="id">@id</span><span class="id"> P</span>)<span class="id"> id</span>).<br/>
<br/>
<div class="doc">Rule 2: Specific type constructors (sigs, sums, and pairs) are delegated
    to the secondary properWitnessedType structure. </div>
<span class="vernacular">Lemma</span><span class="id"> proper_wTypeP</span><span class="id"> P</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> properWitnessedType</span><span class="id"> P</span>)<span class="id"> :</span><span class="id"> inhabited</span><span class="id"> T</span><span class="id"> =</span><span class="id"> P</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> T</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> proper_wType</span><span class="id"> P</span><span class="id"> T</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@WitnessedType</span><span class="id"> P</span> (<span class="id">wrap2Type</span><span class="id"> _</span>) (<span class="id">@proper_wTypeP</span><span class="id"> P</span><span class="id"> T</span>).<br/>
<br/>
<div class="doc">Rule 3: Forall (and -&gt; as a special case). </div>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> forall_wTypeP</span><span class="id"> A</span><span class="id"> P</span><span class="id"> T</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">inhabited</span> (<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A,</span><span class="id"> wTycon</span><span class="id"> P</span><span class="id"> T</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A,</span><span class="id"> P</span><span class="id"> x</span>) .<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> do</span><span class="id"> [eqInh=&gt;</span><span class="id"> allP</span><span class="id"> x;</span><span class="id"> have:=</span><span class="id"> allP</span><span class="id"> x]</span><span class="id"> =&gt;</span><span class="id"> [/wTypeP</span><span class="id"> |</span><span class="id"> /T]</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> forall_wType</span><span class="id"> A</span><span class="id"> P</span><span class="id"> T</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@WitnessedType</span><span class="id"> _</span> (<span class="id">wrap3Type</span><span class="id"> _</span>) (<span class="id">@forall_wTypeP</span><span class="id"> A</span><span class="id"> P</span><span class="id"> T</span>).<br/>
<br/>
<div class="doc">Rule 4: Default to inhabited if all else fails. </div>
<span class="vernacular">Canonical</span><span class="id"> inhabited_wType</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> @WitnessedType</span> (<span class="id">inhabited</span><span class="id"> T</span>) (<span class="id">wrap4Type</span><span class="id"> T</span>)<span class="id"> erefl</span>.<br/>
<br/>
<div class="doc">Specific proper_witnessedType instances. </div>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> void_wTypeP</span><span class="id"> :</span><span class="id"> inhabited</span><span class="id"> void</span><span class="id"> =</span><span class="id"> False</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> eqInh</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> void_wType</span><span class="id"> :=</span><span class="id"> ProperWitnessedType</span><span class="id"> void_wTypeP</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> unit_wTypeP</span><span class="id"> :</span><span class="id"> inhabited</span><span class="id"> unit</span><span class="id"> =</span><span class="id"> True</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> eqInh</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> unit_wType</span><span class="id"> :=</span><span class="id"> ProperWitnessedType</span><span class="id"> unit_wTypeP</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> pair_wTypeP</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> S</span><span class="id"> T</span><span class="id"> :</span><span class="id"> inhabited</span> (<span class="id">wType</span><span class="id"> P</span><span class="id"> S</span><span class="id"> *</span><span class="id"> wType</span><span class="id"> Q</span><span class="id"> T</span>)<span class="id"> =</span> (<span class="id">P</span><span class="id"> /\</span><span class="id"> Q</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> eqInh=&gt;</span><span class="id"> [[/wTypeP-isP</span><span class="id"> /wTypeP]</span><span class="id"> |</span><span class="id"> [/S-x</span><span class="id"> /T]]</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> pair_wType</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> S</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> ProperWitnessedType</span> (<span class="id">@pair_wTypeP</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> S</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> sum_wTypeP</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> S</span><span class="id"> T</span><span class="id"> :</span><span class="id"> inhabited</span> (<span class="id">wType</span><span class="id"> P</span><span class="id"> S</span><span class="id"> +</span><span class="id"> wType</span><span class="id"> Q</span><span class="id"> T</span>)<span class="id"> =</span> (<span class="id">P</span><span class="id"> \/</span><span class="id"> Q</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> eqInh=&gt;</span><span class="id"> [[]</span><span class="id"> /wTypeP</span><span class="id"> |</span><span class="id"> /decide_or[/S</span><span class="id"> |</span><span class="id"> /T]];</span><span class="gallina-kwd"> by</span><span class="id"> [left</span><span class="id"> |</span><span class="id"> right]</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> sum_wType</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> S</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> ProperWitnessedType</span> (<span class="id">@sum_wTypeP</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> S</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> sumbool_wTypeP</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> :</span><span class="id"> inhabited</span> (<span class="id">{P}</span><span class="id"> +</span><span class="id"> {Q}</span>)<span class="id"> =</span> (<span class="id">P</span><span class="id"> \/</span><span class="id"> Q</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> eqInh=&gt;</span><span class="id"> [[]</span><span class="id"> |</span><span class="id"> /decide_or[]];</span><span class="gallina-kwd"> by</span><span class="id"> [left</span><span class="id"> |</span><span class="id"> right]</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> sumbool_wType</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> :=</span><span class="id"> ProperWitnessedType</span> (<span class="id">@sumbool_wTypeP</span><span class="id"> P</span><span class="id"> Q</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> sumor_wTypeP</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> T</span><span class="id"> :</span><span class="id"> inhabited</span> (<span class="id">wType</span><span class="id"> P</span><span class="id"> T</span><span class="id"> +</span><span class="id"> {Q}</span>)<span class="id"> =</span> (<span class="id">P</span><span class="id"> \/</span><span class="id"> Q</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> eqInh=&gt;</span><span class="id"> [[/wTypeP|]</span><span class="id"> |</span><span class="id"> /decide_or[/T|]];</span><span class="gallina-kwd"> by</span><span class="id"> [left</span><span class="id"> |</span><span class="id"> right]</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> sumor_wType</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> ProperWitnessedType</span> (<span class="id">@sumor_wTypeP</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> sig1_wTypeP</span><span class="id"> T</span><span class="id"> P</span><span class="id"> :</span><span class="id"> inhabited</span><span class="id"> {x</span><span class="id"> :</span><span class="id"> T</span><span class="id"> |</span><span class="id"> P</span><span class="id"> x}</span><span class="id"> =</span> (<span class="gallina-kwd">exists</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> P</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> eqInh=&gt;</span><span class="id"> [[x</span><span class="id"> Px]</span><span class="id"> |</span><span class="id"> /cid//];</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> sig1_wType</span><span class="id"> T</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> ProperWitnessedType</span> (<span class="id">@sig1_wTypeP</span><span class="id"> T</span><span class="id"> P</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> sig2_wTypeP</span><span class="id"> T</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">inhabited</span><span class="id"> {x</span><span class="id"> :</span><span class="id"> T</span><span class="id"> |</span><span class="id"> P</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> Q</span><span class="id"> x}</span><span class="id"> =</span><span class="gallina-kwd"> exists2</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> Q</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> eqInh=&gt;</span><span class="id"> [[x</span><span class="id"> Px</span><span class="id"> Qx]</span><span class="id"> |</span><span class="id"> /cid2//];</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> sig2_wType</span><span class="id"> T</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> :=</span><span class="id"> ProperWitnessedType</span> (<span class="id">@sig2_wTypeP</span><span class="id"> T</span><span class="id"> P</span><span class="id"> Q</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> sigT_wTypeP</span><span class="id"> A</span><span class="id"> P</span><span class="id"> T</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">inhabited</span><span class="id"> {x</span><span class="id"> :</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> wTycon</span><span class="id"> P</span><span class="id"> T</span><span class="id"> x}</span><span class="id"> =</span> (<span class="gallina-kwd">exists</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A,</span><span class="id"> P</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> eqInh=&gt;</span><span class="id"> [[x</span><span class="id"> /wTypeP]</span><span class="id"> |</span><span class="id"> /cid[x</span><span class="id"> /T]];</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> sigT_wType</span><span class="id"> A</span><span class="id"> P</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> ProperWitnessedType</span> (<span class="id">@sigT_wTypeP</span><span class="id"> A</span><span class="id"> P</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> sigT2_wTypeP</span><span class="id"> A</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> S</span><span class="id"> T</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">inhabited</span><span class="id"> {x</span><span class="id"> :</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> wTycon</span><span class="id"> P</span><span class="id"> S</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> wTycon</span><span class="id"> Q</span><span class="id"> T</span><span class="id"> x}</span><span class="id"> =</span> (<span class="gallina-kwd">exists2</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A,</span><span class="id"> P</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> Q</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> eqInh=&gt;</span><span class="id"> [[x</span><span class="id"> /wTypeP-Px</span><span class="id"> /wTypeP]</span><span class="id"> |</span><span class="id"> /cid2[x</span><span class="id"> /S-y</span><span class="id"> /T]];</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> sigT2_wType</span><span class="id"> A</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> S</span><span class="id"> T</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperWitnessedType</span> (<span class="id">@sigT2_wTypeP</span><span class="id"> A</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> S</span><span class="id"> T</span>).<br/>
<br/>
<div class="ssrdoc md">
The witnessProp structure provides for conversion of some Prop
assumptions to Type values with some constructive contents, e.g., convert
a P \/ Q assumption to a {P} + {Q} sumbool value. This is not the same as
the forward direction of witnessedType, because instances here match the
Prop statement: witness_Prop find a T such that P -&gt; T while witnessedType
finds a P such that P -&gt; T (and T -&gt; P for the converse direction).
</div>
<br/>
<div class="ssrdoc md">
The implementation follows the wrapper telescope pattern similarly to
negatedProp, with three rules, one for Prop constructors with proper
constructive contents, one for forall propositions (also with proper
constructive contents) and one default rule that just returns P : Prop as
is (thus, with no other contents except the provability of P).

The witnessProp structure also uses projection parameters to return the
inferred Type T together with a bool 'trivial' flag that is set when the
trivial rule is used. Here, however, this flag is used in both directions:
the 'witness' view forces it to false to prevent trivial instances, but
the flag is also used to fine tune the choice of T, selecting between
sum, sumor, and sumbool, between sig and sigT, and sig2 and sigT2. This
relies on the fact that the tactic engine will eagerly iota reduce the
returned type, so that the user will never see the conditionals specified
in the proper_witness_Prop instances.

However, it would not be possible to construct the specialised types
for trivial witnesses (e.g., {P} + {Q}) using the types returned by
witnessProp instances, since thes are in Type, and the information that
they are actully in Prop has been lost. This is solved by returning an
additional Prop P0 that is a copy of the matched Prop P when
trivial = true. (We put P0 = True when trivial = false, as we only need to
ensure P -&gt; P0.)

Caveat: although P0 should in principle be the last parameter of
witness_Prop, and we use this order for the wProp and wPred projector
local notation, it is important to put P0 _BEFORE_ T, to circumvent an
incompleteness in Coq's implementation of higher-order pattern unification
that would cause the trivial rule to fail for the body of an exists.
In such a case the rule needs to unify (1) ?P0 x ~ ?P and (2) ?T x ~ ?P
for some type A some x : A in the context of ?P, but not ?P0 nor ?T. This
succeeds easily if (1) is performed before (2), setting ?P := ?P0 x and
?T := ?P0, but if (2) is attempted first Coq tries to perform ?P := ?T x,
which fails Type/Prop universe constraints, and then fails outright,
instead of using pattern unification to solve (2) as ?P := ?Q x, ?T := ?Q
for a fresh ?Q : A -&gt; Prop.
</div>
<br/>
<span class="vernacular">Structure</span><span class="id"> witnessProp</span> (<span class="id">trivial</span><span class="id"> :</span><span class="id"> bool</span>) (<span class="id">P0</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>) (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">WitnessProp</span><span class="id"> {witness_Prop</span><span class="id"> :&gt;</span><span class="id"> wrappedProp;</span><span class="id"> _</span><span class="id"> :</span><span class="id"> witness_Prop</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> *</span><span class="id"> P0}</span>.<br/>
<span class="vernacular">Structure</span><span class="id"> properWitnessProp</span><span class="id"> T</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperWitnessProp</span><span class="id"> {proper_witness_Prop</span><span class="id"> :&gt;</span><span class="id"> Prop;</span><span class="id"> _</span><span class="id"> :</span><span class="id"> proper_witness_Prop</span><span class="id"> -&gt;</span><span class="id"> T}</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> wProp</span><span class="id"> t</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> :=</span> (<span class="id">unwrap_Prop</span> (<span class="id">@witness_Prop</span><span class="id"> t</span><span class="id"> P0</span><span class="id"> T</span><span class="id"> P</span>)).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> wPred</span><span class="id"> t</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> x</span><span class="id"> :=</span> (<span class="id">wProp</span><span class="id"> t</span> (<span class="id">T</span><span class="id"> x</span>) (<span class="id">P0</span><span class="id"> x</span>) (<span class="id">P</span><span class="id"> x</span>)).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> wPropP</span><span class="id"> t</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> :</span><span class="id"> wProp</span><span class="id"> t</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> *</span><span class="id"> P0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> P</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> lax_witness</span><span class="id"> {t</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P}</span><span class="id"> :</span><span class="id"> move_view</span> (<span class="id">wProp</span><span class="id"> t</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P</span>)<span class="id"> T</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split=&gt;</span><span class="id"> /wPropP[]</span>. Qed.</div></details>
<span class="vernacular">Definition</span><span class="id"> witness</span><span class="id"> {T</span><span class="id"> P0</span><span class="id"> P}</span><span class="id"> :=</span><span class="id"> @lax_witness</span><span class="id"> false</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P</span>.<br/>
<br/>
<div class="doc">Rule 1: proper instances (except forall), delegated to an auxiliary
    structures. </div>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> proper_wPropP</span><span class="id"> T</span><span class="id"> P</span><span class="id"> :</span><span class="id"> wrap1Prop</span> (<span class="id">@proper_witness_Prop</span><span class="id"> T</span><span class="id"> P</span>)<span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> *</span><span class="id"> True</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> P</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> P_T</span><span class="id"> {}/P_T</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> proper_wProp</span><span class="id"> T</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> WitnessProp</span><span class="id"> false</span> (<span class="id">@proper_wPropP</span><span class="id"> T</span><span class="id"> P</span>).<br/>
<br/>
<div class="doc">Rule 2: forall types (including implication); as only proper instances are
    allowed, we set trivial = false for the recursive body instance. </div>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> forall_wPropP</span><span class="id"> A</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">wrap2Prop</span> (<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A,</span><span class="id"> wPred</span><span class="id"> false</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> T</span><span class="id"> x</span>)<span class="id"> *</span><span class="id"> True</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> P_A;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> x;</span><span class="id"> have</span><span class="id"> /witness</span><span class="id"> :=</span><span class="id"> P_A</span><span class="id"> x</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> forall_wProp</span><span class="id"> A</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> WitnessProp</span><span class="id"> false</span> (<span class="id">@forall_wPropP</span><span class="id"> A</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P</span>).<br/>
<br/>
<div class="doc">Rule 3: trivial (proof) self-witness. </div>
<span class="vernacular">Canonical</span><span class="id"> trivial_wProp</span><span class="id"> P</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">WitnessProp</span><span class="id"> true</span> (<span class="gallina-kwd">fun</span><span class="id"> p</span><span class="id"> :</span><span class="id"> wrap3Prop</span><span class="id"> P</span><span class="id"> =&gt;</span> (<span class="id">p,</span><span class="id"> p</span>)<span class="id"> :</span><span class="id"> P</span><span class="id"> *</span><span class="id"> P</span>).<br/>
<br/>
<div class="doc">Specific proper_witnesss_Prop instances. </div>
<br/>
<span class="vernacular">Canonical</span><span class="id"> inhabited_wProp</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> ProperWitnessProp</span> (<span class="id">@inhabited_witness</span><span class="id"> T</span>).<br/>
<br/>
<div class="ssrdoc md">
Conjunctions P /\ Q are a little delicate to handle, as we should not
produce a proper instance (and thus fail) if neither P nor Q is proper.
We use a tertiary structure for this : nand_bool b, which has instances
only for booleans b0 such that ~~ (b0 &amp;&amp; b). We allow the witness_Prop
instance for P to return an arbitrary 'trivial' flag s, but then force the
'trivial' flag for Q to be an instance of nand_bool s.
</div>
<br/>
<span class="vernacular">Structure</span><span class="id"> nandBool</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> NandBool</span><span class="id"> {nand_bool</span><span class="id"> :&gt;</span><span class="id"> bool;</span><span class="id"> _</span><span class="id"> :</span><span class="id"> ~~</span> (<span class="id">nand_bool</span><span class="id"> &amp;&amp;</span><span class="id"> b</span>)<span class="id">}</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> nand_false_bool</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> @NandBool</span><span class="id"> b</span><span class="id"> false</span><span class="id"> isT</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> nand_true_bool</span><span class="id"> :=</span><span class="id"> @NandBool</span><span class="id"> false</span><span class="id"> true</span><span class="id"> isT</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> and_wPropP</span><span class="id"> s</span><span class="id"> S</span><span class="id"> P0</span><span class="id"> P</span> (<span class="id">t</span><span class="id"> :</span><span class="id"> nandBool</span><span class="id"> s</span>)<span class="id"> T</span><span class="id"> Q0</span><span class="id"> Q</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">wProp</span><span class="id"> s</span><span class="id"> S</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> /\</span><span class="id"> wProp</span><span class="id"> t</span><span class="id"> T</span><span class="id"> Q0</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> *</span><span class="id"> T</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case=&gt;</span><span class="id"> /lax_witness-x</span><span class="id"> /lax_witness</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> and_wProp</span><span class="id"> s</span><span class="id"> S</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> t</span><span class="id"> T</span><span class="id"> Q0</span><span class="id"> Q</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperWitnessProp</span> (<span class="id">@and_wPropP</span><span class="id"> s</span><span class="id"> S</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> t</span><span class="id"> T</span><span class="id"> Q0</span><span class="id"> Q</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> or_wPropP</span><span class="id"> s</span><span class="id"> S</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> t</span><span class="id"> T</span><span class="id"> Q0</span><span class="id"> Q</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">wProp</span><span class="id"> s</span><span class="id"> S</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> \/</span><span class="id"> wProp</span><span class="id"> t</span><span class="id"> T</span><span class="id"> Q0</span><span class="id"> Q</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> t</span><span class="gallina-kwd"> then</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="gallina-kwd"> then</span><span class="id"> {P0}</span><span class="id"> +</span><span class="id"> {Q0}</span><span class="id"> :</span><span class="gallina-kwd"> Type</span><span class="gallina-kwd"> else</span><span class="id"> S</span><span class="id"> +</span><span class="id"> {Q0}</span><span class="gallina-kwd"> else</span><span class="id"> S</span><span class="id"> +</span><span class="id"> T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> -[]</span><span class="gallina-kwd"> in</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> *;</span> (<span class="id">case/decide_or=&gt;</span><span class="id"> /wPropP[];</span><span class="id"> [left</span><span class="id"> |</span><span class="id"> right]</span>).<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> or_wProp</span><span class="id"> s</span><span class="id"> S</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> t</span><span class="id"> T</span><span class="id"> Q0</span><span class="id"> Q</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperWitnessProp</span> (<span class="id">@or_wPropP</span><span class="id"> s</span><span class="id"> S</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> t</span><span class="id"> T</span><span class="id"> Q0</span><span class="id"> Q</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> exists_wPropP</span><span class="id"> A</span><span class="id"> t</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">exists</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A,</span><span class="id"> wPred</span><span class="id"> t</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="gallina-kwd"> if</span><span class="id"> t</span><span class="gallina-kwd"> then</span><span class="id"> {x</span><span class="id"> |</span><span class="id"> P0</span><span class="id"> x}</span><span class="gallina-kwd"> else</span><span class="id"> {x</span><span class="id"> &amp;</span><span class="id"> T</span><span class="id"> x}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case/cid</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /wPropP[];</span><span class="id"> case</span><span class="id"> t;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> exists_wProp</span><span class="id"> A</span><span class="id"> t</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperWitnessProp</span> (<span class="id">@exists_wPropP</span><span class="id"> A</span><span class="id"> t</span><span class="id"> T</span><span class="id"> P0</span><span class="id"> P</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> exists2_wPropP</span><span class="id"> A</span><span class="id"> s</span><span class="id"> S</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> t</span><span class="id"> T</span><span class="id"> Q0</span><span class="id"> Q</span> (<span class="id">st</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="gallina-kwd"> then</span><span class="id"> t</span><span class="gallina-kwd"> else</span><span class="id"> false</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">exists2</span><span class="id"> x</span><span class="id"> :</span><span class="id"> A,</span><span class="id"> wPred</span><span class="id"> s</span><span class="id"> S</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> wPred</span><span class="id"> t</span><span class="id"> T</span><span class="id"> Q0</span><span class="id"> Q</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> st</span><span class="gallina-kwd"> then</span><span class="id"> {x</span><span class="id"> |</span><span class="id"> P0</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> Q0</span><span class="id"> x}</span><span class="gallina-kwd"> else</span><span class="id"> {x</span><span class="id"> :</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> S</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> T</span><span class="id"> x}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case/cid2=&gt;</span><span class="id"> x</span><span class="id"> /wPropP[P0x</span><span class="id"> y]</span><span class="id"> /wPropP[];</span><span class="id"> case:</span><span class="id"> ifP;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> exists2_wProp</span><span class="id"> A</span><span class="id"> s</span><span class="id"> S</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> t</span><span class="id"> T</span><span class="id"> Q0</span><span class="id"> Q</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ProperWitnessProp</span> (<span class="id">@exists2_wPropP</span><span class="id"> A</span><span class="id"> s</span><span class="id"> S</span><span class="id"> P0</span><span class="id"> P</span><span class="id"> t</span><span class="id"> T</span><span class="id"> Q0</span><span class="id"> Q</span>).<br/>
<br/>
<div class="ssrdoc md">
## User lemmas and tactics for proof by contradiction and contraposition.
</div>
<br/>
<div class="ssrdoc md">
Helper lemmas:
- push_goal_copy makes a copy of the goal that can then be matched with
    witnessedType and negatedProp instances to generate a contradiction
    assuption, without disturbing the original form of the goal.
- assume_not_with turns the copy generated by push_identity into an
    equivalent negative assumption, which can then be simplified using the
    lax_notP and lax_witness views.
- absurd and absurdW replace the goal with False; absurdW does this under
    an assumption, and is used to weaken proof-by-assuming-negation to
    proof-by-contradiction.
- contra_Type converts an arbitrary function goal (with assumption and
    conclusion in Type) to an equivalent contrapositive Prop implication.
- contra_notP simplifies a contrapositive ~ Q -&gt; ~ P goal using
    negatedProp instances.
</div>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> push_goal_copy</span><span class="id"> {T}</span><span class="id"> :</span> ((<span class="id">T</span><span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> -&gt;</span><span class="id"> T</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact</span>. Qed.</div></details>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> assume_not_with</span><span class="id"> {R</span><span class="id"> P</span><span class="id"> T}</span><span class="id"> :</span> (<span class="id">~</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> -&gt;</span> (<span class="id">wType</span><span class="id"> P</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> -&gt;</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> nP_T</span><span class="id"> T_R;</span><span class="id"> have</span><span class="id"> [/T|]</span><span class="id"> :=</span><span class="id"> asboolP</span><span class="id"> P</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> absurdW</span><span class="id"> {S</span><span class="id"> T}</span><span class="id"> :</span> (<span class="id">S</span><span class="id"> -&gt;</span><span class="id"> False</span>)<span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> T</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> contra_Type</span><span class="id"> {P</span><span class="id"> Q</span><span class="id"> S</span><span class="id"> T}</span><span class="id"> :</span> (<span class="id">~</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="id"> ~</span><span class="id"> P</span>)<span class="id"> -&gt;</span><span class="id"> wType</span><span class="id"> P</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> wType</span><span class="id"> Q</span><span class="id"> T</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> implyNN</span><span class="id"> =&gt;</span><span class="id"> P_Q</span><span class="id"> /wTypeP/P_Q/T</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fact</span><span class="id"> contra_notP</span><span class="id"> tP</span><span class="id"> tQ</span> (<span class="id">nP</span><span class="id"> nQ</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>)<span class="id"> P</span><span class="id"> Q</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">nP</span><span class="id"> -&gt;</span><span class="id"> nQ</span>)<span class="id"> -&gt;</span> (<span class="id">~</span><span class="id"> nProp</span><span class="id"> tP</span><span class="id"> nP</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> ~</span><span class="id"> nProp</span><span class="id"> tQ</span><span class="id"> nQ</span><span class="id"> Q</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> 2!lax_notE</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Internals</span>.<br/>
<span class="vernacular">Import</span><span class="id"> Internals</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> notP</span><span class="id"> :=</span><span class="id"> @Internals</span>.<span class="id">notP</span>.<br/>
<span class="vernacular">Hint</span><span class="id"> View</span><span class="gallina-kwd"> for</span><span class="id"> move/</span><span class="id"> move_viewP|2</span>.<br/>
<span class="vernacular">Hint</span><span class="id"> View</span><span class="gallina-kwd"> for</span><span class="id"> move/</span><span class="id"> Internals</span>.<span class="id">equivT_LR|2</span><span class="id"> Internals</span>.<span class="id">equivT_RL|2</span>.<br/>
<span class="vernacular">Hint</span><span class="id"> View</span><span class="gallina-kwd"> for</span><span class="id"> apply/</span><span class="id"> Internals</span>.<span class="id">equivT_RL|2</span><span class="id"> Internals</span>.<span class="id">equivT_LR|2</span>.<br/>
<span class="vernacular">Export</span> (<span class="id">canonicals</span>)<span class="id"> Internals</span>.<br/>
<br/>
<div class="ssrdoc md">
Lemma and tactic assume_not: add a goal negation assumption. The tactic
also works for goals in Type, simplifies the added assumption, and
exposes its top-level constructive content.
</div>
<br/>
<span class="vernacular">Lemma</span><span class="id"> assume_not</span><span class="id"> {P}</span><span class="id"> :</span> (<span class="id">~</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> P</span>)<span class="id"> -&gt;</span><span class="id"> P</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> implyNp</span><span class="id"> orB</span>. Qed.</div></details>
<span class="vernacular">Ltac</span><span class="id"> assume_not</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> Internals</span>.<span class="id">push_goal_copy;</span><span class="id"> apply:</span><span class="id"> Internals</span>.<span class="id">assume_not_with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">=&gt;</span><span class="id"> /Internals</span>.<span class="id">lax_notP-/Internals</span>.<span class="id">lax_witness</span>.<br/>
<br/>
<div class="ssrdoc md">
Lemma and tactic absurd_not: proof by contradiction. Same as assume_not,
but the goal is erased and replaced by False.
Caveat: absurd_not cannot be used as a move/ view because its conclusion
is indeterminate. The more general notP defined above can be used instead.
</div>
<span class="vernacular">Lemma</span><span class="id"> absurd_not</span><span class="id"> {P}</span><span class="id"> :</span> (<span class="id">~</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> False</span>)<span class="id"> -&gt;</span><span class="id"> P</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/Internals</span>.<span class="id">notP</span>. Qed.</div></details>
<span class="vernacular">Ltac</span><span class="id"> absurd_not</span><span class="id"> :=</span><span class="id"> assume_not;</span><span class="id"> apply:</span><span class="id"> Internals</span>.<span class="id">absurdW</span>.<br/>
<br/>
<div class="ssrdoc md">
Tactic contra: proof by contraposition. Assume the negation of the goal
conclusion, and prove the negation of a given assumption. The defective
form contra (which can also be written contrapose) expects the assumption
to be pushed on the goal which thus has the form assumption -&gt; conclusion.

As with assume_not, contra allows both assumption and conclusion to be
in Type, simplifies the negation of both assumption and conclusion, and
exposes the constructive contents of the negated conclusion.

The contra tactic also supports a limited form of the ':' discharge
pseudo tactical, whereby contra: &lt;d-items&gt; means move: &lt;d-items&gt;; contra.
The only &lt;d-items&gt; allowed are one term, possibly preceded by a clear
switch.
</div>
<br/>
<span class="vernacular">Ltac</span><span class="id"> contrapose</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> Internals</span>.<span class="id">contra_Type;</span><br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> Internals</span>.<span class="id">contra_notP</span><span class="id"> =&gt;</span><span class="id"> /Internals</span>.<span class="id">lax_witness</span>.<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;contra&quot;</span><span class="id"> :=</span><span class="id"> contrapose</span>.<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;contra&quot;</span> <span class="id">&quot;:&quot;</span><span class="id"> constr</span>(<span class="id">H</span>)<span class="id"> :=</span><span class="id"> move:</span> (<span class="id">H</span>)<span class="id">;</span><span class="id"> contra</span>.<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;contra&quot;</span> <span class="id">&quot;:&quot;</span><span class="id"> ident</span>(<span class="id">H</span>)<span class="id"> :=</span><span class="id"> move:</span><span class="id"> H;</span><span class="id"> contra</span>.<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;contra&quot;</span> <span class="id">&quot;:&quot;</span> <span class="id">&quot;{&quot;</span><span class="id"> hyp_list</span>(<span class="id">Hs</span>) <span class="id">&quot;}&quot;</span><span class="id"> constr</span>(<span class="id">H</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">contra:</span> (<span class="id">H</span>)<span class="id">;</span><span class="id"> clear</span><span class="id"> Hs</span>.<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;contra&quot;</span> <span class="id">&quot;:&quot;</span> <span class="id">&quot;{&quot;</span><span class="id"> hyp_list</span>(<span class="id">Hs</span>) <span class="id">&quot;}&quot;</span><span class="id"> ident</span>(<span class="id">H</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">contra:</span><span class="id"> H;</span><span class="id"> clear</span><span class="id"> Hs</span>.<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;contra&quot;</span> <span class="id">&quot;:&quot;</span> <span class="id">&quot;{&quot;</span> <span class="id">&quot;-&quot;</span> <span class="id">&quot;}&quot;</span><span class="id"> constr</span>(<span class="id">H</span>)<span class="id"> :=</span><span class="id"> contra:</span> (<span class="id">H</span>).<br/>
<br/>
<div class="ssrdoc md">
Lemma and tactic absurd: proof by contradiction. The defective form of the
lemma simply replaces the entire goal with False (just as the Ltac
exfalso), leaving the user to derive a contradiction from the assumptions.
The ':' form absurd: &lt;d-items&gt; replaces the goal with the negation of the
(single) &lt;d-item&gt; (as with contra:, a clear switch is also allowed.
Finally the Ltac absurd term form is also supported.
</div>
<br/>
<span class="vernacular">Lemma</span><span class="id"> absurd</span><span class="id"> T</span><span class="id"> :</span><span class="id"> False</span><span class="id"> -&gt;</span><span class="id"> T</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0</span>) <span class="id">&quot;absurd&quot;</span><span class="id"> :=</span><span class="id"> apply</span><span class="id"> absurd</span>.<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0</span>) <span class="id">&quot;absurd&quot;</span><span class="id"> constr</span>(<span class="id">P</span>)<span class="id"> :=</span><span class="id"> have</span><span class="id"> []:</span><span class="id"> ~</span><span class="id"> P</span>.<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;absurd&quot;</span> <span class="id">&quot;:&quot;</span><span class="id"> constr</span>(<span class="id">H</span>)<span class="id"> :=</span><span class="id"> absurd;</span><span class="id"> contra:</span> (<span class="id">H</span>)<span class="id"> =&gt;</span><span class="id"> _</span>.<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;absurd&quot;</span> <span class="id">&quot;:&quot;</span><span class="id"> ident</span>(<span class="id">H</span>)<span class="id"> :=</span><span class="id"> absurd;</span><span class="id"> contra:</span><span class="id"> H</span><span class="id"> =&gt;</span><span class="id"> _</span>.<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;absurd&quot;</span> <span class="id">&quot;:&quot;</span> <span class="id">&quot;{&quot;</span><span class="id"> hyp_list</span>(<span class="id">Hs</span>) <span class="id">&quot;}&quot;</span><span class="id"> constr</span>(<span class="id">H</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">absurd:</span> (<span class="id">H</span>)<span class="id"> =&gt;</span><span class="id"> _;</span><span class="id"> clear</span><span class="id"> Hs</span>.<br/>
<span class="vernacular">Tactic</span><span class="vernacular"> Notation</span> <span class="id">&quot;absurd&quot;</span> <span class="id">&quot;:&quot;</span> <span class="id">&quot;{&quot;</span><span class="id"> hyp_list</span>(<span class="id">Hs</span>) <span class="id">&quot;}&quot;</span><span class="id"> ident</span>(<span class="id">H</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">absurd:</span><span class="id"> H</span><span class="id"> =&gt;</span><span class="id"> _;</span><span class="id"> clear</span><span class="id"> Hs</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
