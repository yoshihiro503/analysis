
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.analysis.cantor</title>
<meta name="description" content="Documentation of Coq module mathcomp.analysis.cantor" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.analysis.cantor</h1>
<span class="vernacular">From</span><span class="id"> HB</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> structures</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> all_ssreflect</span><span class="id"> ssralg</span><span class="id"> ssrint</span><span class="id"> ssrnum</span><span class="id"> interval</span><span class="id"> rat</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> finmap</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> mathcomp_extra</span><span class="id"> boolp</span><span class="id"> classical_sets</span><span class="id"> functions</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> cardinality</span><span class="id"> reals</span><span class="id"> signed</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> topology</span><span class="id"> function_spaces</span><span class="id"> separation_axioms</span>.<br/>
<br/>
<div class="ssrdoc md">
# The Cantor Space and Applications

This file develops the theory of the Cantor space, that is bool^nat with
the product topology. The two main theorems proved here are
homeomorphism_cantor_like, and cantor_surj, a.k.a. Alexandroff-Hausdorff.

```
         cantor_space == the Cantor space, with its canonical metric
        cantor_like T == perfect + compact + hausdroff + zero dimensional
            tree_of T == builds a topological tree with levels (T n)
```

The overall goal of the next few sections is to prove that
      Every compact metric space `T` is the image of the Cantor space.
 The overall proof will build two continuous functions
          Cantor space -&gt; a bespoke tree for `T` -&gt; `T`

The proof is in 4 parts:
- Part 1: Some generic machinery about continuous functions from trees.
- Part 2: All cantor-like spaces are homeomorphic to the Cantor space.
          (an application of part 1)
- Part 3: Finitely branching trees are Cantor-like.
- Part 4: Every compact metric space has a finitely branching tree with
          a continuous surjection. (a second application of part 1)

</div>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> Order</span>.<span class="id">TTheory</span><span class="id"> GRing</span>.<span class="id">Theory</span><span class="id"> Num</span>.<span class="id">Def</span><span class="id"> Num</span>.<span class="id">Theory</span>.<br/>
<span class="vernacular">Import</span><span class="id"> numFieldTopology</span>.<span class="vernacular">Exports</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> classical_set_scope</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> cantor_space</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">prod_topology</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> =&gt;</span><span class="id"> discrete_topology</span><span class="id"> discrete_bool</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Pointed</span>.<span class="id">on</span><span class="id"> cantor_space</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Nbhs</span>.<span class="id">on</span><span class="id"> cantor_space</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Topological</span>.<span class="id">on</span><span class="id"> cantor_space</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> cantor_like</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> topologicalType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> perfect_set</span><span class="id"> [set:</span><span class="id"> T],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">compact</span><span class="id"> [set:</span><span class="id"> T],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hausdorff_space</span><span class="id"> T</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">zero_dimensional</span><span class="id"> T]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cantor_space_compact</span><span class="id"> :</span><span class="id"> compact</span><span class="id"> [set:</span><span class="id"> cantor_space]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> :=</span><span class="id"> @tychonoff</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> =&gt;</span><span class="id"> _</span>)<span class="id"> _</span> (<span class="id">fun=&gt;</span><span class="id"> discrete_bool_compact</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> congr</span> (<span class="id">compact</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cantor_space_hausdorff</span><span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> cantor_space</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> hausdorff_product</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> apply:</span><span class="id"> discrete_hausdorff</span>.<br/>
<span class="id">exact:</span><span class="id"> discrete_space_discrete</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cantor_zero_dimensional</span><span class="id"> :</span><span class="id"> zero_dimensional</span><span class="id"> cantor_space</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> zero_dimension_prod</span><span class="id"> =&gt;</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> discrete_zero_dimension</span>.<br/>
<span class="id">exact:</span><span class="id"> discrete_space_discrete</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cantor_perfect</span><span class="id"> :</span><span class="id"> perfect_set</span><span class="id"> [set:</span><span class="id"> cantor_space]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> perfect_diagonal</span><span class="id"> =&gt;</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span> (<span class="id">true,</span><span class="id"> false</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cantor_like_cantor_space</span><span class="id"> :</span><span class="id"> cantor_like</span><span class="id"> cantor_space</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> cantor_perfect</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> cantor_space_compact</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> cantor_space_hausdorff</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> cantor_zero_dimensional</span>.<br/>
Qed.</div></details>
<br/>
<br/>
<div class="ssrdoc md">
## Part 1

A tree here has countable levels, and nodes of type `K n` on the nth
level.
Each level is in the 'discrete' topology, so the nodes are independent.
The goal is to build a map from branches to X.
1. Each level of the tree corresponds to an approximation of `X`.
2. Each level refines the previous approximation.
3. Then each branch has a corresponding Cauchy filter.
4. The overall function from branches to X is a continuous surjection.
5. With an extra disjointness condition, this is also an injection

</div>
<span class="vernacular">Section</span><span class="id"> topological_trees</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {K</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> ptopologicalType}</span><span class="id"> {X</span><span class="id"> :</span><span class="id"> ptopologicalType}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">refine_apx</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> n,</span><span class="id"> set</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> K</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> X</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">tree_invariant</span><span class="id"> :</span><span class="id"> set</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>).<br/>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> cmptX</span><span class="id"> :</span><span class="id"> compact</span><span class="id"> [set:</span><span class="id"> X]</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> hsdfX</span><span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> X</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> discreteK</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> n,</span><span class="id"> discrete_space</span> (<span class="id">K</span><span class="id"> n</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> refine_cover</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> n</span><span class="id"> U,</span><span class="id"> U</span><span class="id"> =</span><span class="id"> \bigcup_e</span><span class="id"> @refine_apx</span><span class="id"> n</span><span class="id"> U</span><span class="id"> e</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> refine_invar</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> n</span><span class="id"> U</span><span class="id"> e,</span><br/>
&nbsp;&nbsp;<span class="id">tree_invariant</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> tree_invariant</span> (<span class="id">@refine_apx</span><span class="id"> n</span><span class="id"> U</span><span class="id"> e</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> invar_n0</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> U,</span><span class="id"> tree_invariant</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> !=set0</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> invarT</span><span class="id"> :</span><span class="id"> tree_invariant</span><span class="id"> [set:</span><span class="id"> X]</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> invar_cl</span><span class="id"> :</span><span class="id"> tree_invariant</span><span class="id"> `&lt;=`</span><span class="id"> closed</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> refine_separates:</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> X,</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> y</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> n,</span><span class="gallina-kwd"> forall</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> set</span><span class="id"> X</span>)<span class="id"> e,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">@refine_apx</span><span class="id"> n</span><span class="id"> U</span><span class="id"> e</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> ~@refine_apx</span><span class="id"> n</span><span class="id"> U</span><span class="id"> e</span><span class="id"> y</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> refine_subset</span><span class="id"> n</span><span class="id"> U</span><span class="id"> e</span><span class="id"> :</span><span class="id"> @refine_apx</span><span class="id"> n</span><span class="id"> U</span><span class="id"> e</span><span class="id"> `&lt;=`</span><span class="id"> U</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> `&lt;=`</span><span class="id"> X]</span>(<span class="id">refine_cover</span><span class="id"> n</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> bigcup_sup</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> prod_topology</span><span class="id"> K</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fixpoint</span><span class="id"> branch_apx</span> (<span class="id">b</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> n</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> n</span><span class="id"> is</span><span class="id"> m</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="id"> refine_apx</span> (<span class="id">branch_apx</span><span class="id"> b</span><span class="id"> m</span>) (<span class="id">b</span><span class="id"> m</span>)<span class="gallina-kwd"> else</span><span class="id"> [set:</span><span class="id"> X]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> tree_mapF</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> filter_from</span><span class="id"> [set:</span><span class="id"> nat]</span> (<span class="id">branch_apx</span><span class="id"> b</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> tree_map_invar</span><span class="id"> b</span><span class="id"> n</span><span class="id"> :</span><span class="id"> tree_invariant</span> (<span class="id">branch_apx</span><span class="id"> b</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> refine_invar</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> tree_map_sub</span><span class="id"> b</span><span class="id"> i</span><span class="id"> j</span><span class="id"> :</span> (<span class="id">i</span><span class="id"> &lt;=</span><span class="id"> j</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> branch_apx</span><span class="id"> b</span><span class="id"> j</span><span class="id"> `&lt;=`</span><span class="id"> branch_apx</span><span class="id"> b</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> j</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> [?|j</span><span class="id"> IH</span><span class="id"> i];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> leqn0</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;</span>.<br/>
<span class="id">rewrite</span><span class="id"> leq_eqVlt</span><span class="id"> =&gt;</span><span class="id"> /predU1P[-&gt;//|/IH]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subset_trans;</span><span class="id"> exact:</span><span class="id"> refine_subset</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Instance</span><span class="id"> tree_map_filter</span><span class="id"> b</span><span class="id"> :</span><span class="id"> ProperFilter</span> (<span class="id">tree_mapF</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> case</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> _</span><span class="id"> P;</span><span class="id"> case:</span> (<span class="id">invar_n0</span> (<span class="id">tree_map_invar</span><span class="id"> b</span><span class="id"> n</span>))<span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /P</span>.<br/>
<span class="id">apply:</span><span class="id"> filter_from_filter;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 0%N</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span> (<span class="id">maxn</span><span class="id"> i</span><span class="id"> j</span>) <span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> subsetI</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split;</span><span class="id"> apply:</span><span class="id"> tree_map_sub;</span><span class="id"> [exact:</span><span class="id"> leq_maxl</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> leq_maxr]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> tree_map</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> lim</span> (<span class="id">tree_mapF</span><span class="id"> b</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> cvg_tree_map</span><span class="id"> b</span><span class="id"> :</span><span class="id"> cvg</span> (<span class="id">tree_mapF</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [|x</span><span class="id"> [_</span><span class="id"> clx]]</span><span class="id"> :=</span><span class="id"> cmptX</span> (<span class="id">tree_map_filter</span><span class="id"> b</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> filterT</span>.<br/>
<span class="id">apply/cvg_ex;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> apply:</span> (<span class="id">compact_cluster_set1</span><span class="id"> _</span><span class="id"> cmptX</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> filterT</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> filterT</span>.<br/>
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split=&gt;</span><span class="id"> [y</span><span class="id"> cly|?</span><span class="id"> -&gt;</span><span class="id"> //]</span>.<br/>
<span class="id">have</span><span class="id"> [-&gt;//|/refine_separates[n</span><span class="id"> sep]]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> x</span><span class="id"> y</span>.<br/>
<span class="id">have</span><span class="id"> bry</span><span class="id"> :</span><span class="id"> branch_apx</span><span class="id"> b</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /closure_id</span><span class="id"> -&gt;</span><span class="id"> :=</span><span class="id"> invar_cl</span> (<span class="id">tree_map_invar</span><span class="id"> b</span><span class="id"> n</span>.<span class="id">+1</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> cly;</span><span class="id"> rewrite</span><span class="id"> clusterE;</span><span class="id"> apply;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<span class="id">+1</span>.<br/>
<span class="id">suff</span><span class="id"> /sep</span><span class="id"> :</span><span class="id"> branch_apx</span><span class="id"> b</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> x</span><span class="gallina-kwd"> by</span><span class="id"> []</span>.<br/>
<span class="id">have</span><span class="id"> /closure_id</span><span class="id"> -&gt;</span><span class="id"> :=</span><span class="id"> invar_cl</span> (<span class="id">tree_map_invar</span><span class="id"> b</span><span class="id"> n</span>.<span class="id">+1</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> clx;</span><span class="id"> rewrite</span><span class="id"> clusterE;</span><span class="id"> apply;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<span class="id">+1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> tree_map_surj</span><span class="id"> :</span><span class="id"> set_surj</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> [set:</span><span class="id"> X]</span><span class="id"> tree_map</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> _;</span><span class="id"> suff</span><span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> g,</span><span class="gallina-kwd"> forall</span><span class="id"> n,</span><span class="id"> branch_apx</span><span class="id"> g</span><span class="id"> n</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> g</span><span class="id"> gnz;</span><span class="gallina-kwd"> exists</span><span class="id"> g</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> close_eq</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> U</span><span class="id"> [oU</span><span class="id"> Uz]</span><span class="id"> V</span><span class="id"> ngV;</span><span class="gallina-kwd"> exists</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> have</span><span class="id"> [n</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> @cvg_tree_map</span><span class="id"> g</span><span class="id"> _</span><span class="id"> ngV;</span><span class="id"> exact</span>.<br/>
<span class="id">have</span><span class="id"> zcov'</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> n</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> set</span><span class="id"> X</span>)<span class="id">,</span><span class="gallina-kwd"> exists</span><span class="id"> e,</span><span class="id"> U</span><span class="id"> z</span><span class="id"> -&gt;</span><span class="id"> @refine_apx</span><span class="id"> n</span><span class="id"> U</span><span class="id"> e</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> n</span><span class="id"> U;</span><span class="id"> have</span><span class="id"> [|?]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">U</span><span class="id"> z</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> point</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> z</span><span class="id"> -&gt;</span><span class="id"> _]</span>(<span class="id">@refine_cover</span><span class="id"> n</span><span class="id"> U</span>)<span class="id">;</span><span class="id"> case</span><span class="id"> =&gt;</span><span class="id"> e</span><span class="id"> _</span><span class="id"> ?;</span><span class="gallina-kwd"> exists</span><span class="id"> e</span>.<br/>
<span class="id">pose</span><span class="id"> zcov</span><span class="id"> n</span><span class="id"> U</span><span class="id"> :=</span><span class="id"> projT1</span> (<span class="id">cid</span> (<span class="id">zcov'</span><span class="id"> n</span><span class="id"> U</span>)).<br/>
<span class="id">pose</span><span class="gallina-kwd"> fix</span><span class="id"> g</span><span class="id"> n</span><span class="id"> :</span><span class="id"> K</span><span class="id"> n</span><span class="id"> *</span><span class="id"> set</span><span class="id"> X</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> n</span><span class="id"> is</span><span class="id"> m</span>.<span class="id">+1</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">then</span> (<span class="id">zcov</span><span class="id"> m</span>.<span class="id">+1</span> (<span class="id">g</span><span class="id"> m</span>).<span class="id">2,</span><span class="id"> @refine_apx</span><span class="id"> m</span>.<span class="id">+1</span> (<span class="id">g</span><span class="id"> m</span>).<span class="id">2</span> (<span class="id">zcov</span><span class="id"> m</span>.<span class="id">+1</span> (<span class="id">g</span><span class="id"> m</span>).<span class="id">2</span>))<br/>
&nbsp;&nbsp;<span class="gallina-kwd">else</span> (<span class="id">zcov</span><span class="id"> O</span><span class="id"> [set:</span><span class="id"> X],</span><span class="id"> @refine_apx</span><span class="id"> O</span><span class="id"> [set:</span><span class="id"> X]</span> (<span class="id">zcov</span><span class="id"> O</span><span class="id"> [set:</span><span class="id"> X]</span>)).<br/>
<span class="id">pose</span><span class="id"> g'</span><span class="id"> n</span><span class="id"> :=</span> (<span class="id">g</span><span class="id"> n</span>).<span class="id">1;</span><span class="id"> have</span><span class="id"> apxg</span><span class="id"> n</span><span class="id"> :</span><span class="id"> branch_apx</span><span class="id"> g'</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> =</span> (<span class="id">g</span><span class="id"> n</span>).<span class="id">2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> g';</span><span class="id"> elim</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n</span><span class="id"> /=</span><span class="id"> IH</span>.<br/>
<span class="id">have</span><span class="id"> /</span>(_<span class="id"> IH</span>)<span class="id"> :=</span><span class="id"> projT2</span> (<span class="id">cid</span> (<span class="id">zcov'</span><span class="id"> n</span> (<span class="id">branch_apx</span><span class="id"> g'</span><span class="id"> n</span>))).<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> n</span><span class="id"> {IH}</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> apxg</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> tree_prefix</span> (<span class="id">b</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">n</span><span class="id"> :</span><span class="id"> nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\forall</span><span class="id"> c</span><span class="id"> \near</span><span class="id"> b,</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span>  (<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> b</span><span class="id"> i</span><span class="id"> =</span><span class="id"> c</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> IH];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> near=&gt;</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> ltn0</span>.<br/>
<span class="id">near=&gt;</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> leq_eqVlt</span><span class="id"> =&gt;</span><span class="id"> /predU1P[|iSn];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">near</span><span class="id"> IH</span><span class="id"> z</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> [-&gt;];</span><span class="id"> near:</span><span class="id"> z;</span><span class="gallina-kwd"> exists</span> (<span class="id">proj</span><span class="id"> n</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> b</span><span class="id"> n]</span>).<br/>
<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> suff</span><span class="id"> :</span><span class="id"> @open</span><span class="id"> T</span> (<span class="id">proj</span><span class="id"> n</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> b</span><span class="id"> n]</span>)<span class="gallina-kwd"> by</span><span class="id"> []</span>.<br/>
<span class="id">apply:</span><span class="id"> open_comp;</span><span class="id"> [move=&gt;</span><span class="id"> +</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> proj_continuous|</span><span class="id"> apply:</span><span class="id"> discrete_open]</span>.<br/>
<span class="id">exact:</span><span class="id"> discreteK</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> apx_prefix</span><span class="id"> b</span><span class="id"> c</span><span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span> (<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> b</span><span class="id"> i</span><span class="id"> =</span><span class="id"> c</span><span class="id"> i</span>)<span class="id"> -&gt;</span><span class="id"> branch_apx</span><span class="id"> b</span><span class="id"> n</span><span class="id"> =</span><span class="id"> branch_apx</span><span class="id"> c</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> IH</span><span class="id"> inS;</span><span class="id"> rewrite</span><span class="id"> IH;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inS</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> exact/inS/ltnW</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> tree_map_apx</span><span class="id"> b</span><span class="id"> n</span><span class="id"> :</span><span class="id"> branch_apx</span><span class="id"> b</span><span class="id"> n</span> (<span class="id">tree_map</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">@closed_cvg</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">tree_map_filter</span><span class="id"> b</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> cvg_tree_map</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> invar_cl;</span><span class="id"> exact:</span><span class="id"> tree_map_invar</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> tree_map_cts</span><span class="id"> :</span><span class="id"> continuous</span><span class="id"> tree_map</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> b</span><span class="id"> U</span><span class="id"> /cvg_tree_map</span><span class="id"> [n</span><span class="id"> _]</span><span class="id"> /filterS;</span><span class="id"> apply</span>.<br/>
<span class="id">rewrite</span><span class="id"> nbhs_simpl</span><span class="id"> /=;</span><span class="id"> near_simpl;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> tree_prefix</span><span class="id"> b</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> filter_app</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> near=&gt;</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> /apx_prefix</span><span class="id"> -&gt;;</span><span class="id"> exact:</span><span class="id"> tree_map_apx</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> tree_map_setI</span><span class="id"> x</span><span class="id"> y</span><span class="id"> n</span><span class="id"> :</span><span class="id"> tree_map</span><span class="id"> x</span><span class="id"> =</span><span class="id"> tree_map</span><span class="id"> y</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">refine_apx</span> (<span class="id">branch_apx</span><span class="id"> x</span><span class="id"> n</span>) (<span class="id">x</span><span class="id"> n</span>)<span class="id"> `&amp;`</span><span class="id"> refine_apx</span> (<span class="id">branch_apx</span><span class="id"> y</span><span class="id"> n</span>) (<span class="id">y</span><span class="id"> n</span>)<span class="id"> !=set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> xyE;</span><span class="gallina-kwd"> exists</span> (<span class="id">tree_map</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -xyE</span><span class="id"> -/</span>(<span class="id">branch_apx</span><span class="id"> x</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> tree_map_apx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -/</span>(<span class="id">branch_apx</span><span class="id"> y</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> tree_map_apx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> tree_map_inj</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> n</span><span class="id"> U,</span><span class="id"> trivIset</span><span class="id"> [set:</span><span class="id"> K</span><span class="id"> n]</span> (<span class="id">@refine_apx</span><span class="id"> n</span><span class="id"> U</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">set_inj</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> tree_map</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> triv</span><span class="id"> x</span><span class="id"> y</span><span class="id"> _</span><span class="id"> _</span><span class="id"> xyE;</span><span class="id"> apply:</span><span class="id"> functional_extensionality_dep</span><span class="id"> =&gt;</span><span class="id"> n</span>.<br/>
<span class="id">suff</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> n,</span><span class="id"> branch_apx</span><span class="id"> x</span><span class="id"> n</span><span class="id"> =</span><span class="id"> branch_apx</span><span class="id"> y</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> brE;</span><span class="id"> apply:</span> (<span class="id">@triv</span><span class="id"> n</span> (<span class="id">branch_apx</span><span class="id"> x</span><span class="id"> n</span>)<span class="id"> _</span><span class="id"> _</span><span class="id"> I</span><span class="id"> I</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [in</span><span class="id"> X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> `&amp;`</span><span class="id"> X]brE;</span><span class="id"> exact:</span><span class="id"> tree_map_setI</span>.<br/>
<span class="id">elim</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> m</span><span class="id"> /=</span><span class="id"> brE</span>.<br/>
<span class="id">rewrite</span> (<span class="id">@triv</span><span class="id"> m</span> (<span class="id">branch_apx</span><span class="id"> x</span><span class="id"> m</span>) (<span class="id">x</span><span class="id"> m</span>) (<span class="id">y</span><span class="id"> m</span>)<span class="id"> I</span><span class="id"> I</span>)<span class="id"> 1?brE//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -[in</span><span class="id"> X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> `&amp;`</span><span class="id"> _]brE;</span><span class="id"> exact:</span><span class="id"> tree_map_setI</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> tree_map_props</span><span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> X,</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> continuous</span><span class="id"> f,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_surj</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> [set:</span><span class="id"> X]</span><span class="id"> f</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n</span><span class="id"> U,</span><span class="id"> trivIset</span><span class="id"> [set:</span><span class="id"> K</span><span class="id"> n]</span> (<span class="id">@refine_apx</span><span class="id"> n</span><span class="id"> U</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_inj</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> f]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">exists</span><span class="id"> tree_map;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> tree_map_cts</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> tree_map_surj</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> tree_map_inj</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> topological_trees</span>.<br/>
<br/>
<div class="ssrdoc md">
## Part 2
We can use `tree_map_props` to build a homeomorphism from the
cantor_space to a Cantor-like space T.
</div>
<br/>
<span class="vernacular">Section</span><span class="id"> TreeStructure</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> pseudoPMetricType</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> cantorT</span><span class="id"> :</span><span class="id"> cantor_like</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> dsctT</span><span class="id"> :</span><span class="id"> zero_dimensional</span><span class="id"> T</span><br/>
<details>
&nbsp;&nbsp;<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> cantorT</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> pftT</span> <span class="id"> :</span><span class="id"> perfect_set</span><span class="id"> [set:</span><span class="id"> T]</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> cantorT</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> cmptT</span><span class="id"> :</span><span class="id"> compact</span><span class="id"> [set:</span><span class="id"> T]</span><br/>
<details>
&nbsp;&nbsp;&nbsp;&nbsp;<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> cantorT</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> hsdfT</span><span class="id"> :</span><span class="id"> @hausdorff_space</span><span class="id"> T</span><br/>
<details>
&nbsp;&nbsp;<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> cantorT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> c_invar</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><span class="id"> clopen</span><span class="id"> U</span><span class="id"> /\</span><span class="id"> U</span><span class="id"> !=set0</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> U_</span><span class="id"> :=</span><span class="id"> unsquash</span> (<span class="id">clopen_surj</span><span class="id"> cmptT</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> split_clopen'</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> V,</span><br/>
&nbsp;&nbsp;<span class="id">open</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> !=set0</span><span class="id"> -&gt;</span><span class="id"> [/\</span><span class="id"> clopen</span><span class="id"> V,</span><span class="id"> V</span><span class="id"> `&amp;`</span><span class="id"> U</span><span class="id"> !=set0</span><span class="id"> &amp;</span><span class="id"> ~`V</span><span class="id"> `&amp;`</span><span class="id"> U</span><span class="id"> !=set0]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [oU|?]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">open</span><span class="id"> U</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> point</span>.<br/>
<span class="id">have</span><span class="id"> [Un0|?]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">U</span><span class="id"> !=set0</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> point</span>.<br/>
<span class="id">have</span><span class="id"> [x</span><span class="id"> [y]</span><span class="id"> [Ux]</span><span class="id"> Uy</span><span class="id"> xny]</span><span class="id"> :=</span> (<span class="id">iffLR</span><span class="id"> perfectTP_ex</span>)<span class="id"> pftT</span><span class="id"> U</span><span class="id"> oU</span><span class="id"> Un0</span>.<br/>
<span class="id">have</span><span class="id"> [V</span><span class="id"> [clV</span><span class="id"> Vx</span><span class="id"> Vy]]</span><span class="id"> :=</span><span class="id"> dsctT</span><span class="id"> xny;</span><span class="gallina-kwd"> exists</span><span class="id"> V</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> [exists</span><span class="id"> x</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> y]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> split_clopen</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><span class="id"> projT1</span> (<span class="id">cid</span> (<span class="id">split_clopen'</span><span class="id"> U</span>)).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> c_ind</span><span class="id"> n</span> (<span class="id">V</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">b</span><span class="id"> :</span><span class="id"> bool</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> Wn</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> pselect</span> ((<span class="id">U_</span><span class="id"> n</span>)<span class="id"> `&amp;`</span><span class="id"> V</span><span class="id"> !=set0</span><span class="id"> /\</span><span class="id"> ~`</span> (<span class="id">U_</span><span class="id"> n</span>)<span class="id"> `&amp;`</span><span class="id"> V</span><span class="id"> !=set0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">then</span><span class="id"> U_</span><span class="id"> n</span><span class="gallina-kwd"> else</span><span class="id"> split_clopen</span><span class="id"> V</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">if</span><span class="id"> b</span><span class="gallina-kwd"> then</span><span class="id"> Wn</span><span class="gallina-kwd"> else</span><span class="id"> ~`</span><span class="id"> Wn</span>)<span class="id"> `&amp;`</span><span class="id"> V</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> cantor_map</span><span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> f</span><span class="id"> :</span><span class="id"> cantor_space</span><span class="id"> -&gt;</span><span class="id"> T,</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> continuous</span><span class="id"> f,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_surj</span><span class="id"> [set:</span><span class="id"> cantor_space]</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> f</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_inj</span><span class="id"> [set:</span><span class="id"> cantor_space]</span><span class="id"> f</span><span class="id"> ]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> @tree_map_props</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fun=&gt;</span><span class="id"> discrete_topology</span><span class="id"> discrete_bool</span>)<span class="id"> T</span><span class="id"> c_ind</span><span class="id"> c_invar</span><span class="id"> cmptT</span><span class="id"> hsdfT</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> discrete_space_discrete</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> V;</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [t</span><span class="id"> Vt|t</span><span class="id"> [?</span><span class="id"> ?</span><span class="id"> []]//]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [?|?]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">U_</span><span class="id"> n</span><span class="id"> `&amp;`</span><span class="id"> V</span><span class="id"> !=set0</span><span class="id"> /\</span><span class="id"> ~`</span><span class="id"> U_</span><span class="id"> n</span><span class="id"> `&amp;`</span><span class="id"> V</span><span class="id"> !=set0</span>).<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> have</span><span class="id"> [Unt|Unt]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">U_</span><span class="id"> n</span><span class="id"> t</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">*</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> true</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> /c_ind;</span><span class="id"> case:</span><span class="id"> pselect</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">*</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> false</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> /c_ind;</span><span class="id"> case:</span><span class="id"> pselect</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> have</span><span class="id"> [scVt|scVt]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">split_clopen</span><span class="id"> V</span><span class="id"> t</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">*</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> true</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> /c_ind;</span><span class="id"> case:</span><span class="id"> pselect</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">*</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> false</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> /c_ind;</span><span class="id"> case:</span><span class="id"> pselect</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> U</span><span class="id"> e</span><span class="id"> []</span><span class="id"> clU</span><span class="id"> Un0;</span><span class="id"> rewrite</span><span class="id"> /c_ind;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> move=&gt;</span><span class="id"> [UU</span><span class="id"> CUU];</span><span class="id"> case:</span><span class="id"> e</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> clopenI</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> funS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> clopenC</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> funS</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> move=&gt;</span><span class="id"> _;</span><span class="id"> have</span><span class="id"> [|//|clscU</span><span class="id"> scUU</span><span class="id"> CscUU]</span><span class="id"> :=</span><span class="id"> projT2</span> (<span class="id">cid</span> (<span class="id">split_clopen'</span><span class="id"> U</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> clU</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case:</span><span class="id"> e;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> clopenI</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> clopenI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> clopenC</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> []</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> split;</span><span class="id"> [exact:</span><span class="id"> clopenT</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> point]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> [[]]</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /dsctT</span><span class="id"> [A</span><span class="id"> [clA</span><span class="id"> Ax</span><span class="id"> Any]]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [n</span><span class="id"> _</span><span class="id"> UnA]</span><span class="id"> :=</span><span class="id"> @surj</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> U_</span><span class="id"> _</span><span class="id"> clA;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> V</span><span class="id"> e</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [|+</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">V</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> subsetC</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> []</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [Vx</span><span class="id"> Vy|?</span><span class="id"> _</span><span class="id"> []//]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">V</span><span class="id"> x</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> {1</span><span class="id"> 2}/c_ind;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> ?UnA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> e;</span><span class="id"> case</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> apply/not_andP;</span><span class="id"> left</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> absurd;</span><span class="id"> split;</span><span class="id"> [exists</span><span class="id"> x</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> y]</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> f</span><span class="id"> [ctsf</span><span class="id"> surjf</span><span class="id"> injf];</span><span class="gallina-kwd"> exists</span><span class="id"> f;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> injf</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> U</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [z]</span><span class="id"> []</span><span class="id"> []</span><span class="id"> +</span><span class="id"> Uz</span><span class="id"> [+</span><span class="id"> _];</span><span class="id"> move:</span><span class="id"> i</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> []</span><span class="id"> []</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> tree_map</span><span class="id"> :=</span><span class="id"> projT1</span> (<span class="id">cid</span><span class="id"> cantor_map</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> tree_map_bij</span><span class="id"> :</span><span class="id"> bijective</span><span class="id"> tree_map</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -setTT_bijective;</span><span class="id"> have</span><span class="id"> [?</span><span class="id"> ?</span><span class="id"> ?]</span><span class="id"> :=</span><span class="id"> projT2</span> (<span class="id">cid</span><span class="id"> cantor_map</span>)<span class="id">;</span><span class="id"> split</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">#[local]</span><span class="id"> HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @BijTT</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> tree_map_bij</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> homeomorphism_cantor_like</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> f</span><span class="id"> :</span><span class="id"> {splitbij</span><span class="id"> [set:</span><span class="id"> cantor_space]</span><span class="id"> &gt;-&gt;</span><span class="id"> [set:</span><span class="id"> T]},</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">continuous</span><span class="id"> f</span><span class="id"> /\</span> (<span class="gallina-kwd">forall</span><span class="id"> A,</span><span class="id"> closed</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> closed</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> A</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">exists</span><span class="id"> [the</span><span class="id"> {splitbij</span><span class="id"> _</span><span class="id"> &gt;-&gt;</span><span class="id"> _}</span><span class="id"> of</span><span class="id"> tree_map]</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="id">have</span><span class="id"> [cts</span><span class="id"> surj</span><span class="id"> inje]</span><span class="id"> :=</span><span class="id"> projT2</span> (<span class="id">cid</span><span class="id"> cantor_map</span>)<span class="id">;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> cts</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> clA;</span><span class="id"> apply:</span> (<span class="id">compact_closed</span><span class="id"> hsdfT</span>).<br/>
<span class="id">apply:</span> (<span class="id">@continuous_compact</span><span class="id"> _</span><span class="id"> _</span><span class="id"> tree_map</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> continuous_subspaceT</span>.<br/>
<span class="id">apply:</span> (<span class="id">@subclosed_compact</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [set:</span><span class="id"> cantor_space]</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">exact:</span><span class="id"> cantor_space_compact</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> TreeStructure</span>.<br/>
<br/>
<div class="ssrdoc md">
## Part 3: Finitely branching trees are Cantor-like
</div>
<span class="vernacular">Section</span><span class="id"> FinitelyBranchingTrees</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> tree_of</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> pointedType</span>)<span class="id"> :</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">prod_topology</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span> <span class="id"> discrete_topology_type</span> (<span class="id">T</span><span class="id"> n</span>)).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> pointedType</span>)<span class="id"> :</span><span class="id"> Pointed</span> (<span class="id">tree_of</span><span class="id"> T</span>)<span class="id">:=</span> <br/>
&nbsp;&nbsp;<span class="id">Pointed</span>.<span class="id">on</span> (<span class="id">tree_of</span><span class="id"> T</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> pointedType</span>)<span class="id"> :=</span><span class="id"> Uniform</span>.<span class="id">on</span> (<span class="id">tree_of</span><span class="id"> T</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> pointedType</span>)<span class="id"> :</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">@PseudoMetric</span><span class="id"> R</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">@PseudoMetric</span>.<span class="id">on</span> (<span class="id">tree_of</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cantor_like_finite_prod</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> ptopologicalType</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> finite_set</span><span class="id"> [set:</span><span class="id"> discrete_topology_type</span> (<span class="id">T</span><span class="id"> n</span>)<span class="id">]</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n,</span> (<span class="gallina-kwd">exists</span><span class="id"> xy</span><span class="id"> :</span><span class="id"> T</span><span class="id"> n</span><span class="id"> *</span><span class="id"> T</span><span class="id"> n,</span><span class="id"> xy</span>.<span class="id">1</span><span class="id"> !=</span><span class="id"> xy</span>.<span class="id">2</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">cantor_like</span> (<span class="id">tree_of</span><span class="id"> T</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> finiteT</span><span class="id"> twoElems;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="id"> exact/</span>(<span class="id">@perfect_diagonal</span> (<span class="id">discrete_topology_type</span><span class="id"> \o</span><span class="id"> T</span>))<span class="id">/twoElems</span>.<br/>
<span class="id">-</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> tychonoff</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> finite_compact</span> (<span class="id">finiteT</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;<span class="id">set</span><span class="id"> A</span><span class="id"> :=</span> (<span class="id">X</span><span class="gallina-kwd"> in</span><span class="id"> compact</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="id">suff</span><span class="id"> :</span><span class="id"> A</span><span class="id"> =</span><span class="id"> [set:</span><span class="id"> tree_of</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="id"> x</span>)<span class="id">]</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span> (<span class="id">@hausdorff_product</span><span class="id"> _</span> (<span class="id">discrete_topology_type</span><span class="id"> \o</span><span class="id"> T</span>))<span class="id"> =&gt;</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> discrete_hausdorff;</span><span class="id"> exact:</span><span class="id"> discrete_space_discrete</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> zero_dimension_prod</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> apply:</span><span class="id"> discrete_zero_dimension</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> discrete_space_discrete</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> FinitelyBranchingTrees</span>.<br/>
<br/>
<div class="ssrdoc md">
## Part 4: Building a finitely branching tree to cover `T`
</div>
<span class="vernacular">Section</span><span class="id"> alexandroff_hausdorff</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> pseudoPMetricType</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> cptT</span><span class="id"> :</span><span class="id"> compact</span><span class="id"> [set:</span><span class="id"> T]</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> hsdfT</span><span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> two_pointed</span>.<br/>
<span class="vernacular">Context</span> (<span class="id">t0</span><span class="id"> t1</span><span class="id"> :</span><span class="id"> T</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> T2e</span><span class="id"> :</span><span class="id"> t0</span><span class="id"> !=</span><span class="id"> t1</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> ent_balls'</span> (<span class="id">E</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> T</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> M</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">,</span><span class="id"> entourage</span><span class="id"> E</span><span class="id"> -&gt;</span><span class="id"> [/\</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> M,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> A,</span><span class="id"> M</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> a,</span><span class="id"> A</span><span class="id"> a</span><span class="id"> /\</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> `&lt;=`</span><span class="id"> closure</span> (<span class="id">xsection</span> (<span class="id">split_ent</span><span class="id"> E</span>)<span class="id"> a</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span><span class="id"> M</span><span class="id"> A</span><span class="id"> /\</span><span class="id"> M</span><span class="id"> B</span><span class="id"> /\</span><span class="id"> A</span><span class="id"> !=</span><span class="id"> B,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\bigcup_</span>(<span class="id">A</span><span class="gallina-kwd"> in</span><span class="id"> M</span>)<span class="id"> A</span><span class="id"> =</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">M</span><span class="id"> `&lt;=`</span><span class="id"> closed]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [entE|?]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">entourage</span><span class="id"> E</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> point</span>.<br/>
<span class="id">move:</span><span class="id"> cptT;</span><span class="id"> rewrite</span><span class="id"> compact_cover</span>.<br/>
<span class="id">pose</span><span class="id"> fs</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> interior</span> (<span class="id">xsection</span> (<span class="id">split_ent</span><span class="id"> E</span>)<span class="id"> x</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> /</span>(_<span class="id"> T</span><span class="id"> [</span><span class="id"> set:</span><span class="id"> T]</span><span class="id"> fs</span>)<span class="id">[t</span><span class="id"> _|t</span><span class="id"> _</span><span class="id"> |]</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> open_interior</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> exists</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> /fs</span><span class="id"> /interior</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -nbhs_entourageE;</span><span class="gallina-kwd"> exists</span> (<span class="id">split_ent</span><span class="id"> E</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?</span><span class="id"> /xsectionP</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> M'</span><span class="id"> _</span><span class="id"> Mcov;</span><span class="gallina-kwd"> exists</span><br/>
&nbsp;&nbsp;((<span class="id">closure</span><span class="id"> \o</span><span class="id"> fs</span>)<span class="id"> @`</span><span class="id"> [set`</span><span class="id"> M']</span><span class="id"> `|`</span><span class="id"> [set</span><span class="id"> [set</span><span class="id"> t0];</span><span class="id"> [set</span><span class="id"> t1]]</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> _;</span><span class="id"> split=&gt;</span><span class="id"> [|A</span><span class="id"> [|]|</span><span class="id"> |</span><span class="id"> |]</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> finite_setU;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact/finite_image/finite_fset</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> finite_set2</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> [z</span><span class="id"> M'z]</span><span class="id"> &lt;-;</span><span class="gallina-kwd"> exists</span><span class="id"> z;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> apply:</span><span class="id"> subset_closure;</span><span class="id"> apply:</span><span class="id"> nbhs_singleton;</span><span class="id"> apply:</span><span class="id"> nbhs_interior</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -nbhs_entourageE;</span><span class="gallina-kwd"> exists</span> (<span class="id">split_ent</span><span class="id"> E</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> t</span><span class="id"> /xsectionP</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> closure_subset;</span><span class="id"> exact:</span><span class="id"> interior_subset</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> case</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> [exists</span><span class="id"> t0</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> t1];</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> t</span><span class="id"> -&gt;;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/subset_closure/xsectionP;</span><span class="id"> exact:</span><span class="id"> entourage_refl</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> exists</span><span class="id"> [set</span><span class="id"> t0],</span><span class="id"> [set</span><span class="id"> t1];</span><span class="id"> split;[|split]</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> right;</span><span class="id"> left</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> right;</span><span class="id"> right</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> =&gt;</span><span class="id"> -[]</span><span class="id"> /</span>(_<span class="id"> t0</span><span class="id"> erefl</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> T2e</span><span class="id"> =&gt;</span><span class="id"> /[swap]</span><span class="id"> -&gt;</span><span class="id"> /eqP</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> -subTset</span><span class="id"> =&gt;</span><span class="id"> t</span><span class="id"> /Mcov</span><span class="id"> [t'</span><span class="id"> M't'</span><span class="id"> fsxt];</span><span class="gallina-kwd"> exists</span> (<span class="id">closure</span> (<span class="id">fs</span><span class="id"> t'</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> left;</span><span class="gallina-kwd"> exists</span><span class="id"> t'</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> subset_closure</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> [[?</span><span class="id"> ?]</span><span class="id"> &lt;-|];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> closed_closure</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [|]</span><span class="id"> -&gt;;</span><span class="id"> exact/accessible_closed_set1/hausdorff_accessible</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> ent_balls</span><span class="id"> E</span><span class="id"> :=</span><span class="id"> projT1</span> (<span class="id">cid</span> (<span class="id">ent_balls'</span><span class="id"> E</span>)).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> count_unif'</span><span class="id"> :=</span><span class="id"> cid2</span><br/>
&nbsp;&nbsp;((<span class="id">iffLR</span><span class="id"> countable_uniformityP</span>) (<span class="id">@countable_uniformity_metric</span><span class="id"> _</span><span class="id"> T</span>)).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> count_unif</span><span class="id"> :=</span><span class="id"> projT1</span><span class="id"> count_unif'</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> ent_count_unif</span><span class="id"> n</span><span class="id"> :</span><span class="id"> entourage</span> (<span class="id">count_unif</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> :=</span><span class="id"> projT2</span> (<span class="id">cid</span> (<span class="id">ent_balls'</span> (<span class="id">count_unif</span><span class="id"> n</span>))).<br/>
<span class="id">rewrite</span><span class="id"> /count_unif;</span><span class="id"> case:</span><span class="id"> count_unif'</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /=</span><span class="id"> f</span><span class="id"> fnA</span><span class="id"> fnE;</span><span class="id"> case</span><span class="id"> /</span>(_ (<span class="id">fnE</span><span class="id"> _</span>))<span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> +</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -subTset</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> count_unif_sub</span><span class="id"> E</span><span class="id"> :</span><span class="id"> entourage</span><span class="id"> E</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> N,</span><span class="id"> count_unif</span><span class="id"> N</span><span class="id"> `&lt;=`</span><span class="id"> E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> entE;</span><span class="id"> rewrite</span><span class="id"> /count_unif;</span><span class="id"> case:</span><span class="id"> count_unif'</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> +</span><span class="id"> ?</span><span class="id"> /=;</span><span class="id"> exact</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> K'</span><span class="id"> n</span><span class="id"> :</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><span class="id"> @sigT</span> (<span class="id">set</span><span class="id"> T</span>) (<span class="id">ent_balls</span> (<span class="id">count_unif</span><span class="id"> n</span>)).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> K'p</span><span class="id"> n</span><span class="id"> :</span><span class="id"> K'</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> cid;</span><span class="id"> have</span><span class="id"> [//|</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> +</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> projT2</span> (<span class="id">cid</span> (<span class="id">ent_balls'</span> (<span class="id">count_unif</span><span class="id"> n</span>))).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -subTset</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> point</span><span class="id"> I</span>)<span class="id"> [W</span><span class="id"> Q</span><span class="id"> ?];</span><span class="gallina-kwd"> exists</span><span class="id"> W;</span><span class="id"> exact:</span><span class="id"> Q</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> gen_eqMixin</span> (<span class="id">K'</span><span class="id"> n</span>).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> gen_choiceMixin</span> (<span class="id">K'</span><span class="id"> n</span>).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> isPointed</span>.<span class="id">Build</span> (<span class="id">K'</span><span class="id"> n</span>) (<span class="id">K'p</span><span class="id"> n</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> K</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> K'</span><span class="id"> n</span>.<br/>
<span class="vernacular">Let</span><span class="id"> Tree</span><span class="id"> :=</span><span class="id"> @tree_of</span><span class="id"> K</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> embed_refine</span><span class="id"> n</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">k</span><span class="id"> :</span><span class="id"> K</span><span class="id"> n</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">if</span><span class="id"> pselect</span> (<span class="id">projT1</span><span class="id"> k</span><span class="id"> `&amp;`</span><span class="id"> U</span><span class="id"> !=set0</span>)<br/>
&nbsp;&nbsp;<span class="gallina-kwd">then</span><span class="id"> projT1</span><span class="id"> k</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="gallina-kwd"> if</span><span class="id"> pselect</span> (<span class="gallina-kwd">exists</span><span class="id"> e</span><span class="id"> :</span><span class="id"> K</span><span class="id"> n</span><span class="id"> ,</span><span class="id"> projT1</span><span class="id"> e</span><span class="id"> `&amp;`</span><span class="id"> U</span><span class="id"> !=set0</span>)<span class="id"> is</span><span class="id"> left</span><span class="id"> e</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">then</span><span class="id"> projT1</span> (<span class="id">projT1</span> (<span class="id">cid</span><span class="id"> e</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="id"> set0</span>)<span class="id"> `&amp;`</span><span class="id"> U</span>.<br/>
<span class="vernacular">Let</span><span class="id"> embed_invar</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><span class="id"> closed</span><span class="id"> U</span><span class="id"> /\</span><span class="id"> U</span><span class="id"> !=set0</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> Kn_closed</span><span class="id"> n</span> (<span class="id">e</span><span class="id"> :</span><span class="id"> K</span><span class="id"> n</span>)<span class="id"> :</span><span class="id"> closed</span> (<span class="id">projT1</span><span class="id"> e</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case:</span><span class="id"> e</span><span class="id"> =&gt;</span><span class="id"> W;</span><span class="id"> have</span><span class="id"> [//|</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> projT2</span> (<span class="id">cid</span> (<span class="id">ent_balls'</span> (<span class="id">count_unif</span><span class="id"> n</span>))).<br/>
<span class="id">exact</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> discrete_subproof</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">discrete_space</span> (<span class="id">principal_filter_type</span><span class="id"> P</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> cantor_surj_pt1</span><span class="id"> :</span><span class="gallina-kwd"> exists2</span><span class="id"> f</span><span class="id"> :</span><span class="id"> Tree</span><span class="id"> -&gt;</span><span class="id"> T,</span><br/>
&nbsp;&nbsp;<span class="id">continuous</span><span class="id"> f</span><span class="id"> &amp;</span><span class="id"> set_surj</span><span class="id"> [set:</span><span class="id"> Tree]</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> entn</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> projT2</span> (<span class="id">cid</span> (<span class="id">ent_balls'</span> (<span class="id">count_unif</span><span class="id"> n</span>))).<br/>
<span class="id">have</span><span class="id"> [//|</span><span class="id"> |</span><span class="id"> |?</span><span class="id"> []//|</span><span class="id"> |?</span><span class="id"> []//</span><span class="id"> |</span><span class="id"> |]</span><span class="id"> :=</span><span class="id"> @tree_map_props</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">discrete_topology_type</span><span class="id"> \o</span><span class="id"> K</span>)<span class="id"> T</span> (<span class="id">embed_refine</span>) (<span class="id">embed_invar</span>)<span class="id"> cptT</span><span class="id"> hsdfT</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> exact:</span><span class="id"> discrete_space_discrete</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> U;</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split=&gt;</span><span class="id"> [t</span><span class="id"> Ut|t</span><span class="id"> [?</span><span class="id"> ?</span><span class="id"> []]//]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [//|_</span><span class="id"> _</span><span class="id"> _</span><span class="id"> +</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> entn</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> -subTset</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /</span>(_<span class="id"> t</span><span class="id"> I</span>)<span class="id">[W</span><span class="id"> cbW</span><span class="id"> Wt];</span><span class="gallina-kwd"> exists</span> (<span class="id">existT</span><span class="id"> _</span><span class="id"> W</span><span class="id"> cbW</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /embed_refine;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> apply:</span><span class="id"> absurd;</span><span class="gallina-kwd"> exists</span><span class="id"> t</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> U</span><span class="id"> e</span><span class="id"> [clU</span><span class="id"> Un0];</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> closedI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> ?</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> [exact:</span><span class="id"> Kn_closed|exact:</span><span class="id"> closed0]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /embed_refine;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> ?;</span><span class="id"> case:</span><span class="id"> pselect</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> i</span><span class="id"> [z</span><span class="id"> [pz</span><span class="id"> bz]];</span><span class="id"> set</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> cid</span><span class="id"> _;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> projT2</span><span class="id"> P;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> Un0</span><span class="id"> =&gt;</span><span class="id"> z</span><span class="id"> Uz;</span><span class="id"> apply:</span><span class="id"> absurd</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [//|_</span><span class="id"> _</span><span class="id"> _</span><span class="id"> +</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> entn</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> -subTset;</span><span class="id"> move=&gt;</span><span class="id"> /</span>(_<span class="id"> z</span><span class="id"> I</span>)<span class="id">[i</span><span class="id"> bi</span><span class="id"> iz]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">existT</span><span class="id"> _</span><span class="id"> _</span><span class="id"> bi</span>)<span class="id">,</span><span class="id"> z</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> split;</span><span class="id"> [exact:</span><span class="id"> closedT</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> point]</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> xny;</span><span class="id"> move:</span><span class="id"> hsdfT;</span><span class="id"> rewrite</span><span class="id"> open_hausdorff</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> _</span><span class="id"> xny</span>)<span class="id">[[U</span><span class="id"> V]]</span><span class="id"> /=</span><span class="id"> [/set_mem</span><span class="id"> Ux</span><span class="id"> /set_mem</span><span class="id"> Vy]</span><span class="id"> [+</span><span class="id"> oV</span><span class="id"> UVI0]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> openE</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> Ux</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> /interior</span><span class="id"> -nbhs_entourageE</span><span class="id"> =&gt;</span><span class="id"> -[E</span><span class="id"> entE</span><span class="id"> ExU]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [//|</span><span class="id"> n</span><span class="id"> ctE]</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">@count_unif_sub</span> (<span class="id">split_ent</span><span class="id"> E</span><span class="id"> `&amp;`</span> (<span class="id">split_ent</span><span class="id"> E</span>)<span class="id">^-1%relation</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> filterI</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> B</span><span class="id"> [C</span><span class="id"> ebC];</span><span class="id"> have</span><span class="id"> [//|_</span><span class="id"> Csub</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> embx</span><span class="id"> emby]</span><span class="id"> :=</span><span class="id"> entn</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [[D</span><span class="id"> cbD]</span><span class="id"> /=</span><span class="id"> Dx</span><span class="id"> Dy]</span><span class="id"> :</span><span class="gallina-kwd"> exists2</span><span class="id"> e</span><span class="id"> :</span><span class="id"> K</span><span class="id"> n,</span><span class="id"> projT1</span><span class="id"> e</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> projT1</span><span class="id"> e</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move:</span><span class="id"> embx</span><span class="id"> emby;</span><span class="id"> rewrite</span><span class="id"> /embed_refine;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> [?</span><span class="id"> ?]</span><span class="id"> [?</span><span class="id"> ?];</span><span class="gallina-kwd"> exists</span> (<span class="id">existT</span><span class="id"> _</span><span class="id"> _</span><span class="id"> ebC</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case:</span><span class="id"> pselect;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> []</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> e</span><span class="id"> _</span><span class="id"> [?</span><span class="id"> ?]</span><span class="id"> [?</span><span class="id"> ?];</span><span class="gallina-kwd"> exists</span> (<span class="id">projT1</span> (<span class="id">cid</span><span class="id"> e</span>)).<br/>
&nbsp;&nbsp;<span class="id">suff</span><span class="id"> :</span><span class="id"> E</span> (<span class="id">x,</span><span class="id"> y</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/xsectionP/ExU;</span><span class="id"> move/eqP/disjoints_subset:</span><span class="id"> UVI0</span><span class="id"> =&gt;</span><span class="id"> /[apply]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [z</span><span class="id"> [Dz</span><span class="id"> DzE]]</span><span class="id"> :=</span><span class="id"> Csub</span><span class="id"> _</span><span class="id"> cbD</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /ent_closure</span><span class="id"> :=</span><span class="id"> DzE</span><span class="id"> _</span><span class="id"> Dx</span><span class="id"> =&gt;</span><span class="id"> /</span>(_ (<span class="id">ent_count_unif</span><span class="id"> n</span>))<span class="id">/xsectionP/ctE</span><span class="id"> [_</span><span class="id"> /=</span><span class="id"> Exz]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /ent_closure</span><span class="id"> :=</span><span class="id"> DzE</span><span class="id"> _</span><span class="id"> Dy</span><span class="id"> =&gt;</span><span class="id"> /</span>(_ (<span class="id">ent_count_unif</span><span class="id"> n</span>))<span class="id">/xsectionP/ctE</span><span class="id"> [Ezy</span><span class="id"> _]</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">@entourage_split</span><span class="id"> _</span> <span class="comment">(*[the&nbsp;uniformType&nbsp;of&nbsp;T]*)</span><span class="id"> z</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> f</span><span class="id"> [ctsf</span><span class="id"> surjf</span><span class="id"> _];</span><span class="gallina-kwd"> exists</span><span class="id"> f</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> cantor_surj_pt2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> f</span><span class="id"> :</span><span class="id"> {surj</span><span class="id"> [set:</span><span class="id"> cantor_space]</span><span class="id"> &gt;-&gt;</span><span class="id"> [set:</span><span class="id"> Tree]},</span><span class="id"> continuous</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [|f</span><span class="id"> [ctsf</span><span class="id"> _]]</span><span class="id"> :=</span><span class="id"> @homeomorphism_cantor_like</span><span class="id"> R</span><span class="id"> Tree;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> f</span>.<br/>
<span class="id">apply:</span> (<span class="id">@cantor_like_finite_prod</span> (<span class="id">discrete_topology_type</span><span class="id"> \o</span><span class="id"> K</span>))<span class="id"> =&gt;</span><span class="id"> [n</span><span class="id"> /=|n]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [//|</span><span class="id"> fs</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> projT2</span> (<span class="id">cid</span> (<span class="id">ent_balls'</span> (<span class="id">count_unif</span><span class="id"> n</span>))).<br/>
&nbsp;&nbsp;<span class="id">suff</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> [set:</span><span class="id"> {classic</span><span class="id"> K'</span><span class="id"> n}]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">@projT1</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> _</span>)<span class="id"> @^-1`</span> (<span class="id">projT1</span> (<span class="id">cid</span> (<span class="id">ent_balls'</span> (<span class="id">count_unif</span><span class="id"> n</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> finite_preimage</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> eq_sigT_hprop</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[]</span>.<br/>
<span class="id">have</span><span class="id"> [//|</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [A</span><span class="id"> [B</span><span class="id"> [pA</span><span class="id"> [pB</span><span class="id"> AB]]]]</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">projT2</span> (<span class="id">cid</span> (<span class="id">ent_balls'</span> (<span class="id">count_unif</span><span class="id"> n</span>))).<br/>
<span class="gallina-kwd">exists</span> (<span class="id">existT</span><span class="id"> _</span><span class="id"> _</span><span class="id"> pA,</span><span class="id"> existT</span><span class="id"> _</span><span class="id"> _</span><span class="id"> pB</span>)<span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> AB;</span><span class="id"> apply:</span><span class="id"> contra_neq</span><span class="id"> =&gt;</span><span class="id"> -[]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> cantor_surj_twop</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> f</span><span class="id"> :</span><span class="id"> {surj</span><span class="id"> [set:</span><span class="id"> cantor_space]</span><span class="id"> &gt;-&gt;</span><span class="id"> [set:</span><span class="id"> T]},</span><span class="id"> continuous</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move:</span><span class="id"> cantor_surj_pt2</span><span class="id"> cantor_surj_pt1</span><span class="id"> =&gt;</span><span class="id"> -[f</span><span class="id"> ctsf]</span><span class="id"> [g</span><span class="id"> ctsg</span><span class="id"> /Psurj[sjg</span><span class="id"> gsjg]]</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> [surj</span><span class="id"> of</span><span class="id"> sjg</span><span class="id"> \o</span><span class="id"> f]</span><span class="id"> =&gt;</span><span class="id"> z</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply</span><span class="id"> continuous_comp;</span><span class="id"> [exact:</span><span class="id"> ctsf|rewrite</span><span class="id"> -gsjg;</span><span class="id"> exact:</span><span class="id"> ctsg]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> two_pointed</span>.<br/>
<br/>
<div class="doc">The Alexandroff-Hausdorff theorem </div>
<span class="vernacular">Theorem</span><span class="id"> cantor_surj</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> f</span><span class="id"> :</span><span class="id"> {surj</span><span class="id"> [set:</span><span class="id"> cantor_space]</span><span class="id"> &gt;-&gt;</span><span class="id"> [set:</span><span class="id"> T]},</span><span class="id"> continuous</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [[p</span><span class="id"> ppt]|/forallNP</span><span class="id"> xpt]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="gallina-kwd">exists</span><span class="id"> p</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> p</span><span class="id"> !=</span><span class="id"> point</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> cantor_surj_twop;</span><span class="id"> exact:</span><span class="id"> ppt</span>.<br/>
<span class="id">have</span><span class="id"> /Psurj[f</span><span class="id"> cstf]</span><span class="id"> :</span><span class="id"> set_surj</span><span class="id"> [set:</span><span class="id"> cantor_space]</span><span class="id"> [set:</span><span class="id"> T]</span> (<span class="id">cst</span><span class="id"> point</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> q</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span><span class="id"> point</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> have</span><span class="id"> /negP/negPn/eqP</span><span class="id"> -&gt;</span><span class="id"> :=</span><span class="id"> xpt</span><span class="id"> q</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> f;</span><span class="id"> rewrite</span><span class="id"> -cstf;</span><span class="id"> exact:</span><span class="id"> cst_continuous</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> alexandroff_hausdorff</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
