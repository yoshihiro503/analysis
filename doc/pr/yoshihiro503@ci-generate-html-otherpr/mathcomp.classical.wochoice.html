
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.classical.wochoice</title>
<meta name="description" content="Documentation of Coq module mathcomp.classical.wochoice" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.classical.wochoice</h1>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> ssreflect</span><span class="id"> ssrfun</span><span class="id"> ssrbool</span><span class="id"> eqtype</span><span class="id"> ssrnat</span><span class="id"> seq</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> boolp</span><span class="id"> contra</span>.<br/>
<br/>
<div class="ssrdoc md">
# Well-ordered choice

This file provides proofs of Zorn's lemma, Hausdorff maximal principle,
and the well-ordering principle. It does not rely on `classical_sets.v`.

NB: Some definitions are likely to move to MathComp. Similar definitions
can be found in `classical_sets.v` but expressed with `Prop` instead of
`bool` (in particular); there is likely to be more sharing in the future.

```
        nonempty A := exists x, x \in A
      {in &lt;= S, P} == the predicate P holds for all subsets of S
                      P has type {pred T} -&gt; Prop for T : predArgType.
       maximal R z == z is a maximal element for the relation R
       minimal R z == z is a minimal element for the relation R
 upper_bound R A z == for all x in A, we have R x z
 lower_bound R A z == for all x in A, we have R z x
        preorder R == R is reflexive and transitive
   partial_order R == R is an antisymmetric preorder
     total_order R == R is a total partial order
  minimum_of R A z := z \in A /\ lower_bound A z
  maximum_of R A z := z \in A /\ upper_bound A z
      well_order R == every non-empty subset has a unique minimum element
         chain R C == the subset C is totally ordered
                   := {in C &amp;, total R}
      wo_chain R C := {in &lt;= C, well_order R}
```

</div>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> nonempty</span><span class="id"> {T:</span><span class="id"> Type}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span>)<span class="id"> :=</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> A</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="vernacular"> LocalProperties</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T1</span><span class="id"> T2</span><span class="id"> T3</span><span class="id"> :</span><span class="id"> Type}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> predArgType}</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> A</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'allA' P }&quot;</span><span class="id"> :=</span> (<span class="gallina-kwd">forall</span><span class="id"> A</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T},</span><span class="id"> P</span><span class="id"> A</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> ph</span><span class="id"> :=</span> (<span class="id">phantom</span><span class="id"> _</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> prop_within</span><span class="id"> d</span><span class="id"> P</span><span class="id"> &amp;</span><span class="id"> ph</span><span class="id"> {allA</span><span class="id"> P}</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> sub_mem</span> (<span class="id">mem</span><span class="id"> A</span>)<span class="id"> d</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> A</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> withinW</span><span class="id"> A</span><span class="id"> P</span><span class="id"> :</span><span class="id"> {allA</span><span class="id"> P}</span><span class="id"> -&gt;</span><span class="id"> prop_within</span> (<span class="id">mem</span><span class="id"> A</span>) (<span class="id">inPhantom</span><span class="id"> {allA</span><span class="id"> P}</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> allP</span><span class="id"> ?</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> allP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> withinT</span><span class="id"> P</span><span class="id"> :</span><span class="id"> prop_within</span> (<span class="id">mem</span><span class="id"> T</span>) (<span class="id">inPhantom</span><span class="id"> {allA</span><span class="id"> P}</span>)<span class="id"> -&gt;</span><span class="id"> {allA</span><span class="id"> P}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> allP</span><span class="id"> A;</span><span class="id"> apply:</span><span class="id"> allP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_within</span><span class="id"> d</span><span class="id"> d'</span><span class="id"> P</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">sub_mem</span><span class="id"> d</span><span class="id"> d'</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> phP,</span><span class="id"> @prop_within</span><span class="id"> d'</span><span class="id"> P</span><span class="id"> phP</span><span class="id"> -&gt;</span><span class="id"> @prop_within</span><span class="id"> d</span><span class="id"> P</span><span class="id"> phP</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sdd'</span><span class="id"> phP</span><span class="id"> Pd'</span><span class="id"> A</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> _</span>)<span class="id">/sdd'-/Pd'</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="vernacular"> LocalProperties</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'in' &lt;= S , P }&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">prop_within</span> (<span class="id">mem</span><span class="id"> S</span>) (<span class="id">inPhantom</span><span class="id"> P</span>))<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> RelDefs</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> rel</span><span class="id"> T</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">A</span><span class="id"> C</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> maximal</span><span class="id"> z</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> R</span><span class="id"> z</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> x</span><span class="id"> z</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> minimal</span><span class="id"> z</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> R</span><span class="id"> x</span><span class="id"> z</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> z</span><span class="id"> x</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> upper_bound</span><span class="id"> A</span><span class="id"> z</span><span class="id"> :=</span><span class="id"> {in</span><span class="id"> A,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> R</span><span class="id"> x</span><span class="id"> z}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> lower_bound</span><span class="id"> A</span><span class="id"> z</span><span class="id"> :=</span><span class="id"> {in</span><span class="id"> A,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> R</span><span class="id"> z</span><span class="id"> x}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> preorder</span><span class="id"> :=</span><span class="id"> reflexive</span><span class="id"> R</span><span class="id"> /\</span><span class="id"> transitive</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> partial_order</span><span class="id"> :=</span><span class="id"> preorder</span><span class="id"> /\</span><span class="id"> antisymmetric</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> total_order</span><span class="id"> :=</span><span class="id"> partial_order</span><span class="id"> /\</span><span class="id"> total</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> minimum_of</span><span class="id"> A</span><span class="id"> z</span><span class="id"> :=</span><span class="id"> z</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> /\</span><span class="id"> lower_bound</span><span class="id"> A</span><span class="id"> z</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> maximum_of</span><span class="id"> A</span><span class="id"> z</span><span class="id"> :=</span><span class="id"> z</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> /\</span><span class="id"> upper_bound</span><span class="id"> A</span><span class="id"> z</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> well_order</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> nonempty</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> exists!</span><span class="id"> z,</span><span class="id"> minimum_of</span><span class="id"> A</span><span class="id"> z</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> chain</span><span class="id"> C</span><span class="id"> :=</span><span class="id"> {in</span><span class="id"> C</span><span class="id"> &amp;,</span><span class="id"> total</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> wo_chain</span><span class="id"> C</span><span class="id"> :=</span><span class="id"> {in</span><span class="id"> &lt;=</span><span class="id"> C,</span><span class="id"> well_order}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> antisymmetric_wo_chain</span><span class="id"> C</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{in</span><span class="id"> C</span><span class="id"> &amp;,</span><span class="id"> antisymmetric</span><span class="id"> R}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{in</span><span class="id"> &lt;=</span><span class="id"> C,</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> nonempty</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> z,</span><span class="id"> minimum_of</span><span class="id"> A</span><span class="id"> z}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">wo_chain</span><span class="id"> C</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Ranti</span><span class="id"> Rwo</span><span class="id"> A</span><span class="id"> sAC</span><span class="id"> /Rwo[//|z</span><span class="id"> [Az</span><span class="id"> lbAz]];</span><span class="gallina-kwd"> exists</span><span class="id"> z;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> [Ax</span><span class="id"> lbAx]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> Ranti;</span><span class="id"> rewrite</span><span class="id"> ?sAC</span><span class="id"> ?lbAx</span><span class="id"> ?lbAz</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> antisymmetric_well_order</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">antisymmetric</span><span class="id"> R</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> A,</span><span class="id"> nonempty</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> z,</span><span class="id"> minimum_of</span><span class="id"> A</span><span class="id"> z</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">well_order</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Ranti</span><span class="id"> /withinW/</span>(<span class="id">antisymmetric_wo_chain</span> (<span class="id">in2W</span><span class="id"> Ranti</span>))<span class="id">/withinT</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> RelDefs</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> wo_chainW</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>)<span class="id"> R</span><span class="id"> C</span><span class="id"> :</span><span class="id"> @wo_chain</span><span class="id"> T</span><span class="id"> R</span><span class="id"> C</span><span class="id"> -&gt;</span><span class="id"> chain</span><span class="id"> R</span><span class="id"> C</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> ne_cons</span><span class="id"> x</span><span class="id"> s:</span><span class="id"> nonempty</span><span class="id"> [mem</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T]</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> mem_head</span>.<br/>
<span class="id">have</span><span class="id"> all_mem</span><span class="id"> s:</span><span class="id"> all</span><span class="id"> [mem</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T]</span><span class="id"> s</span><span class="gallina-kwd"> by</span><span class="id"> apply/allP</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> Rwo</span><span class="id"> x</span><span class="id"> y</span><span class="id"> Cx</span><span class="id"> Cy;</span><span class="id"> have</span><span class="id"> /Rwo[]</span><span class="id"> :=</span><span class="id"> ne_cons</span><span class="id"> x</span><span class="id"> [::y];</span><span class="id"> first</span><span class="id"> exact/allP/and3P</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> z</span><span class="id"> []</span><span class="id"> []</span><span class="id"> /or3P[]</span><span class="id"> //</span><span class="id"> /eqP-&gt;</span><span class="id"> /allP/and3P[]</span><span class="id"> =&gt;</span><span class="id"> [_|]</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> ?orbT</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> wo_chain_reflexive</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>)<span class="id"> R</span><span class="id"> C</span><span class="id"> :</span><span class="id"> @wo_chain</span><span class="id"> T</span><span class="id"> R</span><span class="id"> C</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> C,</span><span class="id"> reflexive</span><span class="id"> R}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/wo_chainW</span><span class="id"> =&gt;</span><span class="id"> Rtotal</span><span class="id"> x</span><span class="id"> xC;</span><span class="id"> rewrite</span><span class="id"> -[R</span><span class="id"> x</span><span class="id"> x]orbb</span><span class="id"> Rtotal</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> wo_chain_antisymmetric</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>)<span class="id"> R</span><span class="id"> C</span><span class="id"> :</span><span class="id"> @wo_chain</span><span class="id"> T</span><span class="id"> R</span><span class="id"> C</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> C</span><span class="id"> &amp;,</span><span class="id"> antisymmetric</span><span class="id"> R}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> ne_cons</span><span class="id"> x</span><span class="id"> s:</span><span class="id"> nonempty</span><span class="id"> [mem</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T]</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> mem_head</span>.<br/>
<span class="id">have</span><span class="id"> all_mem</span><span class="id"> s:</span><span class="id"> all</span><span class="id"> [mem</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T]</span><span class="id"> s</span><span class="gallina-kwd"> by</span><span class="id"> apply/allP</span>.<br/>
<span class="id">move/[dup]/wo_chainW</span><span class="id"> =&gt;</span><span class="id"> Rtotal</span><span class="id"> /[dup]/wo_chain_reflexive</span><span class="id"> Rxx</span><span class="id"> Rwo</span><span class="id"> x</span><span class="id"> y</span><span class="id"> xC</span><span class="id"> yC</span>.<br/>
<span class="id">have</span><span class="id"> /Rwo[]</span><span class="id"> :=</span><span class="id"> ne_cons</span><span class="id"> x</span><span class="id"> [::y];</span><span class="id"> first</span><span class="id"> exact/allP/and3P</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> [_</span><span class="id"> Uz]</span><span class="id"> /andP[Rxy</span><span class="id"> Ryx];</span><span class="id"> have</span><span class="id"> /and3P[xy_x</span><span class="id"> xy_y</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> all_mem</span><span class="id"> [::</span><span class="id"> x;</span><span class="id"> y]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">Uz</span><span class="id"> x</span>)<span class="id"> ?</span>(<span class="id">Uz</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply/allP;</span><span class="id"> rewrite</span><span class="id"> /=</span> (<span class="id">Rxy,</span><span class="id"> Ryx</span>)<span class="id"> Rxx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> Zorn</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Zorn's_lemma</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> rel</span><span class="id"> T</span>) (<span class="id">S</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> S,</span><span class="id"> reflexive</span><span class="id"> R}</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> S</span><span class="id"> &amp;</span><span class="id"> &amp;,</span><span class="id"> transitive</span><span class="id"> R}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> &lt;=</span><span class="id"> S,</span><span class="gallina-kwd"> forall</span><span class="id"> C,</span><span class="id"> wo_chain</span><span class="id"> R</span><span class="id"> C</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists2</span><span class="id"> z,</span><span class="id"> z</span><span class="id"> \in</span><span class="id"> S</span><span class="id"> &amp;</span><span class="id"> upper_bound</span><span class="id"> R</span><span class="id"> C</span><span class="id"> z}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{z</span><span class="id"> :</span><span class="id"> T</span><span class="id"> |</span><span class="id"> z</span><span class="id"> \in</span><span class="id"> S</span><span class="id"> &amp;</span><span class="id"> {in</span><span class="id"> S,</span><span class="id"> maximal</span><span class="id"> R</span><span class="id"> z}}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">suffices{T</span><span class="id"> R</span><span class="id"> S}</span><span class="id"> Zorn</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> rel</span><span class="id"> T</span>) (<span class="id">Well</span><span class="id"> :=</span><span class="id"> wo_chain</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">preorder</span><span class="id"> R</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> C,</span><span class="id"> Well</span><span class="id"> C</span><span class="id"> -&gt;</span><span class="id"> {z</span><span class="id"> |</span><span class="id"> upper_bound</span><span class="id"> R</span><span class="id"> C</span><span class="id"> z}</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{z</span><span class="id"> |</span><span class="id"> maximal</span><span class="id"> R</span><span class="id"> z}</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> Rxx</span><span class="id"> Rtr</span><span class="id"> UBch;</span><span class="id"> pose</span><span class="id"> T1</span><span class="id"> :=</span><span class="id"> {x</span><span class="id"> |</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> S}</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> S_T1</span> (<span class="id">u</span><span class="id"> :</span><span class="id"> T1</span>)<span class="id">:</span><span class="id"> val</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> S</span><span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> u</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [|C1</span><span class="id"> chC1|u</span><span class="id"> maxT1u]</span><span class="id"> :=</span><span class="id"> Zorn</span><span class="id"> T1</span> (<span class="id">relpre</span><span class="id"> val</span><span class="id"> R</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> 1</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span> (<span class="id">val</span><span class="id"> u</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> Sx</span><span class="id"> Rux;</span><span class="id"> apply:</span> (<span class="id">maxT1u</span> (<span class="id">Sub</span><span class="id"> x</span><span class="id"> Sx</span>)).<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> split=&gt;</span><span class="id"> [x|y</span><span class="id"> x</span><span class="id"> z];</span><span class="id"> [apply:</span><span class="id"> Rxx</span><span class="id"> |</span><span class="id"> apply:</span><span class="id"> Rtr]</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> C</span><span class="id"> :=</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> oapp</span> (<span class="id">mem</span><span class="id"> C1</span>)<span class="id"> false</span> (<span class="id">insub</span><span class="id"> x</span>)<span class="id">]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sC1C</span><span class="id"> u:</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> C1</span><span class="id"> -&gt;</span><span class="id"> val</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> C</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> valK</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> memC</span><span class="id"> x:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> C</span><span class="id"> -&gt;</span><span class="id"> {u</span><span class="id"> |</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> C1</span><span class="id"> &amp;</span><span class="id"> val</span><span class="id"> u</span><span class="id"> =</span><span class="id"> x}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> case:</span><span class="id"> insubP</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> u</span><span class="id"> _</span><span class="id"> &lt;-;</span><span class="gallina-kwd"> exists</span><span class="id"> u</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/cid;</span><span class="id"> suffices</span><span class="id"> /UBch[_</span><span class="id"> /memC[u</span><span class="id"> _</span><span class="id"> &lt;-]//|z</span><span class="id"> Sz</span><span class="id"> ubCz]:</span><span class="id"> wo_chain</span><span class="id"> R</span><span class="id"> C</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">Sub</span><span class="id"> z</span><span class="id"> Sz</span>)<span class="id"> =&gt;</span><span class="id"> u</span><span class="id"> C1u;</span><span class="id"> apply/ubCz/sC1C</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> sAC</span><span class="id"> [x0</span><span class="id"> Ax0]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [||w</span><span class="id"> [[C1w</span><span class="id"> minC1w]</span><span class="id"> Uw]]</span><span class="id"> :=</span><span class="id"> chC1</span><span class="id"> [preim</span><span class="id"> val</span><span class="id"> of</span><span class="id"> A]</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> v</span><span class="id"> /sAC;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> valK</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> /sAC/memC[u0</span><span class="id"> C1u0</span><span class="id"> Du0]</span><span class="id"> :=</span><span class="id"> Ax0;</span><span class="gallina-kwd"> exists</span><span class="id"> u0;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> Du0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">val</span><span class="id"> w</span>)<span class="id">;</span><span class="id"> do</span><span class="id"> ?[split]</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> [y</span><span class="id"> Ay</span><span class="id"> |</span><span class="id"> y</span><span class="id"> [Ay</span><span class="id"> minAy]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/sAC/memC:</span><span class="id"> Ay</span> (<span class="id">Ay</span>)<span class="id"> =&gt;</span><span class="id"> v</span><span class="id"> C1v</span><span class="id"> &lt;-;</span><span class="id"> apply:</span><span class="id"> minC1w</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /sAC/memC[v</span><span class="id"> C1v</span><span class="id"> Dv]</span><span class="id"> :=</span><span class="id"> Ay;</span><span class="id"> rewrite</span> (<span class="id">Uw</span><span class="id"> v</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> [|u</span><span class="id"> Au];</span><span class="id"> rewrite</span><span class="id"> ?inE</span><span class="id"> /=</span><span class="id"> Dv</span><span class="id"> //</span><span class="id"> minAy</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> Rxx</span><span class="id"> Rtr</span><span class="id"> UBch;</span><span class="id"> absurd_not=&gt;</span><span class="id"> nomaxR</span>.<br/>
<span class="id">pose</span><span class="id"> R'</span><span class="id"> :=</span><span class="id"> [rel</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> R</span><span class="id"> x</span><span class="id"> y</span><span class="id"> &amp;&amp;</span><span class="id"> ~~</span><span class="id"> R</span><span class="id"> y</span><span class="id"> x]</span>.<br/>
<span class="id">have{nomaxR}</span><span class="id"> /all_sig[f</span><span class="id"> fP]</span><span class="id"> C:</span><span class="id"> {z</span><span class="id"> |</span><span class="id"> Well</span><span class="id"> C</span><span class="id"> -&gt;</span><span class="id"> upper_bound</span><span class="id"> R'</span><span class="id"> C</span><span class="id"> z}</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /UBch[z0</span><span class="id"> _]:</span><span class="id"> Well</span><span class="id"> pred0</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> sA0</span><span class="id"> [x</span><span class="id"> /sA0]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [/UBch[y</span><span class="id"> RCy]|]</span><span class="id"> :=</span><span class="id"> asboolP</span> (<span class="id">Well</span><span class="id"> C</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> z0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [z</span><span class="id"> Ryz</span><span class="id"> notRzy]</span><span class="id"> :=</span><span class="id"> nomaxR</span><span class="id"> y;</span><span class="gallina-kwd"> exists</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> x</span><span class="id"> /RCy-Rxy</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">Rtr</span><span class="id"> y</span>)<span class="id"> //=;</span><span class="id"> contra:</span><span class="id"> notRzy</span><span class="id"> =&gt;</span><span class="id"> /Rtr-&gt;</span>.<br/>
<span class="id">have</span><span class="id"> notCf</span><span class="id"> C:</span><span class="id"> Well</span><span class="id"> C</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> C</span><span class="id"> \notin</span><span class="id"> C</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/fP=&gt;</span><span class="id"> R'Cf;</span><span class="id"> apply/negP=&gt;</span><span class="id"> /R'Cf/=;</span><span class="id"> rewrite</span><span class="id"> Rxx</span><span class="id"> ?andbF</span>.<br/>
<span class="id">pose</span><span class="id"> f_ind</span><span class="id"> X</span><span class="id"> :=</span><span class="id"> Well</span><span class="id"> X</span><span class="id"> /\</span><span class="id"> {in</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> f</span><span class="id"> [pred</span><span class="id"> y</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> |</span><span class="id"> ~~</span><span class="id"> R</span><span class="id"> x</span><span class="id"> y]</span><span class="id"> =</span><span class="id"> x}</span>.<br/>
<span class="id">pose</span><span class="id"> init_seg</span> (<span class="id">X</span><span class="id"> Y</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{subset</span><span class="id"> X</span><span class="id"> &lt;=</span><span class="id"> Y}</span><span class="id"> /\</span><span class="id"> {in</span><span class="id"> Y,</span><span class="gallina-kwd"> forall</span><span class="id"> y,</span><span class="id"> y</span><span class="id"> \notin</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> upper_bound</span><span class="id"> R</span><span class="id"> X</span><span class="id"> y}</span>.<br/>
<span class="id">have</span><span class="id"> init_total</span><span class="id"> Y</span><span class="id"> Z:</span><span class="id"> f_ind</span><span class="id"> Y</span><span class="id"> -&gt;</span><span class="id"> f_ind</span><span class="id"> Z</span><span class="id"> -&gt;</span><span class="id"> {init_seg</span><span class="id"> Y</span><span class="id"> Z}</span><span class="id"> +</span><span class="id"> {init_seg</span><span class="id"> Z</span><span class="id"> Y}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> indY</span><span class="id"> indZ;</span><span class="id"> pose</span><span class="id"> iniYZ</span><span class="id"> X</span><span class="id"> :=</span><span class="id"> `[&lt;</span><span class="id"> init_seg</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> /\</span><span class="id"> init_seg</span><span class="id"> X</span><span class="id"> Z</span><span class="id"> &gt;]</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> I</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> `[&lt;</span><span class="gallina-kwd"> exists2</span><span class="id"> X,</span><span class="id"> X</span><span class="id"> \in</span><span class="id"> iniYZ</span><span class="id"> &amp;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> X</span><span class="id"> &gt;];</span><span class="id"> pose</span><span class="id"> I1</span><span class="id"> :=</span><span class="id"> [predU1</span><span class="id"> f</span><span class="id"> I</span><span class="id"> &amp;</span><span class="id"> I]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [iIY</span><span class="id"> iIZ]:</span><span class="id"> init_seg</span><span class="id"> I</span><span class="id"> Y</span><span class="id"> /\</span><span class="id"> init_seg</span><span class="id"> I</span><span class="id"> Z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">split;</span><span class="id"> split=&gt;</span><span class="id"> [x</span><span class="id"> /asboolP[X</span><span class="id"> /asboolP[[sXY</span><span class="id"> _]</span><span class="id"> [sXZ</span><span class="id"> _]]]|];</span><span class="id"> try</span><span class="gallina-kwd"> by</span><span class="id"> move:</span> (<span class="id">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> y</span><span class="id"> Yy</span><span class="id"> /asboolP-I'y</span><span class="id"> x</span><span class="id"> /asboolP[X</span><span class="id"> iXYZ</span><span class="id"> Xx];</span><span class="id"> have</span><span class="id"> /asboolP[[_</span><span class="id"> RXY]</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> iXYZ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> RXY</span><span class="id"> //;</span><span class="id"> contra:</span><span class="id"> I'y;</span><span class="gallina-kwd"> exists</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> Zz</span><span class="id"> /asboolP-I'z</span><span class="id"> x</span><span class="id"> /asboolP[X</span><span class="id"> iXYZ</span><span class="id"> Xx];</span><span class="id"> have</span><span class="id"> /asboolP[_</span><span class="id"> [_</span><span class="id"> RXZ]]</span><span class="id"> :=</span><span class="id"> iXYZ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> RXZ</span><span class="id"> //;</span><span class="id"> contra:</span><span class="id"> I'z;</span><span class="gallina-kwd"> exists</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> maxI:</span><span class="id"> {in</span><span class="id"> iniYZ,</span><span class="gallina-kwd"> forall</span><span class="id"> X,</span><span class="id"> {subset</span><span class="id"> X</span><span class="id"> &lt;=</span><span class="id"> I}};</span><span class="id"> last</span><span class="id"> clearbody</span><span class="id"> I</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> sXYZ</span><span class="id"> x</span><span class="id"> Xx;</span><span class="id"> apply/asboolP;</span><span class="gallina-kwd"> exists</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Ich:</span><span class="id"> Well</span><span class="id"> I</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> [Ych</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> indY;</span><span class="id"> apply:</span><span class="id"> sub_within</span><span class="id"> Ych;</span><span class="id"> case:</span><span class="id"> iIY</span>.<br/>
&nbsp;&nbsp;<span class="id">generally</span><span class="id"> have</span><span class="id"> iI1,</span><span class="id"> iI1Y:</span><span class="id"> Y</span><span class="id"> indY</span><span class="id"> iIY</span><span class="id"> {iniYZ</span><span class="id"> maxI}</span><span class="id"> /</span><span class="id"> {I</span><span class="id"> =</span><span class="id"> Y}</span><span class="id"> +</span><span class="id"> {init_seg</span><span class="id"> I1</span><span class="id"> Y}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [[Ych</span><span class="id"> fY]</span><span class="id"> [sIY</span><span class="id"> RIY]]</span><span class="id"> :=</span> (<span class="id">indY,</span><span class="id"> iIY</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /wo_chain_antisymmetric</span><span class="id"> RYanti</span><span class="id"> :=</span><span class="id"> Ych</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [sYI</span><span class="id"> |</span><span class="id"> /notP-ltIY]</span><span class="id"> :=</span><span class="id"> asboolP</span><span class="id"> {subset</span><span class="id"> Y</span><span class="id"> &lt;=</span><span class="id"> I};</span><span class="id"> [left</span><span class="id"> |</span><span class="id"> right]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/funext=&gt;</span><span class="id"> y;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> [/sIY</span><span class="id"> |</span><span class="id"> /sYI]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have{ltIY}</span><span class="id"> /Ych[_</span><span class="id"> /andP[]//|</span><span class="id"> z</span><span class="id"> [[/andP/=[I'z</span><span class="id"> Yz]]]]:</span><span class="id"> nonempty</span><span class="id"> [predD</span><span class="id"> Y</span><span class="id"> &amp;</span><span class="id"> I]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [y]</span><span class="id"> :=</span><span class="id"> ltIY;</span><span class="gallina-kwd"> exists</span><span class="id"> y;</span><span class="id"> apply/andP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> minYz</span><span class="id"> _;</span><span class="id"> suffices</span><span class="id"> Dz:</span><span class="id"> f</span><span class="id"> I</span><span class="id"> =</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /I1</span><span class="id"> Dz;</span><span class="id"> do</span><span class="id"> 2?[split]</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> [x</span><span class="id"> /predU1P[-&gt;|/sIY]</span><span class="id"> //</span><span class="id"> |</span><span class="id"> y</span><span class="id"> Yy]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/norP=&gt;</span><span class="id"> /=</span><span class="id"> z'y</span><span class="id"> I'y</span><span class="id"> x</span><span class="id"> /predU1P[-&gt;|/RIY-&gt;//];</span><span class="id"> apply/minYz/andP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">fY</span><span class="id"> z</span><span class="id"> Yz</span>)<span class="id">;</span><span class="id"> congr</span><span class="id"> f;</span><span class="id"> apply/esym/funext=&gt;</span><span class="id"> x</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/idP/idP=&gt;</span><span class="id"> [/andP[Yx]</span><span class="id"> |</span><span class="id"> Ix];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> contra=&gt;</span><span class="id"> I'x;</span><span class="id"> apply/minYz/andP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> Yx</span><span class="id"> :=</span><span class="id"> sIY</span><span class="id"> x</span><span class="id"> Ix;</span><span class="id"> rewrite</span><span class="id"> Yx</span><span class="id"> /=;</span><span class="id"> contra:</span> (<span class="id">I'z</span>)<span class="id"> =&gt;</span><span class="id"> Rzx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">RYanti</span><span class="id"> z</span><span class="id"> x</span>)<span class="id"> //</span><span class="id"> Rzx</span><span class="id"> RIY</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> iI1Y</span><span class="id"> {iI1}</span>(<span class="id">iI1</span><span class="id"> Z</span>)<span class="id"> =&gt;</span><span class="id"> [&lt;-</span><span class="id"> _|</span><span class="id"> iI1Y</span><span class="id"> [||&lt;-|iI1Z]//];</span><span class="id"> [by</span><span class="id"> left</span><span class="id"> |</span><span class="gallina-kwd"> by</span><span class="id"> right</span><span class="id"> |]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/notCf/negP:</span><span class="id"> Ich;</span><span class="id"> apply/</span>(<span class="id">maxI</span><span class="id"> I1</span>)<span class="id">;</span><span class="id"> [apply/asboolP|apply/predU1l]</span>.<br/>
<span class="id">pose</span><span class="id"> U</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> `[&lt;</span><span class="gallina-kwd"> exists2</span><span class="id"> X,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> X</span><span class="id"> &amp;</span><span class="id"> f_ind</span><span class="id"> X</span><span class="id"> &gt;]</span>.<br/>
<span class="id">have</span><span class="id"> Umax</span><span class="id"> X:</span><span class="id"> f_ind</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> init_seg</span><span class="id"> X</span><span class="id"> U</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> indX;</span><span class="id"> split=&gt;</span><span class="id"> [x</span><span class="id"> Xx</span><span class="id"> |</span><span class="id"> y];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/asboolP;</span><span class="gallina-kwd"> exists</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="id">case/asboolP=&gt;</span><span class="id"> Y</span><span class="id"> Yy</span><span class="id"> indY</span><span class="id"> notXy</span><span class="id"> x</span><span class="id"> Xx</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [[sYX</span><span class="id"> _]|[_</span><span class="id"> -&gt;//]]</span><span class="id"> :=</span><span class="id"> init_total</span><span class="id"> Y</span><span class="id"> X</span><span class="id"> indY</span><span class="id"> indX;</span><span class="id"> rewrite</span><span class="id"> sYX</span><span class="gallina-kwd"> in</span><span class="id"> notXy</span>.<br/>
<span class="id">have</span><span class="id"> RUanti:</span><span class="id"> {in</span><span class="id"> U</span><span class="id"> &amp;,</span><span class="id"> antisymmetric</span><span class="id"> R}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /asboolP[X</span><span class="id"> Xx</span><span class="id"> indX]</span><span class="id"> /asboolP[Y</span><span class="id"> Yy</span><span class="id"> indY]</span>.<br/>
&nbsp;&nbsp;<span class="id">without</span><span class="id"> loss</span><span class="id"> [sXY</span><span class="id"> _]:</span><span class="id"> x</span><span class="id"> y</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> Xx</span><span class="id"> Yy</span><span class="id"> {indX}</span><span class="id"> indY</span><span class="id"> /</span><span class="id"> init_seg</span><span class="id"> X</span><span class="id"> Y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> IH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">init_total</span><span class="id"> X</span><span class="id"> Y</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> {}/IH-IH;</span><span class="id"> [|rewrite</span><span class="id"> andbC]</span><span class="id"> =&gt;</span><span class="id"> /IH-&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [/wo_chain_antisymmetric</span><span class="id"> RYanti</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> indY</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> RYanti</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> sXY</span>.<br/>
<span class="id">have</span><span class="id"> Uch:</span><span class="id"> Well</span><span class="id"> U</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> antisymmetric_wo_chain</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> A</span><span class="id"> sAU</span><span class="id"> [x0</span><span class="id"> Ax0]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /sAU/asboolP[X</span><span class="id"> Xx0</span><span class="id"> indX]</span><span class="id"> :=</span><span class="id"> Ax0</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> B</span><span class="id"> :=</span><span class="id"> [predI</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> X];</span><span class="id"> have</span><span class="id"> sBX:</span><span class="id"> {subset</span><span class="id"> B</span><span class="id"> &lt;=</span><span class="id"> X}</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> /andP[]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [[Xch</span><span class="id"> _]</span><span class="id"> /Umax[sXU</span><span class="id"> iXU]]</span><span class="id"> :=</span> (<span class="id">indX,</span><span class="id"> indX</span>).<br/>
&nbsp;&nbsp;<span class="id">have{x0</span><span class="id"> Ax0</span><span class="id"> Xx0}</span><span class="id"> /Xch[//|z</span><span class="id"> [[/andP[/=</span><span class="id"> Az</span><span class="id"> Xz]</span><span class="id"> minBz]</span><span class="id"> _]]:</span><span class="id"> nonempty</span><span class="id"> B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> x0;</span><span class="id"> apply/andP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> z;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> y</span><span class="id"> Ay;</span><span class="id"> have</span><span class="id"> Uy</span><span class="id"> :=</span><span class="id"> sAU</span><span class="id"> y</span><span class="id"> Ay</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [Xy</span><span class="id"> |</span><span class="id"> /iXU-&gt;//]</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> X</span>)<span class="id">;</span><span class="id"> apply/minBz/andP</span>.<br/>
<span class="id">pose</span><span class="id"> U1</span><span class="id"> :=</span><span class="id"> [predU1</span><span class="id"> f</span><span class="id"> U</span><span class="id"> &amp;</span><span class="id"> U];</span><span class="id"> have</span><span class="id"> notUfU:</span><span class="id"> f</span><span class="id"> U</span><span class="id"> \notin</span><span class="id"> U</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> notCf</span>.<br/>
<span class="id">suffices</span><span class="id"> indU1:</span><span class="id"> f_ind</span><span class="id"> U1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [sU1U</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> Umax</span><span class="id"> U1</span><span class="id"> indU1;</span><span class="id"> rewrite</span><span class="id"> sU1U</span><span class="id"> ?inE</span><span class="id"> ?eqxx</span><span class="gallina-kwd"> in</span><span class="id"> notUfU</span>.<br/>
<span class="id">have</span><span class="id"> RU1fU:</span><span class="id"> upper_bound</span><span class="id"> R</span><span class="id"> U1</span> (<span class="id">f</span><span class="id"> U</span>)<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> /predU1P[-&gt;</span><span class="id"> //</span><span class="id"> |</span><span class="id"> /fP/andP[]]</span> .<br/>
<span class="id">split=&gt;</span><span class="id"> [A</span><span class="id"> sAU1</span><span class="id"> neA</span><span class="id"> |</span><span class="id"> x</span><span class="id"> U1x]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [sAfU</span><span class="id"> |</span><span class="id"> {neA}/notP[x</span><span class="id"> Ax</span><span class="id"> fU'x]]</span><span class="id"> :=</span><span class="id"> asboolP</span><span class="id"> {subset</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> pred1</span> (<span class="id">f</span><span class="id"> U</span>)<span class="id">}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> AfU:</span><span class="id"> f</span><span class="id"> U</span><span class="id"> \in</span><span class="id"> A</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> [x</span><span class="id"> Ax]</span><span class="id"> :=</span><span class="id"> neA;</span><span class="id"> have</span><span class="id"> /sAfU/eqP&lt;-</span><span class="id"> :=</span><span class="id"> Ax</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">f</span><span class="id"> U</span>)<span class="id">;</span><span class="id"> split=&gt;</span><span class="id"> [|y</span><span class="id"> [/sAfU/eqP//]];</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> /sAfU/eqP-&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Ux:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> U</span><span class="gallina-kwd"> by</span><span class="id"> case/sAU1/orP:</span><span class="id"> Ax</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> /idPn</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> B</span><span class="id"> :=</span><span class="id"> [predI</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> U];</span><span class="id"> have</span><span class="id"> sBU:</span><span class="id"> {subset</span><span class="id"> B</span><span class="id"> &lt;=</span><span class="id"> U}</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> /andP[]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /Uch[//|z</span><span class="id"> [[/andP[/=</span><span class="id"> Az</span><span class="id"> Uz]</span><span class="id"> minBz]</span><span class="id"> _]]:</span><span class="id"> nonempty</span><span class="id"> B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> apply/andP</span>.<br/>
&nbsp;&nbsp;<span class="id">have{minBz}</span><span class="id"> minAz:</span><span class="id"> lower_bound</span><span class="id"> R</span><span class="id"> A</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> y</span><span class="id"> Ay;</span><span class="id"> case/sAU1/predU1P:</span> (<span class="id">Ay</span>)<span class="id"> =&gt;</span><span class="id"> [-&gt;|/=</span><span class="id"> Uy];</span><span class="id"> first</span><span class="id"> exact/RU1fU/sAU1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact/minBz/andP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> z;</span><span class="id"> do</span><span class="id"> ?[split]</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> y</span><span class="id"> [Ay</span><span class="id"> minAy]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /sAU1/predU1P[Dy|Uy]</span><span class="id"> :=</span><span class="id"> Ay;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> RUanti;</span><span class="id"> rewrite</span><span class="id"> ?minAz</span><span class="id"> ?minAy</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /andP[_]</span><span class="id"> :=</span><span class="id"> fP</span><span class="id"> U</span><span class="id"> Uch</span><span class="id"> z</span><span class="id"> Uz;</span><span class="id"> rewrite</span><span class="id"> -Dy</span><span class="id"> minAy</span>.<br/>
<span class="id">have</span><span class="id"> /predU1P[-&gt;</span><span class="id"> |</span><span class="id"> /asboolP[X</span><span class="id"> Xx</span><span class="id"> indX]]</span><span class="id"> :=</span><span class="id"> U1x</span>.<br/>
&nbsp;&nbsp;<span class="id">congr</span><span class="id"> f;</span><span class="id"> apply/funext=&gt;</span><span class="id"> y;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> [|Uy];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> unfold_in</span><span class="id"> -/</span>(<span class="id">U</span><span class="id"> y</span>)<span class="id"> Uy</span><span class="id"> orbT;</span><span class="id"> case/andP:</span> (<span class="id">fP</span><span class="id"> U</span><span class="id"> Uch</span><span class="id"> y</span><span class="id"> Uy</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/andP=&gt;</span><span class="id"> /predU1P[-&gt;|//];</span><span class="id"> rewrite</span><span class="id"> Rxx</span>.<br/>
<span class="id">have{indX}</span><span class="id"> [[_</span><span class="id"> f_indX]</span><span class="id"> /Umax[sXU</span><span class="id"> iXU]]</span><span class="id"> :=</span> (<span class="id">indX,</span><span class="id"> indX</span>).<br/>
<span class="id">rewrite</span><span class="id"> -[RHS]f_indX</span><span class="id"> //;</span><span class="id"> congr</span><span class="id"> f;</span><span class="id"> apply/funext=&gt;</span><span class="id"> y;</span><span class="id"> apply/andb_id2r=&gt;</span><span class="id"> notRyx</span>.<br/>
<span class="id">apply/idP/idP=&gt;</span><span class="id"> [U1y</span><span class="id"> |</span><span class="id"> Xy];</span><span class="id"> last</span><span class="id"> exact/predU1r/sXU</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> contra:</span><span class="id"> notRyx</span><span class="id"> =&gt;</span><span class="id"> notXy;</span><span class="id"> have</span><span class="id"> /predU1P[-&gt;|/iXU-&gt;]</span><span class="id"> :=</span><span class="id"> U1y;</span><span class="id"> first</span><span class="id"> apply/RU1fU</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Theorem</span><span class="id"> Hausdorff_maximal_principle</span><span class="id"> T</span><span class="id"> R</span> (<span class="id">S</span><span class="id"> C</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> S,</span><span class="id"> reflexive</span><span class="id"> R}</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> S</span><span class="id"> &amp;</span><span class="id"> &amp;,</span><span class="id"> transitive</span><span class="id"> R}</span><span class="id"> -&gt;</span><span class="id"> chain</span><span class="id"> R</span><span class="id"> C</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> C</span><span class="id"> &lt;=</span><span class="id"> S}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{M</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span><span class="id"> |</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> {subset</span><span class="id"> C</span><span class="id"> &lt;=</span><span class="id"> M},</span><span class="id"> {subset</span><span class="id"> M</span><span class="id"> &lt;=</span><span class="id"> S}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> forall</span><span class="id"> X,</span><span class="id"> chain</span><span class="id"> R</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> M</span><span class="id"> &lt;=</span><span class="id"> X}</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> X</span><span class="id"> &lt;=</span><span class="id"> S}</span><span class="id"> -&gt;</span><span class="id"> M</span><span class="id"> =</span><span class="id"> X]}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Rxx</span><span class="id"> Rtr</span><span class="id"> Cch</span><span class="id"> sCS</span>.<br/>
<span class="id">pose</span><span class="id"> CSch</span><span class="id"> X</span><span class="id"> :=</span><span class="id"> `[&lt;</span><span class="id"> [/\</span><span class="id"> chain</span><span class="id"> R</span><span class="id"> X,</span><span class="id"> {subset</span><span class="id"> C</span><span class="id"> &lt;=</span><span class="id"> X}</span><span class="id"> &amp;</span><span class="id"> {subset</span><span class="id"> X</span><span class="id"> &lt;=</span><span class="id"> S}]</span><span class="id"> &gt;]</span>.<br/>
<span class="id">pose</span><span class="id"> Rch</span> (<span class="id">X</span><span class="id"> Y</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span>)<span class="id"> :=</span><span class="id"> `[&lt;</span><span class="id"> {subset</span><span class="id"> X</span><span class="id"> &lt;=</span><span class="id"> Y}</span><span class="id"> &gt;]</span>.<br/>
<span class="id">have:</span><span class="id"> {in</span><span class="id"> CSch</span><span class="id"> &amp;</span><span class="id"> &amp;,</span><span class="id"> transitive</span><span class="id"> Rch}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> Z</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> /asboolP-sXY</span><span class="id"> /asboolP-sYZ;</span><span class="id"> apply/asboolP</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /sXY/sYZ</span>.<br/>
<span class="id">have</span><span class="id"> /Zorn's_lemma/[apply]:</span><span class="id"> {in</span><span class="id"> CSch,</span><span class="id"> reflexive</span><span class="id"> Rch}</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> _;</span><span class="id"> apply/asboolP</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> [XX</span><span class="id"> CSchXX</span><span class="id"> XXwo</span><span class="id"> |</span><span class="id"> M</span><span class="id"> /asboolP[Mch</span><span class="id"> sCM</span><span class="id"> sMS]</span><span class="id"> maxM];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> M;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> X</span><span class="id"> Xch</span><span class="id"> sMX</span><span class="id"> sXS</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> /asboolP-sXM:</span><span class="id"> Rch</span><span class="id"> X</span><span class="id"> M</span><span class="gallina-kwd"> by</span><span class="id"> apply/funext=&gt;</span><span class="id"> x;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> [/sMX|/sXM]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> maxM;</span><span class="id"> apply/asboolP=&gt;</span><span class="id"> //;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> /sCM/sMX</span>.<br/>
<span class="id">move/</span>(<span class="id">@wo_chainW</span><span class="id"> {pred</span><span class="id"> T}</span>)<span class="id">:</span><span class="id"> XXwo</span><span class="id"> =&gt;</span><span class="id"> XXch</span>.<br/>
<span class="id">without</span><span class="id"> loss</span><span class="id"> XX_C:</span><span class="id"> XX</span><span class="id"> CSchXX</span><span class="id"> XXch</span><span class="id"> /</span><span class="id"> C</span><span class="id"> \in</span><span class="id"> XX</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> CSchC:</span><span class="id"> C</span><span class="id"> \in</span><span class="id"> CSch</span><span class="gallina-kwd"> by</span><span class="id"> apply/asboolP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> RchC_CSch</span><span class="id"> X:</span><span class="id"> X</span><span class="id"> \in</span><span class="id"> CSch</span><span class="id"> -&gt;</span><span class="id"> Rch</span><span class="id"> C</span><span class="id"> X</span><span class="gallina-kwd"> by</span><span class="id"> case/asboolP=&gt;</span><span class="id"> _</span><span class="id"> sCX</span><span class="id"> _;</span><span class="id"> apply/asboolP</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> XX1</span><span class="id"> X</span><span class="id"> :=</span><span class="id"> `[&lt;</span><span class="id"> X</span><span class="id"> =</span><span class="id"> C</span><span class="id"> \/</span><span class="id"> X</span><span class="id"> \in</span><span class="id"> XX</span><span class="id"> &gt;]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> CSchXX1:</span><span class="id"> {subset</span><span class="id"> XX1</span><span class="id"> &lt;=</span><span class="id"> CSch}</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> /asboolP[-&gt;</span><span class="id"> |</span><span class="id"> /CSchXX]</span>.<br/>
&nbsp;&nbsp;<span class="id">case/</span>(_<span class="id"> XX1</span>)<span class="id">=&gt;</span><span class="id"> //</span><span class="id"> [||Z</span><span class="id"> CSchZ</span><span class="id"> ubZ];</span><span class="id"> first</span><span class="id"> 2</span><span class="id"> [by</span><span class="id"> apply/asboolP;</span><span class="id"> left]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> /asboolP[-&gt;</span><span class="id"> /CSchXX1/RchC_CSch-&gt;</span><span class="id"> //|</span><span class="id"> XX_X]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> orbC</span><span class="id"> =&gt;</span><span class="id"> /asboolP[-&gt;</span><span class="id"> |</span><span class="id"> /XXch-&gt;//];</span><span class="id"> rewrite</span><span class="id"> RchC_CSch</span><span class="id"> ?CSchXX</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> Z</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> X</span><span class="id"> XX_X;</span><span class="id"> apply/ubZ/asboolP;</span><span class="id"> right</span>.<br/>
<span class="id">pose</span><span class="id"> D</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> `[&lt;</span><span class="gallina-kwd"> exists2</span><span class="id"> X,</span><span class="id"> X</span><span class="id"> \in</span><span class="id"> XX</span><span class="id"> &amp;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> X</span><span class="id"> &gt;]</span>.<br/>
<span class="id">have</span><span class="id"> sCD:</span><span class="id"> {subset</span><span class="id"> C</span><span class="id"> &lt;=</span><span class="id"> D}</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> Cx;</span><span class="id"> apply/asboolP;</span><span class="gallina-kwd"> exists</span><span class="id"> C</span>.<br/>
<span class="id">have</span><span class="id"> sDS:</span><span class="id"> {subset</span><span class="id"> D</span><span class="id"> &lt;=</span><span class="id"> S}</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> /asboolP[X</span><span class="id"> /CSchXX/asboolP[_</span><span class="id"> _</span><span class="id"> sXS]</span><span class="id"> /sXS]</span>.<br/>
<span class="id">have</span><span class="id"> in2D:</span><span class="id"> {in</span><span class="id"> D</span><span class="id"> &amp;,</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> y,</span><span class="gallina-kwd"> exists</span><span class="id"> X,</span><span class="id"> [/\</span><span class="id"> X</span><span class="id"> \in</span><span class="id"> XX,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> X</span><span class="id"> &amp;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> X]}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /asboolP[X</span><span class="id"> XX_X</span><span class="id"> Xx]</span><span class="id"> /asboolP[Y</span><span class="id"> XX_Y</span><span class="id"> Yy];</span><span class="id"> have:=</span><span class="id"> XXch</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> XX_X</span><span class="id"> XX_Y</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/orP=&gt;</span><span class="id"> [/asboolP/</span>(_<span class="id"> x</span><span class="id"> Xx</span>)<span class="id">|/asboolP/</span>(_<span class="id"> y</span><span class="id"> Yy</span>)<span class="id">];</span><span class="id"> [exists</span><span class="id"> Y</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> X]</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> D</span><span class="id"> =&gt;</span><span class="id"> [|X</span><span class="id"> XX_X];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/asboolP=&gt;</span><span class="id"> x</span><span class="id"> Xx;</span><span class="id"> apply/asboolP;</span><span class="gallina-kwd"> exists</span><span class="id"> X</span>.<br/>
<span class="id">apply/asboolP;</span><span class="id"> split=&gt;</span><span class="id"> //</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> xD</span><span class="id"> /</span>(<span class="id">in2D</span><span class="id"> x</span>)<span class="id">-/</span>(_<span class="id"> xD</span>)<span class="id"> [X</span><span class="id"> [/CSchXX/asboolP[Xch</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> Xx</span><span class="id"> Xy]]</span>.<br/>
<span class="id">exact:</span><span class="id"> Xch</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Theorem</span><span class="id"> well_ordering_principle</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>)<span class="id"> :</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> rel</span><span class="id"> T</span><span class="id"> |</span><span class="id"> well_order</span><span class="id"> R}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have{T}</span><span class="id"> [T</span><span class="id"> -&gt;]:</span><span class="id"> {T1</span><span class="id"> :</span><span class="id"> eqType</span><span class="id"> |</span><span class="id"> T</span><span class="id"> =</span><span class="id"> T1}</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> T</span>.<br/>
<span class="id">pose</span><span class="id"> srel</span><span class="id"> :=</span><span class="id"> pred</span><span class="id"> T</span><span class="id"> *</span><span class="id"> rel</span><span class="id"> T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>.<br/>
<span class="id">pose</span><span class="id"> loc</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> srel</span>)<span class="id"> :=</span><span class="id"> [rel</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> [&amp;&amp;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> R</span>.<span class="id">1,</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> R</span>.<span class="id">1</span><span class="id"> &amp;</span><span class="id"> R</span>.<span class="id">2</span><span class="id"> x</span><span class="id"> y]]</span>.<br/>
<span class="id">pose</span><span class="id"> pwo</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> srel</span>)<span class="id"> :=</span><span class="id"> `[&lt;</span><span class="id"> wo_chain</span><span class="id"> R</span>.<span class="id">2</span><span class="id"> R</span>.<span class="id">1</span><span class="id"> &gt;]</span>.<br/>
<span class="id">pose</span><span class="id"> init_seg</span> (<span class="id">R</span><span class="id"> S</span><span class="id"> :</span><span class="id"> srel</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> R</span>.<span class="id">1</span><span class="id"> &amp;</span><span class="id"> S</span>.<span class="id">1,</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> S</span>.<span class="id">2</span><span class="id"> x</span><span class="id"> y</span><span class="id"> =</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> R</span>.<span class="id">1</span>)<span class="id"> ==&gt;</span><span class="id"> R</span>.<span class="id">2</span><span class="id"> x</span><span class="id"> y}</span>.<br/>
<span class="id">pose</span><span class="id"> initR</span><span class="id"> R</span><span class="id"> S</span><span class="id"> :=</span><span class="id"> `[&lt;</span><span class="id"> {subset</span><span class="id"> R</span>.<span class="id">1</span><span class="id"> &lt;=</span><span class="id"> S</span>.<span class="id">1}</span><span class="id"> /\</span><span class="id"> init_seg</span><span class="id"> R</span><span class="id"> S</span><span class="id"> &gt;]</span>.<br/>
<span class="id">have</span><span class="id"> initRR:</span><span class="id"> reflexive</span><span class="id"> initR</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> R;</span><span class="id"> apply/asboolP;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> y</span><span class="id"> _</span><span class="id"> -&gt;</span>.<br/>
<span class="id">have</span><span class="id"> initRtr:</span><span class="id"> transitive</span><span class="id"> initR</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> R2</span><span class="id"> R1</span><span class="id"> R3</span><span class="id"> /asboolP[D12</span><span class="id"> R12]</span><span class="id"> /asboolP[D23</span><span class="id"> R23];</span><span class="id"> apply/asboolP</span>.<br/>
&nbsp;&nbsp;<span class="id">split=&gt;</span><span class="id"> [x</span><span class="id"> /D12/D23//</span><span class="id"> |</span><span class="id"> x</span><span class="id"> y</span><span class="id"> D1x</span><span class="id"> D3y];</span><span class="id"> rewrite</span><span class="id"> R23</span><span class="id"> ?</span>(<span class="id">D12</span><span class="id"> x</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case</span><span class="id"> D2y:</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> R2</span>.<span class="id">1</span>)<span class="id">;</span><span class="id"> [apply:</span><span class="id"> R12</span><span class="id"> |</span><span class="id"> rewrite</span> (<span class="id">contraFF</span> (<span class="id">D12</span><span class="id"> y</span>))<span class="id">]</span>.<br/>
<span class="id">have:</span><span class="id"> {in</span><span class="id"> pwo</span><span class="id"> &amp;</span><span class="id"> &amp;,</span><span class="id"> transitive</span><span class="id"> initR}</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> Z</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> initRtr</span>.<br/>
<span class="id">have/Zorn's_lemma/[apply]:</span><span class="id"> {in</span><span class="id"> pwo,</span><span class="id"> reflexive</span><span class="id"> initR}</span><span class="gallina-kwd"> by</span><span class="id"> []</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> [C</span><span class="id"> pwoC</span><span class="id"> Cch</span><span class="id"> |</span><span class="id"> [D</span><span class="id"> R]</span><span class="id"> /asboolP/=pwoR</span><span class="id"> maxR]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /</span>(<span class="id">@wo_chainW</span> (<span class="id">{pred</span><span class="id"> T}</span><span class="id"> *</span><span class="id"> rel</span><span class="id"> T</span>)<span class="id">%type</span>)<span class="id"> {}Cch</span><span class="id"> :=</span><span class="id"> Cch</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> D</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> `[&lt;</span><span class="gallina-kwd"> exists2</span><span class="id"> S,</span><span class="id"> S</span><span class="id"> \in</span><span class="id"> C</span><span class="id"> &amp;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> S</span>.<span class="id">1</span><span class="id"> &gt;];</span><span class="id"> pose</span><span class="id"> R</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :=</span><span class="id"> `[&lt;</span><span class="gallina-kwd"> exists2</span><span class="id"> S,</span><span class="id"> S</span><span class="id"> \in</span><span class="id"> C</span><span class="id"> &amp;</span><span class="id"> loc</span><span class="id"> S</span><span class="id"> x</span><span class="id"> y</span><span class="id"> &gt;]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">D,</span><span class="id"> R</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/asboolP=&gt;</span><span class="id"> /=</span><span class="id"> X</span><span class="id"> sXD</span><span class="id"> [x</span><span class="id"> Xx];</span><span class="id"> have</span><span class="id"> /sXD/asboolP[R0</span><span class="id"> CR0</span><span class="id"> /=</span><span class="id"> D0x]</span><span class="id"> :=</span><span class="id"> Xx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /pwoC/asboolP/=R0wo</span><span class="id"> :=</span><span class="id"> CR0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have{x</span><span class="id"> Xx</span><span class="id"> D0x}:</span><span class="id"> nonempty</span><span class="id"> [predI</span><span class="id"> X</span><span class="id"> &amp;</span><span class="id"> R0</span>.<span class="id">1]</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> apply/andP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case/R0wo=&gt;</span><span class="id"> [_</span><span class="id"> /andP[]//</span><span class="id"> |z</span><span class="id"> [[/andP/=[Xz</span><span class="id"> D0z]</span><span class="id"> min0z]</span><span class="id"> _]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have{R0</span><span class="id"> CR0</span><span class="id"> R0wo</span><span class="id"> D0z</span><span class="id"> min0z}</span><span class="id"> minXz:</span><span class="id"> lower_bound</span><span class="id"> R</span><span class="id"> X</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> y</span><span class="id"> Xy;</span><span class="id"> have</span><span class="id"> /sXD/asboolP[R1</span><span class="id"> /=</span><span class="id"> CR1</span><span class="id"> D1y]</span><span class="id"> :=</span><span class="id"> Xy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /orP[/asboolP/=[D10</span><span class="id"> R10]</span><span class="id"> |</span><span class="id"> /asboolP/=[D01</span><span class="id"> R01]]</span><span class="id"> :=</span><span class="id"> Cch</span><span class="id"> _</span><span class="id"> _</span><span class="id"> CR1</span><span class="id"> CR0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/asboolP;</span><span class="gallina-kwd"> exists</span><span class="id"> R0;</span><span class="id"> rewrite</span><span class="id"> //=</span><span class="id"> D0z</span><span class="id"> min0z</span><span class="id"> ?inE</span><span class="id"> ?Xy</span><span class="id"> D10</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/asboolP;</span><span class="gallina-kwd"> exists</span><span class="id"> R1;</span><span class="id"> rewrite</span><span class="id"> //=</span><span class="id"> R01</span><span class="id"> ?D1y//</span><span class="id"> D01//=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/implyP=&gt;</span><span class="id"> D0y;</span><span class="id"> apply/min0z/andP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> z;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> y</span><span class="id"> [{}/minXz/asboolP[R0</span><span class="id"> CR0</span><span class="id"> R0zy]</span><span class="id"> minXy]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case/minXy/asboolP:</span><span class="id"> Xz</span><span class="id"> =&gt;</span><span class="id"> {minXy}</span><span class="id"> R1</span><span class="id"> CR1</span><span class="id"> R1yz</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">without</span><span class="id"> loss</span><span class="id"> /asboolP[D01</span><span class="id"> R01]:</span><span class="id"> y</span><span class="id"> z</span><span class="id"> R0</span><span class="id"> R1</span><span class="id"> CR0</span><span class="id"> CR1</span><span class="id"> R0zy</span><span class="id"> R1yz</span><span class="id"> /</span><span class="id"> initR</span><span class="id"> R0</span><span class="id"> R1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> IH;</span><span class="id"> have</span><span class="id"> /orP[/</span>(<span class="id">IH</span><span class="id"> y</span><span class="id"> z</span>)<span class="id">-&gt;</span><span class="id"> |</span><span class="id"> /</span>(<span class="id">IH</span><span class="id"> z</span><span class="id"> y</span>)<span class="id">-&gt;</span><span class="id"> ]</span><span class="id"> :=</span><span class="id"> Cch</span><span class="id"> _</span><span class="id"> _</span><span class="id"> CR0</span><span class="id"> CR1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have{R1yz</span><span class="id"> R0zy}</span><span class="id"> [/and3P[D1y</span><span class="id"> D1z</span><span class="id"> R1zy]</span><span class="id"> /and3P[D0z</span><span class="id"> D0y</span><span class="id"> R0yz]]</span><span class="id"> :=</span> (<span class="id">R1yz,</span><span class="id"> R0zy</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /pwoC/asboolP/wo_chain_antisymmetric</span><span class="id"> R1anti</span><span class="id"> :=</span><span class="id"> CR1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> R1anti</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> R1zy</span><span class="id"> R01</span><span class="id"> //</span><span class="id"> D0y</span><span class="id"> R0yz</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> R0</span><span class="id"> CR0;</span><span class="id"> apply/asboolP;</span><span class="id"> split=&gt;</span><span class="id"> [x</span><span class="id"> D0x|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/asboolP;</span><span class="gallina-kwd"> exists</span><span class="id"> R0</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> D0x</span><span class="id"> Dy;</span><span class="id"> apply/asboolP/idP=&gt;</span><span class="id"> [[R1</span><span class="id"> CR1</span><span class="id"> /and3P[D1x</span><span class="id"> D1y</span><span class="id"> R1xy]]</span><span class="id"> |</span><span class="id"> R0xy]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /orP[/asboolP[_</span><span class="id"> R10]</span><span class="id"> |</span><span class="id"> /asboolP[_</span><span class="id"> &lt;-</span><span class="id"> //]]</span><span class="id"> :=</span><span class="id"> Cch</span><span class="id"> _</span><span class="id"> _</span><span class="id"> CR1</span><span class="id"> CR0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/implyP=&gt;</span><span class="id"> D0y;</span><span class="id"> rewrite</span><span class="id"> R10</span><span class="id"> //</span><span class="id"> D1y</span><span class="id"> R1xy</span>.<br/>
&nbsp;&nbsp;<span class="id">case/asboolP:</span><span class="id"> Dy</span><span class="id"> =&gt;</span><span class="id"> R1</span><span class="id"> CR1</span><span class="id"> D1y</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /orP[/asboolP[D10</span><span class="id"> _]</span><span class="id"> |</span><span class="id"> /asboolP[D01</span><span class="id"> R01]]</span><span class="id"> :=</span><span class="id"> Cch</span><span class="id"> _</span><span class="id"> _</span><span class="id"> CR1</span><span class="id"> CR0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> R0;</span><span class="id"> rewrite</span><span class="id"> //=</span><span class="id"> D0x</span> (<span class="id">implyP</span><span class="id"> R0xy</span>)<span class="id"> D10</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> R1;</span><span class="id"> rewrite</span><span class="id"> //=</span><span class="id"> D1y</span><span class="id"> D01</span><span class="id"> ?R01</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> R;</span><span class="id"> apply:</span><span class="id"> withinT;</span><span class="id"> apply:</span><span class="id"> sub_within</span> (<span class="id">pwoR</span>)<span class="id"> =&gt;</span><span class="id"> z</span><span class="id"> _;</span><span class="id"> assume_not=&gt;</span><span class="id"> notDz</span>.<br/>
<span class="id">pose</span><span class="id"> Rz</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> predU1</span><span class="id"> z</span> (<span class="gallina-kwd">if</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> D</span><span class="gallina-kwd"> then</span><span class="id"> R</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> pred0</span>).<br/>
<span class="id">have</span><span class="id"> /maxR/</span>(_<span class="id"> _</span>)<span class="id">/asboolP:</span> (<span class="id">[predU1</span><span class="id"> z</span><span class="id"> &amp;</span><span class="id"> D]</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T,</span><span class="id"> Rz</span><span class="id"> :</span><span class="id"> rel</span><span class="id"> T</span>)<span class="id"> \in</span><span class="id"> pwo</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/asboolP=&gt;</span><span class="id"> X</span><span class="id"> sXxD</span><span class="id"> neX;</span><span class="id"> pose</span><span class="id"> XD</span><span class="id"> :=</span><span class="id"> [predI</span><span class="id"> X</span><span class="id"> &amp;</span><span class="id"> D]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [{neX}/pwoR[_</span><span class="id"> /andP[]//|x]</span><span class="id"> |</span><span class="id"> sXz]</span><span class="id"> :=</span><span class="id"> asboolP</span> (<span class="id">nonempty</span><span class="id"> XD</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> {}sXz</span><span class="id"> x:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> =</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> Xx;</span><span class="id"> case/sXxD/predU1P:</span> (<span class="id">Xx</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> Dx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> sXz;</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> apply/andP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [x</span><span class="id"> Xx]</span><span class="id"> :=</span><span class="id"> neX;</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> have</span><span class="id"> /sXz-eq_xz</span><span class="id"> :=</span><span class="id"> Xx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> [|_</span><span class="id"> [/sXz-&gt;</span><span class="id"> //]];</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> /sXz-&gt;;</span><span class="id"> apply/predU1l</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> -[/andP/=[Xx</span><span class="id"> Dx]</span><span class="id"> minXDx]</span><span class="id"> Ux;</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> split=&gt;</span><span class="id"> [|y</span><span class="id"> [Xy</span><span class="id"> minXy]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">split=&gt;</span><span class="id"> //</span><span class="id"> y</span><span class="id"> Xy;</span><span class="id"> have</span><span class="id"> /sXxD/predU1P[-&gt;</span><span class="id"> |</span><span class="id"> Dy]</span><span class="id"> :=</span><span class="id"> Xy;</span><span class="id"> first</span><span class="id"> exact/predU1l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> Dx;</span><span class="id"> apply/predU1r/minXDx/andP</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Dy:</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> D</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /minXy/=</span><span class="id"> :=</span><span class="id"> Xx;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> /idPn[]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> negb_or</span><span class="id"> andbT</span> (<span class="id">memPn</span><span class="id"> notDz</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> Ux;</span><span class="id"> split=&gt;</span><span class="id"> [|t</span><span class="id"> /andP[/minXy]];</span><span class="id"> first</span><span class="id"> exact/andP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> Dy</span><span class="id"> =&gt;</span><span class="id"> /predU1P[-&gt;</span><span class="id"> /idPn[]|]</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> [|/=</span><span class="id"> -&gt;</span><span class="id"> //];</span><span class="id"> last</span><span class="id"> exact/predU1l</span>.<br/>
<span class="id">apply/asboolP;</span><span class="id"> split=&gt;</span><span class="id"> [x|x</span><span class="id"> y</span><span class="id"> /=</span><span class="id"> Dx];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> predU1r</span>.<br/>
<span class="id">rewrite</span><span class="id"> Dx</span><span class="id"> =&gt;</span><span class="id"> /predU1P[-&gt;</span><span class="id"> |</span><span class="id"> /=</span><span class="id"> Dy];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> eqxx</span> (<span class="id">negPf</span><span class="id"> notDz</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Dy</span><span class="id"> -implyNb</span> (<span class="id">memPn</span><span class="id"> notDz</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Zorn</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
