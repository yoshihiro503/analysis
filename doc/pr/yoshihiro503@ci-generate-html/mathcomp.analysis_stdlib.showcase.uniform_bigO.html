
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.analysis_stdlib.showcase.uniform_bigO</title>
<meta name="description" content="Documentation of Coq module mathcomp.analysis_stdlib.showcase.uniform_bigO" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.analysis_stdlib.showcase.uniform_bigO</h1>
<span class="vernacular">From</span><span class="id"> Coq</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> Reals</span>.<br/>
<span class="vernacular">From</span><span class="id"> Coq</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> ssreflect</span><span class="id"> ssrfun</span><span class="id"> ssrbool</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> ssrnat</span><span class="id"> eqtype</span><span class="id"> choice</span><span class="id"> fintype</span><span class="id"> bigop</span><span class="id"> order</span><span class="id"> ssralg</span><span class="id"> ssrnum</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> boolp</span><span class="id"> reals</span><span class="id"> Rstruct_topology</span><span class="id"> ereal</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> classical_sets</span><span class="id"> signed</span><span class="id"> topology</span><span class="id"> normedtype</span><span class="id"> landau</span>.<br/>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<span class="vernacular">Import</span><span class="id"> Order</span>.<span class="id">TTheory</span><span class="id"> GRing</span>.<span class="id">Theory</span><span class="id"> Num</span>.<span class="id">Def</span><span class="id"> Num</span>.<span class="id">Theory</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> UniformBigO</span>.<br/>
<br/>
<div class="ssrdoc md">
This section shows how we can formalize the uniform bigO from:
Boldo, Clément, Filliâtre, Mayero, Melquiond, Weis,
Wave Equation Numerical Resolution: A Comprehensive Mechanized Proof of a
C Program, Journal of Automated Reasoning 2013. The corresponding source
code is here: http://fost.saclay.inria.fr/coq_total/BigO.html.
</div>
<br/>
<span class="vernacular">Context</span> (<span class="id">A</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">R</span><span class="id"> *</span><span class="id"> R</span>)).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> OuP</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> *</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> R</span><span class="id"> *</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> alp</span><span class="id"> :</span><span class="id"> R</span><span class="id"> &amp;</span><span class="id"> {</span><span class="id"> C</span><span class="id"> :</span><span class="id"> R</span><span class="id"> |</span><br/>
&nbsp;&nbsp;<span class="id">0</span><span class="id"> &lt;</span><span class="id"> alp</span><span class="id"> /\</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> C</span><span class="id"> /\</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> X</span><span class="id"> :</span><span class="id"> A,</span><span class="gallina-kwd"> forall</span><span class="id"> dX</span><span class="id"> :</span><span class="id"> R</span><span class="id"> *</span><span class="id"> R,</span><br/>
&nbsp;&nbsp;<span class="id">sqrt</span> (<span class="id">Rsqr</span> (<span class="id">fst</span><span class="id"> dX</span>)<span class="id"> +</span><span class="id"> Rsqr</span> (<span class="id">snd</span><span class="id"> dX</span>))<span class="id"> &lt;</span><span class="id"> alp</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> dX</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">Rabs</span> (<span class="id">f</span><span class="id"> X</span><span class="id"> dX</span>)<span class="id"> &lt;=</span><span class="id"> C</span><span class="id"> *</span><span class="id"> Rabs</span> (<span class="id">g</span><span class="id"> dX</span>)<span class="id">}}</span>.<br/>
<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> normedR2</span><span class="id"> :=</span><span class="id"> [the</span><span class="id"> normedModType</span><span class="id"> _</span><span class="id"> of</span> (<span class="id">R^o</span><span class="id"> *</span><span class="id"> R^o</span>)<span class="id">%type]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> OuPex</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> *</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> R^o</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> R</span><span class="id"> *</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> R^o</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> alp,</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> alp</span><span class="id"> &amp;</span><span class="gallina-kwd"> exists2</span><span class="id"> C,</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> C</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> dX</span><span class="id"> :</span><span class="id"> normedR2,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">`|dX|</span><span class="id"> &lt;</span><span class="id"> alp</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> dX</span><span class="id"> -&gt;</span><span class="id"> `|f</span><span class="id"> X</span><span class="id"> dX|</span><span class="id"> &lt;=</span><span class="id"> C</span><span class="id"> *</span><span class="id"> `|g</span><span class="id"> dX|</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ler_norm2</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> normedR2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">`|x|</span><span class="id"> &lt;=</span><span class="id"> sqrt</span> (<span class="id">Rsqr</span> (<span class="id">fst</span><span class="id"> x</span>)<span class="id"> +</span><span class="id"> Rsqr</span> (<span class="id">snd</span><span class="id"> x</span>))<span class="id"> &lt;=</span><span class="id"> Num</span>.<span class="id">sqrt</span><span class="id"> 2</span><span class="id"> *</span><span class="id"> `|x|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> RsqrtE;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> addr_ge0</span><span class="id"> //;</span><span class="id"> apply/RleP/Rle_0_sqr</span>.<br/>
<span class="id">rewrite</span><span class="id"> !Rsqr_pow2</span><span class="id"> !RpowE;</span><span class="id"> apply/andP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ge_max;</span><span class="id"> apply/andP;</span><span class="id"> split;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -[`|_|]sqrtr_sqr</span><span class="id"> ler_wsqrtr</span><span class="id"> //</span> (<span class="id">lerDl,</span><span class="id"> lerDr</span>)<span class="id"> sqr_ge0</span>.<br/>
<span class="id">wlog</span><span class="id"> lex12</span><span class="id"> :</span><span class="id"> x</span><span class="id"> /</span> (<span class="id">`|x</span>.<span class="id">1|</span><span class="id"> &lt;=</span><span class="id"> `|x</span>.<span class="id">2|</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> ler_norm;</span><span class="id"> case:</span> (<span class="id">lerP</span><span class="id"> `|x</span>.<span class="id">1|</span><span class="id"> `|x</span>.<span class="id">2|</span>)<span class="id"> =&gt;</span><span class="id"> [/ler_norm|]</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> lt_leAnge</span><span class="id"> =&gt;</span><span class="id"> /andP</span><span class="id"> [lex21</span><span class="id"> _]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> RplusE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> addrC</span><span class="id"> [`|_|]maxC</span> (<span class="id">ler_norm</span> (<span class="id">x</span>.<span class="id">2,</span><span class="id"> x</span>.<span class="id">1</span>)).<br/>
<span class="id">rewrite</span><span class="id"> [`|_|]max_r</span><span class="id"> //</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> *</span><span class="id"> _]ger0_norm</span><span class="id"> //</span><span class="id"> -normrM</span>.<br/>
<span class="id">rewrite</span><span class="id"> -sqrtr_sqr</span><span class="id"> ler_wsqrtr</span><span class="id"> //</span><span class="id"> exprMn</span><span class="id"> sqr_sqrtr</span><span class="id"> //</span><span class="id"> mulr_natl</span><span class="id"> mulr2n</span><span class="id"> lerD2r</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[_</span><span class="id"> ^+</span><span class="id"> 2]ger0_norm</span><span class="id"> ?sqr_ge0</span><span class="id"> //</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> &lt;=X]ger0_norm</span><span class="id"> ?sqr_ge0</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !normrX</span><span class="id"> lerXn2r</span><span class="id"> //</span><span class="id"> nnegrE</span><span class="id"> normr_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> OuP_to_ex</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> OuP</span><span class="id"> f</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> OuPex</span><span class="id"> f</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [_</span><span class="id"> [_</span><span class="id"> [/posnumP[a]</span><span class="id"> [/posnumP[C]</span><span class="id"> fOg]]]]</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">a%:num</span><span class="id"> /</span><span class="id"> Num</span>.<span class="id">sqrt</span><span class="id"> 2</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> C%:num</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> dx</span><span class="id"> ltdxa</span><span class="id"> Pdx</span>.<br/>
<span class="id">apply:</span><span class="id"> fOg;</span><span class="id"> move:</span><span class="id"> ltdxa;</span><span class="id"> rewrite</span><span class="id"> ltr_pdivlMr</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> le_lt_trans</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulrC;</span><span class="id"> have</span><span class="id"> /andP[]</span><span class="id"> :=</span><span class="id"> ler_norm2</span><span class="id"> dx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Ouex_to_P</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> OuPex</span><span class="id"> f</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> OuP</span><span class="id"> f</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /exists2P</span><span class="id"> /getPex;</span><span class="id"> set</span><span class="id"> Q</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> a</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /\</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> -</span><span class="id"> [lt0getQ]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /exists2P</span><span class="id"> /getPex;</span><span class="id"> set</span><span class="id"> R</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> C</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /\</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> -</span><span class="id"> [lt0getR</span><span class="id"> fOg]</span>.<br/>
<span class="id">apply:</span><span class="id"> existT</span> (<span class="id">get</span><span class="id"> Q</span>)<span class="id"> _;</span><span class="id"> apply:</span><span class="id"> exist</span> (<span class="id">get</span><span class="id"> R</span>)<span class="id"> _;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> dx</span><span class="id"> ltdxgetQ;</span><span class="id"> apply:</span><span class="id"> fOg;</span><span class="id"> apply:</span><span class="id"> le_lt_trans</span><span class="id"> ltdxgetQ</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /andP</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> ler_norm2</span><span class="id"> dx</span>.<br/>
Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> OuO</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> *</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> R^o</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> R</span><span class="id"> *</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> R^o</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> x</span>.<span class="id">1</span><span class="id"> x</span>.<span class="id">2</span>)<span class="id"> =O_</span> (<span class="id">filter_prod</span><span class="id"> [set</span><span class="id"> setT]%classic</span><br/>
&nbsp;&nbsp;(<span class="id">within</span><span class="id"> P</span> (<span class="id">nbhs</span> (<span class="id">0%R:R^o,0%R:R^o</span>)))) (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> g</span><span class="id"> x</span>.<span class="id">2</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> OuP_to_O</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> OuP</span><span class="id"> f</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> OuO</span><span class="id"> f</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /OuP_to_ex</span><span class="id"> [_/posnumP[a]</span><span class="id"> [_/posnumP[C]</span><span class="id"> fOg]]</span>.<br/>
<span class="id">apply/eqOP;</span><span class="id"> near=&gt;</span><span class="id"> k;</span><span class="id"> near=&gt;</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> le_trans</span> (<span class="id">fOg</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> _;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> near:</span><span class="id"> x;</span><span class="gallina-kwd"> exists</span> (<span class="id">setT,</span><span class="id"> P</span>)<span class="id">;</span><span class="id"> [split=&gt;</span><span class="id"> //=;</span><span class="id"> apply:</span><span class="id"> withinT|move=&gt;</span><span class="id"> ?</span><span class="id"> []]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ler_pM</span>.<br/>
<span class="id">-</span><span class="id"> near:</span><span class="id"> x;</span><span class="gallina-kwd"> exists</span> (<span class="id">setT,</span><span class="id"> ball</span> (<span class="id">0</span><span class="id"> :</span><span class="id"> R^o</span><span class="id"> *</span><span class="id"> R^o</span>)<span class="id"> a%:num</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> /within</span><span class="id"> /=;</span><span class="id"> near=&gt;</span><span class="id"> x</span><span class="id"> =&gt;_;</span><span class="id"> near:</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> nbhsx_ballx</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> [_</span><span class="id"> [/=]];</span><span class="id"> rewrite</span><span class="id"> -ball_normE</span><span class="id"> /=</span><span class="id"> distrC</span><span class="id"> subr0</span><span class="id"> distrC</span><span class="id"> subr0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> gt_max;</span><span class="id"> apply/andP</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> OuO_to_P</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> OuO</span><span class="id"> f</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> OuP</span><span class="id"> f</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> fOg;</span><span class="id"> apply/Ouex_to_P;</span><span class="id"> move:</span><span class="id"> fOg</span><span class="id"> =&gt;</span><span class="id"> /eqOP</span><span class="id"> [k</span><span class="id"> [kreal</span><span class="id"> hk]]</span>.<br/>
<span class="id">have</span><span class="id"> /hk</span><span class="id"> [Q</span><span class="id"> [-&gt;]]</span><span class="id"> :</span><span class="id"> k</span><span class="id"> &lt;</span><span class="id"> maxr</span><span class="id"> 1</span> (<span class="id">k</span><span class="id"> +</span><span class="id"> 1</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> lt_max</span><span class="id"> ltrDl</span><span class="id"> orbC</span><span class="id"> ltr01</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> [R</span><span class="id"> [[_/posnumP[e1]</span><span class="id"> Re1]</span><span class="id"> [_/posnumP[e2]</span><span class="id"> Re2]]</span><span class="id"> sRQ]</span><span class="id"> fOg</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">minr</span><span class="id"> e1%:num</span><span class="id"> e2%:num</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">maxr</span><span class="id"> 1</span> (<span class="id">k</span><span class="id"> +</span><span class="id"> 1</span>))<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> lt_max</span><span class="id"> ltr01</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> dx</span><span class="id"> dxe</span><span class="id"> Pdx;</span><span class="id"> apply:</span> (<span class="id">fOg</span> (<span class="id">x,</span><span class="id"> dx</span>))<span class="id">;</span><span class="id"> split=&gt;</span><span class="id"> //=</span>.<br/>
<span class="id">move:</span><span class="id"> dxe;</span><span class="id"> rewrite</span><span class="id"> gt_max</span><span class="id"> !lt_min</span><span class="id"> =&gt;</span><span class="id"> /andP[/andP</span><span class="id"> [dxe11</span><span class="id"> _]</span><span class="id"> /andP</span><span class="id"> [_</span><span class="id"> dxe22]]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/sRQ</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split;</span><span class="id"> [apply/Re1|apply/Re2];</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> distrC</span><span class="id"> subr0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> UniformBigO</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
