
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.classical.fsbigop</title>
<meta name="description" content="Documentation of Coq module mathcomp.classical.fsbigop" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.classical.fsbigop</h1>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> all_ssreflect</span><span class="id"> ssralg</span><span class="id"> ssrnum</span><span class="id"> ssrint</span><span class="id"> interval</span><span class="id"> finmap</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> mathcomp_extra</span><span class="id"> boolp</span><span class="id"> classical_sets</span><span class="id"> functions</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> cardinality</span>.<br/>
<br/>
<div class="ssrdoc md">
# Finitely-supported big operators

```
    finite_support idx D F := D `&amp;` F @^-1` [set~ idx]
\big[op/idx]_(i \in A) F i == iterated application of the operator op
                              with neutral idx over finite_support idx A F
        \sum_(i \in A) F i == iterated addition, in ring_scope
```

</div>
<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;\big [ op / idx ]_ ( i '\in' A ) F&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> F</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> op,</span><span class="id"> idx</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 10,</span><span class="id"> i,</span><span class="id"> A</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 50,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;'[' \big [ op / idx ]_ ( i  '\in'  A ) '/  '  F ']'&quot;</span>).<br/>
<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;\sum_ ( i '\in' A ) F&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 41,</span><span class="id"> F</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 41,</span><span class="id"> i,</span><span class="id"> A</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 50,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;'[' \sum_ ( i  '\in'  A ) '/  '  F ']'&quot;</span>).<br/>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<span class="vernacular">Import</span><span class="id"> Order</span>.<span class="id">TTheory</span><span class="id"> GRing</span>.<span class="id">Theory</span><span class="id"> Num</span>.<span class="id">Def</span><span class="id"> Num</span>.<span class="id">Theory</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;\big [ op / idx ]_ ( i '\in' A ) F&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> fset_set</span> (<span class="id">A</span><span class="id"> `&amp;`</span> ((<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> F</span>)<span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> idx]</span>)))<span class="id"> F</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">only</span><span class="id"> parsing</span>)<span class="id"> :</span><span class="id"> big_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_index_key</span><span class="id"> :</span><span class="id"> unit</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> tt</span>. Qed.</div></details>
<span class="vernacular">Definition</span><span class="id"> finite_support</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">idx</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> seq</span><span class="id"> I</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">locked_with</span><span class="id"> finite_index_key</span> (<span class="id">fset_set</span> (<span class="id">D</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> idx]</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)).<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;\big [ op / idx ]_ ( i '\in' D ) F&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> finite_support</span><span class="id"> idx</span><span class="id"> D</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> F</span>))<span class="id"> F</span>)<br/>
&nbsp;&nbsp;<span class="id">:</span><span class="id"> big_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> in_finite_support</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">J</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">i</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> J</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> i]</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">finite_support</span><span class="id"> i</span><span class="id"> P</span><span class="id"> F</span><span class="id"> =i</span><span class="id"> P</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> i]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> finF</span><span class="id"> j;</span><span class="id"> rewrite</span><span class="id"> /finite_support</span><span class="id"> unlock</span><span class="id"> in_fset_set</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_support_uniq</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">J</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">i</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> J</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> uniq</span> (<span class="id">finite_support</span><span class="id"> i</span><span class="id"> P</span><span class="id"> F</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /finite_support</span><span class="id"> unlock;</span><span class="id"> exact:</span><span class="id"> fset_uniq</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> finite_support_uniq</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> no_finite_support</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">J</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">i</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> J</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> infinite_set</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> i]</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">finite_support</span><span class="id"> i</span><span class="id"> P</span><span class="id"> F</span><span class="id"> =</span><span class="id"> [::]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> infinF;</span><span class="id"> rewrite</span><span class="id"> /finite_support</span><span class="id"> unlock</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /fset_set/=;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_finite_support</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">idx</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> G</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> {in</span><span class="id"> D,</span><span class="id"> F</span><span class="id"> =1</span><span class="id"> G}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">finite_support</span><span class="id"> idx</span><span class="id"> D</span><span class="id"> F</span><span class="id"> =</span><span class="id"> finite_support</span><span class="id"> idx</span><span class="id"> D</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> eqFG;</span><span class="id"> rewrite</span><span class="id"> /finite_support</span><span class="id"> !unlock//</span> (<span class="id">eq_preimage</span><span class="id"> _</span><span class="id"> eqFG</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Variant</span><span class="id"> finite_support_spec</span><span class="id"> R</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>)<br/>
&nbsp;&nbsp;(<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><br/>
<span class="id">|</span><span class="id"> NoFiniteSupport</span><span class="id"> of</span><span class="id"> infinite_set</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> idx]</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_support_spec</span><span class="id"> P</span><span class="id"> F</span><span class="id"> idx</span><span class="id"> [::]</span><br/>
<span class="id">|</span><span class="id"> FiniteSupport</span> (<span class="id">X</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span>)<span class="id"> of</span><span class="id"> [set`</span><span class="id"> X]</span><span class="id"> `&lt;=`</span><span class="id"> P</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> i</span><span class="id"> \notin</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> [set`</span><span class="id"> X]</span><span class="id"> =</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> idx]</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_support_spec</span><span class="id"> P</span><span class="id"> F</span><span class="id"> idx</span><span class="id"> X</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_supportP</span><span class="id"> R</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_support_spec</span><span class="id"> P</span><span class="id"> F</span><span class="id"> idx</span> (<span class="id">finite_support</span><span class="id"> idx</span><span class="id"> P</span><span class="id"> F</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /finite_support</span><span class="id"> unlock/=</span><span class="id"> /fset_set</span>.<br/>
<span class="id">case:</span><span class="id"> pselect=&gt;</span><span class="id"> //</span><span class="id"> Xfin;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> constructor</span>.<br/>
<span class="id">case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> X</span><span class="id"> eqX;</span><span class="id"> constructor;</span><span class="id"> rewrite</span><span class="id"> -?eqX//</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> i</span><span class="id"> Pi</span><span class="id"> NXi</span><span class="id"> /=;</span><span class="id"> have</span><span class="id"> :</span> (<span class="id">P</span><span class="id"> `\`</span><span class="id"> [set`</span><span class="id"> X]</span>)<span class="id"> i</span><span class="gallina-kwd"> by</span><span class="id"> split=&gt;</span><span class="id"> //=;</span><span class="id"> apply/negP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -eqX</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> -[_];</span><span class="id"> apply:</span><span class="id"> contra_notP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;\sum_ ( i '\in' A ) F&quot;</span><span class="id"> :=</span> (<span class="id">\big[+%R/0%R]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id"> F</span>)<span class="id"> :</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_fsbigl</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> R</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">P</span><span class="id"> Q</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">P</span><span class="id"> =</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="id"> \big[op/idx]_</span>(<span class="id">x</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> f</span><span class="id"> x</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">x</span><span class="id"> \in</span><span class="id"> Q</span>)<span class="id"> f</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_fsbigr</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> P,</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> g}</span><span class="id"> -&gt;</span> (<span class="id">\big[op/idx]_</span>(<span class="id">x</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> f</span><span class="id"> x</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">x</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> g</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> fg;</span><span class="id"> rewrite</span> (<span class="id">eq_finite_support</span><span class="id"> _</span><span class="id"> fg</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> eq_big_seq</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> finite_supportP</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> X</span><span class="id"> XP</span><span class="id"> _</span><span class="id"> gidx</span><span class="id"> xX;</span><span class="id"> rewrite</span><span class="id"> fg</span><span class="id"> //</span><span class="id"> ?inE;</span><span class="id"> apply/XP</span>.<br/>
Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> eq_fsbigr</span><span class="id"> {R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> T</span><span class="id"> f}</span><span class="id"> g</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbigTE</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> \notin</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> i</span><span class="id"> =</span><span class="id"> idx</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> [set:</span><span class="id"> T]</span>)<span class="id"> f</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> A</span>)<span class="id"> f</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Peq:</span><span class="id"> R</span><span class="id"> =&gt;</span><span class="id"> R</span><span class="gallina-kwd"> in</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> f</span><span class="id"> *</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> Af;</span><span class="id"> have</span><span class="id"> Afin</span><span class="id"> :</span><span class="id"> finite_set</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> idx]</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">finite_subfset</span><span class="id"> A</span>)<span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> contra_notT</span><span class="id"> =&gt;</span><span class="id"> /Af</span>.<br/>
<span class="id">rewrite</span><span class="id"> [in</span><span class="id"> RHS]</span>(<span class="id">big_fsetID</span><span class="id"> _</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> f</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> idx]</span>)<span class="id">/=</span>.<br/>
<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> =</span><span class="id"> op</span><span class="id"> X</span><span class="id"> _]big_fset</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> =</span><span class="id"> op</span><span class="id"> X</span><span class="id"> _]big1</span><span class="id"> ?Monoid</span>.<span class="id">simpm//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> /=</span><span class="id"> /eqP</span>.<br/>
<span class="id">apply</span><span class="id"> eq_fbigl</span><span class="id"> =&gt;</span><span class="id"> r</span>.<br/>
<span class="id">rewrite</span><span class="id"> in_finite_support//</span><span class="id"> ?setTI//</span><span class="id"> /preimage/=;</span><span class="id"> apply/idP/idP</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !inE/=;</span><span class="id"> apply:</span><span class="id"> contra_notP</span><span class="id"> =&gt;</span><span class="id"> /negP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> negb_and</span><span class="id"> negbK</span><span class="id"> =&gt;</span><span class="id"> /orP[|/eqP//];</span><span class="id"> exact:</span><span class="id"> Af</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE/=</span><span class="id"> =&gt;</span><span class="id"> /andP[_</span><span class="id"> /eqP]</span>.<br/>
Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> fsbigTE</span><span class="id"> {R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> T}</span><span class="id"> A</span><span class="id"> f</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_mkcond</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id"> f</span><span class="id"> i</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> [set:</span><span class="id"> T]</span>)<span class="id"> patch</span> (<span class="id">fun=&gt;</span><span class="id"> idx</span>)<span class="id"> A</span><span class="id"> f</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Peq:</span><span class="id"> R</span><span class="id"> =&gt;</span><span class="id"> R</span><span class="gallina-kwd"> in</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> f</span><span class="id"> *</span>.<br/>
<span class="id">rewrite</span><span class="id"> -big_mkcond/=</span><span class="id"> -[in</span><span class="id"> RHS]big_filter;</span><span class="id"> apply:</span><span class="id"> perm_big</span>.<br/>
<span class="id">rewrite</span><span class="id"> uniq_perm</span><span class="id"> ?filter_uniq//=</span><span class="id"> =&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> mem_filter</span>.<br/>
<span class="id">set</span><span class="id"> g</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> A</span><span class="gallina-kwd"> then</span><span class="id"> f</span><span class="id"> i</span><span class="gallina-kwd"> else</span><span class="id"> idx</span>.<br/>
<span class="id">have</span><span class="id"> gAf</span><span class="id"> :</span><span class="id"> setT</span><span class="id"> `&amp;`</span><span class="id"> g</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> idx]</span><span class="id"> =</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> idx]</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setTI;</span><span class="id"> apply/predeqP</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> /preimage/g/=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifPn;</span><span class="id"> rewrite</span> (<span class="id">inE,</span><span class="id"> notin_setE</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifPn;</span><span class="id"> rewrite</span> (<span class="id">inE,</span><span class="id"> notin_setE</span>)<span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> []</span>.<br/>
<span class="id">case:</span><span class="id"> finite_supportP</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -gAf;</span><span class="id"> case:</span><span class="id"> finite_supportP=&gt;</span><span class="id"> //=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ?inE</span><span class="id"> andbF</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> _</span><span class="id"> gidx</span><span class="id"> &lt;-//</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> X</span><span class="id"> XA</span><span class="id"> fidx</span><span class="id"> XE;</span><span class="id"> case:</span><span class="id"> finite_supportP;</span><span class="id"> rewrite</span><span class="id"> gAf</span><span class="id"> -?XE//=</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> Y</span><span class="id"> _</span><span class="id"> gidx</span><span class="id"> /predeqP/=/</span>(_<span class="id"> _</span>)<span class="id">/propext</span><span class="id"> YX</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/idP/andP</span><span class="id"> =&gt;</span><span class="id"> [|[]];</span><span class="id"> rewrite</span><span class="id"> YX//</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> Xi;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> XA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_mkcondr</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">I</span><span class="id"> J</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">a</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> I</span><span class="id"> `&amp;`</span><span class="id"> J</span>)<span class="id"> a</span><span class="id"> i</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> I</span>)<span class="gallina-kwd"> if</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> J</span><span class="gallina-kwd"> then</span><span class="id"> a</span><span class="id"> i</span><span class="gallina-kwd"> else</span><span class="id"> idx</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> fsbig_mkcond</span><span class="id"> [RHS]fsbig_mkcond</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_fsbigr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> patch_setI</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_mkcondl</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">I</span><span class="id"> J</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">a</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> I</span><span class="id"> `&amp;`</span><span class="id"> J</span>)<span class="id"> a</span><span class="id"> i</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> J</span>)<span class="gallina-kwd"> if</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> I</span><span class="gallina-kwd"> then</span><span class="id"> a</span><span class="id"> i</span><span class="gallina-kwd"> else</span><span class="id"> idx</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> fsbig_mkcond</span><span class="id"> [RHS]fsbig_mkcond</span><span class="id"> setIC</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_fsbigr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> patch_setI</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigfs</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">r</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> uniq</span><span class="id"> r</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> i</span><span class="id"> \notin</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> i</span><span class="id"> =</span><span class="id"> idx</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> r</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> f</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> [set`</span><span class="id"> P]</span>)<span class="id"> f</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> r_uniq</span><span class="id"> fidx;</span><span class="id"> rewrite</span><span class="id"> fsbig_mkcond</span>.<br/>
<span class="id">rewrite</span> (<span class="id">fsbigTE</span><span class="id"> [fset</span><span class="id"> x</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> r]%fset</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> inE/=</span><span class="id"> /patch</span><span class="id"> mem_setE;</span><span class="id"> case:</span><span class="id"> ifP=&gt;</span><span class="id"> //</span><span class="id"> +</span><span class="id"> /fidx-&gt;</span>.<br/>
<span class="id">rewrite</span><span class="id"> -big_mkcond;</span><span class="id"> under</span><span class="id"> [RHS]eq_bigl</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> mem_setE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> perm_big;</span><span class="id"> rewrite</span><span class="id"> uniq_perm//</span><span class="id"> =&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> !inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbigE</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> r</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> r]</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> A</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> i</span><span class="id"> \notin</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> i</span><span class="id"> =</span><span class="id"> idx</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id"> f</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> r</span><span class="id"> |</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id"> f</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> r_uniq</span><span class="id"> rQ</span><span class="id"> fidx;</span><span class="id"> rewrite</span><span class="id"> [RHS]bigfs</span><span class="id"> ?set_mem_set//=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> apply:</span><span class="id"> fidx</span>.<br/>
Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> fsbigE</span><span class="id"> {R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> T</span><span class="id"> A}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_seq</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> r</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">a</span><span class="id"> &lt;-</span><span class="id"> r</span>)<span class="id"> F</span><span class="id"> a</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">a</span><span class="id"> \in</span><span class="id"> [set`</span><span class="id"> r]</span>)<span class="id"> F</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ur;</span><span class="id"> rewrite</span> (<span class="id">fsbigE</span><span class="id"> r</span>)<span class="id">//=;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> +</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mem_setE</span><span class="id"> big_seq_cond</span><span class="id"> big_mkcondr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig1</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">law</span><span class="id"> idx</span>) (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> idx</span>)<span class="id"> -&gt;</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> idx</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> PF0;</span><span class="id"> rewrite</span><span class="id"> big1_seq//</span><span class="id"> =&gt;</span><span class="id"> i/=;</span><span class="id"> case:</span><span class="id"> finite_supportP=&gt;</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> XP</span><span class="id"> _</span><span class="id"> _</span><span class="id"> Xi;</span><span class="id"> rewrite</span><span class="id"> PF0//;</span><span class="id"> apply/XP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_dflt</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">law</span><span class="id"> idx</span>) (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">infinite_set</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> idx]</span>)<span class="id">-&gt;</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> idx</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> finite_supportP;</span><span class="id"> rewrite</span><span class="id"> ?big_nil//</span><span class="id"> =&gt;</span><span class="id"> X</span><span class="id"> _</span><span class="id"> _</span><span class="id"> &lt;-</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_widen</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> [R</span><span class="id"> :</span><span class="id"> Type]</span><span class="id"> [idx</span><span class="id"> :</span><span class="id"> R]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>) (<span class="id">P</span><span class="id"> D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P</span><span class="id"> `&lt;=`</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">D</span><span class="id"> `\`</span><span class="id"> P</span><span class="id"> `&lt;=`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> idx]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> f</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> D</span>)<span class="id"> f</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> PD</span><span class="id"> DPf;</span><span class="id"> rewrite</span><span class="id"> fsbig_mkcond</span><span class="id"> [RHS]fsbig_mkcond</span>.<br/>
<span class="id">apply:</span><span class="id"> eq_fsbigr</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /patch;</span><span class="id"> case:</span><span class="id"> ifPn;</span><span class="id"> rewrite</span> (<span class="id">inE,</span><span class="id"> notin_setE</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Px;</span><span class="id"> rewrite</span><span class="id"> ifT//</span><span class="id"> inE;</span><span class="id"> apply:</span><span class="id"> PD</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Px;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> Dx;</span><span class="id"> rewrite</span><span class="id"> DPf</span>.<br/>
Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> fsbig_widen</span><span class="id"> {T</span><span class="id"> R</span><span class="id"> idx</span><span class="id"> op}</span><span class="id"> P</span><span class="id"> D</span><span class="id"> f</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_supp</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> [R</span><span class="id"> :</span><span class="id"> Type]</span><span class="id"> [idx</span><span class="id"> :</span><span class="id"> R]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> f</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> idx]</span>)<span class="id"> f</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/esym/fsbig_widen</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> [Px</span><span class="id"> /not_andP[]//=];</span><span class="id"> rewrite</span><span class="id"> notK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_fwiden</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> [R</span><span class="id"> :</span><span class="id"> eqType]</span><span class="id"> [idx</span><span class="id"> :</span><span class="id"> R]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">r</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">P</span><span class="id"> `&lt;=`</span><span class="id"> [set`</span><span class="id"> r]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> r</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> r]</span><span class="id"> `\`</span><span class="id"> P</span><span class="id"> `&lt;=`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> idx]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> f</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> r</span>)<span class="id"> f</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> rewrite</span> (<span class="id">fsbig_widen</span><span class="id"> _</span><span class="id"> [set`</span><span class="id"> r]</span>)<span class="id">//</span><span class="id"> [RHS]fsbig_seq</span>. Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> fsbig_fwiden</span><span class="id"> {T</span><span class="id"> R</span><span class="id"> idx</span><span class="id"> op}</span><span class="id"> r</span><span class="id"> P</span><span class="id"> f</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_set0</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> \big[op/idx]_</span>(<span class="id">x</span><span class="id"> \in</span><span class="id"> set0</span>)<span class="id"> F</span><span class="id"> x</span><span class="id"> =</span><span class="id"> idx</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">fsbigE</span><span class="id"> [::]</span>)<span class="id">//</span><span class="id"> big_nil</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_set1</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> x</span><br/>
&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> \big[op/idx]_</span>(<span class="id">y</span><span class="id"> \in</span><span class="id"> [set</span><span class="id"> x]</span>)<span class="id"> F</span><span class="id"> y</span><span class="id"> =</span><span class="id"> F</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span> (<span class="id">fsbigE</span><span class="id"> [::</span><span class="id"> x]</span>)<span class="id">//=</span><span class="id"> ?big_cons</span><span class="id"> ?big_nil</span><span class="id"> ?ifT</span><span class="id"> ?inE</span><span class="id"> ?Monoid</span>.<span class="id">simpm//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /eqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> eqxx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __deprecated__full_fsbigID</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> idx]</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> op</span> (<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> F</span><span class="id"> i</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> B</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> finF</span>.<br/>
<span class="id">have</span><span class="id"> fsbig_setI</span><span class="id"> C</span><span class="id"> :</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[fset</span><span class="id"> x</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> fset_set</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> idx]</span>)<span class="id"> &amp;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> C]%fset</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> C</span>)<span class="id"> F</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> eq_fbigl</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> /=;</span><span class="id"> apply/idP/idP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !inE/=</span><span class="id"> =&gt;</span><span class="id"> /andP[+</span><span class="id"> Bi];</span><span class="id"> rewrite</span><span class="id"> in_fset_set//</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> -[Ai</span><span class="id"> Fi]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> unlock</span><span class="id"> in_fset_set</span><span class="id"> ?inE//</span><span class="id"> setIAC;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="gallina-kwd"> in</span><span class="id"> Bi</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact/finite_setIl</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> unlock</span><span class="id"> in_fset_set;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIAC;</span><span class="id"> exact/finite_setIl</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> -[[Ai</span><span class="id"> Bi]</span><span class="id"> Fi0];</span><span class="id"> rewrite</span><span class="id"> !inE/=</span><span class="id"> in_fset_set//</span><span class="id"> !mem_set</span>.<br/>
<span class="id">rewrite</span> (<span class="id">big_fsetID</span><span class="id"> _</span><span class="id"> [pred</span><span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> B]</span>)<span class="id">/=</span><span class="id"> [locked_with</span><span class="id"> _</span><span class="id"> _]unlock</span>.<br/>
<span class="id">rewrite</span><span class="id"> fsbig_setI;</span><span class="id"> congr</span> (<span class="id">op</span><span class="id"> _</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -fsbig_setI</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply</span><span class="id"> eq_fbigl</span><span class="id"> =&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> in_setC</span>.<br/>
Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> __deprecated__full_fsbigID</span><span class="id"> {R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> I}</span><span class="id"> B</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbigID</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> op</span> (<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> F</span><span class="id"> i</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> B</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Afin;</span><span class="id"> apply:</span><span class="id"> __deprecated__full_fsbigID;</span><span class="id"> apply:</span><span class="id"> finite_setIl</span>. Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> fsbigID</span><span class="id"> {R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> I}</span><span class="id"> B</span>.<br/>
<br/>
<span class="id">#[deprecated</span>(<span class="id">note=</span><span class="id">&quot;Use fsbigID instead&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> full_fsbigID</span><span class="id"> :=</span><span class="id"> __deprecated__full_fsbigID</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbigU</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> F</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> idx]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">op</span> (<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span>) (<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> B</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Afin</span><span class="id"> Bfin</span><span class="id"> AB0;</span><span class="id"> rewrite</span> (<span class="id">fsbigID</span><span class="id"> A</span>)<span class="id"> ?finite_setU;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> split</span>.<br/>
<span class="id">rewrite</span><span class="id"> setUK</span><span class="id"> -setDE;</span><span class="id"> congr</span> (<span class="id">op</span><span class="id"> _</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> setIUl</span><span class="id"> setICr</span><span class="id"> set0U</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> fsbig_widen</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> -setDE</span><span class="id"> setDD</span><span class="id"> setIC</span>.<br/>
Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> fsbigU</span><span class="id"> {R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> I}</span><span class="id"> [A</span><span class="id"> B</span><span class="id"> F]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbigU0</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> set0</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">op</span> (<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span>) (<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> B</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Af</span><span class="id"> Bf</span><span class="id"> AB0;</span><span class="id"> rewrite</span><span class="id"> fsbigU//</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /AB0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbigD1</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">i</span><span class="id"> :</span><span class="id"> I</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> i</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">j</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> j</span><span class="id"> =</span><span class="id"> op</span> (<span class="id">F</span><span class="id"> i</span>) (<span class="id">\big[op/idx]_</span>(<span class="id">j</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> `\</span><span class="id"> i</span>)<span class="id"> F</span><span class="id"> j</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> rewrite</span> (<span class="id">fsbigID</span><span class="id"> [set</span><span class="id"> i]</span>)<span class="id"> ?setI1</span><span class="id"> ?ifT</span><span class="id"> ?inE</span><span class="id"> ?fsbig_set1</span>. Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> fsbigD1</span><span class="id"> {R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> I}</span><span class="id"> i</span><span class="id"> A</span><span class="id"> F</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> full_fsbig_distrr</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">zero</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">times</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">mul_law</span><span class="id"> zero</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">plus</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">add_law</span><span class="id"> zero</span><span class="id"> times</span>) (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">a</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> zero]</span>) <span class="id">-&gt;</span><br/>
&nbsp;&nbsp;<span class="id">times</span><span class="id"> a</span> (<span class="id">\big[plus/zero]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">\big[plus/zero]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> times</span><span class="id"> a</span> (<span class="id">F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> finF;</span><span class="id"> elim/Peq</span><span class="id"> :</span><span class="id"> R</span><span class="id"> =&gt;</span><span class="id"> R</span><span class="gallina-kwd"> in</span><span class="id"> zero</span><span class="id"> times</span><span class="id"> plus</span><span class="id"> a</span><span class="id"> F</span><span class="id"> finF</span><span class="id"> *</span>.<br/>
<span class="id">have</span><span class="id"> [-&gt;|a0]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> a</span><span class="id"> zero</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Monoid</span>.<span class="id">mul0m</span><span class="id"> fsbig1//;</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> Monoid</span>.<span class="id">mul0m</span>.<br/>
<span class="id">rewrite</span><span class="id"> big_distrr</span><span class="id"> [RHS]</span>(<span class="id">full_fsbigID</span> (<span class="id">F</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> zero]</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> sub_finite_set</span><span class="id"> finF</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=</span><span class="id"> [Px</span><span class="id"> aFN0]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> contra_not</span><span class="id"> aFN0</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> Monoid</span>.<span class="id">simpm</span>.<br/>
<span class="id">set</span><span class="id"> b0</span><span class="id"> :=</span><span class="id"> bigop</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="id">set</span><span class="id"> b1</span><span class="id"> :=</span><span class="id"> bigop</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="id">set</span><span class="id"> b2</span><span class="id"> :=</span><span class="id"> bigop</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> b1</span><span class="id"> =</span><span class="id"> zero</span>)<span class="id"> ?Monoid</span>.<span class="id">simpm;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /b1</span><span class="id"> fsbig1//</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> [_</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> Monoid</span>.<span class="id">simpm</span>.<br/>
<span class="id">apply/esym/fsbig_fwiden</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> [Px</span><span class="id"> Fx0];</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> in_finite_support//</span><span class="id"> inE</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> i</span><span class="id"> [];</span><span class="id"> rewrite</span><span class="id"> /preimage/=</span><span class="id"> in_finite_support</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> =&gt;</span><span class="id"> -[Pi];</span><span class="id"> rewrite</span><span class="id"> /preimage/=</span><span class="id"> =&gt;</span><span class="id"> Fi0;</span><span class="id"> tauto</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_distrr</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">zero</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">times</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">mul_law</span><span class="id"> zero</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">plus</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">add_law</span><span class="id"> zero</span><span class="id"> times</span>) (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">a</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> P</span> <span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">times</span><span class="id"> a</span> (<span class="id">\big[plus/zero]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">\big[plus/zero]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> times</span><span class="id"> a</span> (<span class="id">F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Pf;</span><span class="id"> apply:</span><span class="id"> full_fsbig_distrr;</span><span class="id"> apply:</span><span class="id"> finite_setIl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mulr_fsumr</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> idomainType</span>) (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> a</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">a</span><span class="id"> *</span> (<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> a</span><span class="id"> *</span><span class="id"> F</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [-&gt;|aN0]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> a</span><span class="id"> 0;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mul0r</span><span class="id"> big1//</span><span class="id"> =&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> mul0r</span>.<br/>
<span class="id">case:</span> (<span class="id">pselect</span> (<span class="id">finite_set</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> 0]</span>)))<span class="id"> =&gt;</span><span class="id"> PFfin</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> full_fsbig_distrr</span>.<br/>
<span class="id">rewrite</span><span class="id"> !fsbig_dflt</span><span class="id"> ?mulr0//;</span><span class="id"> apply:</span><span class="id"> contra_not</span><span class="id"> PFfin;</span><span class="id"> apply:</span><span class="id"> sub_finite_set</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> [Px</span><span class="id"> /eqP</span><span class="id"> Fx0];</span><span class="id"> split=&gt;</span><span class="id"> //=;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> mulf_neq0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mulr_fsuml</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> idomainType</span>) (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> a</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> *</span><span class="id"> a</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>) (<span class="id">F</span><span class="id"> i</span><span class="id"> *</span><span class="id"> a</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mulrC</span><span class="id"> mulr_fsumr;</span><span class="id"> under</span><span class="id"> eq_fsbigr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> mulrC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_ord</span><span class="id"> R</span> (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<span class="id"> n</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">a</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> a</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">a</span><span class="id"> \in</span><span class="id"> `I_n</span>)<span class="id"> F</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">big_mkord</span><span class="id"> xpredT</span>)<span class="id"> [LHS]fsbig_seq</span><span class="id"> ?iota_uniq//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_fsbigl;</span><span class="id"> rewrite</span><span class="id"> -Iiota</span><span class="id"> /index_iota</span><span class="id"> subn0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_finite</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">x</span><span class="id"> \in</span><span class="id"> D</span>)<span class="id"> F</span><span class="id"> x</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> fset_set</span><span class="id"> D</span>)<span class="id"> F</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Peq:</span><span class="id"> R</span><span class="id"> =&gt;</span><span class="id"> R</span><span class="gallina-kwd"> in</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> F</span><span class="id"> *</span><span class="id"> =&gt;</span><span class="id"> Dfin</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> fsbig_fwiden;</span><span class="id"> rewrite</span><span class="id"> ?fset_setK//</span><span class="id"> setDv</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> fsbig2</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> reindex_fsbig</span><span class="id"> {I</span><span class="id"> J</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">h</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> J</span>)<span class="id"> P</span><span class="id"> Q</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> set_bij</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> h</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">j</span><span class="id"> \in</span><span class="id"> Q</span>)<span class="id"> F</span><span class="id"> j</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span> (<span class="id">h</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/choicePpointed:</span><span class="id"> I</span><span class="id"> =&gt;</span><span class="id"> I</span><span class="gallina-kwd"> in</span><span class="id"> h</span><span class="id"> P</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !emptyE</span><span class="id"> =&gt;</span><span class="id"> /Pbij[{}h</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -[in</span><span class="id"> LHS]</span>(<span class="id">image_eq</span><span class="id"> h</span>)<span class="id"> image_set0</span><span class="id"> !fsbig_set0</span>.<br/>
<span class="id">elim/choicePpointed:</span><span class="id"> J</span><span class="id"> =&gt;</span><span class="id"> J</span><span class="gallina-kwd"> in</span><span class="id"> F</span><span class="id"> h</span><span class="id"> Q</span><span class="id"> *;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> no</span> (<span class="id">h</span><span class="id"> point</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> /</span>(<span class="id">@pPbij</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>)<span class="id">[{}h</span><span class="id"> -&gt;]</span>.<br/>
<span class="id">pose</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> P</span><span class="id"> `&amp;`</span> (<span class="id">F</span><span class="id"> \o</span><span class="id"> h</span>)<span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> idx]</span>.<br/>
<span class="id">pose</span><span class="id"> B</span><span class="id"> :=</span><span class="id"> Q</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> @^-1`</span><span class="id"> [set~</span><span class="id"> idx]</span>.<br/>
<span class="id">have</span><span class="id"> /</span>(<span class="id">@pPbij</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>)<span class="id">[g</span><span class="id"> gh]</span><span class="id"> :</span><span class="id"> set_bij</span><span class="id"> A</span><span class="id"> B</span><span class="id"> h</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> splitbij_sub;</span><span class="id"> rewrite</span><span class="id"> /A</span><span class="id"> /B</span><span class="id"> /preimage</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> [Px</span><span class="id"> Fhx];</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> funS</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> [Qx</span><span class="id"> Fx];</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> ?invK</span><span class="id"> ?inE//;</span><span class="id"> apply:</span><span class="id"> funS</span>.<br/>
<span class="id">case:</span><span class="id"> finite_supportP;</span><span class="id"> rewrite</span><span class="id"> ?big_nil//=</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> finite_supportP;</span><span class="id"> rewrite</span><span class="id"> ?big_nil//=</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> X</span><span class="id"> XP</span><span class="id"> _</span><span class="id"> XE</span><span class="id"> [];</span><span class="id"> rewrite</span><span class="id"> -/B</span><span class="id"> -</span>(<span class="id">image_eq</span><span class="id"> g</span>)<span class="id"> /A</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> finite_image;</span><span class="id"> rewrite</span><span class="id"> -XE</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> Y</span><span class="id"> YQ</span><span class="id"> Fidx</span><span class="id"> YE;</span><span class="id"> case:</span><span class="id"> finite_supportP</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> [];</span><span class="id"> rewrite</span><span class="id"> -/A</span><span class="id"> -</span>(<span class="id">image_eq</span><span class="id"> [bij</span><span class="id"> of</span><span class="id"> g^-1%FUN]</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> finite_image;</span><span class="id"> rewrite</span><span class="id"> /B</span><span class="id"> -YE</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> X</span><span class="id"> XP</span><span class="id"> Fhidx</span><span class="id"> XE;</span><span class="id"> suff</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> Y</span><span class="id"> =</span> (<span class="id">h</span><span class="id"> @`</span><span class="id"> X</span>)<span class="id">%fset</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_imfset//</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> /inj;</span><span class="id"> apply;</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> apply:</span><span class="id"> XP</span>.<br/>
<span class="id">have</span><span class="id"> BY</span><span class="id"> j</span><span class="id"> :</span> (<span class="id">B</span><span class="id"> j</span>)<span class="id"> =</span> (<span class="id">j</span><span class="id"> \in</span><span class="id"> Y</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -[RHS]/</span>(<span class="id">[set`</span><span class="id"> Y]</span><span class="id"> j</span>)<span class="id"> YE</span>.<br/>
<span class="id">have</span><span class="id"> AX</span><span class="id"> i</span><span class="id"> :</span> (<span class="id">A</span><span class="id"> i</span>)<span class="id"> =</span> (<span class="id">i</span><span class="id"> \in</span><span class="id"> X</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -[RHS]/</span>(<span class="id">[set`</span><span class="id"> X]</span><span class="id"> i</span>)<span class="id"> XE</span>.<br/>
<span class="id">rewrite</span><span class="id"> gh;</span><span class="id"> apply/fsetP=&gt;</span><span class="id"> j;</span><span class="id"> apply/idP/imfsetP</span><span class="id"> =&gt;</span><span class="id"> [Yj</span><span class="id"> |</span><span class="id"> [i</span><span class="id"> iX</span><span class="id"> -&gt;]];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -BY;</span><span class="id"> apply:</span><span class="id"> funS;</span><span class="id"> rewrite</span><span class="id"> AX</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">g^-1%FUN</span><span class="id"> j</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?invK</span><span class="id"> ?inE</span><span class="id"> ?BY//</span><span class="id"> -AX;</span><span class="id"> apply:</span><span class="id"> funS;</span><span class="id"> rewrite</span><span class="id"> BY</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_image</span><span class="id"> {I</span><span class="id"> J</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> P</span> (<span class="id">h</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> J</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> set_inj</span><span class="id"> P</span><span class="id"> h</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">j</span><span class="id"> \in</span><span class="id"> h</span><span class="id"> @`</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> j</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span> (<span class="id">h</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /inj_bij;</span><span class="id"> apply:</span><span class="id"> reindex_fsbig</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __deprecated__reindex_inside</span><span class="id"> {I</span><span class="id"> J</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> P</span><span class="id"> Q</span> (<span class="id">h</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> J</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">bijective</span><span class="id"> h</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> `&lt;=`</span><span class="id"> h</span><span class="id"> @`</span><span class="id"> Q</span><span class="id"> -&gt;</span><span class="id"> Q</span><span class="id"> `&lt;=`</span><span class="id"> h</span><span class="id"> @^-1`</span><span class="id"> P</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">j</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> j</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> Q</span>)<span class="id"> F</span> (<span class="id">h</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> hbij</span><span class="id"> PQ</span><span class="id"> QP;</span><span class="id"> apply:</span><span class="id"> reindex_fsbig;</span><span class="id"> split=&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> _</span><span class="id"> _</span><span class="id"> /</span>(<span class="id">bij_inj</span><span class="id"> hbij</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> reindex_fsbigT</span><span class="id"> {I</span><span class="id"> J</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">h</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> J</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">bijective</span><span class="id"> h</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">j</span><span class="id"> \in</span><span class="id"> [set:</span><span class="id"> J]</span>)<span class="id"> F</span><span class="id"> j</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> [set:</span><span class="id"> I]</span>)<span class="id"> F</span> (<span class="id">h</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setTT_bijective</span><span class="id"> =&gt;</span><span class="id"> -[?</span><span class="id"> ?</span><span class="id"> ?];</span><span class="id"> apply:</span><span class="id"> reindex_fsbig</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> fsbig2</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> reindex_fsbig</span><span class="id"> {R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> I</span><span class="id"> J}</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> fsbig_image</span><span class="id"> {R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> I</span><span class="id"> J}</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> __deprecated__reindex_inside</span><span class="id"> {R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> I</span><span class="id"> J}</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> reindex_fsbigT</span><span class="id"> {R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> I</span><span class="id"> J}</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">note=</span><span class="id">&quot;use reindex_fsbig, fsbig_image or reindex_fsbigT instead&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> reindex_inside</span><span class="id"> :=</span><span class="id"> __deprecated__reindex_inside</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[deprecated</span>(<span class="id">note=</span><span class="id">&quot;use reindex_fsbigT instead&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> reindex_inside_setT</span><span class="id"> :=</span><span class="id"> reindex_fsbigT</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbigN1</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T1</span><span class="id"> T2</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">Q</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T2</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> T1</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">y</span><span class="id"> \in</span><span class="id"> Q</span>)<span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> !=</span><span class="id"> idx</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists2</span><span class="id"> y,</span><span class="id"> Q</span><span class="id"> y</span><span class="id"> &amp;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> !=</span><span class="id"> idx</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> contra_neqP</span><span class="id"> =&gt;</span><span class="id"> /forall2NP</span><span class="id"> Qf;</span><span class="id"> apply/fsbig1</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> Qy</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">Qf</span><span class="id"> y</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> /negP/negPn/eqP-&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_split</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> P</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">x</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> op</span> (<span class="id">f</span><span class="id"> x</span>) (<span class="id">g</span><span class="id"> x</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">op</span> (<span class="id">\big[op/idx]_</span>(<span class="id">x</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> f</span><span class="id"> x</span>) (<span class="id">\big[op/idx]_</span>(<span class="id">x</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> g</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Pfin;</span><span class="id"> rewrite</span><span class="id"> !fsbig_finite//</span><span class="id"> big_split</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsumr_ge0</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numDomainType</span>) (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> F</span><span class="id"> i</span>)<span class="id"> -&gt;</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> PF;</span><span class="id"> case:</span><span class="id"> finite_supportP;</span><span class="id"> rewrite</span><span class="id"> ?big_nil//</span><span class="id"> =&gt;</span><span class="id"> X</span><span class="id"> XP</span><span class="id"> F0</span><span class="id"> _</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_seq_cond</span><span class="id"> big_mkcondr</span><span class="id"> sumr_ge0//</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> /XP/PF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsumr_le0</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numDomainType</span>) (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> i</span><span class="id"> &lt;=</span><span class="id"> 0</span>)<span class="id"> -&gt;</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> &lt;=</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> PF;</span><span class="id"> case:</span><span class="id"> finite_supportP;</span><span class="id"> rewrite</span><span class="id"> ?big_nil//</span><span class="id"> =&gt;</span><span class="id"> X</span><span class="id"> XP</span><span class="id"> F0</span><span class="id"> _</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_seq_cond</span><span class="id"> big_mkcondr</span><span class="id"> sumr_le0//</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> /XP/PF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsumr_gt0</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realDomainType</span>) (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> I</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">0</span><span class="id"> &lt;</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists2</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> &amp;</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> F</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> contraPP</span><span class="id"> =&gt;</span><span class="id"> /forall2NP</span><span class="id"> xNPF;</span><span class="id"> rewrite</span><span class="id"> le_gtF//</span><span class="id"> fsumr_le0//</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> Pi</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">xNPF</span><span class="id"> i</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> /negP;</span><span class="id"> case:</span><span class="id"> ltP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsumr_lt0</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realDomainType</span>) (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists2</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> &amp;</span><span class="id"> F</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> contraPP</span><span class="id"> =&gt;</span><span class="id"> /forall2NP</span><span class="id"> xNPF;</span><span class="id"> rewrite</span><span class="id"> le_gtF//</span><span class="id"> fsumr_ge0//</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> Pi</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">xNPF</span><span class="id"> i</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> /negP;</span><span class="id"> case:</span><span class="id"> ltP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pfsumr_eq0</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realDomainType</span>) (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> P</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> F</span><span class="id"> i</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Pfin</span><span class="id"> F0</span><span class="id"> /eqP;</span><span class="id"> apply:</span><span class="id"> contraTP</span><span class="id"> =&gt;</span><span class="id"> /existsPNP[i</span><span class="id"> Pi</span><span class="id"> /eqP</span><span class="id"> Fi0]</span>.<br/>
<span class="id">rewrite</span> (<span class="id">fsbigD1</span><span class="id"> i</span>)<span class="id">//=</span><span class="id"> paddr_eq0</span><span class="id"> ?F0</span><span class="id"> ?negb_and</span><span class="id"> ?Fi0//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> fsumr_ge0//</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> [/F0-&gt;]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_setU</span><span class="id"> {T}</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Afin;</span><span class="id"> rewrite</span><span class="id"> fsbig_finite//</span><span class="id"> bigsetU_fset_set</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fsbig_setU_set1</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> \big[setU/set0]_</span>(<span class="id">x</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id"> [set</span><span class="id"> x]</span><span class="id"> =</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> fA;</span><span class="id"> rewrite</span><span class="id"> fsbig_setU//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> [t</span><span class="id"> [x</span><span class="id"> Ax</span><span class="id"> -&gt;]//|t</span><span class="id"> At];</span><span class="gallina-kwd"> exists</span><span class="id"> t</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pair_fsbig</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">I</span><span class="id"> J</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">Q</span><span class="id"> :</span><span class="id"> set</span><span class="id"> J</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> Q</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> \big[op/idx]_</span>(<span class="id">j</span><span class="id"> \in</span><span class="id"> Q</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> j</span><br/>
&nbsp;&nbsp;<span class="id">=</span><span class="id"> \big[op/idx]_</span>(<span class="id">p</span><span class="id"> \in</span><span class="id"> P</span><span class="id"> `*`</span><span class="id"> Q</span>)<span class="id"> F</span><span class="id"> p</span>.<span class="id">1</span><span class="id"> p</span>.<span class="id">2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Pfin</span><span class="id"> Qfin;</span><span class="id"> have</span><span class="id"> PQfin</span><span class="id"> :</span><span class="id"> finite_set</span> (<span class="id">P</span><span class="id"> `*`</span><span class="id"> Q</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> finite_setX</span>.<br/>
<span class="id">rewrite</span><span class="id"> !fsbig_finite//=;</span><span class="id"> under</span><span class="id"> eq_bigr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> fsbig_finite//=</span>.<br/>
<span class="id">rewrite</span><span class="id"> pair_big_dep_cond/=</span><span class="id"> fset_setX//</span>.<br/>
<span class="id">apply:</span><span class="id"> eq_fbigl</span><span class="id"> =&gt;</span><span class="id"> -[i</span><span class="id"> j]</span><span class="id"> //=;</span><span class="id"> apply/imfset2P/idP;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [x</span><span class="id"> +</span><span class="id"> [y</span><span class="id"> +</span><span class="id"> [-&gt;</span><span class="id"> -&gt;]]];</span><span class="id"> rewrite</span><span class="id"> 4!inE/=</span><span class="id"> !andbT/=</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /andP[Pi</span><span class="id"> Qi];</span><span class="gallina-kwd"> exists</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> 2?inE</span><span class="id"> ?andbT//</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> j;</span><span class="id"> rewrite</span><span class="id"> 2?inE</span><span class="id"> ?andbT</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> exchange_fsbig</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">I</span><span class="id"> J</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">Q</span><span class="id"> :</span><span class="id"> set</span><span class="id"> J</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> Q</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> \big[op/idx]_</span>(<span class="id">j</span><span class="id"> \in</span><span class="id"> Q</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> j</span><br/>
&nbsp;&nbsp;<span class="id">=</span><span class="id"> \big[op/idx]_</span>(<span class="id">j</span><span class="id"> \in</span><span class="id"> Q</span>)<span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> j</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Pfin</span><span class="id"> Qfin;</span><span class="id"> rewrite</span><span class="id"> 2?pair_fsbig//;</span><span class="id"> pose</span><span class="id"> swap</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> I</span><span class="id"> *</span><span class="id"> J</span>)<span class="id"> :=</span> (<span class="id">x</span>.<span class="id">2,</span><span class="id"> x</span>.<span class="id">1</span>).<br/>
<span class="id">apply/esym/</span>(<span class="id">reindex_fsbig</span><span class="id"> swap</span>).<br/>
<span class="id">split=&gt;</span><span class="id"> [?</span><span class="id"> [?</span><span class="id"> ?]//|[?</span><span class="id"> ?]</span><span class="id"> [?</span><span class="id"> ?]</span><span class="id"> /set_mem[?</span><span class="id"> ?]</span><span class="id"> /set_mem[?</span><span class="id"> ?]</span><span class="id"> [-&gt;</span><span class="id"> -&gt;]//|]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [i</span><span class="id"> j]</span><span class="id"> [?</span><span class="id"> ?];</span><span class="gallina-kwd"> exists</span> (<span class="id">j,</span><span class="id"> i</span>).<br/>
Qed.</div></details>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
