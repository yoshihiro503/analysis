
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.experimental_reals.xfinmap</title>
<meta name="description" content="Documentation of Coq module mathcomp.experimental_reals.xfinmap" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.experimental_reals.xfinmap</h1>
<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> all_ssreflect</span><span class="id"> all_algebra</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Export</span><span class="id"> finmap</span>.<br/>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<span class="gallina-kwd">Set</span><span class="id"> Asymmetric</span><span class="id"> Patterns</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> Order</span>.<span class="id">TTheory</span><span class="id"> GRing</span>.<span class="id">Theory</span><span class="id"> Num</span>.<span class="id">Theory</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> fset_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniq_fset_keys</span><span class="id"> {K</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">J</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> K}</span>)<span class="id"> :</span><span class="id"> uniq</span> (<span class="id">enum_fset</span><span class="id"> J</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> J</span><span class="id"> =&gt;</span><span class="id"> J</span><span class="id"> /=</span><span class="id"> /canonical_uniq</span>. Qed.</div></details>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> uniq_fset_keys</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> enum_fset0</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">enum</span> (<span class="id">fset0</span><span class="id"> :</span><span class="id"> finType</span>)<span class="id"> =</span><span class="id"> [::]</span><span class="id"> :&gt;</span><span class="id"> seq</span> (<span class="id">@fset0</span><span class="id"> T</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> enumT</span><span class="id"> unlock</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> enum_fset1</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">enum</span> (<span class="id">[fset</span><span class="id"> x]</span><span class="id"> :</span><span class="id"> finType</span>)<span class="id"> =</span><span class="id"> [::</span><span class="id"> [`fset11</span><span class="id"> x]]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/perm_small_eq=&gt;</span><span class="id"> //;</span><span class="id"> apply/uniq_perm</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/enum_uniq</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> [y</span><span class="id"> hy];</span><span class="id"> rewrite</span><span class="id"> mem_seq1</span><span class="id"> mem_enum</span><span class="id"> /in_mem</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqE</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> in_fset1</span><span class="gallina-kwd"> in</span><span class="id"> hy</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> BigFSet</span>.<br/>
<span class="vernacular">Variable</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">law</span><span class="id"> idx</span>).<br/>
<span class="vernacular">Variable</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> big_fset0_cond</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> _</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> :</span><span class="id"> @fset0</span><span class="id"> I</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> idx</span><span class="id"> :&gt;</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> big_pred0</span><span class="id"> =&gt;</span><span class="id"> -[j</span><span class="id"> hj];</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> hj;</span><span class="id"> rewrite</span><span class="id"> in_fset0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> big_fset0</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> @fset0</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> :</span><span class="id"> fset0</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> idx</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /index_enum</span><span class="id"> -enumT</span><span class="id"> /=</span><span class="id"> enum_fset0</span><span class="id"> big_nil</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> big_fset1</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> [fset</span><span class="id"> a]</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> :</span><span class="id"> [fset</span><span class="id"> a]</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> F</span> (<span class="id">FSetSub</span> (<span class="id">fset11</span><span class="id"> a</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /index_enum</span><span class="id"> -enumT</span><span class="id"> enum_fset1</span><span class="id"> big_seq1</span>. Qed.</div></details>
<span class="vernacular">End</span><span class="id"> BigFSet</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> BigFSetCom</span>.<br/>
<span class="vernacular">Variable</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;1&quot;</span><span class="id"> :=</span><span class="id"> idx</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> 1</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;'*%M'&quot;</span><span class="id"> :=</span><span class="id"> op</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;x * y&quot;</span><span class="id"> :=</span> (<span class="id">op</span><span class="id"> x</span><span class="id"> y</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> big_fset_seq_cond</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">J</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span>)<span class="id"> P</span><span class="id"> F</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\big[*%M/1]_</span>(<span class="id">x</span><span class="id"> :</span><span class="id"> J</span><span class="id"> |</span><span class="id"> P</span> (<span class="id">val</span><span class="id"> x</span>))<span class="id"> F</span> (<span class="id">val</span><span class="id"> x</span>)<br/>
&nbsp;&nbsp;<span class="id">=</span><span class="id"> \big[*%M/1]_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> enum_fset</span><span class="id"> J</span><span class="id"> |</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> F</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case:</span><span class="id"> J=&gt;</span><span class="id"> J</span><span class="id"> c;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">big_map</span><span class="id"> val</span>)<span class="id"> /index_enum</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !unlock</span><span class="id"> val_fset_sub_enum</span><span class="id"> ?canonical_uniq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> big_fset_seq</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">J</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span>)<span class="id"> F</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\big[*%M/1]_</span>(<span class="id">x</span><span class="id"> :</span><span class="id"> J</span>)<span class="id"> F</span> (<span class="id">val</span><span class="id"> x</span>)<br/>
&nbsp;&nbsp;<span class="id">=</span><span class="id"> \big[*%M/1]_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> enum_fset</span><span class="id"> J</span>)<span class="id"> F</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/big_fset_seq_cond</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> big_seq_fset_cond</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> P</span><span class="id"> F</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\big[*%M/1]_</span>(<span class="id">x</span><span class="id"> :</span><span class="id"> [fset</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> s]</span><span class="id"> |</span><span class="id"> P</span> (<span class="id">val</span><span class="id"> x</span>))<span class="id"> F</span> (<span class="id">val</span><span class="id"> x</span>)<br/>
&nbsp;&nbsp;<span class="id">=</span><span class="id"> \big[*%M/1]_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> s</span><span class="id"> |</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> F</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_s;</span><span class="id"> rewrite</span><span class="id"> big_fset_seq_cond;</span><span class="id"> apply/perm_big</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/uniq_perm=&gt;</span><span class="id"> //=</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> in_fset</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> big_seq_fset</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> F</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\big[*%M/1]_</span>(<span class="id">x</span><span class="id"> :</span><span class="id"> [fset</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> s]</span>)<span class="id"> F</span> (<span class="id">val</span><span class="id"> x</span>)<br/>
&nbsp;&nbsp;<span class="id">=</span><span class="id"> \big[*%M/1]_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> s</span>)<span class="id"> F</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/big_seq_fset_cond</span>. Qed.</div></details>
<span class="vernacular">End</span><span class="id"> BigFSetCom</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> big_fset_seq_cond</span><span class="id"> [R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> T</span><span class="id"> J]</span><span class="id"> P</span><span class="id"> F</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> big_fset_seq</span><span class="id"> [R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> T</span><span class="id"> J]</span><span class="id"> F</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> big_seq_fset_cond</span><span class="id"> [R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> T</span><span class="id"> s]</span><span class="id"> P</span><span class="id"> F</span><span class="id"> _</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> big_seq_fset</span><span class="id"> [R</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> T</span><span class="id"> s]</span><span class="id"> F</span><span class="id"> _</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> BigFSetU</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> Type}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> big_fsetU</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span>)<span class="id"> F</span><span class="id"> :</span><span class="id"> [disjoint</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> B]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">j</span><span class="id"> :</span><span class="id"> A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> F</span> (<span class="id">val</span><span class="id"> j</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">op</span> (<span class="id">\big[op/idx]_</span>(<span class="id">j</span><span class="id"> :</span><span class="id"> A</span>)<span class="id"> F</span> (<span class="id">val</span><span class="id"> j</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">\big[op/idx]_</span>(<span class="id">j</span><span class="id"> :</span><span class="id"> B</span>)<span class="id"> F</span> (<span class="id">val</span><span class="id"> j</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> dj_AB;</span><span class="id"> rewrite</span><span class="id"> !big_fset_seq</span><span class="id"> -big_cat;</span><span class="id"> apply/perm_big</span>.<br/>
<span class="id">apply/uniq_perm=&gt;</span><span class="id"> //</span>.<br/>
<span class="id">+</span><span class="id"> rewrite</span><span class="id"> cat_uniq</span><span class="id"> ?uniq_fset_keys</span><span class="id"> !</span>(<span class="id">andbT,</span><span class="id"> andTb</span>)<span class="id">;</span><span class="id"> apply/hasPn</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/fdisjointP;</span><span class="id"> rewrite</span><span class="id"> fdisjoint_sym</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mem_cat</span><span class="id"> in_fsetE</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> BigFSetU</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> BigFSetOrder</span>.<br/>
<span class="vernacular">Variable</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realDomainType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> big_fset_subset</span> (<span class="id">I</span><span class="id"> J</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> F</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> I</span><span class="id"> &lt;=</span><span class="id"> J}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> :</span><span class="id"> I</span>)<span class="id"> F</span> (<span class="id">val</span><span class="id"> i</span>)<span class="id"> &lt;=</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> :</span><span class="id"> J</span>)<span class="id"> F</span> (<span class="id">val</span><span class="id"> j</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ge0_F</span><span class="id"> le_IJ;</span><span class="id"> rewrite</span><span class="id"> !big_fset_seq</span><span class="id"> /=</span>.<br/>
<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _&lt;=X]</span>(<span class="id">bigID</span><span class="id"> [pred</span><span class="id"> j</span><span class="id"> :</span><span class="id"> T</span><span class="id"> |</span><span class="id"> j</span><span class="id"> \in</span><span class="id"> I]</span>)<span class="id"> /=</span>.<br/>
<span class="id">rewrite</span><span class="id"> ler_wpDr</span><span class="id"> ?sumr_ge0</span><span class="id"> //</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> _&lt;=X]big_filter</span>.<br/>
<span class="id">rewrite</span><span class="id"> le_eqVlt;</span><span class="id"> apply/orP;</span><span class="id"> left;</span><span class="id"> apply/eqP/perm_big</span>.<br/>
<span class="id">apply/uniq_perm;</span><span class="id"> rewrite</span><span class="id"> ?filter_uniq</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> move=&gt;</span><span class="id"> i</span>.<br/>
<span class="id">rewrite</span><span class="id"> mem_filter;</span><span class="id"> case/boolP:</span> (_<span class="id"> \in</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/le_IJ</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> big_nat_mkfset</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> :</span><span class="id"> [fset</span><span class="id"> x</span><span class="gallina-kwd"> in</span> (<span class="id">iota</span><span class="id"> 0</span><span class="id"> n</span>)<span class="id">]</span>)<span class="id"> F</span> (<span class="id">val</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">big_map</span><span class="id"> val</span><span class="id"> xpredT</span>)<span class="id"> /=;</span><span class="id"> apply/perm_big</span>.<br/>
<span class="id">apply/uniq_perm;</span><span class="id"> rewrite</span><span class="id"> ?iota_uniq</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> map_inj_uniq</span><span class="id"> /=;</span><span class="id"> last</span><span class="id"> apply/val_inj</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /index_enum</span><span class="id"> -enumT</span><span class="id"> enum_uniq</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> /index_enum</span><span class="id"> -enumT</span><span class="id"> -enum_fsetE</span><span class="id"> in_fset</span><span class="id"> /index_iota</span><span class="id"> subn0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> big_ord_mkfset</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> :</span><span class="id"> [fset</span><span class="id"> x</span><span class="gallina-kwd"> in</span> (<span class="id">iota</span><span class="id"> 0</span><span class="id"> n</span>)<span class="id">]</span>)<span class="id"> F</span> (<span class="id">val</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">big_mkord</span><span class="id"> xpredT</span>)<span class="id"> big_nat_mkfset</span>. Qed.</div></details>
<span class="vernacular">End</span><span class="id"> BigFSetOrder</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> enum_fsetT</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> finType}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">perm_eq</span> (<span class="id">enum</span><span class="id"> [fset</span><span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="gallina-kwd"> in</span><span class="id"> I]</span>) (<span class="id">enum</span><span class="id"> I</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/uniq_perm;</span><span class="id"> rewrite</span><span class="id"> ?enum_uniq</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> !mem_enum</span><span class="id"> in_imfset</span>.<br/>
Qed.</div></details>
<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
