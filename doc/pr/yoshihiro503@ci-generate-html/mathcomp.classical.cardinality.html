
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.classical.cardinality</title>
<meta name="description" content="Documentation of Coq module mathcomp.classical.cardinality" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.classical.cardinality</h1>
<span class="vernacular">From</span><span class="id"> HB</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> structures</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> all_ssreflect</span><span class="id"> finmap</span><span class="id"> ssralg</span><span class="id"> ssrnum</span><span class="id"> ssrint</span><span class="id"> rat</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> mathcomp_extra</span><span class="id"> boolp</span><span class="id"> classical_sets</span><span class="id"> functions</span>.<br/>
<br/>
<div class="ssrdoc md">
# Cardinality

This file provides an account of cardinality properties of classical sets.
This includes standard results of set theory such as the Pigeon Hole
principle, the Cantor-Bernstein Theorem, or lemmas about the cardinal of
nat, nat * nat, and rat.

Since universe polymorphism is not yet available in our framework, we
develop a relational theory of cardinals: there is no type for cardinals
only relations A #&lt;= B and A #= B to compare the cardinals of two sets
(on two possibly different types).

```
          A #&lt;= B == the cardinal of A is smaller or equal to the one of B
          A #&gt;= B := B #&lt;= A
           A #= B == the cardinal of A is equal to the cardinal of B
          A #!= B := ~~ (A #= B)
     finite_set A == the set A is finite
                  := exists n, A #= `I_n
                  &lt;-&gt; exists X : {fset T}, A = [set` X]
                  &lt;-&gt; ~ ([set: nat] #&lt;= A)
   infinite_set A := ~ finite_set A
      countable A &lt;-&gt; A is countable
                  := A #&lt;= [set: nat]
       fset_set A == the finite set corresponding if A : set T is finite,
                     set0 otherwise (T : choiceType)
             A.`1 := [fset x.1 | x in A]
             A.`2 := [fset x.2 | x in A]
{fimfun aT &gt;-&gt; T} == type of functions with a finite image
```

</div>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;A '#&lt;=' B&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 79,</span><span class="id"> format</span> <span class="id">&quot;A  '#&lt;='  B&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;A '#&gt;=' B&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 79,</span><span class="id"> format</span> <span class="id">&quot;A  '#&gt;='  B&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;A '#=' B&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 79,</span><span class="id"> format</span> <span class="id">&quot;A  '#='  B&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;A '#!=' B&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 79,</span><span class="id"> format</span> <span class="id">&quot;A  '#!='  B&quot;</span>).<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> Order</span>.<span class="id">Theory</span><span class="id"> GRing</span>.<span class="id">Theory</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> function_scope</span>.<br/>
<br/>
<span class="vernacular">Declare</span><span class="vernacular"> Scope</span><span class="id"> card_scope</span>.<br/>
<span class="vernacular">Delimit</span><span class="vernacular"> Scope</span><span class="id"> card_scope</span><span class="gallina-kwd"> with</span><span class="id"> card</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> card_scope</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> card_le</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">`[&lt;</span><span class="id"> $|{injfun</span><span class="id"> [set:</span><span class="id"> A]</span><span class="id"> &gt;-&gt;</span><span class="id"> [set:</span><span class="id"> B]}|</span><span class="id"> &gt;]</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;A '#&lt;=' B&quot;</span><span class="id"> :=</span> (<span class="id">card_le</span><span class="id"> A</span><span class="id"> B</span>)<span class="id"> :</span><span class="id"> card_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;A '#&gt;=' B&quot;</span><span class="id"> :=</span> (<span class="id">card_le</span><span class="id"> B</span><span class="id"> A</span>) (<span class="id">only</span><span class="id"> parsing</span>)<span class="id"> :</span><span class="id"> card_scope</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> card_eq</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">`[&lt;</span><span class="id"> $|{bij</span><span class="id"> [set:</span><span class="id"> A]</span><span class="id"> &gt;-&gt;</span><span class="id"> [set:</span><span class="id"> B]}|</span><span class="id"> &gt;]</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;A '#=' B&quot;</span><span class="id"> :=</span> (<span class="id">card_eq</span><span class="id"> A</span><span class="id"> B</span>)<span class="id"> :</span><span class="id"> card_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;A '#!=' B&quot;</span><span class="id"> :=</span> (<span class="id">~~</span> (<span class="id">card_eq</span><span class="id"> A</span><span class="id"> B</span>))<span class="id"> :</span><span class="id"> card_scope</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> finite_set</span><span class="id"> {T}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><span class="gallina-kwd"> exists</span><span class="id"> n,</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> `I_n</span>.<br/>
<span class="vernacular">Notation</span><span class="id"> infinite_set</span><span class="id"> A</span><span class="id"> :=</span> (<span class="id">~</span><span class="id"> finite_set</span><span class="id"> A</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> injPex</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">$|{inj</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> U}|</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U,</span><span class="id"> set_inj</span><span class="id"> A</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split=&gt;</span><span class="id"> [[f]|[_</span><span class="id"> /Pinj[f</span><span class="id"> _]]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> f</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> surjPex</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">$|{surj</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> B}|</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> f,</span><span class="id"> set_surj</span><span class="id"> A</span><span class="id"> B</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split=&gt;</span><span class="id"> [[f]|[_</span><span class="id"> /Psurj[f</span><span class="id"> _]]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> f</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bijPex</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">$|{bij</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> B}|</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> f,</span><span class="id"> set_bij</span><span class="id"> A</span><span class="id"> B</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split=&gt;</span><span class="id"> [[f]|[_</span><span class="id"> /Pbij[f</span><span class="id"> _]]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> f</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> surjfunPex</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">$|{surjfun</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> B}|</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> f,</span><span class="id"> B</span><span class="id"> =</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [[f]|[f</span><span class="id"> -&gt;]];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> squash</span><span class="id"> [fun</span><span class="id"> f</span><span class="gallina-kwd"> in</span><span class="id"> A]</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> f;</span><span class="id"> apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> surj</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> injfunPex</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}:</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">$|{injfun</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> B}|</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> exists2</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U,</span><span class="id"> set_fun</span><span class="id"> A</span><span class="id"> B</span><span class="id"> f</span><span class="id"> &amp;</span><span class="id"> set_inj</span><span class="id"> A</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split=&gt;</span><span class="id"> [[f]|[_</span><span class="id"> /Pfun[?</span><span class="id"> -&gt;]</span><span class="id"> /funPinj[f]]];</span><span class="id"> [exists</span><span class="id"> f</span><span class="id"> |</span><span class="id"> squash</span><span class="id"> f]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_leP</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> $|{injfun</span><span class="id"> [set:</span><span class="id"> A]</span><span class="id"> &gt;-&gt;</span><span class="id"> [set:</span><span class="id"> B]}|</span> (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> asboolP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> inj_card_le</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><span class="id"> {injfun</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> B}</span><span class="id"> -&gt;</span> (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> f;</span><span class="id"> apply/card_leP;</span><span class="id"> squash</span> (<span class="id">sigLR</span><span class="id"> f</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pcard_leP</span><span class="id"> {T}</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> pointedType}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> $|{injfun</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> B}|</span> (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> card_leP</span>)<span class="id"> =&gt;</span><span class="id"> -[f];</span><span class="id"> [squash</span> (<span class="id">valLR</span><span class="id"> point</span><span class="id"> f</span>)<span class="id"> |</span><span class="id"> squash</span> (<span class="id">sigLR</span><span class="id"> f</span>)<span class="id">]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pcard_leTP</span><span class="id"> {T}</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> pointedType}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> $|{inj</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> U}|</span> (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> [set:</span><span class="id"> U]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> pcard_leP</span>)<span class="id"> =&gt;</span><span class="id"> -[f];</span><span class="id"> [squash</span><span class="id"> f</span><span class="id"> |</span><span class="id"> squash</span> (<span class="id">'totalfun_A</span><span class="id"> f</span>)<span class="id">]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pcard_injP</span><span class="id"> {T}</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> pointedType}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U,</span><span class="id"> {in</span><span class="id"> A</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> f}</span>) (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> [set:</span><span class="id"> U]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> pcard_leTP</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> injPex</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ppcard_leP</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> pointedType}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> $|{splitinjfun</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> B}|</span> (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> pcard_leP</span>)<span class="id"> =&gt;</span><span class="id"> -[f];</span><span class="id"> squash</span> (<span class="id">split</span><span class="id"> f</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_ge0</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><span class="id"> @set0</span><span class="id"> T</span><span class="id"> #&lt;=</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/card_leP;</span><span class="id"> squash</span><span class="id"> set0fun</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> card_ge0</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_le0P</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> reflect</span> (<span class="id">A</span><span class="id"> =</span><span class="id"> set0</span>) (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> @set0</span><span class="id"> U</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [/card_leP[f]|-&gt;//]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -subset0</span><span class="id"> =&gt;</span><span class="id"> a</span><span class="id"> /mem_set</span><span class="id"> aA;</span><span class="id"> have</span><span class="id"> [x</span><span class="id"> /set_mem]</span><span class="id"> :=</span><span class="id"> f</span> (<span class="id">SigSub</span><span class="id"> aA</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_le0</span> <span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span> (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> @set0</span><span class="id"> U</span>)<span class="id"> =</span> (<span class="id">A</span><span class="id"> ==</span><span class="id"> set0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/card_le0P/eqP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eqP</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> $|{bij</span><span class="id"> [set:</span><span class="id"> A]</span><span class="id"> &gt;-&gt;</span><span class="id"> [set:</span><span class="id"> B]}|</span> (<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> asboolP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pcard_eq</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><span class="id"> {bij</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> B}</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> f;</span><span class="id"> apply/card_eqP;</span><span class="id"> squash</span> (<span class="id">sigLR</span><span class="id"> f</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pcard_eqP</span><span class="id"> {T}</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> pointedType}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> $|</span><span class="id"> {bij</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> B}</span><span class="id"> |</span> (<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> card_eqP</span>)<span class="id"> =&gt;</span><span class="id"> -[f];</span><span class="id"> [squash</span> (<span class="id">valLR</span><span class="id"> point</span><span class="id"> f</span>)<span class="id"> |</span><span class="id"> squash</span> (<span class="id">sigLR</span><span class="id"> f</span>)<span class="id">]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_bijP</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> f</span><span class="id"> :</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> B,</span><span class="id"> bijective</span><span class="id"> f</span>) (<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> card_eqP</span>)<span class="id"> =&gt;</span><span class="id"> [[f]|[_</span><span class="id"> /PbijTT[f</span><span class="id"> _]]];</span><span class="id"> [exists</span><span class="id"> f|squash</span><span class="id"> f]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eqVP</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> $|{splitbij</span><span class="id"> [set:</span><span class="id"> A]</span><span class="id"> &gt;-&gt;</span><span class="id"> [set:</span><span class="id"> B]}|</span> (<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> card_bijP</span>)<span class="id"> =&gt;</span><span class="id"> [[_</span><span class="id"> /PbijTT[f</span><span class="id"> _]]//|[f]];</span><span class="gallina-kwd"> exists</span><span class="id"> f</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_set_bijP</span><span class="id"> {T}</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> pointedType}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> f,</span><span class="id"> set_bij</span><span class="id"> A</span><span class="id"> B</span><span class="id"> f</span>) (<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> pcard_eqP</span>)<span class="id"> =&gt;</span><span class="id"> [[f]|[_</span><span class="id"> /Pbij[f</span><span class="id"> _]]];</span><span class="id"> [exists</span><span class="id"> f|squash</span><span class="id"> f]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ppcard_eqP</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> pointedType}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> $|</span><span class="id"> {splitbij</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> B}</span><span class="id"> |</span> (<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> pcard_eqP</span>)<span class="id"> =&gt;</span><span class="id"> -[f];</span><span class="id"> [squash</span> (<span class="id">split</span><span class="id"> f</span>)<span class="id">|squash</span><span class="id"> f]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eqxx</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/card_eqP;</span><span class="id"> squash</span><span class="id"> idfun</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> card_eqxx</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq00</span><span class="id"> T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> @set0</span><span class="id"> T</span><span class="id"> #=</span><span class="id"> @set0</span><span class="id"> U</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/card_eqP/squash;</span><span class="id"> apply:</span><span class="id"> @bijection_of_bijective</span><span class="id"> set0fun</span><span class="id"> _</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> set0fun</span><span class="id"> =&gt;</span><span class="id"> -[x</span><span class="id"> x0];</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> set_mem</span><span class="id"> x0</span>.<br/>
Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> card_eq00</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> empty1</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> emptyType</span>).<br/>
<span class="vernacular">Lemma</span><span class="id"> empty_eq0</span><span class="id"> T</span><span class="id"> :</span><span class="id"> all_equal_to</span> (<span class="id">set0</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> X;</span><span class="id"> apply/setF_eq0/no</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> card_le_emptyl</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><span class="id"> A</span><span class="id"> #&lt;=</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> empty_eq0</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> card_le_emptyr</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span> (<span class="id">B</span><span class="id"> #&lt;=</span><span class="id"> A</span>)<span class="id"> =</span> (<span class="id">B</span><span class="id"> ==</span><span class="id"> set0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> empty_eq0;</span><span class="id"> apply/idP/eqP=&gt;</span><span class="id"> [/card_le0P|-&gt;//]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> emptyE_subdef</span><span class="id"> :=</span> (<span class="id">empty_eq0,</span><span class="id"> card_le_emptyl,</span><span class="id"> card_le_emptyr,</span><span class="id"> eq_opE</span>).<br/>
<span class="vernacular">End</span><span class="id"> empty1</span>.<br/>
<br/>
<span class="vernacular">Theorem</span><span class="id"> Cantor_Bernstein</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> B</span><span class="id"> #&lt;=</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Ppointed:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> *;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !emptyE_subdef</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> -&gt;</span>.<br/>
<span class="id">elim/Ppointed:</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> U</span><span class="gallina-kwd"> in</span><span class="id"> B</span><span class="id"> *;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !emptyE_subdef</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="id">suff</span><span class="id"> {A</span><span class="id"> B}</span><span class="id"> card_eq</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> #&lt;=</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> B</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /ppcard_leP[f]</span><span class="id"> /ppcard_leP[g]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /</span>(_<span class="id"> _</span>)<span class="id">/ppcard_eqP[|h]</span><span class="id"> :=</span><span class="id"> card_eq</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">fun_image_sub</span><span class="id"> f</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/pcard_leP;</span><span class="id"> squash</span> (<span class="id">[fun</span><span class="id"> f</span><span class="gallina-kwd"> in</span><span class="id"> A]</span><span class="id"> \o</span><span class="id"> g</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/pcard_eqP;</span><span class="id"> squash</span> ((<span class="id">split</span><span class="id"> h</span>)<span class="id">^-1</span><span class="id"> \o</span><span class="id"> [fun</span><span class="id"> f</span><span class="gallina-kwd"> in</span><span class="id"> A]</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> BA</span><span class="id"> /ppcard_leP[u];</span><span class="id"> have</span><span class="id"> uAB</span><span class="id"> :=</span><span class="id"> 'funS_u</span>.<br/>
<span class="id">pose</span><span class="id"> C_</span><span class="id"> :=</span><span class="gallina-kwd"> fix</span><span class="id"> C</span><span class="id"> n</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> is</span><span class="id"> n</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="id"> u</span><span class="id"> @`</span><span class="id"> C</span><span class="id"> n</span><span class="gallina-kwd"> else</span><span class="id"> A</span><span class="id"> `\`</span><span class="id"> B</span>.<br/>
<span class="id">pose</span><span class="id"> C</span><span class="id"> :=</span><span class="id"> \bigcup_n</span><span class="id"> C_</span><span class="id"> n;</span><span class="id"> have</span><span class="id"> CA</span><span class="id"> :</span><span class="id"> C</span><span class="id"> `&lt;=`</span><span class="id"> A</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> +</span><span class="id"> []</span><span class="id"> =&gt;</span><span class="id"> /[swap];</span><span class="id"> elim=&gt;</span><span class="id"> [|i</span><span class="id"> IH]</span><span class="id"> y</span><span class="id"> _</span><span class="id"> []//</span><span class="id"> x</span><span class="id"> /IH/uAB/BA</span><span class="id"> +</span><span class="id"> &lt;-;</span><span class="id"> apply</span>.<br/>
<span class="id">have</span><span class="id"> uC:</span><span class="id"> {homo</span><span class="id"> u</span><span class="id"> :</span><span class="id"> x</span><span class="id"> /</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> C}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> =&gt;</span><span class="id"> -[i</span><span class="id"> _</span><span class="id"> Cix];</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<span class="id">+1</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
<span class="id">apply/card_set_bijP;</span><span class="gallina-kwd"> exists</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> C</span><span class="gallina-kwd"> then</span><span class="id"> u</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> Ax;</span><span class="id"> case:</span><span class="id"> ifPn;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> uAB</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/negP;</span><span class="id"> apply:</span><span class="id"> contra_notP</span><span class="id"> =&gt;</span><span class="id"> NBx;</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="gallina-kwd"> exists</span><span class="id"> 0%N</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> xA</span><span class="id"> yA;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> 'inj_u</span><span class="id"> xA</span><span class="id"> yA</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [xC|]</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> C</span>)<span class="id">;</span><span class="id"> have</span><span class="id"> [yC|]</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> C</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> +</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /[swap]&lt;-;</span><span class="id"> rewrite</span><span class="id"> uC//</span><span class="id"> xC</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /[swap]-&gt;;</span><span class="id"> rewrite</span><span class="id"> uC//</span><span class="id"> yC</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> /[dup]</span><span class="id"> By</span><span class="id"> /BA</span><span class="id"> Ay/=</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">boolP</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> C</span>))<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> ifN</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> -[[|i]/=</span><span class="id"> _</span><span class="id"> []//</span><span class="id"> x</span><span class="id"> Cix</span><span class="id"> &lt;-];</span><span class="id"> have</span><span class="id"> Cx</span><span class="id"> :</span><span class="id"> C</span><span class="id"> x</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> [exact:</span><span class="id"> CA|rewrite</span><span class="id"> ifT//</span><span class="id"> inE]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_esym</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> B</span><span class="id"> #=</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /card_eqVP[f];</span><span class="id"> apply/card_eqP;</span><span class="id"> squash</span><span class="id"> f^-1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq_le</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>)<span class="id"> =</span> (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span>)<span class="id"> &amp;&amp;</span> (<span class="id">B</span><span class="id"> #&lt;=</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/idP/andP</span><span class="id"> =&gt;</span><span class="id"> [/card_eqVP[f]|[]];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> Cantor_Bernstein</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split;</span><span class="id"> apply/card_leP;</span><span class="id"> [squash</span><span class="id"> f|squash</span><span class="id"> f^-1]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eqPle</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>)<span class="id"> &lt;-&gt;</span> (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span>)<span class="id"> /\</span> (<span class="id">B</span><span class="id"> #&lt;=</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> card_eq_le</span> (<span class="id">rwP</span><span class="id"> andP</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_lexx</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> A</span><span class="id"> #&lt;=</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/card_leP;</span><span class="id"> squash</span><span class="id"> idfun</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> card_lexx</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_leT</span><span class="id"> T</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> S</span><span class="id"> #&lt;=</span><span class="id"> [set:</span><span class="id"> T]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/card_leP;</span><span class="id"> squash</span> (<span class="id">to_setT</span><span class="id"> \o</span><span class="id"> inclT</span><span class="id"> _</span><span class="id"> \o</span><span class="id"> val</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subset_card_le</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> #&lt;=</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> AB;</span><span class="id"> apply/card_leP;</span><span class="id"> squash</span> (<span class="id">inclT</span><span class="id"> _</span><span class="id"> \o</span><span class="id"> subfun</span><span class="id"> AB</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_image_le</span><span class="id"> {T</span><span class="id"> U}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> #&lt;=</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Ppointed:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> f</span><span class="id"> *;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !emptyE_subdef</span><span class="id"> image_set0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/pcard_leP;</span><span class="id"> squash</span> (<span class="id">pinv</span><span class="id"> A</span><span class="id"> f</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> inj_card_eq</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A}</span><span class="id"> {f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U}</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> A</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /inj_bij/pcard_eq/card_esym</span>. Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> inj_card_eq</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> A</span><span class="id"> f}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_some</span><span class="id"> {T}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> :</span><span class="id"> some</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> inj_card_eq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_image</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {inj</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> U}</span>)<span class="id"> :</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> inj_card_eq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_imsub</span><span class="id"> {T</span><span class="id"> U}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> {inj</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> U}</span>)<span class="id"> X</span><span class="id"> :</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> X</span><span class="id"> #=</span><span class="id"> X</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> XA;</span><span class="id"> rewrite</span> (<span class="id">card_image</span><span class="id"> [inj</span><span class="id"> of</span><span class="id"> f</span><span class="id"> \o</span><span class="id"> incl</span><span class="id"> XA]</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_le_trans</span> (<span class="id">T</span><span class="id"> U</span><span class="id"> V</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">C</span><span class="id"> :</span><span class="id"> set</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> B</span><span class="id"> #&lt;=</span><span class="id"> C</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> #&lt;=</span><span class="id"> C</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /card_leP[f]/card_leP[g];</span><span class="id"> apply/card_leP;</span><span class="id"> squash</span> (<span class="id">g</span><span class="id"> \o</span><span class="id"> f</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq_sym</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span> (<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>)<span class="id"> =</span> (<span class="id">B</span><span class="id"> #=</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !card_eq_le</span><span class="id"> andbC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq_trans</span><span class="id"> T</span><span class="id"> U</span><span class="id"> V</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">C</span><span class="id"> :</span><span class="id"> set</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> B</span><span class="id"> #=</span><span class="id"> C</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> C</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /card_eqP[f]/card_eqP[g];</span><span class="id"> apply/card_eqP;</span><span class="id"> squash</span> (<span class="id">g</span><span class="id"> \o</span><span class="id"> f</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_le_eql</span><span class="id"> T</span><span class="id"> T'</span><span class="id"> T''</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'</span>)<span class="id"> [C</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'']</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span><span class="id"> -&gt;</span> (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> C</span>)<span class="id"> =</span> (<span class="id">B</span><span class="id"> #&lt;=</span><span class="id"> C</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /card_eqPle[*];</span><span class="id"> apply/idP/idP;</span><span class="id"> apply:</span><span class="id"> card_le_trans</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_le_eqr</span><span class="id"> T</span><span class="id"> T'</span><span class="id"> T''</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'</span>)<span class="id"> [C</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'']</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span><span class="id"> -&gt;</span> (<span class="id">C</span><span class="id"> #&lt;=</span><span class="id"> A</span>)<span class="id"> =</span> (<span class="id">C</span><span class="id"> #&lt;=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /card_eqPle[*];</span><span class="id"> apply/idP/idP</span><span class="id"> =&gt;</span><span class="id"> /card_le_trans;</span><span class="id"> apply</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eql</span><span class="id"> T</span><span class="id"> T'</span><span class="id"> T''</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'</span>)<span class="id"> [C</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'']</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span><span class="id"> -&gt;</span> (<span class="id">A</span><span class="id"> #=</span><span class="id"> C</span>)<span class="id"> =</span> (<span class="id">B</span><span class="id"> #=</span><span class="id"> C</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> e;</span><span class="id"> rewrite</span><span class="id"> !card_eq_le</span> (<span class="id">card_le_eql</span><span class="id"> e</span>) (<span class="id">card_le_eqr</span><span class="id"> e</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eqr</span><span class="id"> T</span><span class="id"> T'</span><span class="id"> T''</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'</span>)<span class="id"> [C</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'']</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span><span class="id"> -&gt;</span> (<span class="id">C</span><span class="id"> #=</span><span class="id"> A</span>)<span class="id"> =</span> (<span class="id">C</span><span class="id"> #=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> e;</span><span class="id"> rewrite</span><span class="id"> !card_eq_le</span> (<span class="id">card_le_eql</span><span class="id"> e</span>) (<span class="id">card_le_eqr</span><span class="id"> e</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_ge_image</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> V}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {inj</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> U}</span>)<span class="id"> X</span> (<span class="id">Y</span><span class="id"> :</span><span class="id"> set</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">X</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> X</span><span class="id"> #&lt;=</span><span class="id"> Y</span>)<span class="id"> =</span> (<span class="id">X</span><span class="id"> #&lt;=</span><span class="id"> Y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> XA;</span><span class="id"> rewrite</span> (<span class="id">card_le_eql</span> (<span class="id">card_imsub</span><span class="id"> _</span><span class="id"> _</span>)). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_le_image</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> V}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {inj</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> U}</span>)<span class="id"> X</span> (<span class="id">Y</span><span class="id"> :</span><span class="id"> set</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">X</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span> (<span class="id">Y</span><span class="id"> #&lt;=</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> X</span>)<span class="id"> =</span> (<span class="id">Y</span><span class="id"> #&lt;=</span><span class="id"> X</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> XA;</span><span class="id"> rewrite</span> (<span class="id">card_le_eqr</span> (<span class="id">card_imsub</span><span class="id"> _</span><span class="id"> _</span>)). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_le_image2</span><span class="id"> {T</span><span class="id"> U}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> {inj</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> U}</span>)<span class="id"> X</span><span class="id"> Y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">X</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> Y</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="id">f</span><span class="id"> @`</span><span class="id"> X</span><span class="id"> #&lt;=</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> Y</span>)<span class="id"> =</span> (<span class="id">X</span><span class="id"> #&lt;=</span><span class="id"> Y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> card_ge_image//</span><span class="id"> card_le_image</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq_image</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> V}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {inj</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> U}</span>)<span class="id"> X</span> (<span class="id">Y</span><span class="id"> :</span><span class="id"> set</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">X</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> X</span><span class="id"> #=</span><span class="id"> Y</span>)<span class="id"> =</span> (<span class="id">X</span><span class="id"> #=</span><span class="id"> Y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> XA;</span><span class="id"> rewrite</span> (<span class="id">card_eql</span> (<span class="id">card_imsub</span><span class="id"> _</span><span class="id"> _</span>)). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq_imager</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> V}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {inj</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> U}</span>)<span class="id"> X</span> (<span class="id">Y</span><span class="id"> :</span><span class="id"> set</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">X</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span> (<span class="id">Y</span><span class="id"> #=</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> X</span>)<span class="id"> =</span> (<span class="id">Y</span><span class="id"> #=</span><span class="id"> X</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> XA;</span><span class="id"> rewrite</span> (<span class="id">card_eqr</span> (<span class="id">card_imsub</span><span class="id"> _</span><span class="id"> _</span>)). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq_image2</span><span class="id"> {T</span><span class="id"> U}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> {inj</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> U}</span>)<span class="id"> X</span><span class="id"> Y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">X</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> Y</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="id">f</span><span class="id"> @`</span><span class="id"> X</span><span class="id"> #=</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> Y</span>)<span class="id"> =</span> (<span class="id">X</span><span class="id"> #=</span><span class="id"> Y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> card_eq_image//</span><span class="id"> card_eq_imager</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_ge_some</span><span class="id"> {T</span><span class="id"> T'}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">some</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> #&lt;=</span><span class="id"> B</span>)<span class="id"> =</span> (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">card_le_eql</span><span class="id"> card_some</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_le_some</span><span class="id"> {T</span><span class="id"> T'}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> some</span><span class="id"> @`</span><span class="id"> B</span>)<span class="id"> =</span> (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">card_le_eqr</span><span class="id"> card_some</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_le_some2</span><span class="id"> {T</span><span class="id"> T'}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">some</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> #&lt;=</span><span class="id"> some</span><span class="id"> @`</span><span class="id"> B</span>)<span class="id"> =</span> (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> card_ge_some</span><span class="id"> card_le_some</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq_somel</span><span class="id"> {T</span><span class="id"> T'}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">some</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> B</span>)<span class="id"> =</span> (<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">card_eql</span><span class="id"> card_some</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq_somer</span><span class="id"> {T</span><span class="id"> T'}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">A</span><span class="id"> #=</span><span class="id"> some</span><span class="id"> @`</span><span class="id"> B</span>)<span class="id"> =</span> (<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">card_eqr</span><span class="id"> card_some</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq_some2</span><span class="id"> {T</span><span class="id"> T'}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">some</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> some</span><span class="id"> @`</span><span class="id"> B</span>)<span class="id"> =</span> (<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> card_eq_somel</span><span class="id"> card_eq_somer</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq0</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> :</span> (<span class="id">A</span><span class="id"> #=</span><span class="id"> @set0</span><span class="id"> U</span>)<span class="id"> =</span> (<span class="id">A</span><span class="id"> ==</span><span class="id"> set0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> card_eq_le</span><span class="id"> card_le0</span><span class="id"> card_ge0</span><span class="id"> andbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_set1</span><span class="id"> {T}</span><span class="id"> {x</span><span class="id"> :</span><span class="id"> T}</span><span class="id"> :</span><span class="id"> [set</span><span class="id"> x]</span><span class="id"> #=</span><span class="id"> `I_1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/pcard_eqP;</span><span class="id"> suff</span><span class="id"> /Pbij[f]:</span><span class="id"> set_bij</span><span class="id"> [set</span><span class="id"> x]</span><span class="id"> `I_1</span> (<span class="id">fun=&gt;</span><span class="id"> 0%N</span>)<span class="gallina-kwd"> by</span><span class="id"> squash</span><span class="id"> f</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> [//|y</span><span class="id"> z</span><span class="id"> /[!in_setE]-&gt;</span><span class="id"> -&gt;//|[]//];</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_card1</span><span class="id"> {T</span><span class="id"> U}</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">y</span><span class="id"> :</span><span class="id"> U</span>)<span class="id"> :</span><span class="id"> [set</span><span class="id"> x]</span><span class="id"> #=</span><span class="id"> [set</span><span class="id"> y]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">card_eql</span><span class="id"> card_set1</span>) (<span class="id">card_eqr</span><span class="id"> card_set1</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq_emptyr</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> emptyType</span>)<span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">B</span><span class="id"> #=</span><span class="id"> A</span>)<span class="id"> =</span> (<span class="id">B</span><span class="id"> ==</span><span class="id"> set0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> empty_eq0;</span><span class="id"> exact:</span><span class="id"> card_eq0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq_emptyl</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> emptyType</span>)<span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>)<span class="id"> =</span> (<span class="id">B</span><span class="id"> ==</span><span class="id"> set0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> card_eq_sym</span><span class="id"> card_eq_emptyr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> emptyE</span><span class="id"> :=</span> (<span class="id">emptyE_subdef,</span><span class="id"> card_eq_emptyr,</span><span class="id"> card_eq_emptyl</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_setT</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> [set:</span><span class="id"> A]</span><span class="id"> #=</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/card_esym/card_eqP;</span><span class="id"> squash</span><span class="id"> to_setT</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> card_setT</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_setT_sym</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> [set:</span><span class="id"> A]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/card_esym/card_setT</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> card_setT</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> surj_card_ge</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><span class="id"> {surj</span><span class="id"> B</span><span class="id"> &gt;-&gt;</span><span class="id"> A}</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> #&lt;=</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> g;</span><span class="id"> rewrite</span> (<span class="id">card_le_trans</span> (<span class="id">subset_card_le</span><span class="id"> 'surj_g</span>))<span class="id"> ?card_image_le</span>.<br/>
Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> surj_card_ge</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> A</span><span class="id"> B}</span><span class="id"> g</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pcard_surjP</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> pointedType}</span><span class="id"> {U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> g,</span><span class="id"> set_surj</span><span class="id"> B</span><span class="id"> A</span><span class="id"> g</span>) (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [|[_</span><span class="id"> /Psurj[g</span><span class="id"> _]]];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> surj_card_ge</span>.<br/>
<span class="id">elim/Ppointed:</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> U</span><span class="gallina-kwd"> in</span><span class="id"> B</span><span class="id"> *;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ?emptyE</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="gallina-kwd"> exists</span><span class="id"> any</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /pcard_leP[f];</span><span class="gallina-kwd"> exists</span> (<span class="id">pinv</span><span class="id"> A</span><span class="id"> f</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> subl_surj</span><span class="id"> surj</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pcard_geP</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> pointedType}</span><span class="id"> {U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> $|{surj</span><span class="id"> B</span><span class="id"> &gt;-&gt;</span><span class="id"> A}|</span> (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> pcard_surjP</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> surjPex</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ocard_geP</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> $|{surj</span><span class="id"> B</span><span class="id"> &gt;-&gt;</span><span class="id"> some</span><span class="id"> @`</span><span class="id"> A}|</span> (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim/Pchoice:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> -card_ge_some;</span><span class="id"> apply:</span><span class="id"> pcard_geP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pfcard_geP</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="id">A</span><span class="id"> =</span><span class="id"> set0</span><span class="id"> \/</span><span class="id"> $|{surjfun</span><span class="id"> B</span><span class="id"> &gt;-&gt;</span><span class="id"> A}|</span>) (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [-&gt;//|[f]];</span><span class="id"> apply:</span><span class="id"> surj_card_ge;</span><span class="id"> exact:</span><span class="id"> f</span>.<br/>
<span class="id">elim/Ppointed:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> *;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !emptyE;</span><span class="id"> left</span>.<br/>
<span class="id">elim/Ppointed:</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> U</span><span class="gallina-kwd"> in</span><span class="id"> B</span><span class="id"> *;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !emptyE</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> right;</span><span class="id"> squash</span><span class="id"> any</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /pcard_geP[f];</span><span class="id"> case:</span> (<span class="id">eqVneq</span><span class="id"> A</span><span class="id"> set0</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> left</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /set0P[x</span><span class="id"> Ax];</span><span class="id"> right;</span><span class="id"> apply/surjfunPex</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> f</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> A</span><span class="gallina-kwd"> then</span><span class="id"> f</span><span class="id"> y</span><span class="gallina-kwd"> else</span><span class="id"> x</span>).<br/>
<span class="id">apply/seteqP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x'</span><span class="id"> /[dup]</span><span class="id"> /=</span><span class="id"> /'surj_f</span><span class="id"> [y</span><span class="id"> By</span><span class="id"> &lt;-]</span><span class="id"> Afy;</span><span class="gallina-kwd"> exists</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> ?ifT//</span><span class="id"> inE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/image_subP</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> By;</span><span class="id"> case:</span><span class="id"> ifPn;</span><span class="id"> rewrite</span> (<span class="id">inE,</span><span class="id"> notin_setE</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_le_II</span><span class="id"> n</span><span class="id"> m</span><span class="id"> :</span> (<span class="id">`I_n</span><span class="id"> #&lt;=</span><span class="id"> `I_m</span>)<span class="id"> =</span> (<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> m</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/idP/idP=&gt;</span><span class="id"> [/card_leP[f]|?];</span><br/>
&nbsp;&nbsp;<span class="id">last</span><span class="gallina-kwd"> by</span><span class="id"> apply/subset_card_le</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> /leq_trans;</span><span class="id"> apply</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /leq_card</span><span class="id"> :=</span><span class="id"> in2TT</span><span class="id"> 'inj_</span>(<span class="id">IIord</span><span class="id"> \o</span><span class="id"> f</span><span class="id"> \o</span><span class="id"> IIord^-1</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !card_ord</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ocard_eqP</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> $|{bij</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> some</span><span class="id"> @`</span><span class="id"> B}|</span> (<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Pchoice:</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> U</span><span class="gallina-kwd"> in</span><span class="id"> B</span><span class="id"> *</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">card_eqr</span><span class="id"> card_some</span>)<span class="id">;</span><span class="id"> exact:</span> (<span class="id">iffP</span><span class="id"> pcard_eqP</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> oocard_eqP</span><span class="id"> {T</span><span class="id"> U}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> {B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> $|{splitbij</span><span class="id"> some</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> some</span><span class="id"> @`</span><span class="id"> B}|</span> (<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Pchoice:</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> U</span><span class="gallina-kwd"> in</span><span class="id"> B</span><span class="id"> *;</span><span class="id"> elim/Pchoice:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> *</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">card_eql</span><span class="id"> card_some</span>)<span class="id"> -</span>(<span class="id">card_eqr</span><span class="id"> card_some</span>).<br/>
<span class="id">exact:</span> (<span class="id">iffP</span><span class="id"> ppcard_eqP</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq_II</span><span class="id"> {n</span><span class="id"> m}</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">n</span><span class="id"> =</span><span class="id"> m</span>) (<span class="id">`I_n</span><span class="id"> #=</span><span class="id"> `I_m</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> card_eq_le</span><span class="id"> !card_le_II</span><span class="id"> -eqn_leq;</span><span class="id"> apply:</span><span class="id"> eqP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_setP</span> <span class="id"> {T}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span> (<span class="id">X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> A</span>)<span class="id"> :</span><span class="id"> set_val</span><span class="id"> @`</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> [/=</span><span class="id"> a</span><span class="id"> Xa</span><span class="id"> &lt;-];</span><span class="id"> apply:</span><span class="id"> set_valP</span>. Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> sub_setP</span><span class="id"> {T</span><span class="id"> A}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> image_subset</span><span class="id"> {aT</span><span class="id"> rT}</span><span class="id"> f</span><span class="id"> [A</span><span class="id"> B]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_subP</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists2</span><span class="id"> C,</span><span class="id"> C</span><span class="id"> #=</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> C</span><span class="id"> `&lt;=`</span><span class="id"> B</span>) (<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [/card_leP[f]|[C</span><span class="id"> CA</span><span class="id"> CB]];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">card_le_eql</span><span class="id"> CA</span>)<span class="id">;</span><span class="id"> apply/card_leP;</span><span class="id"> squash</span> (<span class="id">inclT</span><span class="id"> _</span><span class="id"> \o</span><span class="id"> subfun</span><span class="id"> CB</span>).<br/>
<span class="gallina-kwd">exists</span> (<span class="id">set_val</span><span class="id"> @`</span><span class="id"> range</span><span class="id"> f</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> exact:</span> (<span class="id">subset_trans</span> (<span class="id">sub_setP</span><span class="id"> _</span>)).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">card_eql</span> (<span class="id">inj_card_eq</span><span class="id"> _</span>))<span class="id">//;</span><span class="id"> apply:</span><span class="id"> in2W;</span><span class="id"> apply:</span><span class="id"> in2TT;</span><span class="id"> apply:</span><span class="id"> inj</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pigeonhole</span><span class="id"> m</span><span class="id"> n</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> nat</span>)<span class="id"> :</span><span class="id"> {in</span><span class="id"> `I_m</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> f}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> @`</span><span class="id"> `I_m</span><span class="id"> `&lt;=`</span><span class="id"> `I_n</span><span class="id"> -&gt;</span> (<span class="id">m</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /Pinj[{}f-&gt;]</span><span class="id"> /subset_card_le</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">card_le_eql</span> (<span class="id">inj_card_eq</span><span class="id"> _</span>))<span class="id">//</span><span class="id"> card_le_II</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> countable</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><span class="id"> A</span><span class="id"> #&lt;=</span><span class="id"> @setT</span><span class="id"> nat</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_countable</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> countable</span><span class="id"> A</span><span class="id"> =</span><span class="id"> countable</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /card_le_eql</span><span class="id"> leA;</span><span class="id"> rewrite</span><span class="id"> /countable</span><span class="id"> leA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> countableP</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> countType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> countable</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/card_leP;</span><span class="id"> squash</span> (<span class="id">to_setT</span><span class="id"> \o</span><span class="id"> choice</span>.<span class="id">pickle</span>). Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> countableP</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> countable0</span><span class="id"> T</span><span class="id"> :</span><span class="id"> countable</span> (<span class="id">@set0</span><span class="id"> T</span>)<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> card_ge0</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> countable0</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> countable_injP</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> nat,</span><span class="id"> {in</span><span class="id"> A</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> f}</span>) (<span class="id">countable</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> pcard_injP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> countable_bijP</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> nat,</span> (<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>)<span class="id">%card</span>) (<span class="id">countable</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [B]</span><span class="id"> /eq_countable</span><span class="id"> -&gt;</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /pcard_leP[f];</span><span class="gallina-kwd"> exists</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> A</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/pcard_eqP;</span><span class="id"> squash</span><span class="id"> [fun</span><span class="id"> f</span><span class="gallina-kwd"> in</span><span class="id"> A]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_countable</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><span class="id"> A</span><span class="id"> #&lt;=</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">countable</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> countable</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> card_le_trans</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_setP</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> n,</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> `I_n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_II</span><span class="id"> n</span><span class="id"> :</span><span class="id"> finite_set</span><span class="id"> `I_n</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/finite_setP;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> finite_II</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_II</span><span class="id"> {n}</span><span class="id"> :</span><span class="id"> `I_n</span><span class="id"> #=</span><span class="id"> [set:</span><span class="id"> 'I_n]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/card_esym/pcard_eqP/bijPex;</span><span class="gallina-kwd"> exists</span><span class="id"> val;</span><span class="id"> split</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_fsetP</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> X</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T},</span><span class="id"> A</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> X]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> finite_setP;</span><span class="id"> split=&gt;</span><span class="id"> [[n]|[X</span><span class="id"> {A}-&gt;]];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> #|{:</span><span class="id"> X}|;</span><span class="id"> rewrite</span> (<span class="id">card_eqr</span><span class="id"> card_II</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/card_eqP;</span><span class="id"> squash</span> (<span class="id">to_setT</span><span class="id"> \o</span><span class="id"> enum_rank</span><span class="id"> \o</span><span class="id"> val_finset</span>).<br/>
<span class="id">rewrite</span> (<span class="id">card_eqr</span><span class="id"> card_II</span>)<span class="id"> =&gt;</span><span class="id"> /card_esym/card_eqVP[f];</span><span class="id"> pose</span><span class="id"> g</span><span class="id"> :=</span><span class="id"> f</span><span class="id"> \o</span><span class="id"> to_setT</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> [fset</span><span class="id"> val</span> (<span class="id">g</span><span class="id"> i</span>)<span class="id"> |</span><span class="id"> i</span><span class="gallina-kwd"> in</span><span class="id"> 'I_n]%fset</span>.<br/>
<span class="id">apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> [x</span><span class="id"> /mem_set</span><span class="id"> Ax|_</span><span class="id"> /imfsetP[i</span><span class="id"> _</span><span class="id"> -&gt;]];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> set_valP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/imfsetP;</span><span class="gallina-kwd"> exists</span> (<span class="id">g^-1</span> (<span class="id">SigSub</span><span class="id"> Ax</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?[g</span><span class="id"> _]invK//=</span><span class="id"> inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_subfset</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">X</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span>)<span class="id"> {A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> `&lt;=`</span><span class="id"> [set`</span><span class="id"> X]</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> AX;</span><span class="id"> apply/finite_fsetP;</span><span class="gallina-kwd"> exists</span><span class="id"> [fset</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> |</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> A]%fset</span>.<br/>
<span class="id">apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> ?inE;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /andP[_</span><span class="id"> /set_mem]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Ax;</span><span class="id"> rewrite</span><span class="id"> mem_set</span><span class="id"> ?andbT//;</span><span class="id"> apply:</span><span class="id"> AX</span>.<br/>
Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> finite_subfset</span><span class="id"> {T}</span><span class="id"> X</span><span class="id"> {A}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_set0</span><span class="id"> T</span><span class="id"> :</span><span class="id"> finite_set</span> (<span class="id">set0</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/finite_setP;</span><span class="gallina-kwd"> exists</span><span class="id"> 0%N;</span><span class="id"> rewrite</span><span class="id"> II0</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> finite_set0</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_seqP</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> eqType}</span><span class="id"> A</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T,</span><span class="id"> A</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> s]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/eqPchoice:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> finite_fsetP</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> [[X</span><span class="id"> -&gt;]|[s</span><span class="id"> -&gt;]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> X</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> [fset</span><span class="id"> x</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> s]%fset;</span><span class="id"> apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_seq</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> eqType}</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> [set`</span><span class="id"> s]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/finite_seqP;</span><span class="gallina-kwd"> exists</span><span class="id"> s</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> finite_seq</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_fset</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">X</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> [set`</span><span class="id"> X]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/finite_fsetP;</span><span class="gallina-kwd"> exists</span><span class="id"> X</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> finite_fset</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_finpred</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> finType}</span><span class="id"> {pT</span><span class="id"> :</span><span class="id"> predType</span><span class="id"> T}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> pT</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> [set`</span><span class="id"> P]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> finite_seqP;</span><span class="gallina-kwd"> exists</span> (<span class="id">enum</span><span class="id"> P</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> x/=;</span><span class="id"> rewrite</span><span class="id"> mem_enum</span>.<br/>
Qed.</div></details>
<span class="id">#[global]</span><br/>
<span class="vernacular">Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">finite_set</span><span class="id"> [set`</span><span class="id"> _]</span>)<span class="id"> =&gt;</span><span class="id"> solve</span><span class="id"> [apply:</span><span class="id"> finite_finpred]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_finset</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> finType}</span><span class="id"> {X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span><span class="id"> :</span><span class="id"> finite_set</span><span class="id"> X</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> X</span><span class="id"> =</span><span class="id"> [set`</span><span class="id"> mem</span><span class="id"> X]</span><span class="gallina-kwd"> by</span><span class="id"> apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> ?inE</span>.<br/>
Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> finite_finset</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_set_countable</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> countable</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /finite_setP[n</span><span class="id"> /eq_countable-&gt;]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infiniteP</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> infinite_set</span><span class="id"> A</span><span class="id"> &lt;-&gt;</span><span class="id"> [set:</span><span class="id"> nat]</span><span class="id"> #&lt;=</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Ppointed:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !emptyE;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> /</span>(<span class="id">congr1</span> (<span class="id">@^~</span><span class="id"> 0%N</span>))<span class="id">/=;</span><span class="id"> rewrite</span><span class="id"> propeqE</span><span class="id"> =&gt;</span><span class="id"> -[]</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> [Ainfinite|</span><span class="id"> +</span><span class="id"> /finite_setP[n</span><span class="id"> eqAI]];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">card_le_eqr</span><span class="id"> eqAI</span>)<span class="id"> =&gt;</span><span class="id"> le_nat_n</span>.<br/>
&nbsp;&nbsp;<span class="id">suff:</span><span class="id"> `I_n</span>.<span class="id">+1</span><span class="id"> #&lt;=</span><span class="id"> `I_n</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> card_le_II</span><span class="id"> ltnn</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> card_le_trans</span> (<span class="id">subset_card_le</span><span class="id"> _</span>)<span class="id"> le_nat_n</span>.<br/>
<span class="id">have</span><span class="id"> /all_sig2[f</span><span class="id"> Af</span><span class="id"> fX]</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> X</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T},</span><span class="id"> {x</span><span class="id"> |</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> X}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> X;</span><span class="id"> apply/sig2W;</span><span class="id"> apply:</span><span class="id"> contra_notP</span><span class="id"> Ainfinite</span><span class="id"> =&gt;</span><span class="id"> nAX;</span><span class="id"> apply/finite_fsetP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> [fset</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> |</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> A]%fset;</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x/=;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> =&gt;</span><span class="id"> /andP[_];</span><span class="id"> rewrite</span><span class="id"> inE</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> Ax</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> !inE/=;</span><span class="id"> apply/andP;</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> ?inE//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra_notT</span><span class="id"> nAX</span><span class="id"> =&gt;</span><span class="id"> xNX;</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> ?inE</span>.<br/>
<span class="id">do</span><span class="id"> [under</span><span class="id"> [forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> _},</span><span class="id"> _]eq_forall</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> inE]</span><span class="gallina-kwd"> in</span><span class="id"> Af</span><span class="id"> *</span>.<br/>
<span class="id">suff</span><span class="id"> [g</span><span class="id"> gE]</span><span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> g</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> T,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> g</span><span class="id"> n</span><span class="id"> =</span><span class="id"> f</span><span class="id"> [fset</span><span class="id"> g</span><span class="id"> k</span><span class="id"> |</span><span class="id"> k</span><span class="gallina-kwd"> in</span><span class="id"> iota</span><span class="id"> 0</span><span class="id"> n]%fset</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /Pinj[h</span><span class="id"> hE]</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> setT</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> g}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> contra_eq;</span><span class="id"> wlog</span><span class="id"> lt_ij</span><span class="id"> :</span><span class="id"> i</span><span class="id"> j</span><span class="id"> /</span> (<span class="id">i</span><span class="id"> &lt;</span><span class="id"> j</span>)<span class="id">%N</span><span class="id"> =&gt;</span><span class="id"> [hwlog|_]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ltngtP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ij</span><span class="id"> _;</span><span class="id"> [|rewrite</span><span class="id"> eq_sym];</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> hwlog=&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> lt_eqF//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [g</span><span class="id"> j]gE;</span><span class="id"> set</span><span class="id"> X</span><span class="id"> :=</span> (<span class="id">X</span><span class="gallina-kwd"> in</span><span class="id"> f</span><span class="id"> X</span>)<span class="id">;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> fX</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contraNneq</span><span class="id"> =&gt;</span><span class="id"> &lt;-;</span><span class="id"> apply/imfsetP;</span><span class="gallina-kwd"> exists</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> mem_iota</span>.<br/>
&nbsp;&nbsp;<span class="id">have/injPfun[i</span><span class="id"> _]</span><span class="id"> :</span><span class="id"> {homo</span><span class="id"> h</span><span class="id"> :</span><span class="id"> x</span><span class="id"> /</span><span class="id"> setT</span><span class="id"> x</span><span class="id"> &gt;-&gt;</span><span class="id"> A</span><span class="id"> x}</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> -hE</span><span class="id"> gE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/pcard_leP;</span><span class="id"> squash</span><span class="id"> i</span>.<br/>
<span class="id">pose</span><span class="id"> g</span><span class="id"> :=</span><span class="gallina-kwd"> fix</span><span class="id"> g</span><span class="id"> n</span><span class="id"> k</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> isn't</span><span class="id"> n'</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="id"> f</span><span class="id"> fset0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="id"> f</span><span class="id"> [fset</span><span class="id"> g</span><span class="id"> n'</span><span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="gallina-kwd"> in</span><span class="id"> iota</span><span class="id"> 0</span><span class="id"> k]%fset</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> g</span><span class="id"> n</span><span class="id"> n</span>)<span class="id"> =&gt;</span><span class="id"> n</span>.<br/>
<span class="id">suff</span><span class="id"> {n}</span><span class="id"> gn</span><span class="id"> n</span><span class="id"> k</span><span class="id"> :</span> (<span class="id">k</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> g</span><span class="id"> n</span><span class="id"> k</span><span class="id"> =</span><span class="id"> f</span><span class="id"> [fset</span><span class="id"> g</span><span class="id"> k</span><span class="id"> k</span><span class="id"> |</span><span class="id"> k</span><span class="gallina-kwd"> in</span><span class="id"> iota</span><span class="id"> 0</span><span class="id"> k]%fset</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> gn//;</span><span class="id"> congr</span><span class="id"> f;</span><span class="id"> apply/fsetP</span><span class="id"> =&gt;</span><span class="id"> k</span>.<br/>
<span class="id">have</span><span class="id"> [m]</span><span class="id"> :=</span><span class="id"> ubnP</span><span class="id"> n;</span><span class="id"> elim:</span><span class="id"> m</span><span class="id"> n</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> m</span><span class="id"> IHm</span><span class="id"> [|n]</span><span class="id"> k</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> leqn0</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /eqP-&gt;/=</span>.<br/>
&nbsp;&nbsp;<span class="id">congr</span><span class="id"> f;</span><span class="id"> apply/fsetP</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE;</span><span class="id"> symmetry</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/imfsetP</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> -[]</span>.<br/>
<span class="id">rewrite</span><span class="id"> ltnS</span><span class="id"> =&gt;</span><span class="id"> ltmn</span><span class="id"> lekSn</span><span class="id"> /=;</span><span class="id"> congr</span><span class="id"> f;</span><span class="id"> apply/fsetP</span><span class="id"> =&gt;</span><span class="id"> i</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/imfsetP/imfsetP</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> -[j];</span><span class="id"> rewrite</span><span class="id"> mem_iota/=</span><span class="id"> =&gt;</span><span class="id"> jk</span><span class="id"> -&gt;;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> j;</span><span class="id"> rewrite</span><span class="id"> ?mem_iota//=</span><span class="id"> ?add0n</span><span class="id"> ?IHm//;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> [rewrite</span> (<span class="id">leq_trans</span><span class="id"> jk</span>)<span class="id">//</span> (<span class="id">leq_trans</span><span class="id"> lekSn</span>)<span class="id">|rewrite</span><span class="id"> -ltnS</span> (<span class="id">leq_trans</span><span class="id"> jk</span>)<span class="id">]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_setPn</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> &lt;-&gt;</span><span class="id"> ~</span> (<span class="id">[set:</span><span class="id"> nat]</span><span class="id"> #&lt;=</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -infiniteP</span><span class="id"> notK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_le_finite</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> !finite_setPn;</span><span class="id"> apply:</span><span class="id"> contra_not</span><span class="id"> =&gt;</span><span class="id"> /card_le_trans;</span><span class="id"> apply</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_finite_set</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> apply/card_le_finite/subset_card_le</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_set_leP</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> n,</span><span class="id"> A</span><span class="id"> #&lt;=</span><span class="id"> `I_n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [[n</span><span class="id"> /card_eqPle[]]|[n</span><span class="id"> leAn]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> card_le_finite</span><span class="id"> leAn</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_ge_preimage</span><span class="id"> {T</span><span class="id"> U}</span> (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> B</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> B</span><span class="id"> #&lt;=</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /Pinj[g</span><span class="id"> eqg];</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">card_le_eql</span> (<span class="id">card_image</span><span class="id"> g</span>))<span class="id"> -eqg</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subset_card_le;</span><span class="id"> apply:</span><span class="id"> image_preimage_subset</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Corollary</span><span class="id"> finite_preimage</span><span class="id"> {T</span><span class="id"> U}</span> (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> B</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> finite_set</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /card_ge_preimage</span><span class="id"> fB;</span><span class="id"> apply:</span><span class="id"> card_le_finite</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_finite_set</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> =</span><span class="id"> finite_set</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eqAB;</span><span class="id"> apply/propeqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> -[n</span><span class="id"> Xn];</span><span class="gallina-kwd"> exists</span><span class="id"> n;</span><span class="id"> move:</span><span class="id"> Xn;</span><span class="id"> rewrite</span> (<span class="id">card_eql</span><span class="id"> eqAB</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_le_setD</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> A</span><span class="id"> `\`</span><span class="id"> B</span><span class="id"> #&lt;=</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> subset_card_le;</span><span class="id"> rewrite</span><span class="id"> setDE;</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_image</span><span class="id"> T</span><span class="id"> T'</span><span class="id"> A</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T'</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/card_le_finite/card_image_le</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_set1</span><span class="id"> T</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> [set</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Pchoice:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> x</span><span class="id"> *</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/finite_fsetP;</span><span class="gallina-kwd"> exists</span> (<span class="id">fset1</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> set_fset1</span>.<br/>
Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> finite_set1</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_setD</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span> (<span class="id">A</span><span class="id"> `\`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/card_le_finite/card_le_setD</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_setU</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> =</span> (<span class="id">finite_set</span><span class="id"> A</span><span class="id"> /\</span><span class="id"> finite_set</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> fP</span><span class="id"> :=</span><span class="id"> @finite_fsetP</span><span class="id"> {classic</span><span class="id"> T};</span><span class="id"> rewrite</span><span class="id"> propeqE;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> finAUB;</span><span class="id"> split;</span><span class="id"> apply:</span><span class="id"> sub_finite_set</span><span class="id"> finAUB</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> /fP[X-&gt;]/fP[Y-&gt;];</span><span class="id"> apply/fP;</span><span class="gallina-kwd"> exists</span> (<span class="id">X</span><span class="id"> `|`</span><span class="id"> Y</span>)<span class="id">%fset;</span><span class="id"> rewrite</span><span class="id"> set_fsetU</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_set2</span><span class="id"> T</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> [set</span><span class="id"> x;</span><span class="id"> y]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !finite_setU;</span><span class="id"> split;</span><span class="id"> apply:</span><span class="id"> finite_set1</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> finite_set2</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_set3</span><span class="id"> T</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> [set</span><span class="id"> x;</span><span class="id"> y;</span><span class="id"> z]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !finite_setU;</span><span class="id"> do</span><span class="id"> !split;</span><span class="id"> apply:</span><span class="id"> finite_set1</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> finite_set3</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_set4</span><span class="id"> T</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> t</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> [set</span><span class="id"> x;</span><span class="id"> y;</span><span class="id"> z;</span><span class="id"> t]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !finite_setU;</span><span class="id"> do</span><span class="id"> !split;</span><span class="id"> apply:</span><span class="id"> finite_set1</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> finite_set4</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_set5</span><span class="id"> T</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> t</span><span class="id"> u</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> [set</span><span class="id"> x;</span><span class="id"> y;</span><span class="id"> z;</span><span class="id"> t;</span><span class="id"> u]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !finite_setU;</span><span class="id"> do</span><span class="id"> !split;</span><span class="id"> apply:</span><span class="id"> finite_set1</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> finite_set5</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_set6</span><span class="id"> T</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> t</span><span class="id"> u</span><span class="id"> v</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> [set</span><span class="id"> x;</span><span class="id"> y;</span><span class="id"> z;</span><span class="id"> t;</span><span class="id"> u;</span><span class="id"> v]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !finite_setU;</span><span class="id"> do</span><span class="id"> !split;</span><span class="id"> apply:</span><span class="id"> finite_set1</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> finite_set6</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_set7</span><span class="id"> T</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> t</span><span class="id"> u</span><span class="id"> v</span><span class="id"> w</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> [set</span><span class="id"> x;</span><span class="id"> y;</span><span class="id"> z;</span><span class="id"> t;</span><span class="id"> u;</span><span class="id"> v;</span><span class="id"> w]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !finite_setU;</span><span class="id"> do</span><span class="id"> !split;</span><span class="id"> apply:</span><span class="id"> finite_set1</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> finite_set7</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_setI</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">finite_set</span><span class="id"> A</span><span class="id"> \/</span><span class="id"> finite_set</span><span class="id"> B</span>)<span class="id"> -&gt;</span><span class="id"> finite_set</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> case;</span><span class="id"> apply:</span><span class="id"> contraPP;</span><span class="id"> rewrite</span><span class="id"> !infiniteP</span><span class="id"> =&gt;</span><span class="id"> /card_le_trans;</span><span class="id"> apply;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> subset_card_le</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_setIl</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> apply:</span><span class="id"> finite_setI;</span><span class="id"> left</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_setIr</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> finite_set</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> apply:</span><span class="id"> finite_setI;</span><span class="id"> right</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_setX</span><span class="id"> T</span><span class="id"> T'</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> finite_set</span> (<span class="id">A</span><span class="id"> `*`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Pchoice:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> *;</span><span class="id"> elim/Pchoice:</span><span class="id"> T'</span><span class="id"> =&gt;</span><span class="id"> T'</span><span class="gallina-kwd"> in</span><span class="id"> B</span><span class="id"> *</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /finite_fsetP[{}A</span><span class="id"> -&gt;]</span><span class="id"> /finite_fsetP[{}B</span><span class="id"> -&gt;]</span>.<br/>
<span class="id">apply/finite_fsetP;</span><span class="gallina-kwd"> exists</span> (<span class="id">A</span><span class="id"> `*`</span><span class="id"> B</span>)<span class="id">%fset;</span><span class="id"> apply/predeqP</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /andP</span>.<br/>
Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.3.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed to finite_setX.&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> finite_setM</span><span class="id"> :=</span><span class="id"> finite_setX</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_image2</span><span class="id"> [aT</span><span class="id"> bT</span><span class="id"> rT</span><span class="id"> :</span><span class="id"> Type]</span><span class="id"> [A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> aT]</span><span class="id"> [B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> bT]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> bT</span><span class="id"> -&gt;</span><span class="id"> rT</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> [set</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> y</span><span class="gallina-kwd"> in</span><span class="id"> B]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> fA</span><span class="id"> fB;</span><span class="id"> rewrite</span><span class="id"> image2E;</span><span class="id"> exact/finite_image/finite_setX</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_image11</span><span class="id"> [xT</span><span class="id"> aT</span><span class="id"> bT</span><span class="id"> rT</span><span class="id"> :</span><span class="id"> Type]</span><span class="id"> [X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> xT]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">g</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> bT</span><span class="id"> -&gt;</span><span class="id"> rT</span>) (<span class="id">fa</span><span class="id"> :</span><span class="id"> xT</span><span class="id"> -&gt;</span><span class="id"> aT</span>) (<span class="id">fb</span><span class="id"> :</span><span class="id"> xT</span><span class="id"> -&gt;</span><span class="id"> bT</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span> (<span class="id">fa</span><span class="id"> @`</span><span class="id"> X</span>)<span class="id"> -&gt;</span><span class="id"> finite_set</span> (<span class="id">fb</span><span class="id"> @`</span><span class="id"> X</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> [set</span><span class="id"> g</span> (<span class="id">fa</span><span class="id"> x</span>) (<span class="id">fb</span><span class="id"> x</span>)<span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> X]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /</span>(<span class="id">finite_image2</span><span class="id"> g</span>)<span class="id"> /[apply];</span><span class="id"> apply:</span><span class="id"> sub_finite_set;</span><span class="id"> rewrite</span><span class="id"> image2E</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> r/=</span><span class="id"> [x</span><span class="id"> Xx</span><span class="id"> &lt;-];</span><span class="gallina-kwd"> exists</span> (<span class="id">fa</span><span class="id"> x,</span><span class="id"> fb</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> fset_set</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> pselect</span> (<span class="id">finite_set</span><span class="id"> A</span>)<span class="id"> is</span><span class="id"> left</span><span class="id"> Afin</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">then</span><span class="id"> projT1</span> (<span class="id">cid</span> (<span class="id">finite_fsetP</span>.<span class="id">1</span><span class="id"> Afin</span>))<span class="gallina-kwd"> else</span><span class="id"> fset0</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_setK</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[set`</span><span class="id"> fset_set</span><span class="id"> A]</span><span class="id"> =</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /fset_set;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> Afin</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> cid</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> in_fset_set</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">fset_set</span><span class="id"> A</span><span class="id"> =i</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> fA</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -[A</span><span class="gallina-kwd"> in</span><span class="id"> RHS]fset_setK//;</span><span class="id"> apply/idP/idP;</span><span class="id"> rewrite</span><span class="id"> ?inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_set_sub</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> B</span><span class="id"> =</span> (<span class="id">fset_set</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> fset_set</span><span class="id"> B</span>)<span class="id">%fset</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> finA</span><span class="id"> finB;</span><span class="id"> apply/propext;</span><span class="id"> split=&gt;</span><span class="id"> [AB|/fsubsetP</span><span class="id"> AB</span><span class="id"> t]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/fsubsetP</span><span class="id"> =&gt;</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> in_fset_set//</span><span class="id"> in_fset_set//</span><span class="id"> 2!inE</span><span class="id"> =&gt;</span><span class="id"> /AB</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> AB</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> !in_fset_set//</span><span class="id"> !inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_set_set0</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">fset_set</span><span class="id"> A</span><span class="id"> =</span><span class="id"> fset0</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> =</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> finA;</span><span class="id"> rewrite</span><span class="id"> /fset_set;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> {}finA</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> _/=</span><span class="id"> -&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> set_fset0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_set0</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> :</span><span class="id"> fset_set</span> (<span class="id">set0</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> =</span><span class="id"> fset0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply/fsetP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> in_fset_set</span><span class="id"> ?inE//;</span><span class="id"> apply/negP;</span><span class="id"> rewrite</span><span class="id"> inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_set1</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> fset_set</span><span class="id"> [set</span><span class="id"> x]</span><span class="id"> =</span><span class="id"> [fset</span><span class="id"> x]%fset</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/fsetP=&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> in_fset_set</span><span class="id"> ?inE//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/idP/idP;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /eqP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_setU</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">fset_set</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> =</span> (<span class="id">fset_set</span><span class="id"> A</span><span class="id"> `|`</span><span class="id"> fset_set</span><span class="id"> B</span>)<span class="id">%fset</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> fA</span><span class="id"> fB;</span><span class="id"> apply/fsetP=&gt;</span><span class="id"> x</span>.<br/>
<span class="id">rewrite</span><span class="id"> ?</span>(<span class="id">inE,</span><span class="id"> in_fset_set</span>)<span class="id">//;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> finite_setU</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/idP/orP;</span><span class="id"> rewrite</span><span class="id"> ?inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_setI</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">fset_set</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> =</span> (<span class="id">fset_set</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> fset_set</span><span class="id"> B</span>)<span class="id">%fset</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> fA</span><span class="id"> fB;</span><span class="id"> apply/fsetP=&gt;</span><span class="id"> x</span>.<br/>
<span class="id">rewrite</span><span class="id"> ?</span>(<span class="id">inE,</span><span class="id"> in_fset_set</span>)<span class="id">//;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> finite_setI;</span><span class="id"> left</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/idP/andP;</span><span class="id"> rewrite</span><span class="id"> ?inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_setU1</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> fset_set</span> (<span class="id">x</span><span class="id"> |`</span><span class="id"> A</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> |`</span><span class="id"> fset_set</span><span class="id"> A</span>)<span class="id">%fset</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> fA;</span><span class="id"> rewrite</span><span class="id"> fset_setU//</span><span class="id"> fset_set1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_setD</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">fset_set</span> (<span class="id">A</span><span class="id"> `\`</span><span class="id"> B</span>)<span class="id"> =</span> (<span class="id">fset_set</span><span class="id"> A</span><span class="id"> `\`</span><span class="id"> fset_set</span><span class="id"> B</span>)<span class="id">%fset</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> fA</span><span class="id"> fB;</span><span class="id"> apply/fsetP=&gt;</span><span class="id"> x</span>.<br/>
<span class="id">rewrite</span><span class="id"> ?</span>(<span class="id">inE,</span><span class="id"> in_fset_set</span>)<span class="id">//;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> finite_setD</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/idP/andP;</span><span class="id"> rewrite</span><span class="id"> ?inE</span><span class="id"> =&gt;</span><span class="id"> -[];</span><span class="id"> rewrite</span><span class="id"> ?notin_setE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_setD1</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> fset_set</span> (<span class="id">A</span><span class="id"> `\</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="id">fset_set</span><span class="id"> A</span><span class="id"> `\</span><span class="id"> x</span>)<span class="id">%fset</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> fA;</span><span class="id"> rewrite</span><span class="id"> fset_setD//</span><span class="id"> fset_set1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_setX</span><span class="id"> {T1</span><span class="id"> T2</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T1</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">fset_set</span> (<span class="id">A</span><span class="id"> `*`</span><span class="id"> B</span>)<span class="id"> =</span> (<span class="id">fset_set</span><span class="id"> A</span><span class="id"> `*`</span><span class="id"> fset_set</span><span class="id"> B</span>)<span class="id">%fset</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Afin</span><span class="id"> Bfin;</span><span class="id"> have</span><span class="id"> ABfin</span><span class="id"> :</span><span class="id"> finite_set</span> (<span class="id">A</span><span class="id"> `*`</span><span class="id"> B</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> finite_setX</span>.<br/>
<span class="id">apply/fsetP</span><span class="id"> =&gt;</span><span class="id"> i;</span><span class="id"> apply/idP/idP;</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">inE,</span><span class="id"> in_fset_set</span>)<span class="id">//=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [/mem_set-&gt;</span><span class="id"> /mem_set-&gt;]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /andP[];</span><span class="id"> rewrite</span><span class="id"> !inE</span>.<br/>
Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.3.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed to fset_setX.&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> fset_setM</span><span class="id"> :=</span><span class="id"> fset_setX</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> fst_fset</span> (<span class="id">T1</span><span class="id"> T2</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> {fset</span> (<span class="id">T1</span><span class="id"> *</span><span class="id"> T2</span>)<span class="id">}</span>)<span class="id"> :</span><span class="id"> {fset</span><span class="id"> T1}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[fset</span><span class="id"> x</span>.<span class="id">1</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> A]%fset</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> snd_fset</span> (<span class="id">T1</span><span class="id"> T2</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> {fset</span> (<span class="id">T1</span><span class="id"> *</span><span class="id"> T2</span>)<span class="id">}</span>)<span class="id"> :</span><span class="id"> {fset</span><span class="id"> T2}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[fset</span><span class="id"> x</span>.<span class="id">2</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> A]%fset</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;A .`1&quot;</span><span class="id"> :=</span> (<span class="id">fst_fset</span><span class="id"> A</span>)<span class="id"> :</span><span class="id"> fset_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;A .`2&quot;</span><span class="id"> :=</span> (<span class="id">snd_fset</span><span class="id"> A</span>)<span class="id"> :</span><span class="id"> fset_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_set_fst</span> (<span class="id">T1</span><span class="id"> T2</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">T1</span><span class="id"> *</span><span class="id"> T2</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> A</span>.<span class="id">`1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /finite_fsetP[B</span><span class="id"> A_B];</span><span class="id"> apply/finite_fsetP;</span><span class="gallina-kwd"> exists</span> (<span class="id">B</span>.<span class="id">`1</span>)<span class="id">%fset</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> [x/=</span><span class="id"> [y]|_/=</span><span class="id"> /imfsetP[[x1</span><span class="id"> x2]/=</span><span class="id"> +]</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> A_B;</span><br/>
&nbsp;&nbsp;<span class="id">[move=&gt;</span><span class="id"> xyB;</span><span class="id"> apply/imfsetP;</span><span class="gallina-kwd"> exists</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id">|move=&gt;</span><span class="id"> ?;</span><span class="gallina-kwd"> exists</span><span class="id"> x2]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_set_snd</span> (<span class="id">T1</span><span class="id"> T2</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">T1</span><span class="id"> *</span><span class="id"> T2</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> A</span>.<span class="id">`2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /finite_fsetP[B</span><span class="id"> A_B];</span><span class="id"> apply/finite_fsetP;</span><span class="gallina-kwd"> exists</span> (<span class="id">B</span>.<span class="id">`2</span>)<span class="id">%fset</span>.<br/>
<span class="id">apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> [y/=</span><span class="id"> [x]|_/=</span><span class="id"> /imfsetP[[x1</span><span class="id"> x2]/=</span><span class="id"> +]</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> A_B;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> [move=&gt;</span><span class="id"> xyB;</span><span class="id"> apply/imfsetP;</span><span class="gallina-kwd"> exists</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id">|move=&gt;</span><span class="id"> ?;</span><span class="gallina-kwd"> exists</span><span class="id"> x1]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigcup_finite</span><span class="id"> {I</span><span class="id"> T}</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> finite_set</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span> (<span class="id">\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Pchoice:</span><span class="id"> I</span><span class="id"> =&gt;</span><span class="id"> I</span><span class="gallina-kwd"> in</span><span class="id"> D</span><span class="id"> F</span><span class="id"> *</span>.<br/>
<span class="id">elim/Ppointed:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> F</span><span class="id"> *;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> emptyE</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> Dfin</span><span class="id"> Ffin;</span><span class="id"> pose</span><span class="id"> G</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> fset_set</span><span class="id"> D</span>)<span class="id"> :=</span><span class="id"> fset_set</span> (<span class="id">F</span> (<span class="id">val</span><span class="id"> i</span>)).<br/>
<span class="id">suff:</span> (<span class="id">\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> #&lt;=</span><span class="id"> [set:</span><span class="id"> {i</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> i}]</span>)<span class="id">%card</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /card_le_finite;</span><span class="id"> apply;</span><span class="id"> apply:</span><span class="id"> finite_finset</span>.<br/>
<span class="id">apply/pcard_geP/surjPex</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="gallina-kwd">fun</span> (<span class="id">k</span><span class="id"> :</span><span class="id"> {i</span><span class="id"> :</span><span class="id"> fset_set</span><span class="id"> D</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> i}</span>)<span class="id"> =&gt;</span><span class="id"> val</span> (<span class="id">projT2</span><span class="id"> k</span>)).<br/>
<span class="id">move=&gt;</span><span class="id"> y</span><span class="id"> [i</span><span class="id"> Di</span><span class="id"> Fky]/=</span>.<br/>
<span class="id">have</span><span class="id"> Dk</span><span class="id"> :</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> fset_set</span><span class="id"> D</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> in_fset_set//</span><span class="id"> inE</span>.<br/>
<span class="id">pose</span><span class="id"> k</span><span class="id"> :</span><span class="id"> fset_set</span><span class="id"> D</span><span class="id"> :=</span><span class="id"> [`</span><span class="id"> Dk]%fset</span>.<br/>
<span class="id">have</span><span class="id"> Gy</span><span class="id"> :</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> k</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> in_fset_set</span><span class="id"> ?inE//;</span><span class="id"> apply:</span><span class="id"> Ffin</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">Tagged</span><span class="id"> G</span><span class="id"> [`</span><span class="id"> Gy]%fset</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> trivIset_sum_card</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> finite_set</span> (<span class="id">F</span><span class="id"> n</span>))<span class="id"> -&gt;</span><span class="id"> trivIset</span><span class="id"> [set:</span><span class="id"> nat]</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> #|`</span><span class="id"> fset_set</span> (<span class="id">F</span><span class="id"> i</span>)<span class="id">|</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">#|`</span><span class="id"> fset_set</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> k</span>)<span class="id">|</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> finF</span><span class="id"> tF;</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> ih];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !big_ord0</span><span class="id"> fset_set0</span>.<br/>
<span class="id">rewrite</span><span class="id"> big_ord_recr//=</span><span class="id"> ih</span><span class="id"> big_ord_recr/=</span><span class="id"> fset_setU//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -bigcup_mkord;</span><span class="id"> exact:</span><span class="id"> bigcup_finite</span>.<br/>
<span class="id">rewrite</span><span class="id"> cardfsU</span><span class="id"> [X</span><span class="gallina-kwd"> in</span> (_<span class="id"> -</span><span class="id"> X</span>)<span class="id">%N]</span>(_<span class="id"> :</span><span class="id"> _</span> <span class="id"> =</span><span class="id"> O</span>)<span class="id"> ?subn0//</span><span class="id"> ?EFinD</span><span class="id"> ?natrD//</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> cardfs_eq0</span><span class="id"> -fset_setI//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -bigcup_mkord;</span><span class="id"> exact:</span><span class="id"> bigcup_finite</span>.<br/>
<span class="id">rewrite</span> (<span class="id">@trivIset_bigsetUI</span><span class="id"> _</span><span class="id"> xpredT</span>)<span class="id">//</span><span class="id"> ?fset_set0//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> trivIset</span><span class="id"> X</span><span class="id"> F]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> [set:</span><span class="id"> nat]</span>)<span class="id">//;</span><span class="id"> exact/seteqP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_setXR</span> (<span class="id">T</span><span class="id"> T'</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> A</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> finite_set</span> (<span class="id">B</span><span class="id"> x</span>))<span class="id"> -&gt;</span><span class="id"> finite_set</span> (<span class="id">A</span><span class="id"> `*``</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Afin</span><span class="id"> Bfin;</span><span class="id"> rewrite</span><span class="id"> -bigcupX1l</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_finite</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i</span><span class="id"> Ai;</span><span class="id"> exact/finite_setX/Bfin</span>.<br/>
Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.3.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed to finite_setXR.&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> finite_setMR</span><span class="id"> :=</span><span class="id"> finite_setXR</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_setXL</span> (<span class="id">T</span><span class="id"> T'</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> T'</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> B</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> finite_set</span> (<span class="id">A</span><span class="id"> x</span>))<span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> finite_set</span> (<span class="id">A</span><span class="id"> ``*`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Afin</span><span class="id"> Bfin;</span><span class="id"> rewrite</span><span class="id"> -bigcupX1r</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_finite</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i</span><span class="id"> Ai;</span><span class="id"> apply/finite_setX</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> Afin</span>.<br/>
Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.3.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed to finite_setXL.&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> finite_setML</span><span class="id"> :=</span><span class="id"> finite_setXL</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_set_II</span><span class="id"> n</span><span class="id"> :</span><span class="id"> fset_set</span><span class="id"> `I_n</span><span class="id"> =</span><span class="id"> [fset</span><span class="id"> val</span><span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="gallina-kwd"> in</span><span class="id"> 'I_n]%fset</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/fsetP</span><span class="id"> =&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> ?inE</span><span class="id"> in_fset_set//</span>.<br/>
<span class="id">apply/idP/imfsetP;</span><span class="id"> rewrite</span><span class="id"> ?inE/=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> lt_in;</span><span class="gallina-kwd"> exists</span> (<span class="id">Ordinal</span><span class="id"> lt_in</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [j</span><span class="id"> _</span><span class="id"> -&gt;]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_fsetK</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span>)<span class="id"> :</span><span class="id"> fset_set</span><span class="id"> [set`</span><span class="id"> A]</span><span class="id"> =</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/fsetP</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> in_fset_set//=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/idP/idP;</span><span class="id"> rewrite</span><span class="id"> ?inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_set_image</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> fset_set</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> A</span>)<span class="id"> =</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> fset_set</span><span class="id"> A</span>)<span class="id">%fset</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Afset;</span><span class="id"> apply/fsetP=&gt;</span><span class="id"> i</span>.<br/>
<span class="id">rewrite</span><span class="id"> !in_fset_set;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> finite_image</span>.<br/>
<span class="id">apply/idP/imfsetP;</span><span class="id"> rewrite</span><span class="id"> !inE/=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [x</span><span class="id"> Ax</span><span class="id"> &lt;-];</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> ?in_fset_set</span><span class="id"> ?inE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [x</span><span class="id"> +</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> in_fset_set//</span><span class="id"> inE;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_set_inj</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> fset_set</span><span class="id"> A</span><span class="id"> =</span><span class="id"> fset_set</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> =</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Afin</span><span class="id"> Bfin</span><span class="id"> /</span>(<span class="id">congr1</span><span class="id"> pred_set</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !fset_setK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigsetU_fset_set</span><span class="id"> T</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> \big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> fset_set</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> finA;</span><span class="id"> rewrite</span><span class="id"> -bigcup_fset</span><span class="id"> /fset_set;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> [{}finA|//]</span>.<br/>
<span class="id">apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> [x</span><span class="id"> [i</span><span class="id"> /=]|x</span><span class="id"> [i</span><span class="id"> Ai</span><span class="id"> Fix]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> iB</span><span class="id"> Fix;</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> B</span><span class="id"> AB</span><span class="id"> /=;</span><span class="id"> move:</span><span class="id"> Ai;</span><span class="id"> rewrite</span><span class="id"> AB</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __deprecated__bigcup_fset_set</span><span class="id"> T</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> \bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> fset_set</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /bigsetU_fset_set-&gt;</span>. Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">note=</span><span class="id">&quot;Use -bigsetU_fset_set instead&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> bigcup_fset_set</span><span class="id"> :=</span><span class="id"> __deprecated__bigcup_fset_set</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigsetU_fset_set_cond</span><span class="id"> T</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> I</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> fset_set</span><span class="id"> A</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> bigcup_mkcondr</span><span class="id"> big_mkcond</span><span class="id"> -bigsetU_fset_set</span><span class="id"> ?mem_setE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __deprecated__bigcup_fset_set_cond</span><span class="id"> T</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> I</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> fset_set</span><span class="id"> A</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> F</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /bigsetU_fset_set_cond-&gt;</span>. Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">note=</span><span class="id">&quot;Use -bigsetU_fset_set_cond instead&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> bigcup_fset_set_cond</span><span class="id"> :=</span><span class="id"> __deprecated__bigcup_fset_set_cond</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigsetI_fset_set</span><span class="id"> T</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> \big[setI/setT]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> fset_set</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =\bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> apply:</span><span class="id"> setC_inj;</span><span class="id"> rewrite</span><span class="id"> setC_bigcap</span><span class="id"> setC_bigsetI</span><span class="id"> bigsetU_fset_set</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __deprecated__bigcap_fset_set</span><span class="id"> T</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> \bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \big[setI/setT]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> fset_set</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /bigsetI_fset_set-&gt;</span>. Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">note=</span><span class="id">&quot;Use -bigsetI_fset_set instead&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> bigcap_fset_set</span><span class="id"> :=</span><span class="id"> __deprecated__bigcap_fset_set</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigsetI_fset_set_cond</span><span class="id"> T</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> I</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[setI/setT]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> fset_set</span><span class="id"> A</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> bigcap_mkcondr</span><span class="id"> big_mkcond</span><span class="id"> -bigsetI_fset_set</span><span class="id"> ?mem_setE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> super_bij</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">X</span><span class="id"> A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">Y</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> {bij</span><span class="id"> X</span><span class="id"> &gt;-&gt;</span><span class="id"> Y}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">X</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> Y</span><span class="id"> `&lt;=`</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> `\`</span><span class="id"> X</span><span class="id"> #=</span><span class="id"> B</span><span class="id"> `\`</span><span class="id"> Y</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> g</span><span class="id"> :</span><span class="id"> {bij</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> B},</span><span class="id"> {in</span><span class="id"> X,</span><span class="id"> g</span><span class="id"> =1</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Ppointed:</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> U</span><span class="gallina-kwd"> in</span><span class="id"> Y</span><span class="id"> B</span><span class="id"> f</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !emptyE</span><span class="gallina-kwd"> in</span><span class="id"> f</span><span class="id"> *</span><span class="id"> =&gt;</span><span class="id"> XA</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> setD_eq0</span><span class="id"> =&gt;</span><span class="id"> AX</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> suff</span><span class="id"> /seteqP-&gt;//</span><span class="id"> :</span><span class="id"> A</span><span class="id"> `&lt;=&gt;`</span><span class="id"> X</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> f</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> XA</span><span class="id"> YB</span><span class="id"> /pcard_eqP[g]</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">joinIB</span><span class="id"> X</span><span class="id"> A</span>)<span class="id"> -</span>(<span class="id">joinIB</span><span class="id"> Y</span><span class="id"> B</span>)<span class="id"> !meetEset</span>.<br/>
<span class="id">have</span><span class="id"> /disj_set2P</span><span class="id"> AX</span><span class="id"> :</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> X</span>)<span class="id"> `&amp;`</span> (<span class="id">A</span><span class="id"> `\`</span><span class="id"> X</span>)<span class="id"> =</span><span class="id"> set0</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> meetIB</span>.<br/>
<span class="id">have</span><span class="id"> /disj_set2P</span><span class="id"> BY</span><span class="id"> :</span> (<span class="id">B</span><span class="id"> `&amp;`</span><span class="id"> Y</span>)<span class="id"> `&amp;`</span> (<span class="id">B</span><span class="id"> `\`</span><span class="id"> Y</span>)<span class="id"> =</span><span class="id"> set0</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> meetIB</span>.<br/>
<span class="id">rewrite</span><span class="id"> !</span>(<span class="id">setIidr</span><span class="id"> XA</span>)<span class="id"> !</span>(<span class="id">setIidr</span><span class="id"> YB</span>)<span class="gallina-kwd"> in</span><span class="id"> AX</span><span class="id"> BY</span><span class="id"> *</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> [bij</span><span class="id"> of</span><span class="id"> glue</span><span class="id"> AX</span><span class="id"> BY</span><span class="id"> f</span><span class="id"> g]</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=</span><span class="id"> xX;</span><span class="id"> rewrite</span><span class="id"> glue1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_eq_fsetP</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}}</span><span class="id"> {n}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="id">#|`</span><span class="id"> A|</span><span class="id"> =</span><span class="id"> n</span>) (<span class="id">[set`</span><span class="id"> A]</span><span class="id"> #=</span><span class="id"> `I_n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/choicePpointed:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -{1}[A]set_fsetK</span><span class="id"> !emptyE</span><span class="id"> fset_set0</span><span class="id"> cardfs0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> eqP</span>)<span class="id"> =&gt;</span><span class="id"> [/IIn_eq0-&gt;//|&lt;-];</span><span class="id"> rewrite</span><span class="id"> II0</span>.<br/>
<span class="id">rewrite</span> (<span class="id">card_eqr</span><span class="id"> card_II</span>)<span class="id"> card_eq_sym</span>.<br/>
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> pcard_eqP</span>)<span class="id"> =&gt;</span><span class="id"> [[f]|];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> cardfE</span><span class="id"> =&gt;</span><span class="id"> eqAn</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> squash</span> (<span class="id">set_val</span><span class="id"> \o</span><span class="id"> finset_val</span><span class="id"> \o</span><span class="id"> enum_val</span><span class="id"> \o</span><span class="id"> cast_ord</span> (<span class="id">esym</span><span class="id"> eqAn</span>)).<br/>
<span class="id">suff</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> A</span><span class="id"> =</span><span class="id"> [fset</span><span class="id"> f</span><span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="gallina-kwd"> in</span><span class="id"> 'I_n]%fset</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> card_imfset</span><span class="id"> ?size_enum_ord</span>.<br/>
<span class="id">apply/fsetP</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> apply/idP/imfsetP</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [xA|[i</span><span class="id"> _</span><span class="id"> -&gt;]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [i</span><span class="id"> _</span><span class="id"> &lt;-]</span><span class="id"> :=</span><span class="id"> 'surj_f</span><span class="id"> xA;</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /</span>(_<span class="id"> i</span><span class="id"> I</span>)<span class="id"> :=</span><span class="id"> 'funS_f</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_fset_set</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> #=</span><span class="id"> `I_n</span><span class="id"> -&gt;</span><span class="id"> #|`fset_set</span><span class="id"> A|</span><span class="id"> =</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> An;</span><span class="id"> apply/card_eq_fsetP;</span><span class="id"> rewrite</span><span class="id"> fset_setK//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/finite_setP;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> geq_card_fset_set</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> #&lt;=</span><span class="id"> `I_n</span><span class="id"> -&gt;</span> (<span class="id">#|`fset_set</span><span class="id"> A|</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> An;</span><span class="id"> have</span><span class="id"> /finite_setP[m</span><span class="id"> Am]</span><span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/finite_set_leP;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">card_fset_set</span><span class="id"> Am</span>)<span class="id"> -card_le_II</span><span class="id"> -</span>(<span class="id">card_le_eql</span><span class="id"> Am</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> leq_card_fset_set</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> #&gt;=</span><span class="id"> `I_n</span><span class="id"> -&gt;</span> (<span class="id">#|`fset_set</span><span class="id"> A|</span><span class="id"> &gt;=</span><span class="id"> n</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /finite_setP[m</span><span class="id"> Am];</span><span class="id"> rewrite</span> (<span class="id">card_fset_set</span><span class="id"> Am</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">card_le_eqr</span><span class="id"> Am</span>)<span class="id"> card_le_II</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infinite_set_fset</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">n</span><span class="id"> :</span><span class="id"> nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">infinite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> B</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T},</span><span class="id"> [set`</span><span class="id"> B]</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> &amp;</span> (<span class="id">#|`</span><span class="id"> B|</span><span class="id"> &gt;=</span><span class="id"> n</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/choicePpointed:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> *;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> emptyE</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /infiniteP/ppcard_leP[f];</span><span class="gallina-kwd"> exists</span> (<span class="id">fset_set</span><span class="id"> [set</span><span class="id"> f</span><span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="gallina-kwd"> in</span><span class="id"> `I_n]</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> fset_setK//;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> finite_image</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subset_trans</span> (<span class="id">fun_image_sub</span><span class="id"> f</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> image_subset</span>.<br/>
<span class="id">rewrite</span><span class="id"> fset_set_image//</span><span class="id"> card_imfset//=</span><span class="id"> fset_set_II/=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> card_imfset//=</span><span class="id"> ?size_enum_ord//;</span><span class="id"> apply:</span><span class="id"> val_inj</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infinite_set_fsetP</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">infinite_set</span><span class="id"> A</span><span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="gallina-kwd"> exists2</span><span class="id"> B</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T},</span><span class="id"> [set`</span><span class="id"> B]</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> &amp;</span> (<span class="id">#|`</span><span class="id"> B|</span><span class="id"> &gt;=</span><span class="id"> n</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> apply:</span><span class="id"> infinite_set_fset</span>.<br/>
<span class="id">elim/choicePpointed:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /</span>(_<span class="id"> 1%N</span>)<span class="id">[B</span><span class="id"> _];</span><span class="id"> rewrite</span><span class="id"> cardfs_gt0</span><span class="id"> =&gt;</span><span class="id"> /fset0Pn[x</span><span class="id"> xB]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have:</span><span class="id"> [set`</span><span class="id"> B]</span><span class="id"> x</span><span class="gallina-kwd"> by</span><span class="id"> [];</span><span class="id"> rewrite</span><span class="id"> emptyE</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> Bge</span><span class="id"> /finite_setP[n</span><span class="id"> An];</span><span class="id"> have</span><span class="id"> [B</span><span class="id"> BA]</span><span class="id"> :=</span><span class="id"> Bge</span><span class="id"> n</span>.<span class="id">+1</span>.<br/>
<span class="id">apply/negP;</span><span class="id"> rewrite</span><span class="id"> -leqNgt</span><span class="id"> -</span>(<span class="id">card_fset_set</span><span class="id"> An</span>)<span class="id"> fsubset_leq_card//</span>.<br/>
<span class="id">apply/fsubsetP</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /BA;</span><span class="id"> rewrite</span><span class="id"> in_fset_set</span><span class="id"> ?inE//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/finite_setP;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fcard_eq</span><span class="id"> {T</span><span class="id"> T'</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> finite_set</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="id">#|`fset_set</span><span class="id"> A|</span><span class="id"> =</span><span class="id"> #|`fset_set</span><span class="id"> B|</span>) (<span class="id">A</span><span class="id"> #=</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /finite_setP/cid[n</span><span class="id"> An]</span><span class="id"> /finite_setP/cid[m</span><span class="id"> Bm]</span>.<br/>
<span class="id">rewrite</span> (<span class="id">card_fset_set</span><span class="id"> An</span>) (<span class="id">card_fset_set</span><span class="id"> Bm</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">card_eql</span><span class="id"> An</span>) (<span class="id">card_eqr</span><span class="id"> Bm</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> card_eq_II</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_IID</span><span class="id"> {n</span><span class="id"> k}</span><span class="id"> :</span><span class="id"> `I_n</span><span class="id"> `\`</span><span class="id"> `I_k</span><span class="id"> #=</span><span class="id"> `I_</span>(<span class="id">n</span><span class="id"> -</span><span class="id"> k</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/fcard_eq</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> finite_setD</span>.<br/>
<span class="id">rewrite</span><span class="id"> fset_setD//=</span><span class="id"> cardfsD/=</span><span class="id"> -fset_setI//</span><span class="id"> setI_II</span>.<br/>
<span class="id">rewrite</span><span class="id"> !fset_set_II</span><span class="id"> !card_imfset//</span><span class="id"> /=</span><span class="id"> !size_enum_ord</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> leqP;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> subnn</span><span class="id"> =&gt;</span><span class="id"> /eqP-&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_set_bij</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> n</span><span class="id"> S</span><span class="id"> :</span><span class="id"> A</span><span class="id"> !=</span><span class="id"> set0</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> #=</span><span class="id"> `I_n</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {bij</span><span class="id"> `I_n</span><span class="id"> &gt;-&gt;</span><span class="id"> A}</span>)<span class="id"> k,</span> (<span class="id">k</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> /\</span><span class="id"> `I_n</span><span class="id"> `&amp;`</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> S</span>)<span class="id"> =</span><span class="id"> `I_k</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Ppointed:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> S</span><span class="id"> *;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !emptyE</span><span class="id"> eqxx</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> AN0</span><span class="id"> An</span><span class="id"> SA;</span><span class="id"> have</span><span class="id"> [k</span><span class="id"> kn</span><span class="id"> Sk]</span><span class="id"> :</span><span class="gallina-kwd"> exists2</span><span class="id"> k,</span> (<span class="id">k</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> &amp;</span><span class="id"> S</span><span class="id"> #=</span><span class="id"> `I_k</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /finite_setP[k</span><span class="id"> Sk]:</span><span class="id"> finite_set</span><span class="id"> S</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> sub_finite_set</span><span class="id"> SA</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> -card_le_II</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">card_le_eqr</span><span class="id"> An</span>)<span class="id"> -</span>(<span class="id">card_le_eql</span><span class="id"> Sk</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> subset_card_le</span>.<br/>
<span class="id">have</span><span class="id"> /card_esym/ppcard_eqP[f]</span><span class="id"> :=</span><span class="id"> Sk</span>.<br/>
<span class="id">have</span><span class="id"> eqAS</span><span class="id"> :</span><span class="id"> A</span><span class="id"> `\`</span><span class="id"> S</span><span class="id"> #=</span><span class="id"> `I_n</span><span class="id"> `\`</span><span class="id"> `I_k</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> An'</span><span class="id"> :=</span><span class="id"> An;</span><span class="id"> have</span><span class="id"> Sk'</span><span class="id"> :=</span><span class="id"> Sk</span>.<br/>
&nbsp;&nbsp;<span class="id">do</span><span class="id"> [have</span><span class="id"> /finite_fsetP[{An'}A</span><span class="id"> -&gt;]</span><span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> n]</span><span class="gallina-kwd"> in</span><span class="id"> An</span><span class="id"> AN0</span><span class="id"> SA</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="id">do</span><span class="id"> [have</span><span class="id"> /finite_fsetP[{Sk'}S</span><span class="id"> -&gt;]</span><span class="id"> :</span><span class="id"> finite_set</span><span class="id"> S</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> k]</span><span class="gallina-kwd"> in</span><span class="id"> Sk</span><span class="id"> f</span><span class="id"> SA</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [/card_eq_fsetP</span><span class="id"> {}An</span><span class="id"> /card_eq_fsetP</span><span class="id"> {}Sk]</span><span class="id"> :=</span> (<span class="id">An,</span><span class="id"> Sk</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -set_fsetD</span> (<span class="id">card_eqr</span><span class="id"> card_IID</span>)<span class="id">;</span><span class="id"> apply/card_eq_fsetP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> cardfsD</span> (<span class="id">fsetIidPr</span><span class="id"> _</span>)<span class="id"> ?An</span><span class="id"> ?Sk</span><span class="id"> //;</span><span class="id"> apply/fsubsetP</span>.<br/>
<span class="id">case:</span> (<span class="id">super_bij</span><span class="id"> [bij</span><span class="id"> of</span><span class="id"> f^-1]</span><span class="id"> SA</span><span class="id"> _</span><span class="id"> eqAS</span>)<span class="id"> =&gt;</span><span class="id"> [x</span><span class="id"> /=</span><span class="id"> /leq_trans-&gt;//</span><span class="id"> |</span><span class="id"> g]</span>.<br/>
<span class="id">have</span><span class="id"> [{}g</span><span class="id"> -&gt;]</span><span class="id"> :=</span><span class="id"> pPbij</span><span class="id"> 'bij_g</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> gE</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> [bij</span><span class="id"> of</span><span class="id"> g^-1],</span><span class="id"> k;</span><span class="id"> split=&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> -inv_sub_image</span><span class="id"> //=</span><span class="id"> invV</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_imagel</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> gE</span><span class="id"> ?inE//;</span><span class="id"> rewrite</span><span class="id"> image_eq</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">#[deprecated</span>(<span class="id">note=</span><span class="id">&quot;use countable0 instead&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> countable_set0</span><span class="id"> :=</span><span class="id"> countable0</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> countable1</span><span class="id"> T</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> countable</span><span class="id"> [set</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> finite_set_countable</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> countable1</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> countable_fset</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">X</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span>)<span class="id"> :</span><span class="id"> countable</span><span class="id"> [set`</span><span class="id"> X]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> finite_set_countable</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> countable_fset</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> countable_finpred</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> finType</span>) (<span class="id">pT</span><span class="id"> :</span><span class="id"> predType</span><span class="id"> T</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> pT</span>)<span class="id"> :</span><span class="id"> countable</span><span class="id"> [set`</span><span class="id"> P]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> finite_set_countable</span>. Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">is_true</span> (<span class="id">countable</span><span class="id"> [set`</span><span class="id"> _]</span>))<span class="id"> =&gt;</span><span class="id"> solve</span><span class="id"> [apply:</span><span class="id"> countable_finpred]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_card_nat</span><span class="id"> T</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">countable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> ~</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> [set:</span><span class="id"> nat]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Acnt</span><span class="id"> /infiniteP</span><span class="id"> leNA;</span><span class="id"> rewrite</span><span class="id"> card_eq_le</span><span class="id"> leNA</span><span class="id"> andbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infinite_nat</span><span class="id"> :</span><span class="id"> ~</span><span class="id"> finite_set</span><span class="id"> [set:</span><span class="id"> nat]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/infiniteP/card_lexx</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infinite_prod_nat</span><span class="id"> :</span><span class="id"> infinite_set</span><span class="id"> [set:</span><span class="id"> nat</span><span class="id"> *</span><span class="id"> nat]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply/infiniteP/pcard_leTP/injPex;</span><span class="gallina-kwd"> exists</span> (<span class="id">pair</span><span class="id"> 0%N</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> m</span><span class="id"> n</span><span class="id"> _</span><span class="id"> _</span><span class="id"> []</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_nat2</span><span class="id"> :</span><span class="id"> [set:</span><span class="id"> nat</span><span class="id"> *</span><span class="id"> nat]</span><span class="id"> #=</span><span class="id"> [set:</span><span class="id"> nat]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/eq_card_nat/infinite_prod_nat/countableP</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isPointed</span>.<span class="id">Build</span><span class="id"> rat</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infinite_rat</span><span class="id"> :</span><span class="id"> infinite_set</span><span class="id"> [set:</span><span class="id"> rat]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/infiniteP/pcard_leTP/injPex;</span><span class="gallina-kwd"> exists</span> (<span class="id">GRing</span>.<span class="id">natmul</span><span class="id"> 1</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> m</span><span class="id"> n</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="id">exact/Num</span>.<span class="id">Theory</span>.<span class="id">mulrIn/oner_neq0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_rat</span><span class="id"> :</span><span class="id"> [set:</span><span class="id"> rat]</span><span class="id"> #=</span><span class="id"> [set:</span><span class="id"> nat]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/eq_card_nat/infinite_rat/countableP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> choicePcountable</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> :</span><span class="id"> countable</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{T'</span><span class="id"> :</span><span class="id"> countType</span><span class="id"> |</span><span class="id"> T</span><span class="id"> =</span><span class="id"> T'</span><span class="id"> :&gt;</span><span class="id"> Type}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /pcard_leP/unsquash</span><span class="id"> f</span>.<br/>
<span class="id">pose</span><span class="id"> TcM</span><span class="id"> :=</span><span class="id"> PCanIsCountable</span> (<span class="id">in1TT</span><span class="id"> 'funoK_f</span>).<br/>
<span class="id">pose</span><span class="id"> TC</span><span class="id"> :</span><span class="id"> countType</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span><span class="id"> T</span><span class="id"> TcM</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> TC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eqPcountable</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> eqType}</span><span class="id"> :</span><span class="id"> countable</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{T'</span><span class="id"> :</span><span class="id"> countType</span><span class="id"> |</span><span class="id"> T</span><span class="id"> =</span><span class="id"> T'</span><span class="id"> :&gt;</span><span class="id"> Type}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim/eqPchoice:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="id"> /choicePcountable</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Pcountable</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span><span class="id"> :</span><span class="id"> countable</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{T'</span><span class="id"> :</span><span class="id"> countType</span><span class="id"> |</span><span class="id"> T</span><span class="id"> =</span><span class="id"> T'</span><span class="id"> :&gt;</span><span class="id"> Type}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim/Pchoice:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="id"> /choicePcountable</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigcup_countable</span><span class="id"> {I</span><span class="id"> T}</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">countable</span><span class="id"> D</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> countable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">countable</span> (<span class="id">\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Ppointed:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> F</span><span class="id"> *;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> emptyE</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">eq_countable</span> (<span class="id">card_setT</span><span class="id"> _</span>))<span class="id"> =&gt;</span><span class="id"> cD</span><span class="id"> cF;</span><span class="id"> rewrite</span><span class="id"> bigcup_set_type</span>.<br/>
<span class="id">set</span><span class="id"> G</span><span class="id"> :=</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> :</span><span class="id"> D</span><span class="id"> =&gt;</span><span class="id"> F</span> (<span class="id">val</span><span class="id"> i</span>)).<br/>
<span class="id">have</span><span class="id"> {cF}cG</span><span class="id"> i</span><span class="id"> :</span><span class="id"> countable</span> (<span class="id">G</span><span class="id"> i</span>)<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> cF;</span><span class="id"> apply:</span><span class="id"> set_valP</span>.<br/>
<span class="id">move:</span> (<span class="id">D</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<span class="id"> cD</span><span class="id"> G</span><span class="id"> cG</span><span class="id"> =&gt;</span><span class="id"> {F</span><span class="id"> I}_</span><span class="id"> /Pcountable[{}D</span><span class="id"> -&gt;]</span><span class="id"> G</span><span class="id"> cG</span>.<br/>
<span class="id">suff:</span> (<span class="id">\bigcup_i</span><span class="id"> G</span><span class="id"> i</span><span class="id"> #&lt;=</span><span class="id"> [set:</span><span class="id"> {i</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> i}]</span>)<span class="id">%card</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> cGT</span><span class="id"> i</span><span class="id"> :</span><span class="id"> countable</span><span class="id"> [set:</span><span class="id"> G</span><span class="id"> i]</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">eq_countable</span> (<span class="id">card_setT</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /all_sig[H</span><span class="id"> GE]</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> Pcountable</span> (<span class="id">cGT</span><span class="id"> i</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /sub_countable-&gt;//;</span><span class="id"> rewrite</span> (<span class="id">eq_fun</span><span class="id"> GE</span>).<br/>
<span class="id">apply/pcard_geP/surjPex;</span><span class="gallina-kwd"> exists</span> (<span class="gallina-kwd">fun</span> (<span class="id">k</span><span class="id"> :</span><span class="id"> {i</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> i}</span>)<span class="id"> =&gt;</span><span class="id"> val</span> (<span class="id">projT2</span><span class="id"> k</span>)).<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> [i</span><span class="id"> _]</span><span class="id"> Gix/=;</span><span class="gallina-kwd"> exists</span> (<span class="id">Tagged</span><span class="id"> G</span> (<span class="id">SigSub</span> (<span class="id">mem_set</span><span class="id"> Gix</span>))).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> countableXR</span><span class="id"> T</span><span class="id"> T'</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">countable</span><span class="id"> A</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> A</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> countable</span> (<span class="id">B</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> countable</span> (<span class="id">A</span><span class="id"> `*``</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Ppointed:</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> B</span><span class="id"> *;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> emptyE</span><span class="id"> -bigcupX1l</span><span class="id"> bigcup_set0</span>.<br/>
<span class="id">elim/Ppointed:</span><span class="id"> T'</span><span class="id"> =&gt;</span><span class="id"> T'</span><span class="gallina-kwd"> in</span><span class="id"> B</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -bigcupX1l</span><span class="id"> bigcup0//</span><span class="id"> =&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> emptyE</span><span class="id"> setX0</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> Ac</span><span class="id"> Bc;</span><span class="id"> rewrite</span><span class="id"> -bigcupX1l</span><span class="id"> bigcup_countable//</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> Ai</span>.<br/>
<span class="id">have</span><span class="id"> /ppcard_leP[f]</span><span class="id"> :=</span><span class="id"> Bc</span><span class="id"> i</span><span class="id"> Ai;</span><span class="id"> apply/pcard_geP/surjPex</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="gallina-kwd">fun</span><span class="id"> k</span><span class="id"> =&gt;</span> (<span class="id">i,</span><span class="id"> f^-1%FUN</span><span class="id"> k</span>))<span class="id"> =&gt;</span><span class="id"> -[_</span><span class="id"> j]/=</span><span class="id"> [-&gt;</span><span class="id"> dj]</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">f</span><span class="id"> j</span>)<span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> funK</span><span class="id"> ?inE</span>.<br/>
Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.3.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed to countableXR.&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> countableMR</span><span class="id"> :=</span><span class="id"> countableXR</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> countableX</span><span class="id"> T1</span><span class="id"> T2</span> (<span class="id">D1</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T1</span>) (<span class="id">D2</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">countable</span><span class="id"> D1</span><span class="id"> -&gt;</span><span class="id"> countable</span><span class="id"> D2</span><span class="id"> -&gt;</span><span class="id"> countable</span> (<span class="id">D1</span><span class="id"> `*`</span><span class="id"> D2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> D1c</span><span class="id"> D2c;</span><span class="id"> exact:</span><span class="id"> countableXR</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> D2c</span>). Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.3.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed to countableX.&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> countableM</span><span class="id"> :=</span><span class="id"> countableX</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> countableXL</span><span class="id"> T</span><span class="id"> T'</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> T'</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">countable</span><span class="id"> B</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> B</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> countable</span> (<span class="id">A</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> countable</span> (<span class="id">A</span><span class="id"> ``*`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Bc</span><span class="id"> Ac;</span><span class="id"> rewrite</span><span class="id"> -bigcupX1r;</span><span class="id"> apply:</span><span class="id"> bigcup_countable</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i</span><span class="id"> Bi</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> countableX</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> Ac</span>.<br/>
Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.3.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed to countableXL.&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> countableML</span><span class="id"> :=</span><span class="id"> countableXL</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infiniteXRl</span><span class="id"> T</span><span class="id"> T'</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">infinite_set</span><span class="id"> A</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> B</span><span class="id"> i</span><span class="id"> !=set0</span>)<span class="id"> -&gt;</span><span class="id"> infinite_set</span> (<span class="id">A</span><span class="id"> `*``</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /infiniteP/pcard_geP[f]</span><span class="id"> /</span>(_<span class="id"> _</span>)<span class="id">/cid-/all_sig[b</span><span class="id"> Bb]</span>.<br/>
<span class="id">apply/infiniteP/pcard_geP/surjPex;</span><span class="gallina-kwd"> exists</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> x</span>.<span class="id">1</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> iT;</span><span class="id"> have</span><span class="id"> [a</span><span class="id"> Aa</span><span class="id"> fa]</span><span class="id"> :=</span><span class="id"> 'oinvP_f</span><span class="id"> iT;</span><span class="gallina-kwd"> exists</span> (<span class="id">a,</span><span class="id"> b</span><span class="id"> a</span>).<br/>
Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.3.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed to infiniteXRl.&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> infiniteMRl</span><span class="id"> :=</span><span class="id"> infiniteXRl</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cardXR_eq_nat</span><span class="id"> T</span><span class="id"> T'</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T'</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span><span class="id"> #=</span><span class="id"> [set:</span><span class="id"> nat]</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> countable</span> (<span class="id">B</span><span class="id"> i</span>)<span class="id"> /\</span><span class="id"> B</span><span class="id"> i</span><span class="id"> !=set0</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> `*``</span><span class="id"> B</span><span class="id"> #=</span><span class="id"> [set:</span><span class="id"> nat]</span>)<span class="id">%card</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> !card_eq_le</span><span class="id"> =&gt;</span><span class="id"> /andP[Acnt</span><span class="id"> /infiniteP</span><span class="id"> Ainfty]</span><span class="id"> /all_and2[Bcnt</span><span class="id"> Bn0]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [</span>(_<span class="id"> #&lt;=</span><span class="id"> _</span>)<span class="id">%card]countableXR//=;</span><span class="id"> exact/infiniteP/infiniteXRl</span>.<br/>
Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.3.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed to cardXR_eq_nat.&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> cardMR_eq_nat</span><span class="id"> :=</span><span class="id"> cardXR_eq_nat</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_cardSP</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists2</span><span class="id"> x,</span><span class="id"> A</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> A</span><span class="id"> `\</span><span class="id"> x</span><span class="id"> #=</span><span class="id"> `I_n</span>) (<span class="id">A</span><span class="id"> #=</span><span class="id"> `I_n</span>.<span class="id">+1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Ppointed:</span><span class="id"> T</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> T</span><span class="id"> A</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !emptyE;</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> eqP</span>)<span class="id"> =&gt;</span><span class="id"> [|[]//]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /</span>(<span class="id">congr1</span> (<span class="id">@^~</span><span class="id"> 0%N</span>))<span class="id">/=;</span><span class="id"> rewrite</span><span class="id"> -falseE</span><span class="id"> ltnS</span><span class="id"> leq0n</span><span class="id"> =&gt;</span><span class="id"> /is_true_inj</span>.<br/>
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [|[x</span><span class="id"> Ax]]</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /ppcard_eqP[f];</span><span class="gallina-kwd"> exists</span> (<span class="id">f^-1</span><span class="id"> n</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> funS</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/card_esym/card_set_bijP;</span><span class="gallina-kwd"> exists</span><span class="id"> f^-1;</span><span class="id"> apply:</span><span class="id"> bij_II_D1</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /pcard_eqP[f];</span><span class="id"> have</span><span class="id"> [//|||g</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> @super_bij</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> A</span><span class="id"> _</span><span class="id"> `I_n</span>.<span class="id">+1</span><span class="id"> f</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> k</span><span class="id"> /=;</span><span class="id"> apply:</span><span class="id"> leq_trans</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setDD</span> (<span class="id">card_eqr</span><span class="id"> card_IID</span>)<span class="id"> subSnn//</span><span class="id"> setIidr</span><span class="id"> ?card_set1//</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> -&gt;</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply/pcard_eqP;</span><span class="id"> squash</span><span class="id"> g</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> countable_n_subset</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">countable</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> countable</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> |</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> D</span><span class="id"> /\</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> `I_n]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Dcnt;</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> countable</span><span class="id"> X]</span>(<span class="id"> _</span><span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> set0]</span>)<span class="id">//</span><span class="id"> eqEsubset</span><span class="id"> II0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> A</span><span class="id"> /=;</span><span class="id"> [rewrite</span><span class="id"> card_eq0;</span><span class="id"> case=&gt;</span><span class="id"> _</span><span class="id"> /eqP</span><span class="id"> |</span><span class="id"> move-&gt;;</span><span class="id"> split]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /</span>(<span class="id">countableX</span><span class="id"> Dcnt</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> sub_countable</span>.<br/>
<span class="id">apply:</span><span class="id"> card_le_trans</span> (<span class="id">card_image_le</span> (<span class="gallina-kwd">fun</span><span class="id"> u</span><span class="id"> =&gt;</span><span class="id"> u</span>.<span class="id">1</span><span class="id"> |`</span><span class="id"> u</span>.<span class="id">2</span>)<span class="id"> _</span>).<br/>
<span class="id">apply:</span><span class="id"> subset_card_le</span><span class="id"> =&gt;</span><span class="id"> B</span><span class="id"> [BD]</span><span class="id"> /eq_cardSP</span><span class="id"> [x</span><span class="id"> Bx</span><span class="id"> BDx]</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">x,</span><span class="id"> B</span><span class="id"> `\</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> setDUK</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> do</span><span class="id"> !split=&gt;</span><span class="id"> //;</span><span class="id"> [exact:</span><span class="id"> BD</span><span class="id"> |</span><span class="id"> apply:</span><span class="id"> subset_trans</span><span class="id"> _</span><span class="id"> BD;</span><span class="id"> apply:</span><span class="id"> subDsetl]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> countable_finite_subset</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">countable</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> countable</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> |</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> D</span><span class="id"> /\</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> ]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Dcnt;</span><span class="id"> suff</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> |</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> D</span><span class="id"> /\</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> ]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\bigcup_n</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> |</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> D</span><span class="id"> /\</span><span class="id"> A</span><span class="id"> #=</span><span class="id"> `I_n</span><span class="id"> ]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_countable</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> countable_n_subset</span>.<br/>
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split=&gt;</span><span class="id"> [A</span><span class="id"> [AD</span><span class="id"> /finite_setP[n</span><span class="id"> An]]|A];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [n</span><span class="id"> _</span><span class="id"> [AD</span><span class="id"> An]];</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply/finite_setP;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_card_fset_subset</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> pointedType}</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> A</span><span class="id"> |</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> D</span><span class="id"> /\</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> ]</span><span class="id"> #=</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span><span class="id"> |</span><span class="id"> {subset</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> D}]</span> .<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/card_set_bijP;</span><span class="gallina-kwd"> exists</span> (<span class="id">@fset_set</span><span class="id"> T</span>)<span class="id">;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> [AD</span><span class="id"> fsetA]</span><span class="id"> /=</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> in_fset_set</span><span class="id"> //</span><span class="id"> ?inE;</span><span class="id"> exact:</span><span class="id"> AD</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> /set_mem</span><span class="id"> [_</span><span class="id"> +]</span><span class="id"> /set_mem</span><span class="id"> [_</span><span class="id"> +];</span><span class="id"> exact:</span><span class="id"> fset_set_inj</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> B</span><span class="id"> /=</span><span class="id"> BD;</span><span class="gallina-kwd"> exists</span><span class="id"> [set`</span><span class="id"> B];</span><span class="id"> rewrite</span><span class="id"> ?set_fsetK</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split;</span><span class="id"> [by</span><span class="id"> move</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=</span><span class="id"> /BD</span><span class="id"> /set_mem</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> finite_fset]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_subset_countable</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> pointedType}</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">countable</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> countable</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> T}</span><span class="id"> |</span><span class="id"> {subset</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> D}]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">eq_countable</span> (<span class="id">eq_card_fset_subset</span><span class="id"> _</span>))<span class="id"> =&gt;</span><span class="id"> ?</span>.<br/>
<span class="id">exact:</span><span class="id"> countable_finite_subset</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> FiniteImage</span><span class="id"> aT</span><span class="id"> rT</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> rT</span>)<span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">fimfunP</span><span class="id"> :</span><span class="id"> finite_set</span> (<span class="id">range</span><span class="id"> f</span>)<br/>
<span class="id">}</span>.<br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> FImFun</span><span class="id"> aT</span><span class="id"> rT</span><span class="id"> :=</span><span class="id"> {f</span><span class="id"> of</span><span class="id"> @FiniteImage</span><span class="id"> aT</span><span class="id"> rT</span><span class="id"> f}</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> fimfunP</span><span class="id"> {aT</span><span class="id"> rT}</span><span class="id"> _</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">finite_set</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> solve</span><span class="id"> [apply:</span><span class="id"> fimfunP]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'fimfun' aT &gt;-&gt; T }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;{ 'fimfun'  aT  &gt;-&gt;  T }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;[ 'fimfun' 'of' f ]&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ 'fimfun'  'of'  f ]&quot;</span>).<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'fimfun' aT &gt;-&gt; T }&quot;</span><span class="id"> :=</span> (<span class="id">@FImFun</span>.<span class="id">type</span><span class="id"> aT</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> form_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'fimfun' 'of' f ]&quot;</span><span class="id"> :=</span><span class="id"> [the</span><span class="id"> {fimfun</span><span class="id"> _</span><span class="id"> &gt;-&gt;</span><span class="id"> _}</span><span class="id"> of</span><span class="id"> f]</span><span class="id"> :</span><span class="id"> form_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fimfun_inP</span><span class="id"> {aT</span><span class="id"> rT}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {fimfun</span><span class="id"> aT</span><span class="id"> &gt;-&gt;</span><span class="id"> rT}</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> aT</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span> (<span class="id">f</span><span class="id"> @`</span><span class="id"> D</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">@sub_finite_set</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">range</span><span class="id"> f</span>))<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> y</span><span class="id"> [x];</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>. Qed.</div></details>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> fimfun_inP</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fset_set_comp</span> (<span class="id">T1</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">T2</span><span class="id"> T3</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> {fimfun</span><span class="id"> T1</span><span class="id"> &gt;-&gt;</span><span class="id"> T2}</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> T3</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">fset_set</span><span class="id"> [set</span> (<span class="id">g</span><span class="id"> \o</span><span class="id"> f</span>)<span class="id"> x</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> D]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">[fset</span><span class="id"> g</span><span class="id"> x</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> fset_set</span><span class="id"> [set</span><span class="id"> f</span><span class="id"> x</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> D]]%fset</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">image_comp</span><span class="id"> f</span><span class="id"> g</span>)<span class="id"> fset_set_image</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> fimfun_pred</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> :</span><span class="id"> Type}</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> fimfun</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> rT}</span><span class="id"> :=</span><span class="id"> mem</span><span class="id"> [set</span><span class="id"> f</span><span class="id"> |</span><span class="id"> finite_set</span> (<span class="id">range</span><span class="id"> f</span>)<span class="id">]</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> fimfun_key</span><span class="id"> :</span><span class="id"> pred_key</span><span class="id"> fimfun</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> fimfun_keyed</span><span class="id"> :=</span><span class="id"> KeyedPred</span><span class="id"> fimfun_key</span>.<br/>
<span class="vernacular">End</span><span class="id"> fimfun_pred</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> fimfun</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> :</span><span class="id"> Type}</span>.<br/>
<span class="vernacular">Notation</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> {fimfun</span><span class="id"> aT</span><span class="id"> &gt;-&gt;</span><span class="id"> rT}</span>.<br/>
<span class="vernacular">Notation</span><span class="id"> fimfun</span><span class="id"> :=</span> (<span class="id">@fimfun</span><span class="id"> aT</span><span class="id"> rT</span>).<br/>
<span class="vernacular">Section</span><span class="id"> Sub</span>.<br/>
<span class="vernacular">Context</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> rT</span>) (<span class="id">fP</span><span class="id"> :</span><span class="id"> f</span><span class="id"> \in</span><span class="id"> fimfun</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> fimfun_Sub_subproof</span><span class="id"> :=</span><span class="id"> @FiniteImage</span>.<span class="id">Build</span><span class="id"> aT</span><span class="id"> rT</span><span class="id"> f</span> (<span class="id">set_mem</span><span class="id"> fP</span>).<br/>
<span class="id">#[local]</span><span class="id"> HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> fimfun_Sub_subproof</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> fimfun_Sub</span><span class="id"> :=</span><span class="id"> [fimfun</span><span class="id"> of</span><span class="id"> f]</span>.<br/>
<span class="vernacular">End</span><span class="id"> Sub</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fimfun_rect</span> (<span class="id">K</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Type</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> f</span> (<span class="id">Pf</span><span class="id"> :</span><span class="id"> f</span><span class="id"> \in</span><span class="id"> fimfun</span>)<span class="id">,</span><span class="id"> K</span> (<span class="id">fimfun_Sub</span><span class="id"> Pf</span>))<span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> u</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> K</span><span class="id"> u</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Ksub</span><span class="id"> [f</span><span class="id"> [[Pf]]]/=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> suff</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> Pf</span><span class="id"> =</span> (<span class="id">set_mem</span> (<span class="id">@mem_set</span><span class="id"> _</span><span class="id"> [set</span><span class="id"> f</span><span class="id"> |</span><span class="id"> _]</span><span class="id"> f</span><span class="id"> Pf</span>))<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> Ksub</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fimfun_valP</span><span class="id"> f</span> (<span class="id">Pf</span><span class="id"> :</span><span class="id"> f</span><span class="id"> \in</span><span class="id"> fimfun</span>)<span class="id"> :</span><span class="id"> fimfun_Sub</span><span class="id"> Pf</span><span class="id"> =</span><span class="id"> f</span><span class="id"> :&gt;</span> (_<span class="id"> -&gt;</span><span class="id"> _</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isSub</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> T</span><span class="id"> fimfun_rect</span><span class="id"> fimfun_valP</span>.<br/>
<span class="vernacular">End</span><span class="id"> fimfun</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fimfuneqP</span><span class="id"> aT</span><span class="id"> rT</span> (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> {fimfun</span><span class="id"> aT</span><span class="id"> &gt;-&gt;</span><span class="id"> rT}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> =</span><span class="id"> g</span><span class="id"> &lt;-&gt;</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split=&gt;</span><span class="id"> [-&gt;//|fg];</span><span class="id"> apply/val_inj/funext</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> aT</span> (<span class="id">rT</span><span class="id"> :</span><span class="id"> eqType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[Equality</span><span class="id"> of</span><span class="id"> {fimfun</span><span class="id"> aT</span><span class="id"> &gt;-&gt;</span><span class="id"> rT}</span><span class="gallina-kwd"> by</span><span class="id"> &lt;:]</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> aT</span> (<span class="id">rT</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[Choice</span><span class="id"> of</span><span class="id"> {fimfun</span><span class="id"> aT</span><span class="id"> &gt;-&gt;</span><span class="id"> rT}</span><span class="gallina-kwd"> by</span><span class="id"> &lt;:]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_image_cst</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> rT</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span> (<span class="id">range</span> (<span class="id">cst</span><span class="id"> x</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> _</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Ppointed:</span><span class="id"> aT</span><span class="id"> =&gt;</span><span class="id"> aT;</span><span class="id"> rewrite</span><span class="id"> ?emptyE</span><span class="id"> ?image_set0//</span>.<br/>
<span class="id">suff</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> cst</span><span class="id"> x</span><span class="id"> @`</span><span class="id"> [set:</span><span class="id"> aT]</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> x]</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> finite_set1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/predeqP</span><span class="id"> =&gt;</span><span class="id"> y;</span><span class="id"> split=&gt;</span><span class="id"> [[t'</span><span class="id"> _</span><span class="id"> &lt;-]//|-&gt;//]</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> point</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> aT</span><span class="id"> rT</span><span class="id"> x</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">FiniteImage</span>.<span class="id">Build</span><span class="id"> aT</span><span class="id"> rT</span> (<span class="id">cst</span><span class="id"> x</span>) (<span class="id">@finite_image_cst</span><span class="id"> aT</span><span class="id"> rT</span><span class="id"> x</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> cst_fimfun</span><span class="id"> {aT</span><span class="id"> rT}</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> [the</span><span class="id"> {fimfun</span><span class="id"> aT</span><span class="id"> &gt;-&gt;</span><span class="id"> rT}</span><span class="id"> of</span><span class="id"> cst</span><span class="id"> x]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fimfun_cst</span><span class="id"> aT</span><span class="id"> rT</span><span class="id"> x</span><span class="id"> :</span><span class="id"> @cst_fimfun</span><span class="id"> aT</span><span class="id"> rT</span><span class="id"> x</span><span class="id"> =1</span><span class="id"> cst</span><span class="id"> x</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> comp_fimfun_subproof</span><span class="id"> aT</span><span class="id"> rT</span><span class="id"> sT</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> {fimfun</span><span class="id"> aT</span><span class="id"> &gt;-&gt;</span><span class="id"> rT}</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> rT</span><span class="id"> -&gt;</span><span class="id"> sT</span>)<span class="id"> :</span><span class="id"> @FiniteImage</span><span class="id"> aT</span><span class="id"> sT</span> (<span class="id">g</span><span class="id"> \o</span><span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">image_comp</span><span class="id"> f</span><span class="id"> g</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> finite_image</span>. Qed.</div></details>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> aT</span><span class="id"> rT</span><span class="id"> sT</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :=</span><span class="id"> @comp_fimfun_subproof</span><span class="id"> aT</span><span class="id"> rT</span><span class="id"> sT</span><span class="id"> f</span><span class="id"> g</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> zmod</span>.<br/>
<span class="vernacular">Context</span> (<span class="id">aT</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">rT</span><span class="id"> :</span><span class="id"> zmodType</span>).<br/>
<span class="vernacular">Lemma</span><span class="id"> fimfun_zmod_closed</span><span class="id"> :</span><span class="id"> zmod_closed</span> (<span class="id">@fimfun</span><span class="id"> aT</span><span class="id"> rT</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [|f</span><span class="id"> g];</span><span class="id"> rewrite</span><span class="id"> !inE/=;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> finite_image_cst</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> fA</span><span class="id"> gA;</span><span class="id"> apply:</span> (<span class="id">finite_image11</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> -</span><span class="id"> y</span>)).<br/>
Qed.</div></details>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">GRing</span>.<span class="id">isZmodClosed</span>.<span class="id">Build</span> (<span class="id">aT</span><span class="id"> -&gt;</span><span class="id"> rT</span>)<span class="id"> fimfun</span><span class="id"> fimfun_zmod_closed</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[SubChoice_isSubZmodule</span><span class="id"> of</span><span class="id"> {fimfun</span><span class="id"> aT</span><span class="id"> &gt;-&gt;</span><span class="id"> rT}</span><span class="gallina-kwd"> by</span><span class="id"> &lt;:]</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> {fimfun</span><span class="id"> aT</span><span class="id"> &gt;-&gt;</span><span class="id"> rT}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fimfunD</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> f</span><span class="id"> +</span><span class="id"> g</span><span class="id"> =</span><span class="id"> f</span><span class="id"> \+</span><span class="id"> g</span><span class="id"> :&gt;</span> (_<span class="id"> -&gt;</span><span class="id"> _</span>)<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> fimfunN</span><span class="id"> f</span><span class="id"> :</span><span class="id"> -</span><span class="id"> f</span><span class="id"> =</span><span class="id"> \-</span><span class="id"> f</span><span class="id"> :&gt;</span> (_<span class="id"> -&gt;</span><span class="id"> _</span>)<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> fimfunB</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> f</span><span class="id"> -</span><span class="id"> g</span><span class="id"> =</span><span class="id"> f</span><span class="id"> \-</span><span class="id"> g</span><span class="id"> :&gt;</span> (_<span class="id"> -&gt;</span><span class="id"> _</span>)<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> fimfun0</span><span class="id"> :</span> (<span class="id">0</span><span class="id"> :</span><span class="id"> {fimfun</span><span class="id"> aT</span><span class="id"> &gt;-&gt;</span><span class="id"> rT}</span>)<span class="id"> =</span><span class="id"> cst</span><span class="id"> 0</span><span class="id"> :&gt;</span> (_<span class="id"> -&gt;</span><span class="id"> _</span>)<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> fimfun_sum</span><span class="id"> I</span><span class="id"> r</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> I}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> {fimfun</span><span class="id"> aT</span><span class="id"> &gt;-&gt;</span><span class="id"> rT}</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> aT</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> r</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> f</span><span class="id"> i</span>)<span class="id"> x</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> r</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> f</span><span class="id"> i</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim/big_rec2:</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> i</span><span class="id"> y</span><span class="id"> ?</span><span class="id"> Pi</span><span class="id"> &lt;-</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :=</span><span class="id"> FImFun</span>.<span class="id">copy</span> (<span class="id">f</span><span class="id"> \+</span><span class="id"> g</span>) (<span class="id">f</span><span class="id"> +</span><span class="id"> g</span>).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :=</span><span class="id"> FImFun</span>.<span class="id">copy</span> (<span class="id">\-</span><span class="id"> f</span>) (<span class="id">-</span><span class="id"> f</span>).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :=</span><span class="id"> FImFun</span>.<span class="id">copy</span> (<span class="id">f</span><span class="id"> \-</span><span class="id"> g</span>) (<span class="id">f</span><span class="id"> -</span><span class="id"> g</span>).<br/>
<span class="vernacular">End</span><span class="id"> zmod</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
