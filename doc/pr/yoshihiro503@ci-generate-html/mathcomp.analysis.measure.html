
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.analysis.measure</title>
<meta name="description" content="Documentation of Coq module mathcomp.analysis.measure" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.analysis.measure</h1>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> all_ssreflect</span><span class="id"> all_algebra</span><span class="id"> archimedean</span><span class="id"> finmap</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> mathcomp_extra</span><span class="id"> boolp</span><span class="id"> classical_sets</span><span class="id"> functions</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> cardinality</span><span class="id"> fsbigop</span><span class="id"> reals</span><span class="id"> ereal</span><span class="id"> signed</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> topology</span><span class="id"> normedtype</span><span class="id"> sequences</span><span class="id"> esum</span><span class="id"> numfun</span>.<br/>
<span class="vernacular">From</span><span class="id"> HB</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> structures</span>.<br/>
<br/>
<div class="ssrdoc md">
# Measure Theory

NB: See CONTRIBUTING.md for an introduction to HB concepts and commands.

This files provides a formalization of the basics of measure theory. This
includes the formalization of mathematical structures and of measures, as
well as standard theorems such as the Measure Extension theorem that
builds a measure given a function defined over a semiring of sets, the
intermediate outer measure being
$\inf_F\{ \sum_{k=0}^\infty \mu(F_k)  | X \subseteq \bigcup_k F_k\}.$

References:
- R. Affeldt, C. Cohen. Measure construction by extension in dependent
  type theory with application to integration. JAR 2023
- Daniel Li. Int√©gration et applications. 2016
- Achim Klenke. Probability Theory. 2014

## Mathematical structures
```
   semiRingOfSetsType d == the type of semirings of sets
                           The carrier is a set of sets A_i such that
                           "measurable A_i" holds.
                           "measurable A" is printed as "d.-measurable A"
                           where d is a "display parameter" whose purpose
                           is to distinguish different "measurable"
                           predicates in the same context.
                           The HB class is SemiRingOfSets.
       ringOfSetsType d == the type of rings of sets
                           The HB class is RingOfSets.
        sigmaRingType d == the type of sigma-rings (of sets)
                           The HB class is SigmaRing.
    algebraOfSetsType d == the type of algebras of sets
                           The HB class is AlgebraOfsets.
         measurableType == the type of sigma-algebras
                           The HB class is Measurable.
```

## Instances of mathematical structures
```
discrete_measurable_unit == the measurableType corresponding to
                            [set: set unit]
discrete_measurable_bool == the measurableType corresponding to
                            [set: set bool]
 discrete_measurable_nat == the measurableType corresponding to
                            [set: set nat]
               setring G == the set of sets G contains the empty set, is
                            closed by union, and difference (it is a ring
                            of sets in the sense of ringOfSetsType)
                &lt;&lt;r G &gt;&gt; := smallest setring G
                            &lt;&lt;r G &gt;&gt; is equipped with a structure of ring
                            of sets.
   G.-ring.-measurable A == A belongs to the ring of sets &lt;&lt;r G &gt;&gt;
            sigma_ring G == the set of sets G forms a sigma-ring
               &lt;&lt;sr G &gt;&gt; == sigma-ring generated by G
                         := smallest sigma_ring G
       sigma_algebra D G == the set of sets G forms a sigma-algebra on D
             &lt;&lt;s D, G &gt;&gt; == sigma-algebra generated by G on D
                         := smallest (sigma_algebra D) G
                &lt;&lt;s G &gt;&gt; := &lt;&lt;s setT, G &gt;&gt;
                            &lt;&lt;s G &gt;&gt; is equipped with a structure of
                            sigma-algebra
  G.-sigma.-measurable A == A is measurable for the sigma-algebra &lt;&lt;s G &gt;&gt;
   g_sigma_algebraType G == the measurableType corresponding to &lt;&lt;s G &gt;&gt;
                            This is an HB alias.
   mu .-cara.-measurable == sigma-algebra of Caratheodory measurable sets
```

## Structures for functions on classes of sets

Hierarchy of contents, measures, s-finite/sigma-finite/finite measures,
etc. Also contains a number of details about its implementation.
```
{content set T -&gt; \bar R} == type of contents
                             T is expected to be a semiring of sets and R
                             a numFieldType.
                             The HB class is Content.
{measure set T -&gt; \bar R} == type of (non-negative) measures
                             T is expected to be a semiring of sets and
                             R is expected to be a numFieldType.
                             The HB class is Measure.
        Content_isMeasure == interface that extends a content to a measure
                             with the proof that it is semi_sigma_additive
Content_SubSigmaAdditive_isMeasure == interface that extends a content to
                             a measure with the proof that it is
                             sigma_sub_additive
                isMeasure == interface corresponding to the "textbook
                             definition" of measures
          sfinite_measure == predicate for s-finite measure functions
{sfinite_measure set T -&gt; \bar R} == type of s-finite measures
                             The HB class is SFiniteMeasure.
   sfinite_measure_seq mu == the sequence of finite measures of the
                             s-finite measure mu
                isSFinite == interface for functions that satisfy the
                             sfinite_measure predicate
                             s-finite measure using a sequence of finite
                             measures
        Measure_isSFinite == interface that extends a measure to an
                             s-finite measure using a sequence of finite
                             measures
            isSigmaFinite == interface for functions that satisfy
                             sigma finiteness
{sigma_finite_content set T -&gt; \bar R} == contents that are also sigma
                             finite
                             The HB class is SigmaFiniteContent.
{sigma_finite_measure set T -&gt; \bar R} == measures that are also sigma
                             finite
                             The HB class is SigmaFiniteMeasure.
         sigma_finite A f == the measure function f is sigma-finite on the
                             A : set T with T a semiring of sets
              fin_num_fun == predicate for finite function over measurable
                             sets
           FinNumFun.type == type of functions over semiring of sets
                             returning a fin_num
                             The HB class is FinNumFun.
{finite_measure set T -&gt; \bar R} == finite measures
                             The HB class is FiniteMeasure.
                 isFinite == interface for functions that satisfy the
                             fin_num_fun predicate
         Measure_isFinite == interface that extends a measure to a finite
                             measure using a proof of fin_num_fun
         isSubProbability == interface for functions that satisfy the
                             property of subprobability
                             The HB class is SubProbability.
       subprobability T R == subprobability measure over the
                             measurableType T with values in \bar R with
                             R : realType
                             The HB class is SubProbability.
 Measure_isSubProbability == interface that extends measures to
                             subprobability measures
            isProbability == interface for functions that satisfy the
                             property of probability measures
                             The HB class is Probability.
          probability T R == type of probability measure over the
                             measurableType T with values in \bar R
                             with R : realType
    Measure_isProbability == interface that extends measures to
                             probability measures
            mnormalize mu == normalization of a measure to a probability
                 mset U r == the set of probability measures mu such that
                             mu U &lt; r
                     pset == the sets mset U r with U measurable and
                             r \in [0,1]
             pprobability == the measurable type generated by pset
            lim_sup_set F == limit superior (or upper limit) of a
                             sequence of sets F
{outer_measure set T -&gt; \bar R} == type of an outer measure over sets
                             of elements of type T : Type where R is
                             expected to be a numFieldType
                             The HB class is OuterMeasure.
                             interfaces: isOuterMeasure,
                             isSubsetOuterMeasure
```

## Instances of measures
```
 pushforward mf m == pushforward/image measure of m by f, where mf is a
                     proof that f is measurable
                     m has type set T -&gt; \bar R.
             \d_a == Dirac measure
        msum mu n == the measure corresponding to the sum of the measures
                     mu_0, ..., mu_{n-1}
       @mzero T R == the zero measure
measure_add m1 m2 == the measure corresponding to the sum of the
                     measures m1 and m2
       mscale r m == the measure of corresponding to fun A =&gt; r * m A
                     where r has type {nonneg R}
     mseries mu n == the measure corresponding to the sum of the
                     measures mu_n, mu_{n+1}, ...
     mrestr mu mD == restriction of the measure mu to a set D; mD is a
                     proof that D is measurable
     counting T R == counting measure
 mfrestr mD muDoo == finite measure corresponding to the restriction of
                     the measure mu over D with mu D &lt; +oo,
                     mD : measurable D, muDoo : mu D &lt; +oo
```

## About sets of sets
```
     setI_closed G == the set of sets G is closed under finite
                      intersection
     setU_closed G == the set of sets G is closed under finite union
     setC_closed G == the set of sets G is closed under complement
    setSD_closed G == the set of sets G is closed under proper
                      difference
    setDI_closed G == the set of sets G is closed under difference
     setY_closed G == the set of sets G is closed under symmetric
                      difference
    ndseq_closed G == the set of sets G is closed under non-decreasing
                      countable union
    niseq_closed G == the set of sets G is closed under non-increasing
                      countable intersection
 trivIset_closed G == the set of sets G is closed under pairwise-disjoint
                      countable union
 lambda_system D G == G is a lambda_system of subsets of D
       &lt;&lt;l D, G &gt;&gt; == lambda-system generated by G on D
          &lt;&lt;l G &gt;&gt; := &lt;&lt;m setT, G &gt;&gt;
        monotone G == G is a monotone class
          &lt;&lt;M G &gt;&gt; == monotone class generated by G
                   := smallest monotone G
          dynkin G == G is a set of sets that form a Dynkin
                      system (or a d-system)
          &lt;&lt;d G &gt;&gt; == Dynkin system generated by G, i.e.,
                      smallest dynkin G
        strace G D := [set x `&amp;` D | x in G]
```
## Other measure-theoretic definitions

```
     measurable_fun D f == the function f with domain D is measurable
   preimage_class D f G == class of the preimages by f of sets in G
      image_class D f G == class of the sets with a preimage by f in G
   sigma_subadditive mu == predicate defining sigma-subadditivity
subset_sigma_subadditive mu == alternative predicate defining
                           sigma-subadditivity
       mu.-negligible A == A is mu negligible
 measure_is_complete mu == the measure mu is complete
 {ae mu, forall x, P x} == P holds almost everywhere for the measure mu,
                           declared as an instance of the type of filters
            ae_eq D f g == f is equal to g almost everywhere
```

## Measure extension theorem

From a premeasure to an outer measure (Measure Extension Theorem part 1):
```
     measurable_cover X == the set of sequences F such that
                           - forall k, F k is measurable
                           - X `&lt;=` \bigcup_k (F k)
                   mu^* == extension of the measure mu over a semiring of
                           sets (it is an outer measure)
```
From an outer measure to a measure (Measure Extension Theorem part 2):
```
    mu.-caratheodory == the set of Caratheodory measurable sets for the
                        outer measure mu, i.e., sets A such that
                        forall B, mu A = mu (A `&amp;` B) + mu (A `&amp;` ~` B)
caratheodory_type mu := T, where mu : {outer_measure set T -&gt; \bar R}
                        It is a canonical measurableType copy of T.
                        The restriction of the outer measure mu to the
                        sigma algebra of Caratheodory measurable sets is a
                        measure.
                        Remark: sets that are negligible for
                        this measure are Caratheodory measurable.
```
Measure Extension Theorem:
```
   measure_extension mu == extension of the content mu over a semiring of
                           sets to a measure over the generated
                           sigma algebra (requires a proof of
                           sigma-sub-additivity)
completed_measure_extension mu == similar to measure_extension but returns
                           a complete measure
```

## Product of measurable spaces
```
        preimage_classes f1 f2 == sigma-algebra generated by the union of
                                  the preimages by f1 and the preimages by
                                  f2 with f1 : T -&gt; T1 and f : T -&gt; T2, T1
                                  and T2 being semiRingOfSetsType's
  (d1, d2).-prod.-measurable A == A is measurable for the sigma-algebra
                                  generated from T1 x T2, with T1 and T2
                                  semiRingOfSetsType's with resp. display
                                  d1 and d2
```

## More measure-theoretic definitions
```
 m1 `&lt;&lt; m2 == m1 is absolutely continuous w.r.t. m2 or m2 dominates m1
 ess_sup f == essential supremum of the function f : T -&gt; R where T is a
              semiRingOfSetsType and R is a realType
```

</div>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<span class="vernacular">Import</span><span class="id"> Order</span>.<span class="id">TTheory</span><span class="id"> GRing</span>.<span class="id">Theory</span><span class="id"> Num</span>.<span class="id">Def</span><span class="id"> Num</span>.<span class="id">Theory</span>.<br/>
<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'s&lt;|' D , G '|&gt;'&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 40,</span><span class="id"> G,</span><span class="id"> D</span><span class="gallina-kwd"> at</span><span class="id"> next</span><span class="id"> level</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'s&lt;&lt;' A '&gt;&gt;'&quot;</span>.<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'d&lt;&lt;' D '&gt;&gt;'&quot;</span>.<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;mu .-negligible&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;mu .-negligible&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'ae' m , P }&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;{ 'ae'  m ,  P }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;mu .-measurable&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;mu .-measurable&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'\d_' a&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> a</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;'\d_' a&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;G .-sigma&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 1,</span><span class="id"> format</span> <span class="id">&quot;G .-sigma&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;G .-sigma.-measurable&quot;</span><br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;G .-sigma.-measurable&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;d .-ring&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 1,</span><span class="id"> format</span> <span class="id">&quot;d .-ring&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;d .-ring.-measurable&quot;</span><br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;d .-ring.-measurable&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;mu .-cara&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 1,</span><span class="id"> format</span> <span class="id">&quot;mu .-cara&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;mu .-cara.-measurable&quot;</span><br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;mu .-cara.-measurable&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;mu .-caratheodory&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;mu .-caratheodory&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'&lt;&lt;l' D , G '&gt;&gt;'&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;'&lt;&lt;l'  D ,  G  '&gt;&gt;'&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'&lt;&lt;l' G '&gt;&gt;'&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;'&lt;&lt;l'  G  '&gt;&gt;'&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'&lt;&lt;d' G '&gt;&gt;'&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;'&lt;&lt;d'  G '&gt;&gt;'&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'&lt;&lt;s' D , G '&gt;&gt;'&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;'&lt;&lt;s'  D ,  G  '&gt;&gt;'&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'&lt;&lt;s' G '&gt;&gt;'&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;'&lt;&lt;s'  G  '&gt;&gt;'&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'&lt;&lt;r' G '&gt;&gt;'&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;'&lt;&lt;r'  G '&gt;&gt;'&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'&lt;&lt;sr' G '&gt;&gt;'&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;'&lt;&lt;sr'  G '&gt;&gt;'&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;'&lt;&lt;M' G '&gt;&gt;'&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;'&lt;&lt;M'  G '&gt;&gt;'&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'content' fUV }&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;{ 'content'  fUV }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;[ 'content' 'of' f 'as' g ]&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ 'content'  'of'  f  'as'  g ]&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;[ 'content' 'of' f ]&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ 'content'  'of'  f ]&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'measure' fUV }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;{ 'measure'  fUV }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;[ 'measure' 'of' f 'as' g ]&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ 'measure'  'of'  f  'as'  g ]&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;[ 'measure' 'of' f ]&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ 'measure'  'of'  f ]&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'outer_measure' fUV }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;{ 'outer_measure'  fUV }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;[ 'outer_measure' 'of' f 'as' g ]&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ 'outer_measure'  'of'  f  'as'  g ]&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;[ 'outer_measure' 'of' f ]&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ 'outer_measure'  'of'  f ]&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;p .-prod&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 1,</span><span class="id"> format</span> <span class="id">&quot;p .-prod&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;p .-prod.-measurable&quot;</span><br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;p .-prod.-measurable&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;m1 `&lt;&lt; m2&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 51</span>).<br/>
<br/>
<span class="vernacular">Inductive</span><span class="id"> measure_display</span><span class="id"> :=</span><span class="id"> default_measure_display</span>.<br/>
<span class="vernacular">Declare</span><span class="vernacular"> Scope</span><span class="id"> measure_display_scope</span>.<br/>
<span class="vernacular">Delimit</span><span class="vernacular"> Scope</span><span class="id"> measure_display_scope</span><span class="gallina-kwd"> with</span><span class="id"> mdisp</span>.<br/>
<span class="vernacular">Bind</span><span class="vernacular"> Scope</span><span class="id"> measure_display_scope</span><span class="gallina-kwd"> with</span><span class="id"> measure_display</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> classes</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T}</span> (<span class="id">C</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> setC_closed</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> G</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">~`</span><span class="id"> A</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> setI_closed</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> A</span><span class="id"> B,</span><span class="id"> G</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> setU_closed</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> A</span><span class="id"> B,</span><span class="id"> G</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> setSD_closed</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> A</span><span class="id"> B,</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">A</span><span class="id"> `\`</span><span class="id"> B</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> setDI_closed</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> A</span><span class="id"> B,</span><span class="id"> G</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">A</span><span class="id"> `\`</span><span class="id"> B</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> setY_closed</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> A</span><span class="id"> B,</span><span class="id"> G</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">A</span><span class="id"> `+`</span><span class="id"> B</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> fin_bigcap_closed</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> I</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<span class="id"> A_,</span><span class="id"> finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">A_</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">G</span> (<span class="id">\bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>) (<span class="id">A_</span><span class="id"> i</span>)).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> finN0_bigcap_closed</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> I</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<span class="id"> A_,</span><span class="id"> finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> D</span><span class="id"> !=set0</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">A_</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">G</span> (<span class="id">\bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>) (<span class="id">A_</span><span class="id"> i</span>)).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> fin_bigcup_closed</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> I</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<span class="id"> A_,</span><span class="id"> finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">A_</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">G</span> (<span class="id">\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>) (<span class="id">A_</span><span class="id"> i</span>)).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> semi_setD_closed</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> A</span><span class="id"> B,</span><span class="id"> G</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> D,</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> finite_set</span><span class="id"> D,</span><span class="id"> D</span><span class="id"> `&lt;=`</span><span class="id"> G,</span><span class="id"> A</span><span class="id"> `\`</span><span class="id"> B</span><span class="id"> =</span><span class="id"> \bigcup_</span>(<span class="id">X</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> X</span><span class="id"> &amp;</span><span class="id"> trivIset</span><span class="id"> D</span><span class="id"> id]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setDI_semi_setD_closed</span><span class="id"> :</span><span class="id"> setDI_closed</span><span class="id"> -&gt;</span><span class="id"> semi_setD_closed</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mD</span><span class="id"> A</span><span class="id"> B</span><span class="id"> Am</span><span class="id"> Bm;</span><span class="gallina-kwd"> exists</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> `\`</span><span class="id"> B];</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> ?bigcup_set1//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> -&gt;;</span><span class="id"> apply:</span><span class="id"> mD</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> ndseq_closed</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> F,</span><span class="id"> nondecreasing_seq</span><span class="id"> F</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> G</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">\bigcup_i</span> (<span class="id">F</span><span class="id"> i</span>)).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> niseq_closed</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> F,</span><span class="id"> nonincreasing_seq</span><span class="id"> F</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> G</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">\bigcap_i</span> (<span class="id">F</span><span class="id"> i</span>)).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> trivIset_closed</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat,</span><span class="id"> trivIset</span><span class="id"> setT</span><span class="id"> F</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> G</span> (<span class="id">F</span><span class="id"> n</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">G</span> (<span class="id">\bigcup_k</span><span class="id"> F</span><span class="id"> k</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> fin_trivIset_closed</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> I</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id">,</span><span class="id"> finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> trivIset</span><span class="id"> D</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">\bigcup_</span>(<span class="id">k</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> F</span><span class="id"> k</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> setring</span><span class="id"> :=</span><span class="id"> [/\</span><span class="id"> G</span><span class="id"> set0,</span><span class="id"> setU_closed</span><span class="id"> &amp;</span><span class="id"> setDI_closed]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> sigma_ring</span><span class="id"> :=</span><span class="id"> [/\</span><span class="id"> G</span><span class="id"> set0,</span><span class="id"> setDI_closed</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> A</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat,</span> (<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> G</span> (<span class="id">A</span><span class="id"> n</span>))<span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">\bigcup_k</span><span class="id"> A</span><span class="id"> k</span>))<span class="id">]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> sigma_algebra</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> G</span><span class="id"> set0,</span> (<span class="gallina-kwd">forall</span><span class="id"> A,</span><span class="id"> G</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">D</span><span class="id"> `\`</span><span class="id"> A</span>))<span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> A</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat,</span> (<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> G</span> (<span class="id">A</span><span class="id"> n</span>))<span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">\bigcup_k</span><span class="id"> A</span><span class="id"> k</span>))<span class="id">]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> dynkin</span><span class="id"> :=</span><span class="id"> [/\</span><span class="id"> G</span><span class="id"> setT,</span><span class="id"> setC_closed</span><span class="id"> &amp;</span><span class="id"> trivIset_closed]</span>.<br/>
<br/>
<div class="doc md"> Until MathComp-Analysis 1.1.0, the identifier was `monotone_class`
because this definition corresponds to "classe monotone" in several
French references, e.g., the definition of "classe monotone" on the French wikipedia.</div>
<span class="vernacular">Definition</span><span class="id"> lambda_system</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> G</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> D,</span><span class="id"> setSD_closed</span><span class="id"> &amp;</span><span class="id"> ndseq_closed]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> monotone</span><span class="id"> :=</span><span class="id"> ndseq_closed</span><span class="id"> /\</span><span class="id"> niseq_closed</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> classes</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.2.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `lambda_system`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> monotone_class</span><span class="id"> :=</span><span class="id"> lambda_system</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.3.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `setSD_closed`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> setD_closed</span><span class="id"> :=</span><span class="id"> setSD_closed</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> powerset_sigma_ring</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">sigma_ring</span><span class="id"> [set</span><span class="id"> X</span><span class="id"> |</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> D]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> F</span><span class="id"> FA/=;</span><span class="id"> apply:</span><span class="id"> bigcup_sub</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> FA</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> U</span><span class="id"> V</span><span class="id"> +</span><span class="id"> VA;</span><span class="id"> apply:</span><span class="id"> subset_trans;</span><span class="id"> exact:</span><span class="id"> subDsetl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> powerset_lambda_system</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">lambda_system</span><span class="id"> D</span><span class="id"> [set</span><span class="id"> X</span><span class="id"> |</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> D]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> BA</span><span class="id"> +</span><span class="id"> BD;</span><span class="id"> apply:</span><span class="id"> subset_trans;</span><span class="id"> exact:</span><span class="id"> subDsetl</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /=</span><span class="id"> F</span><span class="id"> _</span><span class="id"> FD;</span><span class="id"> exact:</span><span class="id"> bigcup_sub</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'&lt;&lt;l' D , G '&gt;&gt;'&quot;</span><span class="id"> :=</span> (<span class="id">smallest</span> (<span class="id">lambda_system</span><span class="id"> D</span>)<span class="id"> G</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">classical_set_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'&lt;&lt;l' G '&gt;&gt;'&quot;</span><span class="id"> :=</span> (<span class="id">&lt;&lt;l</span><span class="id"> setT,</span><span class="id"> G&gt;&gt;</span>)<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'&lt;&lt;d' G '&gt;&gt;'&quot;</span><span class="id"> :=</span> (<span class="id">smallest</span><span class="id"> dynkin</span><span class="id"> G</span>)<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'&lt;&lt;s' D , G '&gt;&gt;'&quot;</span><span class="id"> :=</span> (<span class="id">smallest</span> (<span class="id">sigma_algebra</span><span class="id"> D</span>)<span class="id"> G</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">classical_set_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'&lt;&lt;s' G '&gt;&gt;'&quot;</span><span class="id"> :=</span> (<span class="id">&lt;&lt;s</span><span class="id"> setT,</span><span class="id"> G&gt;&gt;</span>)<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'&lt;&lt;r' G '&gt;&gt;'&quot;</span><span class="id"> :=</span> (<span class="id">smallest</span><span class="id"> setring</span><span class="id"> G</span>)<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'&lt;&lt;sr' G '&gt;&gt;'&quot;</span><span class="id"> :=</span> (<span class="id">smallest</span><span class="id"> sigma_ring</span><span class="id"> G</span>)<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'&lt;&lt;M' G '&gt;&gt;'&quot;</span><span class="id"> :=</span> (<span class="id">smallest</span><span class="id"> monotone</span><span class="id"> G</span>)<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> lambda_system_smallest</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> GD</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> G</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> D</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lambda_system_smallest</span><span class="id"> :</span><span class="id"> lambda_system</span><span class="id"> D</span><span class="id"> &lt;&lt;l</span><span class="id"> D</span><span class="id"> ,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> [A</span><span class="id"> MA</span><span class="id"> |</span><span class="id"> E</span><span class="id"> [monoE]</span><span class="id"> |</span><span class="id"> A</span><span class="id"> B</span><span class="id"> BA</span><span class="id"> MA</span><span class="id"> MB</span><span class="id"> E</span><span class="id"> [[EsubD</span><span class="id"> ED</span><span class="id"> setDE</span><span class="id"> ndE]</span><span class="id"> GE]</span><span class="id"> |]</span>.<br/>
<span class="id">-</span><span class="id"> have</span><span class="id"> monoH</span><span class="id"> :=</span><span class="id"> powerset_lambda_system</span><span class="id"> D</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">monoH</span>)<span class="id"> =&gt;</span><span class="id"> +</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> apply;</span><span class="id"> exact:</span><span class="id"> MA</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> monoE</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply</span><span class="id"> setDE</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> [exact:</span><span class="id"> MA|exact:</span><span class="id"> MB]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> F</span><span class="id"> ndF</span><span class="id"> MF</span><span class="id"> E</span><span class="id"> [[EsubD</span><span class="id"> ED</span><span class="id"> setDE</span><span class="id"> ndE]</span><span class="id"> CE];</span><span class="id"> apply</span><span class="id"> ndE=&gt;</span><span class="id"> //</span><span class="id"> n;</span><span class="id"> exact:</span><span class="id"> MF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> lambda_system_smallest</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fin_bigcup_closedP</span><span class="id"> T</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">G</span><span class="id"> set0</span><span class="id"> /\</span><span class="id"> setU_closed</span><span class="id"> G</span>)<span class="id"> &lt;-&gt;</span><span class="id"> fin_bigcup_closed</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [[G0</span><span class="id"> GU]</span><span class="id"> I</span><span class="id"> D</span><span class="id"> A</span><span class="id"> DF</span><span class="id"> GA|GU];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> G0</span><span class="id"> :</span><span class="id"> G</span><span class="id"> set0</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> GU</span><span class="id"> void</span><span class="id"> set0</span><span class="id"> point;</span><span class="id"> rewrite</span><span class="id"> bigcup0//;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> A</span><span class="id"> B</span><span class="id"> GA</span><span class="id"> GB;</span><span class="id"> rewrite</span><span class="id"> -bigcup2inE;</span><span class="id"> apply:</span><span class="id"> GU</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[|[|[]]]</span>.<br/>
<span class="id">elim/Pchoice:</span><span class="id"> I</span><span class="id"> =&gt;</span><span class="id"> I</span><span class="gallina-kwd"> in</span><span class="id"> D</span><span class="id"> DF</span><span class="id"> A</span><span class="id"> GA</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> -bigsetU_fset_set//</span><span class="id"> big_seq</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> elim/big_ind:</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> in_fset_set//</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /GA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finN0_bigcap_closedP</span><span class="id"> T</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">setI_closed</span><span class="id"> G</span><span class="id"> &lt;-&gt;</span><span class="id"> finN0_bigcap_closed</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [GI</span><span class="id"> I</span><span class="id"> D</span><span class="id"> A</span><span class="id"> DF</span><span class="id"> [i</span><span class="id"> Di]</span><span class="id"> GA|GI</span><span class="id"> A</span><span class="id"> B</span><span class="id"> GA</span><span class="id"> GB];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -bigcap2inE;</span><span class="id"> apply:</span><span class="id"> GI</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> [|[|[|[]]]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 0%N</span>.<br/>
<span class="id">elim/Pchoice:</span><span class="id"> I</span><span class="id"> =&gt;</span><span class="id"> I</span><span class="gallina-kwd"> in</span><span class="id"> D</span><span class="id"> DF</span><span class="id"> i</span><span class="id"> Di</span><span class="id"> A</span><span class="id"> GA</span><span class="id"> *</span>.<br/>
<span class="id">have</span><span class="id"> finDDi</span><span class="id"> :</span><span class="id"> finite_set</span> (<span class="id">D</span><span class="id"> `\</span><span class="id"> i</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> finite_setD</span>.<br/>
<span class="id">rewrite</span> (<span class="id">bigcap_setD1</span><span class="id"> i</span>)<span class="id">//</span><span class="id"> -bigsetI_fset_set//</span><span class="id"> big_seq</span>.<br/>
<span class="id">elim/big_rec:</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> [|j</span><span class="id"> B];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIT;</span><span class="id"> apply:</span><span class="id"> GA</span>.<br/>
<span class="id">rewrite</span><span class="id"> in_fset_set//</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> -[Dj</span><span class="id"> /eqP</span><span class="id"> nij]</span><span class="id"> GAB</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setICA;</span><span class="id"> apply:</span><span class="id"> GI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> GA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sedDI_closedP</span><span class="id"> T</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">setDI_closed</span><span class="id"> G</span><span class="id"> &lt;-&gt;</span> (<span class="id">setI_closed</span><span class="id"> G</span><span class="id"> /\</span><span class="id"> setSD_closed</span><span class="id"> G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [GDI|[GI</span><span class="id"> GD]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> =&gt;</span><span class="id"> [|AB]</span><span class="id"> =&gt;</span><span class="id"> GA</span><span class="id"> GB;</span><span class="id"> rewrite</span><span class="id"> -?setDD//;</span><span class="id"> do</span><span class="id"> ?apply:</span> (<span class="id">GDI</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> GA</span><span class="id"> GB;</span><span class="id"> suff</span><span class="id"> &lt;-</span><span class="id"> :</span><span class="id"> A</span><span class="id"> `\`</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> A</span><span class="id"> `\`</span><span class="id"> B</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> GD</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> GI</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> setCI</span><span class="id"> setIUr</span><span class="id"> -setDE</span><span class="id"> setDv</span><span class="id"> set0U</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_algebra_bigcap</span><span class="id"> T</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)) (<span class="id">J</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> J</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> sigma_algebra</span><span class="id"> D</span> (<span class="id">F</span><span class="id"> n</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">sigma_algebra</span><span class="id"> D</span> (<span class="id">\bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> J</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mG;</span><span class="id"> split=&gt;</span><span class="id"> [i</span><span class="id"> Ji|A</span><span class="id"> AJ</span><span class="id"> i</span><span class="id"> Ji|H</span><span class="id"> GH</span><span class="id"> i</span><span class="id"> Ji];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> mG</span><span class="id"> i</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> mGiC</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> mG</span><span class="id"> i</span><span class="id"> Ji;</span><span class="id"> exact/mGiC/AJ</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> mGiU]</span><span class="id"> :=</span><span class="id"> mG</span><span class="id"> i</span><span class="id"> Ji;</span><span class="id"> apply:</span><span class="id"> mGiU</span><span class="id"> =&gt;</span><span class="id"> j;</span><span class="id"> exact:</span><span class="id"> GH</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_algebraP</span><span class="id"> T</span><span class="id"> U</span> (<span class="id">C</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> X,</span><span class="id"> C</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> U</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">sigma_algebra</span><span class="id"> U</span><span class="id"> C</span><span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> C</span><span class="id"> U,</span><span class="id"> setSD_closed</span><span class="id"> C,</span><span class="id"> ndseq_closed</span><span class="id"> C</span><span class="id"> &amp;</span><span class="id"> setI_closed</span><span class="id"> C]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> C_subU;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [[C0</span><span class="id"> CD</span><span class="id"> CU]|[DT</span><span class="id"> DC</span><span class="id"> DU</span><span class="id"> DI]];</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">setD0</span><span class="id"> U</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> CD</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> BA</span><span class="id"> CA</span><span class="id"> CB;</span><span class="id"> rewrite</span> (_<span class="id"> :</span><span class="id"> A</span><span class="id"> `\`</span><span class="id"> B</span><span class="id"> =</span><span class="id"> U</span><span class="id"> `\`</span> ((<span class="id">U</span><span class="id"> `\`</span><span class="id"> A</span>)<span class="id"> `|`</span><span class="id"> B</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply</span><span class="id"> CD;</span><span class="id"> rewrite</span><span class="id"> -bigcup2E;</span><span class="id"> apply:</span><span class="id"> CU</span><span class="id"> =&gt;</span><span class="id"> -[|[|[|]]]</span><span class="id"> //=;</span><span class="id"> exact:</span><span class="id"> CD</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setDUr</span><span class="id"> setDD</span><span class="id"> [in</span><span class="id"> RHS]setDE</span><span class="id"> setIACA</span><span class="id"> setIid</span><span class="id"> -setDE</span><span class="id"> setIidr//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setDE;</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left;</span><span class="id"> apply:</span><span class="id"> C_subU</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> F</span><span class="id"> ndF</span><span class="id"> DF;</span><span class="id"> exact:</span><span class="id"> CU</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> DA</span><span class="id"> DB;</span><span class="id"> rewrite</span> (_<span class="id"> :</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> =</span><span class="id"> U</span><span class="id"> `\`</span> ((<span class="id">U</span><span class="id"> `\`</span><span class="id"> A</span>)<span class="id"> `|`</span> (<span class="id">U</span><span class="id"> `\`</span><span class="id"> B</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply</span><span class="id"> CD;</span><span class="id"> rewrite</span><span class="id"> -bigcup2E;</span><span class="id"> apply:</span><span class="id"> CU</span><span class="id"> =&gt;</span><span class="id"> -[|[|[|]]]</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> CD</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setDUr</span><span class="id"> !setDD</span><span class="id"> setIACA</span><span class="id"> setIid</span> (<span class="id">@setIidr</span><span class="id"> _</span><span class="id"> U</span>)<span class="id">//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left;</span><span class="id"> exact:</span><span class="id"> C_subU</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">setDv</span><span class="id"> U</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> DC</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> CA;</span><span class="id"> apply:</span><span class="id"> DC</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> C_subU</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> F</span><span class="id"> DF</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> C</span><span class="id"> X]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> \bigcup_i</span><span class="id"> \big[setU/set0]_</span>(<span class="id">j</span><span class="id"> &lt;</span><span class="id"> i</span>.<span class="id">+1</span>)<span class="id"> F</span><span class="id"> j</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> DU;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> exact/subsetPset/subset_bigsetU</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">elim=&gt;</span><span class="id"> [|n</span><span class="id"> ih];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> big_ord_recr</span><span class="id"> /=</span><span class="id"> big_ord0</span><span class="id"> set0U;</span><span class="id"> exact:</span><span class="id"> DF</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> CU</span><span class="id"> :</span><span class="id"> setU_closed</span><span class="id"> C</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> DA</span><span class="id"> DB;</span><span class="id"> rewrite</span> (_<span class="id"> :</span><span class="id"> A</span><span class="id"> `|`</span><span class="id"> B</span><span class="id"> =</span><span class="id"> U</span><span class="id"> `\`</span> ((<span class="id">U</span><span class="id"> `\`</span><span class="id"> A</span>)<span class="id"> `&amp;`</span> (<span class="id">U</span><span class="id"> `\`</span><span class="id"> B</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> DC</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> DI;</span><span class="id"> apply:</span><span class="id"> DC</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> C_subU</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left;</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setDIr//</span><span class="id"> !setDD</span> (<span class="id">setIidr</span> (<span class="id">C_subU</span><span class="id"> _</span><span class="id"> DA</span>)) (<span class="id">setIidr</span> (<span class="id">C_subU</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_ord_recr;</span><span class="id"> exact:</span><span class="id"> CU</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [[n</span><span class="id"> _</span><span class="id"> Fnx]|[n</span><span class="id"> _]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> big_ord_recr</span><span class="id"> /=;</span><span class="id"> right</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -bigcup_mkord</span><span class="id"> =&gt;</span><span class="id"> -[m</span><span class="id"> /=];</span><span class="id"> rewrite</span><span class="id"> ltnS</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> Fmx;</span><span class="gallina-kwd"> exists</span><span class="id"> m</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> generated_sigma_algebra</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">M</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> smallest_sigma_algebra</span><span class="id"> :</span><span class="id"> sigma_algebra</span><span class="id"> D</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [|A</span><span class="id"> GA|A</span><span class="id"> GA]</span><span class="id"> P</span><span class="id"> [[P0</span><span class="id"> PD</span><span class="id"> PU]]</span><span class="id"> GP</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">PD</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> GA</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">PU</span>)<span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> GA</span>.<br/>
Qed.</div></details>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> smallest_sigma_algebra</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_sigma_algebra2</span><span class="id"> M</span><span class="id"> :</span><span class="id"> M</span><span class="id"> `&lt;=`</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> M</span><span class="id"> &gt;&gt;</span><span class="id"> `&lt;=`</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> sub_smallest2r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_algebra_id</span><span class="id"> :</span><span class="id"> sigma_algebra</span><span class="id"> D</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> =</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /smallest_id-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_sigma_algebra</span><span class="id"> :</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> sub_smallest</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_algebra0</span><span class="id"> :</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> smallest_sigma_algebra</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_algebraCD</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span> (<span class="id">D</span><span class="id"> `\`</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> smallest_sigma_algebra</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_algebra_bigcup</span> (<span class="id">A</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span> (<span class="id">A</span><span class="id"> i</span>))<span class="id"> -&gt;</span> <span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span> (<span class="id">\bigcup_i</span> (<span class="id">A</span><span class="id"> i</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> smallest_sigma_algebra</span><span class="id"> A</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> generated_sigma_algebra</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> smallest_sigma_algebra</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> generated_setring</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">M</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> smallest_setring</span><span class="id"> :</span><span class="id"> setring</span><span class="id"> &lt;&lt;r</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [|A</span><span class="id"> B</span><span class="id"> GA</span><span class="id"> GB|A</span><span class="id"> B</span><span class="id"> GA</span><span class="id"> GB]</span><span class="id"> P</span><span class="id"> [[P0</span><span class="id"> PU</span><span class="id"> PDI]]</span><span class="id"> GP</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">PU</span>)<span class="id">;</span><span class="id"> [apply:</span><span class="id"> GA|apply:</span><span class="id"> GB]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">PDI</span>)<span class="id">;</span><span class="id"> [apply:</span><span class="id"> GA|apply:</span><span class="id"> GB]</span>.<br/>
Qed.</div></details>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> smallest_setring</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_setring2</span><span class="id"> M</span><span class="id"> :</span><span class="id"> M</span><span class="id"> `&lt;=`</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> &lt;&lt;r</span><span class="id"> M</span><span class="id"> &gt;&gt;</span><span class="id"> `&lt;=`</span><span class="id"> &lt;&lt;r</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> sub_smallest2r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setring_id</span><span class="id"> :</span><span class="id"> setring</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> &lt;&lt;r</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> =</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /smallest_id-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_setring</span><span class="id"> :</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> &lt;&lt;r</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> sub_smallest</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setring0</span><span class="id"> :</span><span class="id"> &lt;&lt;r</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> smallest_setring</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setringDI</span><span class="id"> :</span><span class="id"> setDI_closed</span><span class="id"> &lt;&lt;r</span><span class="id"> G&gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> smallest_setring</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setringU</span><span class="id"> :</span><span class="id"> setU_closed</span><span class="id"> &lt;&lt;r</span><span class="id"> G&gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> smallest_setring</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setring_fin_bigcup</span><span class="id"> :</span><span class="id"> fin_bigcup_closed</span><span class="id"> &lt;&lt;r</span><span class="id"> G&gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply/fin_bigcup_closedP;</span><span class="id"> split;</span><span class="id"> [apply:</span><span class="id"> setring0|apply:</span><span class="id"> setringU]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> generated_setring</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> smallest_setring</span><span class="id"> setring0</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> g_sigma_algebra_lambda_system</span><span class="id"> T</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> X,</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> D</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">lambda_system</span><span class="id"> D</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sDGD;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> smallest_sigma_algebra</span><span class="id"> D</span><span class="id"> G</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /</span>(<span class="id">sigma_algebraP</span><span class="id"> sDGD</span>)<span class="id"> [sT</span><span class="id"> sD</span><span class="id"> snd</span><span class="id"> sI];</span><span class="id"> split</span>.<br/>
Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.2.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `g_sigma_algebra_lambda_system`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> monotone_class_g_salgebra</span><span class="id"> :=</span><span class="id"> g_sigma_algebra_lambda_system</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> smallest_sigma_ring</span><span class="id"> T</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><span class="id"> sigma_ring</span><span class="id"> &lt;&lt;sr</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [B</span><span class="id"> [[]]//|A</span><span class="id"> B</span><span class="id"> GA</span><span class="id"> GB</span><span class="id"> C</span><span class="id"> [[?</span><span class="id"> CDI</span><span class="id"> ?]]</span><span class="id"> GC|A</span><span class="id"> GA</span><span class="id"> C</span><span class="id"> [[?</span><span class="id"> ?</span><span class="id"> CU]]</span><span class="id"> GC]</span><span class="id"> /=</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">CDI</span>)<span class="id">;</span><span class="id"> [exact:</span><span class="id"> GA|exact:</span><span class="id"> GB]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">CU</span>)<span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> exact:</span><span class="id"> GA</span>.<br/>
Qed.</div></details>
<br/>
<div class="doc md"> see Paul Halmos' Measure Theory, Ch.1, sec.6, thm.A(1), p.27</div>
<span class="vernacular">Lemma</span><span class="id"> sigma_ring_monotone</span><span class="id"> T</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><span class="id"> sigma_ring</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> monotone</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [G0</span><span class="id"> GDI</span><span class="id"> GU];</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [F</span><span class="id"> ndF</span><span class="id"> GF|F</span><span class="id"> icF</span><span class="id"> GF];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> GU</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">@setD_bigcup</span><span class="id"> _</span><span class="id"> _</span><span class="id"> F</span><span class="id"> _</span><span class="id"> O</span>)<span class="id">//;</span><span class="id"> apply:</span> (<span class="id">GDI</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> GF</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> bigcup_mkcond;</span><span class="id"> apply:</span><span class="id"> GU</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> GDI</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> g_sigma_ring_monotone</span><span class="id"> T</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><span class="id"> monotone</span><span class="id"> &lt;&lt;sr</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> sigma_ring_monotone</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> smallest_sigma_ring</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_g_sigma_ring</span><span class="id"> T</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> &lt;&lt;sr</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> sub_smallest</span>. Qed.</div></details>
<br/>
<div class="doc md"> see Paul Halmos' Measure Theory, Ch.1, sec.6, thm.A(2), p.27</div>
<span class="vernacular">Lemma</span><span class="id"> setring_monotone_sigma_ring</span><span class="id"> T</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">setring</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> monotone</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> sigma_ring</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [G0</span><span class="id"> GU</span><span class="id"> GD]</span><span class="id"> [ndG</span><span class="id"> niG];</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> F</span><span class="id"> GF</span>.<br/>
<span class="id">rewrite</span><span class="id"> -bigcup_bigsetU_bigcup;</span><span class="id"> apply:</span><span class="id"> ndG</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> exact/subsetPset/subset_bigsetU</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> elim=&gt;</span><span class="id"> [|n</span><span class="id"> ih];</span><span class="id"> rewrite</span><span class="id"> big_ord_recr/=</span><span class="id"> ?big_ord0</span><span class="id"> ?set0U//;</span><span class="id"> exact:</span><span class="id"> GU</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> g_monotone_monotone</span><span class="id"> T</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><span class="id"> monotone</span><span class="id"> &lt;&lt;M</span><span class="id"> G&gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> /=</span><span class="id"> F</span><span class="id"> ndF</span><span class="id"> GF</span><span class="id"> C</span><span class="id"> [[ndC</span><span class="id"> niC]</span><span class="id"> GC];</span><br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> {}GC</span><span class="id"> :</span><span class="id"> &lt;&lt;M</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> `&lt;=`</span><span class="id"> C</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> smallest_sub</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">ndC</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i;</span><span class="id"> apply:</span> (<span class="id">GC</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> GF</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">niC</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i;</span><span class="id"> apply:</span> (<span class="id">GC</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> GF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> g_monotone_g_sigma_ring</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> ringG</span><span class="id"> :</span><span class="id"> setring</span><span class="id"> G</span>.<br/>
<br/>
<div class="doc md"> see Paul Halmos' Measure Theory, Ch.1, sec.6, thm.B, p.27</div>
<span class="vernacular">Lemma</span><span class="id"> g_monotone_setring</span><span class="id"> :</span><span class="id"> setring</span><span class="id"> &lt;&lt;M</span><span class="id"> G&gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> M</span><span class="id"> :=</span><span class="id"> &lt;&lt;M</span><span class="id"> G&gt;&gt;</span>.<br/>
<span class="id">pose</span><span class="id"> K</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> E</span><span class="id"> |</span><span class="id"> [/\</span><span class="id"> M</span> (<span class="id">E</span><span class="id"> `\`</span><span class="id"> F</span>)<span class="id">,</span><span class="id"> M</span> (<span class="id">F</span><span class="id"> `\`</span><span class="id"> E</span>)<span class="id"> &amp;</span><span class="id"> M</span> (<span class="id">E</span><span class="id"> `|`</span><span class="id"> F</span>)<span class="id">]</span><span class="id"> ]</span>.<br/>
<span class="id">have</span><span class="id"> KP</span><span class="id"> E</span><span class="id"> F</span><span class="id"> :</span><span class="id"> K</span>(<span class="id">F</span>)<span class="id"> E</span><span class="id"> -&gt;</span><span class="id"> K</span>(<span class="id">E</span>)<span class="id"> F</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> []</span><span class="id"> *;</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> 1?setUC</span>.<br/>
<span class="id">have</span><span class="id"> K_monotone</span><span class="id"> F</span><span class="id"> :</span><span class="id"> monotone</span> (<span class="id">K</span>(<span class="id">F</span>)).<br/>
&nbsp;&nbsp;<span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /=</span><span class="id"> H</span><span class="id"> ndH</span><span class="id"> KFH;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> setD_bigcupl;</span><span class="id"> apply:</span> (<span class="id">g_monotone_monotone</span><span class="id"> G</span>).<span class="id">1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> m</span><span class="id"> n</span><span class="id"> mn;</span><span class="id"> apply/subsetPset;</span><span class="id"> apply:</span><span class="id"> setSD;</span><span class="id"> exact/subsetPset/ndH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> KFH</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> setC_bigcup</span><span class="id"> -bigcapIr//;</span><span class="id"> apply:</span> (<span class="id">g_monotone_monotone</span><span class="id"> G</span>).<span class="id">2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> m</span><span class="id"> n</span><span class="id"> mn;</span><span class="id"> apply/subsetPset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> setDS;</span><span class="id"> exact/subsetPset/ndH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> KFH</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> -bigcupUl//;</span><span class="id"> apply:</span> (<span class="id">g_monotone_monotone</span><span class="id"> G</span>).<span class="id">1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> m</span><span class="id"> n</span><span class="id"> mn;</span><span class="id"> apply/subsetPset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> setSU;</span><span class="id"> exact/subsetPset/ndH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> KFH</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /=</span><span class="id"> H</span><span class="id"> niH</span><span class="id"> KFH;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> -bigcapIl//;</span><span class="id"> apply:</span> (<span class="id">g_monotone_monotone</span><span class="id"> G</span>).<span class="id">2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> m</span><span class="id"> n</span><span class="id"> mn;</span><span class="id"> apply/subsetPset;</span><span class="id"> apply:</span><span class="id"> setSI;</span><span class="id"> exact/subsetPset/niH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> KFH</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> setC_bigcap</span><span class="id"> setI_bigcupr;</span><span class="id"> apply:</span> (<span class="id">g_monotone_monotone</span><span class="id"> G</span>).<span class="id">1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> m</span><span class="id"> n</span><span class="id"> mn;</span><span class="id"> apply/subsetPset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> setIS;</span><span class="id"> apply:</span><span class="id"> subsetC;</span><span class="id"> exact/subsetPset/niH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> KFH</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> setU_bigcapl//;</span><span class="id"> apply:</span> (<span class="id">g_monotone_monotone</span><span class="id"> G</span>).<span class="id">2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> m</span><span class="id"> n</span><span class="id"> mn;</span><span class="id"> apply/subsetPset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> setSU;</span><span class="id"> exact/subsetPset/niH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> KFH</span><span class="id"> i</span>.<br/>
<span class="id">have</span><span class="id"> G_KF</span><span class="id"> F</span><span class="id"> :</span><span class="id"> G</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> K</span>(<span class="id">F</span>).<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> ringG</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> GU</span><span class="id"> GDI</span><span class="id"> GF</span><span class="id"> A</span><span class="id"> GA;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest;</span><span class="id"> exact:</span><span class="id"> GDI</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest;</span><span class="id"> exact:</span><span class="id"> GDI</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest;</span><span class="id"> exact:</span><span class="id"> GU</span>.<br/>
<span class="id">have</span><span class="id"> GM_KF</span><span class="id"> F</span><span class="id"> :</span><span class="id"> G</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> M</span><span class="id"> `&lt;=`</span><span class="id"> K</span>(<span class="id">F</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> GF;</span><span class="id"> apply:</span><span class="id"> smallest_sub</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> G_KF</span>.<br/>
<span class="id">have</span><span class="id"> MG_KF</span><span class="id"> F</span><span class="id"> :</span><span class="id"> M</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> K</span>(<span class="id">F</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> MF</span><span class="id"> A</span><span class="id"> GA;</span><span class="id"> rewrite</span><span class="id"> /K/=;</span><span class="id"> split;</span><span class="id"> have</span><span class="id"> /KP[]</span><span class="id"> :=</span><span class="id"> GM_KF</span><span class="id"> _</span><span class="id"> GA</span><span class="id"> _</span><span class="id"> MF</span>.<br/>
<span class="id">have</span><span class="id"> MM_KF</span><span class="id"> F</span><span class="id"> :</span><span class="id"> M</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> M</span><span class="id"> `&lt;=`</span><span class="id"> K</span>(<span class="id">F</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> MF;</span><span class="id"> apply:</span><span class="id"> smallest_sub</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> MG_KF</span>.<br/>
<span class="id">split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest;</span><span class="id"> case:</span><span class="id"> ringG</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> GA</span><span class="id"> GB;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> MM_KF</span><span class="id"> _</span><span class="id"> GB</span><span class="id"> _</span><span class="id"> GA</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> GA</span><span class="id"> GB;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> MM_KF</span><span class="id"> _</span><span class="id"> GB</span><span class="id"> _</span><span class="id"> GA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> g_monotone_g_sigma_ring</span><span class="id"> :</span><span class="id"> &lt;&lt;M</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> =</span><span class="id"> &lt;&lt;sr</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> smallest_sub;</span><span class="id"> [exact:</span><span class="id"> g_sigma_ring_monotone|</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> sub_g_sigma_ring]</span>.<br/>
<span class="id">apply:</span><span class="id"> smallest_sub;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> sub_smallest</span>.<br/>
<span class="id">apply:</span><span class="id"> setring_monotone_sigma_ring;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> g_monotone_monotone</span>.<br/>
<span class="id">exact:</span><span class="id"> g_monotone_setring</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> g_monotone_g_sigma_ring</span>.<br/>
<br/>
<span class="vernacular">Corollary</span><span class="id"> monotone_setring_sub_g_sigma_ring</span><span class="id"> T</span> (<span class="id">G</span><span class="id"> R</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><span class="id"> monotone</span><span class="id"> G</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">setring</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> `&lt;=`</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> &lt;&lt;sr</span><span class="id"> R&gt;&gt;</span><span class="id"> `&lt;=`</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> mG</span><span class="id"> rR</span><span class="id"> RG;</span><span class="id"> rewrite</span><span class="id"> -g_monotone_g_sigma_ring//;</span><span class="id"> exact:</span><span class="id"> smallest_sub</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> smallest_lambda_system</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)) (<span class="id">setIG</span><span class="id"> :</span><span class="id"> setI_closed</span><span class="id"> G</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> lambdaDG</span><span class="id"> :</span><span class="id"> lambda_system</span><span class="id"> D</span><span class="id"> &lt;&lt;l</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> smallest_lambda_system</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> X,</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> D</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">&lt;&lt;l</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> =</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sDGD;</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> smallest_sub;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> g_sigma_algebra_lambda_system</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> sub_sigma_algebra</span>.<br/>
<span class="id">suff:</span><span class="id"> setI_closed</span><span class="id"> &lt;&lt;l</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> IH;</span><span class="id"> apply:</span><span class="id"> smallest_sub</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/sigma_algebraP;</span><span class="id"> case:</span><span class="id"> lambdaDG</span>.<br/>
<span class="id">pose</span><span class="id"> H</span><span class="id"> :=</span><span class="id"> &lt;&lt;l</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<span class="id">pose</span><span class="id"> H_</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> X</span><span class="id"> |</span><span class="id"> H</span><span class="id"> X</span><span class="id"> /\</span><span class="id"> H</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="id">]</span>.<br/>
<span class="id">have</span><span class="id"> setDH_</span><span class="id"> A</span><span class="id"> :</span><span class="id"> setSD_closed</span> (<span class="id">H_</span><span class="id"> A</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> XY</span><span class="id"> [HX</span><span class="id"> HXA]</span><span class="id"> [HY</span><span class="id"> HYA];</span><span class="id"> case:</span><span class="id"> lambdaDG</span><span class="id"> =&gt;</span><span class="id"> h</span><span class="id"> _</span><span class="id"> setDH</span><span class="id"> _;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> setDH</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> _</span><span class="id"> `&amp;`</span><span class="id"> _</span><span class="id"> =</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="id"> `\`</span> (<span class="id">Y</span><span class="id"> `&amp;`</span><span class="id"> A</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> split=&gt;</span><span class="id"> [[[?</span><span class="id"> ?]</span><span class="id"> ?]|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [[?</span><span class="id"> ?]</span><span class="id"> YAx];</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> contra_not</span><span class="id"> YAx</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> setDH</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> setSI</span>.<br/>
<span class="id">have</span><span class="id"> ndH_</span><span class="id"> A</span><span class="id"> :</span><span class="id"> ndseq_closed</span> (<span class="id">H_</span><span class="id"> A</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> ndF</span><span class="id"> H_AF;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> lambdaDG</span><span class="id"> =&gt;</span><span class="id"> h</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> apply</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> H_AF</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setI_bigcupl;</span><span class="id"> case:</span><span class="id"> lambdaDG</span><span class="id"> =&gt;</span><span class="id"> h</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> apply</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> m</span><span class="id"> n</span><span class="id"> mn;</span><span class="id"> apply/subsetPset;</span><span class="id"> apply:</span><span class="id"> setSI;</span><span class="id"> apply/subsetPset/ndF</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> H_AF</span><span class="id"> n</span>.<br/>
<span class="id">have</span><span class="id"> GGH_</span><span class="id"> X</span><span class="id"> :</span><span class="id"> G</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> H_</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> GX;</span><span class="id"> rewrite</span><span class="id"> /H_</span><span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> GA;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> sub_smallest</span><span class="id"> GA</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">@sub_smallest</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> G</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> setIG</span>.<br/>
<span class="id">have</span><span class="id"> HD</span><span class="id"> X</span><span class="id"> :</span><span class="id"> H</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> D</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> case:</span><span class="id"> lambdaDG</span><span class="id"> =&gt;</span><span class="id"> +</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> apply</span>.<br/>
<span class="id">have</span><span class="id"> GHH_</span><span class="id"> X</span><span class="id"> :</span><span class="id"> G</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> H</span><span class="id"> `&lt;=`</span><span class="id"> H_</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> GX;</span><span class="id"> apply:</span><span class="id"> smallest_sub;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> GGH_</span>.<br/>
&nbsp;&nbsp;<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> [HA</span><span class="id"> _];</span><span class="id"> case:</span><span class="id"> lambdaDG</span><span class="id"> =&gt;</span><span class="id"> +</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> XD</span><span class="id"> :</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> D</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> HD;</span><span class="id"> exact:</span> (<span class="id">@sub_smallest</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> G</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /H_</span><span class="id"> /=</span><span class="id"> setIidr//;</span><span class="id"> split;</span><span class="id"> [by</span><span class="id"> case:</span><span class="id"> lambdaDG|]</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">@sub_smallest</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> G</span>).<br/>
<span class="id">have</span><span class="id"> HGH_</span><span class="id"> X</span><span class="id"> :</span><span class="id"> H</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> H_</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> *;</span><span class="id"> split;</span><span class="id"> [|by</span><span class="id"> rewrite</span><span class="id"> setIC;</span><span class="id"> apply</span><span class="id"> GHH_]</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">@sub_smallest</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> G</span>).<br/>
<span class="id">have</span><span class="id"> HHH_</span><span class="id"> X</span><span class="id"> :</span><span class="id"> H</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> H</span><span class="id"> `&lt;=`</span><span class="id"> H_</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> HX;</span>  <span class="id"> apply:</span><span class="id"> smallest_sub;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> HGH_</span>.<br/>
&nbsp;&nbsp;<span class="id">split=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> [?</span><span class="id"> ?];</span><span class="id"> case:</span><span class="id"> lambdaDG</span><span class="id"> =&gt;</span><span class="id"> +</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> have</span><span class="id"> XD</span><span class="id"> :</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> D</span><span class="id"> :=</span><span class="id"> HD</span><span class="id"> _</span><span class="id"> HX</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /H_/=</span><span class="id"> setIidr//;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> case:</span><span class="id"> lambdaDG</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> apply</span><span class="id"> HHH_</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> smallest_lambda_system</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.2.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `smallest_lambda_system`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> smallest_monotone_classE</span><span class="id"> :=</span><span class="id"> smallest_lambda_system</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> lambda_system_subset</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)) (<span class="id">setIG</span><span class="id"> :</span><span class="id"> setI_closed</span><span class="id"> G</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">H</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)) (<span class="id">DH</span><span class="id"> :</span><span class="id"> lambda_system</span><span class="id"> D</span><span class="id"> H</span>) (<span class="id">GH</span><span class="id"> :</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> H</span>).<br/>
<br/>
<div class="doc md"> a.k.a. Sierpi≈Ñski‚ÄìDynkin's pi-lambda theorem</div>
<span class="vernacular">Lemma</span><span class="id"> lambda_system_subset</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> X,</span> (<span class="id">&lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>)<span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> D</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">&lt;&lt;s</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> `&lt;=`</span><span class="id"> H</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sDGD;</span><span class="id"> set</span><span class="id"> M</span><span class="id"> :=</span><span class="id"> &lt;&lt;l</span><span class="id"> D,</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">@smallest_lambda_system</span><span class="id"> _</span><span class="id"> _</span><span class="id"> setIG</span><span class="id"> D</span>)<span class="id"> //</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> smallest_sub</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> lambda_system_smallest</span><span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> GA</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> sDGD;</span><span class="id"> exact:</span><span class="id"> sub_sigma_algebra</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> lambda_system_subset</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.2.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `lambda_system_subset`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> monotone_class_subset</span><span class="id"> :=</span><span class="id"> lambda_system_subset</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> dynkin</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> G</span><span class="id"> D</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dynkinT</span><span class="id"> G</span><span class="id"> :</span><span class="id"> dynkin</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> setT</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dynkinC</span><span class="id"> G</span><span class="id"> :</span><span class="id"> dynkin</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> setC_closed</span><span class="id"> G</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dynkinU</span><span class="id"> G</span><span class="id"> :</span><span class="id"> dynkin</span><span class="id"> G</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat,</span><span class="id"> trivIset</span><span class="id"> setT</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> G</span> (<span class="id">F</span><span class="id"> n</span>))<span class="id"> -&gt;</span><span class="id"> G</span> (<span class="id">\bigcup_k</span><span class="id"> F</span><span class="id"> k</span>))<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> dynkin</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> dynkin_lemmas</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> D</span><span class="id"> G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dynkin_lambda_system</span><span class="id"> G</span><span class="id"> :</span><span class="id"> dynkin</span><span class="id"> G</span><span class="id"> &lt;-&gt;</span><span class="id"> lambda_system</span><span class="id"> setT</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> [[GT</span><span class="id"> setCG</span><span class="id"> trG]|[_</span><span class="id"> GT</span><span class="id"> setDG</span><span class="id"> ndG]];</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> BA</span><span class="id"> GA</span><span class="id"> GB;</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> -</span>(<span class="id">setCK</span> (_<span class="id"> `&amp;`</span><span class="id"> _</span>))<span class="id"> setCI;</span><span class="id"> apply:</span> (<span class="id">setCG</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setCK</span><span class="id"> -bigcup2E;</span><span class="id"> apply</span><span class="id"> trG</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -trivIset_bigcup2</span><span class="id"> setIC;</span><span class="id"> apply</span><span class="id"> subsets_disjoint</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [|[//|n]];</span><span class="id"> [exact:</span><span class="id"> setCG|rewrite</span><span class="id"> /bigcup2</span><span class="id"> -setCT;</span><span class="id"> apply:</span><span class="id"> setCG]</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> F</span><span class="id"> ndF</span><span class="id"> GF;</span><span class="id"> rewrite</span><span class="id"> -eq_bigcup_seqD;</span><span class="id"> apply:</span> (<span class="id">trG</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> trivIset_seqD</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> [/=|n];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> GF</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /seqD</span><span class="id"> setDE</span><span class="id"> -</span>(<span class="id">setCK</span> (_<span class="id"> `&amp;`</span><span class="id"> _</span>))<span class="id"> setCI;</span><span class="id"> apply:</span> (<span class="id">setCG</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setCK</span><span class="id"> -bigcup2E;</span><span class="id"> apply:</span><span class="id"> trG</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> rewrite</span><span class="id"> -trivIset_bigcup2</span><span class="id"> setIC;</span><span class="id"> apply</span><span class="id"> subsets_disjoint</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact/subsetPset/ndF/ltnW</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> move=&gt;</span><span class="id"> [|[|]];</span><span class="id"> rewrite</span><span class="id"> /bigcup2</span><span class="id"> /=;</span><span class="id"> [exact/setCG/GF|exact/GF|]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -setCT;</span><span class="id"> apply:</span><span class="id"> setCG</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> B;</span><span class="id"> rewrite</span><span class="id"> -setTD;</span><span class="id"> apply:</span><span class="id"> setDG</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> F</span><span class="id"> tF</span><span class="id"> GF;</span><span class="id"> pose</span><span class="id"> A</span><span class="id"> i</span><span class="id"> :=</span><span class="id"> \big[setU/set0]_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> i</span>.<span class="id">+1</span>)<span class="id"> F</span><span class="id"> k</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -bigcup_bigsetU_bigcup</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> ndG;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> b</span><span class="id"> ab;</span><span class="id"> exact/subsetPset/subset_bigsetU</span>.<br/>
&nbsp;&nbsp;<span class="id">elim=&gt;</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> ih]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /A</span><span class="id"> big_ord_recr</span><span class="id"> /=</span><span class="id"> big_ord0</span><span class="id"> set0U;</span><span class="id"> exact:</span><span class="id"> GF</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /A</span><span class="id"> /=</span><span class="id"> big_ord_recr</span><span class="id"> /=</span><span class="id"> -/</span>(<span class="id">A</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> _</span><span class="id"> `|`</span><span class="id"> _</span><span class="id"> =</span><span class="id"> ~`</span> (<span class="id">~`</span><span class="id"> A</span><span class="id"> n</span><span class="id"> `\`</span><span class="id"> F</span><span class="id"> n</span>.<span class="id">+1</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> setCI</span><span class="id"> !setCK</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -setTD;</span><span class="id"> apply:</span> (<span class="id">setDG</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span> (<span class="id">setDG</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -setTD;</span><span class="id"> apply:</span><span class="id"> setDG</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/disjoints_subset;</span><span class="id"> rewrite</span><span class="id"> setIC</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">@trivIset_bigsetUI</span><span class="id"> _</span><span class="id"> predT</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> /predT</span><span class="id"> /=</span><span class="id"> trueE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> g_dynkin_dynkin</span><span class="id"> G</span><span class="id"> :</span><span class="id"> dynkin</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [D</span><span class="id"> /=</span><span class="id"> []</span><span class="id"> []//|</span><span class="id"> |</span><span class="id"> ]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Y</span><span class="id"> sGY</span><span class="id"> D</span><span class="id"> /=</span><span class="id"> [dD</span><span class="id"> GD];</span><span class="id"> exact/</span>(<span class="id">dynkinC</span><span class="id"> dD</span>)<span class="id">/</span>(<span class="id">sGY</span><span class="id"> D</span>).<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> F</span><span class="id"> tF</span><span class="id"> gGF</span><span class="id"> D</span><span class="id"> /=</span><span class="id"> [dD</span><span class="id"> GD];</span><span class="id"> apply</span><span class="id"> dD</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> k;</span><span class="id"> exact:</span><span class="id"> gGF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_algebra_dynkin</span><span class="id"> G</span><span class="id"> :</span><span class="id"> sigma_algebra</span><span class="id"> setT</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> dynkin</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case=&gt;</span><span class="id"> ?</span><span class="id"> DC</span><span class="id"> DU;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [|</span><span class="id"> |?</span><span class="id"> ?</span><span class="id"> ?];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> DU</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setC0</span><span class="id"> -setTD;</span><span class="id"> exact:</span><span class="id"> DC</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> GA;</span><span class="id"> rewrite</span><span class="id"> -setTD;</span><span class="id"> apply:</span><span class="id"> DC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dynkin_setI_bigsetI</span><span class="id"> G</span> (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>)<span class="id"> :</span><span class="id"> dynkin</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> setI_closed</span><span class="id"> G</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> G</span> (<span class="id">F</span><span class="id"> n</span>))<span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> n,</span><span class="id"> G</span> (<span class="id">\big[setI/setT]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> dG</span><span class="id"> GI</span><span class="id"> GF;</span><span class="id"> elim</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> ih];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> big_ord_recr</span><span class="id"> /=;</span><span class="id"> apply:</span><span class="id"> GI</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_ord0;</span><span class="id"> exact:</span> (<span class="id">dynkinT</span><span class="id"> dG</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dynkin_setI_sigma_algebra</span><span class="id"> G</span><span class="id"> :</span><span class="id"> dynkin</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> setI_closed</span><span class="id"> G</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">sigma_algebra</span><span class="id"> setT</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> dG</span><span class="id"> GI;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [|//|F</span><span class="id"> DF]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setCT;</span><span class="id"> exact/</span>(<span class="id">dynkinC</span><span class="id"> dG</span>)<span class="id">/</span>(<span class="id">dynkinT</span><span class="id"> dG</span>).<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> GA;</span><span class="id"> rewrite</span><span class="id"> setTD;</span><span class="id"> exact:</span> (<span class="id">dynkinC</span><span class="id"> dG</span>).<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> seqDU_bigcup_eq;</span><span class="id"> apply/</span>(<span class="id">dynkinU</span><span class="id"> dG</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> /seqDU</span><span class="id"> setDE;</span><span class="id"> apply</span><span class="id"> GI</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -bigcup_mkord</span><span class="id"> setC_bigcup</span><span class="id"> bigcap_mkord</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">@dynkin_setI_bigsetI</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> ~`</span><span class="id"> F</span><span class="id"> x</span>))<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?;</span><span class="id"> exact/</span>(<span class="id">dynkinC</span><span class="id"> dG</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setI_closed_g_dynkin_g_sigma_algebra</span><span class="id"> G</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">setI_closed</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> =</span><span class="id"> &lt;&lt;s</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> GI;</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> sub_smallest2l;</span><span class="id"> exact:</span><span class="id"> sigma_algebra_dynkin</span>.<br/>
<span class="id">pose</span><span class="id"> delta</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><span class="id"> [set</span><span class="id"> E</span><span class="id"> |</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span> (<span class="id">E</span><span class="id"> `&amp;`</span><span class="id"> D</span>)<span class="id">]</span>.<br/>
<span class="id">have</span><span class="id"> ddelta</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> dynkin</span> (<span class="id">delta</span><span class="id"> D</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> dGD;</span><span class="id"> split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /delta</span><span class="id"> /=</span><span class="id"> setTI</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> E</span><span class="id"> DE;</span><span class="id"> rewrite</span><span class="id"> /delta</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span> (<span class="id">~`</span><span class="id"> E</span>)<span class="id"> `&amp;`</span><span class="id"> D</span><span class="id"> =</span><span class="id"> ~`</span> ((<span class="id">E</span><span class="id"> `&amp;`</span><span class="id"> D</span>)<span class="id"> `|`</span> (<span class="id">~`</span><span class="id"> D</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -[LHS]setU0</span><span class="id"> -</span>(<span class="id">setICl</span><span class="id"> D</span>)<span class="id"> -setIUl</span><span class="id"> -setCI</span><span class="id"> -{2}</span>(<span class="id">setCK</span><span class="id"> D</span>)<span class="id"> -setCU</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> :</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span> ((<span class="id">E</span><span class="id"> `&amp;`</span><span class="id"> D</span>)<span class="id"> `|`</span><span class="id"> ~`</span><span class="id"> D</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -bigcup2E</span><span class="id"> =&gt;</span><span class="id"> S</span><span class="id"> [dS</span><span class="id"> GS];</span><span class="id"> apply:</span> (<span class="id">dynkinU</span><span class="id"> dS</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> [|[|i]]</span><span class="id"> [|[|j]]</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /bigcup2</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setIA</span><span class="id"> setICr</span><span class="id"> setI0</span><span class="id"> =&gt;</span><span class="id"> /set0P;</span><span class="id"> rewrite</span><span class="id"> eqxx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setI0</span><span class="id"> =&gt;</span><span class="id"> /set0P;</span><span class="id"> rewrite</span><span class="id"> eqxx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setICA</span><span class="id"> setICl</span><span class="id"> setI0</span><span class="id"> =&gt;</span><span class="id"> /set0P;</span><span class="id"> rewrite</span><span class="id"> eqxx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setI0</span><span class="id"> =&gt;</span><span class="id"> /set0P;</span><span class="id"> rewrite</span><span class="id"> eqxx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> set0I</span><span class="id"> =&gt;</span><span class="id"> /set0P;</span><span class="id"> rewrite</span><span class="id"> eqxx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> set0I</span><span class="id"> =&gt;</span><span class="id"> /set0P;</span><span class="id"> rewrite</span><span class="id"> eqxx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> set0I</span><span class="id"> =&gt;</span><span class="id"> /set0P;</span><span class="id"> rewrite</span><span class="id"> eqxx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> [|[|n]]</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> /bigcup2</span><span class="id"> /=;</span><span class="id"> [exact:</span><span class="id"> DE|</span><span class="id"> |]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="id"> suff:</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span> (<span class="id">~`</span><span class="id"> D</span>)<span class="gallina-kwd"> by</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> F</span><span class="id"> [dF</span><span class="id"> GF];</span><span class="id"> apply:</span> (<span class="id">dynkinC</span><span class="id"> dF</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> dGD</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setCT;</span><span class="id"> apply/</span>(<span class="id">dynkinC</span><span class="id"> dS</span>)<span class="id">/</span>(<span class="id">dynkinT</span><span class="id"> dS</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> dGEDD</span><span class="id"> S</span><span class="id"> /=</span><span class="id"> [+</span><span class="id"> GS]</span><span class="id"> =&gt;</span><span class="id"> dS;</span><span class="id"> apply/</span>(<span class="id">dynkinC</span><span class="id"> dS</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> dGEDD</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> F</span><span class="id"> tF</span><span class="id"> deltaDF;</span><span class="id"> rewrite</span><span class="id"> /delta</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> S</span><span class="id"> /=</span><span class="id"> [dS</span><span class="id"> GS]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setI_bigcupl;</span><span class="id"> apply:</span> (<span class="id">dynkinU</span><span class="id"> dS</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> setIC;</span><span class="id"> exact:</span><span class="id"> trivIset_setIl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> exact:</span><span class="id"> deltaDF</span>.<br/>
<span class="id">have</span><span class="id"> GdG</span><span class="id"> :</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> [_];</span><span class="id"> apply</span>.<br/>
<span class="id">have</span><span class="id"> Gdelta</span><span class="id"> A</span><span class="id"> :</span><span class="id"> G</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> delta</span><span class="id"> A</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> /delta</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> [?];</span><span class="id"> apply;</span><span class="id"> exact/GI</span>.<br/>
<span class="id">have</span><span class="id"> GdGdelta</span><span class="id"> A</span><span class="id"> :</span><span class="id"> G</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> `&lt;=`</span><span class="id"> delta</span><span class="id"> A</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> ?;</span><span class="id"> apply:</span><span class="id"> smallest_sub</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> Gdelta</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/ddelta;</span><span class="id"> exact:</span><span class="id"> GdG</span>.<br/>
<span class="id">have</span><span class="id"> dGGI</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> apply:</span><span class="id"> GdGdelta</span>.<br/>
<span class="id">have</span><span class="id"> dGGdelta</span><span class="id"> A</span><span class="id"> :</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> delta</span><span class="id"> A</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> /delta</span><span class="id"> /=</span><span class="id"> setIC;</span><span class="id"> exact:</span><span class="id"> dGGI</span>.<br/>
<span class="id">have</span><span class="id"> dGdGdelta</span><span class="id"> A</span><span class="id"> :</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> `&lt;=`</span><span class="id"> delta</span><span class="id"> A</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> smallest_sub</span> (<span class="id">ddelta</span><span class="id"> _</span><span class="id"> _</span>) (<span class="id">dGGdelta</span><span class="id"> _</span><span class="id"> _</span>).<br/>
<span class="id">have</span><span class="id"> dGdGdG</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> &lt;&lt;d</span><span class="id"> G</span><span class="id"> &gt;&gt;</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> dGdGdelta</span>.<br/>
<span class="id">apply:</span><span class="id"> smallest_sub</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> dynkin_setI_sigma_algebra</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">exact:</span><span class="id"> g_dynkin_dynkin</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> dynkin_lemmas</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.2.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed into `setI_closed_g_dynkin_g_sigma_algebra`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> setI_closed_gdynkin_salgebra</span><span class="id"> :=</span><span class="id"> setI_closed_g_dynkin_g_sigma_algebra</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.2.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed into `g_dynkin_dynkin`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> dynkin_g_dynkin</span><span class="id"> :=</span><span class="id"> g_dynkin_dynkin</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.2.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed into `dynkin_lambda_system`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> dynkin_monotone</span><span class="id"> :=</span><span class="id"> dynkin_lambda_system</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> trace</span>.<br/>
<span class="vernacular">Variable</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)) (<span class="id">A</span><span class="id"> D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> strace</span><span class="id"> G</span><span class="id"> D</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> `&amp;`</span><span class="id"> D</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> G]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subset_strace</span><span class="id"> G</span><span class="id"> C</span><span class="id"> :</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> C</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> D,</span><span class="id"> strace</span><span class="id"> G</span><span class="id"> D</span><span class="id"> `&lt;=`</span><span class="id"> strace</span><span class="id"> C</span><span class="id"> D</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> GC</span><span class="id"> D</span><span class="id"> _</span><span class="id"> [A</span><span class="id"> GA</span><span class="id"> &lt;-];</span><span class="gallina-kwd"> exists</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> GC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> g_sigma_ring_strace</span><span class="id"> G</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> &lt;&lt;sr</span><span class="id"> strace</span><span class="id"> G</span><span class="id"> A</span><span class="id"> &gt;&gt;</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> H;</span><span class="id"> apply</span><span class="id"> H</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> powerset_sigma_ring</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> [A0</span><span class="id"> GA0</span><span class="id"> &lt;-];</span><span class="id"> exact:</span><span class="id"> subIsetr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> strace_sigma_ring</span><span class="id"> G</span><span class="id"> A</span><span class="id"> :</span><span class="id"> sigma_ring</span> (<span class="id">strace</span><span class="id"> &lt;&lt;sr</span><span class="id"> G&gt;&gt;</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> set0;</span><span class="id"> rewrite</span><span class="id"> ?set0I//;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> smallest_sigma_ring</span><span class="id"> G</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [A0</span><span class="id"> GA0]</span><span class="id"> &lt;-</span><span class="id"> [A1</span><span class="id"> GA1]</span><span class="id"> &lt;-</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">A0</span><span class="id"> `\`</span><span class="id"> A1</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> +</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> smallest_sigma_ring</span><span class="id"> G;</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -setIDA</span><span class="id"> setDIr</span><span class="id"> setDv</span><span class="id"> setU0</span><span class="id"> setIDAC</span><span class="id"> setIDA</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> F</span><span class="id"> GAF</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> f</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> sval</span> (<span class="id">cid2</span> (<span class="id">GAF</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> Hf</span><span class="id"> n</span><span class="id"> :=</span> (<span class="id">svalP</span> (<span class="id">cid2</span> (<span class="id">GAF</span><span class="id"> n</span>))).<span class="id">1</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> H</span><span class="id"> n</span><span class="id"> :=</span> (<span class="id">svalP</span> (<span class="id">cid2</span> (<span class="id">GAF</span><span class="id"> n</span>))).<span class="id">2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">\bigcup_k</span><span class="id"> f</span><span class="id"> k</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> smallest_sigma_ring</span><span class="id"> G;</span><span class="id"> apply</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> exact:</span><span class="id"> Hf</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setI_bigcupl;</span><span class="id"> apply:</span><span class="id"> eq_bigcupr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> H</span>.<br/>
Qed.</div></details>
<br/>
<div class="doc md"> see Paul Halmos' Measure Theory, Ch.1, sec.5, thm.E, p.25</div>
<span class="vernacular">Lemma</span><span class="id"> setI_g_sigma_ring</span><span class="id"> G</span><span class="id"> A</span><span class="id"> :</span><span class="id"> strace</span><span class="id"> &lt;&lt;sr</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> A</span><span class="id"> =</span><span class="id"> &lt;&lt;sr</span><span class="id"> strace</span><span class="id"> G</span><span class="id"> A</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> D</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> B</span><span class="id"> `|`</span> (<span class="id">C</span><span class="id"> `\`</span><span class="id"> A</span>)<span class="id"> |</span><span class="id"> B</span><span class="gallina-kwd"> in</span><span class="id"> &lt;&lt;sr</span><span class="id"> strace</span><span class="id"> G</span><span class="id"> A&gt;&gt;</span><span class="id"> &amp;</span><span class="id"> C</span><span class="gallina-kwd"> in</span><span class="id"> &lt;&lt;sr</span><span class="id"> G</span><span class="id"> &gt;&gt;]</span>.<br/>
<span class="id">have</span><span class="id"> D_sigma_ring</span><span class="id"> :</span><span class="id"> sigma_ring</span><span class="id"> D</span>.<br/>
&nbsp;&nbsp;<span class="id">split</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> exists</span><span class="id"> set0;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> smallest_sigma_ring</span> (<span class="id">strace</span><span class="id"> G</span><span class="id"> A</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> set0;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> smallest_sigma_ring</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> set0D</span><span class="id"> setU0</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [B0</span><span class="id"> GAB0]</span><span class="id"> [C0</span><span class="id"> GC0]</span><span class="id"> &lt;-</span><span class="id"> [B1</span><span class="id"> GAB1]</span><span class="id"> [C1</span><span class="id"> GC1]</span><span class="id"> &lt;-</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">B0</span><span class="id"> `\`</span><span class="id"> B1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> +</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> smallest_sigma_ring</span> (<span class="id">strace</span><span class="id"> G</span><span class="id"> A</span>)<span class="id">;</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">C0</span><span class="id"> `\`</span><span class="id"> C1</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> +</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> smallest_sigma_ring</span><span class="id"> G;</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/esym;</span><span class="id"> rewrite</span><span class="id"> setDUD</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transitivity</span> (((<span class="id">B0</span><span class="id"> `\`</span><span class="id"> B1</span>)<span class="id"> `&amp;`</span> (<span class="id">B0</span><span class="id"> `\`</span> (<span class="id">C1</span><span class="id"> `\`</span><span class="id"> A</span>)))<span class="id"> `|`</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id">C0</span><span class="id"> `\`</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B1</span>))<span class="id"> `&amp;`</span> (<span class="id">C0</span><span class="id"> `\`</span><span class="id"> C1</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">congr</span><span class="id"> setU;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setDUr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [x</span><span class="id"> [[C0x</span><span class="id"> Ax]]|x]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /not_orP[B1x</span><span class="id"> /not_andP[C1x|//]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> [[C0x</span><span class="id"> /not_orP[Ax</span><span class="id"> B1x]</span><span class="id"> [_</span><span class="id"> C1x]]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> -[//|[]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transitivity</span> (((<span class="id">B0</span><span class="id"> `\`</span><span class="id"> B1</span>)<span class="id"> `&amp;`</span><span class="id"> B0</span>)<span class="id"> `|`</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id">C0</span><span class="id"> `\`</span><span class="id"> A</span> )<span class="id"> `&amp;`</span> (<span class="id">C0</span><span class="id"> `\`</span><span class="id"> C1</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [x</span><span class="id"> [[[B0x</span><span class="id"> B1x]</span><span class="id"> [_</span><span class="id"> /not_andP[C1x|]]]|</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[[C0x</span><span class="id"> /not_orP[Ax</span><span class="id"> B1x]]</span><span class="id"> [_</span><span class="id"> C1x]]]|</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">x</span><span class="id"> [[[B0x</span><span class="id"> B1x]</span><span class="id"> _]|[[C0x</span><span class="id"> Ax]</span><span class="id"> [_</span><span class="id"> C1x]]]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> left;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /contrapT</span><span class="id"> Ax;</span><span class="id"> left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> right;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="id"> left;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[]</span><span class="id"> _;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">g_sigma_ring_strace</span><span class="id"> GAB0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="id"> right;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[//|B1x];</span><span class="id"> apply:</span><span class="id"> Ax</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">g_sigma_ring_strace</span><span class="id"> GAB1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="id"> congr</span><span class="id"> setU;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> setIAC</span><span class="id"> setIid</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setDDl</span><span class="id"> setDUr</span><span class="id"> setIC</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> F</span><span class="id"> DF</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> f</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> sval</span> (<span class="id">cid2</span> (<span class="id">DF</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> Hf</span><span class="id"> n</span><span class="id"> :=</span> (<span class="id">svalP</span> (<span class="id">cid2</span> (<span class="id">DF</span><span class="id"> n</span>))).<span class="id">1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> g</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> sval</span> (<span class="id">cid2</span> (<span class="id">svalP</span> (<span class="id">cid2</span> (<span class="id">DF</span><span class="id"> n</span>))).<span class="id">2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> Hg</span><span class="id"> n</span><span class="id"> :=</span> (<span class="id">svalP</span> (<span class="id">cid2</span> (<span class="id">svalP</span> (<span class="id">cid2</span> (<span class="id">DF</span><span class="id"> n</span>))).<span class="id">2</span>)).<span class="id">1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">\bigcup_n</span><span class="id"> f</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [_</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> smallest_sigma_ring</span> (<span class="id">strace</span><span class="id"> G</span><span class="id"> A</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> exact:</span><span class="id"> Hf</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">\bigcup_n</span><span class="id"> g</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [_</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> smallest_sigma_ring</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> exact:</span><span class="id"> Hg</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> H</span><span class="id"> n</span><span class="id"> :=</span> (<span class="id">svalP</span> (<span class="id">cid2</span> (<span class="id">svalP</span> (<span class="id">cid2</span> (<span class="id">DF</span><span class="id"> n</span>))).<span class="id">2</span>)).<span class="id">2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setD_bigcupl</span><span class="id"> -bigcupU;</span><span class="id"> apply:</span><span class="id"> eq_bigcupr</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> H</span>.<br/>
<span class="id">apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [|]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> GD</span><span class="id"> :</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> D</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> E</span><span class="id"> GE;</span><span class="gallina-kwd"> exists</span> (<span class="id">E</span><span class="id"> `&amp;`</span><span class="id"> A</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> sub_g_sigma_ring;</span><span class="gallina-kwd"> exists</span><span class="id"> E</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> E;</span><span class="id"> [exact:</span><span class="id"> sub_g_sigma_ring|exact:</span><span class="id"> setUIDK]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> {}GD</span><span class="id"> :</span><span class="id"> &lt;&lt;sr</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> `&lt;=`</span><span class="id"> D</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> smallest_sub</span><span class="id"> GD</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> GDA</span><span class="id"> :</span><span class="id"> strace</span><span class="id"> &lt;&lt;sr</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> strace</span><span class="id"> D</span><span class="id"> A</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> subset_strace</span>.<br/>
&nbsp;&nbsp;<span class="id">suff:</span><span class="id"> strace</span><span class="id"> D</span><span class="id"> A</span><span class="id"> =</span><span class="id"> &lt;&lt;sr</span><span class="id"> strace</span><span class="id"> G</span><span class="id"> A</span><span class="id"> &gt;&gt;</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> &lt;-</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/seteqP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> [_</span><span class="id"> [gA</span><span class="id"> HgA</span><span class="id"> [g</span><span class="id"> Hg]</span><span class="id"> &lt;-]</span><span class="id"> &lt;-]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIUl</span><span class="id"> setDKI</span><span class="id"> setU0</span><span class="id"> setIidl//;</span><span class="id"> exact:</span> (<span class="id">g_sigma_ring_strace</span><span class="id"> HgA</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> X</span><span class="id"> HX;</span><span class="gallina-kwd"> exists</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> X</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> set0;</span><span class="id"> rewrite</span><span class="id"> ?set0D</span><span class="id"> ?setU0//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> smallest_sigma_ring</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIidl//;</span><span class="id"> exact:</span> (<span class="id">g_sigma_ring_strace</span><span class="id"> HX</span>).<br/>
<span class="id">have</span><span class="id"> :</span><span class="id"> strace</span><span class="id"> G</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> strace</span><span class="id"> &lt;&lt;sr</span><span class="id"> G&gt;&gt;</span><span class="id"> A</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> [Y</span><span class="id"> GY</span><span class="id"> &lt;-];</span><span class="gallina-kwd"> exists</span><span class="id"> Y</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> sub_smallest</span><span class="id"> GY</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> smallest_sub;</span><span class="id"> exact:</span><span class="id"> strace_sigma_ring</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_algebra_strace</span><span class="id"> G</span><span class="id"> D</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">sigma_algebra</span><span class="id"> setT</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> sigma_algebra</span><span class="id"> D</span> (<span class="id">strace</span><span class="id"> G</span><span class="id"> D</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [G0</span><span class="id"> GC</span><span class="id"> GU];</span><span class="id"> split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> set0</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> set0I</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> S</span><span class="id"> [A</span><span class="id"> mA</span><span class="id"> ADS];</span><span class="id"> have</span><span class="id"> mCA</span><span class="id"> :=</span><span class="id"> GC</span><span class="id"> _</span><span class="id"> mA</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> :</span><span class="id"> strace</span><span class="id"> G</span><span class="id"> D</span> (<span class="id">D</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIC;</span><span class="gallina-kwd"> exists</span> (<span class="id">setT</span><span class="id"> `\`</span><span class="id"> A</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> setTD</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -setDE</span><span class="id"> =&gt;</span><span class="id"> trDA</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> DADS</span><span class="id"> :</span><span class="id"> D</span><span class="id"> `\`</span><span class="id"> A</span><span class="id"> =</span><span class="id"> D</span><span class="id"> `\`</span><span class="id"> S</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -ADS</span><span class="id"> !setDE</span><span class="id"> setCI</span><span class="id"> setIUr</span><span class="id"> setICr</span><span class="id"> setU0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> DADS</span><span class="gallina-kwd"> in</span><span class="id"> trDA</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> S</span><span class="id"> mS;</span><span class="id"> have</span><span class="id"> /choice[M</span><span class="id"> GM]</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> n,</span><span class="gallina-kwd"> exists</span><span class="id"> A,</span><span class="id"> G</span><span class="id"> A</span><span class="id"> /\</span><span class="id"> S</span><span class="id"> n</span><span class="id"> =</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> D</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> have</span><span class="id"> [A</span><span class="id"> mA</span><span class="id"> ADSn]</span><span class="id"> :=</span><span class="id"> mS</span><span class="id"> n;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">\bigcup_i</span> (<span class="id">M</span><span class="id"> i</span>))<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply</span><span class="id"> GU</span><span class="id"> =&gt;</span><span class="id"> i;</span> <span class="id"> exact:</span> (<span class="id">GM</span><span class="id"> i</span>).<span class="id">1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setI_bigcupl;</span><span class="id"> apply</span><span class="id"> eq_bigcupr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span> (<span class="id">GM</span><span class="id"> i</span>).<span class="id">2</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> trace</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> isSemiRingOfSets</span> (<span class="id">d</span><span class="id"> :</span><span class="id"> measure_display</span>)<span class="id"> T</span><span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurable0</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> set0</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurableI</span><span class="id"> :</span><span class="id"> setI_closed</span><span class="id"> measurable;</span><br/>
&nbsp;&nbsp;<span class="id">semi_measurableD</span><span class="id"> :</span><span class="id"> semi_setD_closed</span><span class="id"> measurable;</span><br/>
<span class="id">}</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=</span><span class="id">&quot;semiRingOfSetsType&quot;</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> SemiRingOfSets</span><span class="id"> d</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{T</span><span class="id"> of</span><span class="id"> Pointed</span><span class="id"> T</span><span class="id"> &amp;</span><span class="id"> isSemiRingOfSets</span><span class="id"> d</span><span class="id"> T}</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> measurable</span><span class="id"> {d}%measure_display_scope</span><span class="id"> {s}</span><span class="id"> _%classical_set_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_curry</span> (<span class="id">T1</span><span class="id"> T2</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">G</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> *</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> *</span><span class="id"> T2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">G</span><span class="id"> x</span>)<span class="id"> &lt;-&gt;</span><span class="id"> measurable</span> (<span class="id">curry</span><span class="id"> G</span><span class="id"> x</span>.<span class="id">1</span><span class="id"> x</span>.<span class="id">2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> x</span>. Qed.</div></details>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;d .-measurable&quot;</span><span class="id"> :=</span> (<span class="id">@measurable</span><span class="id"> d%mdisp</span>)<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'measurable&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">@measurable</span><span class="id"> default_measure_display</span>)<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> SemiRingOfSets_isRingOfSets</span><span class="id"> d</span><span class="id"> T</span><span class="id"> of</span><span class="id"> SemiRingOfSets</span><span class="id"> d</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">measurableU</span><span class="id"> :</span><span class="id"> @setU_closed</span><span class="id"> T</span><span class="id"> measurable</span><br/>
<span class="id">}</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=</span><span class="id">&quot;ringOfSetsType&quot;</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> RingOfSets</span><span class="id"> d</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{T</span><span class="id"> of</span><span class="id"> SemiRingOfSets</span><span class="id"> d</span><span class="id"> T</span><span class="id"> &amp;</span><span class="id"> SemiRingOfSets_isRingOfSets</span><span class="id"> d</span><span class="id"> T</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> RingOfSets_isAlgebraOfSets</span><span class="id"> d</span><span class="id"> T</span><span class="id"> of</span><span class="id"> RingOfSets</span><span class="id"> d</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">measurableT</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> [set:</span><span class="id"> T]</span><br/>
<span class="id">}</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=</span><span class="id">&quot;algebraOfSetsType&quot;</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> AlgebraOfSets</span><span class="id"> d</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{T</span><span class="id"> of</span><span class="id"> RingOfSets</span><span class="id"> d</span><span class="id"> T</span><span class="id"> &amp;</span><span class="id"> RingOfSets_isAlgebraOfSets</span><span class="id"> d</span><span class="id"> T</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> hasMeasurableCountableUnion</span><span class="id"> d</span><span class="id"> T</span><span class="id"> of</span><span class="id"> SemiRingOfSets</span><span class="id"> d</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">bigcupT_measurable</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat,</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">\bigcup_i</span> (<span class="id">F</span><span class="id"> i</span>))<br/>
<span class="id">}</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span><span class="id"> T</span><span class="id"> of</span><span class="id"> hasMeasurableCountableUnion</span><span class="id"> d</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> mU</span><span class="id"> :</span><span class="id"> @setU_closed</span><span class="id"> T</span><span class="id"> measurable</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mA</span><span class="id"> mB;</span><span class="id"> rewrite</span><span class="id"> -bigcup2E</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcupT_measurable</span><span class="id"> =&gt;</span><span class="id"> -[//|[//|/=</span><span class="id"> _]];</span><span class="id"> exact:</span><span class="id"> measurable0</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> SemiRingOfSets_isRingOfSets</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> mU</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=</span><span class="id">&quot;sigmaRingType&quot;</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> SigmaRing</span><span class="id"> d</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{T</span><span class="id"> of</span><span class="id"> SemiRingOfSets</span><span class="id"> d</span><span class="id"> T</span><span class="id"> &amp;</span><span class="id"> hasMeasurableCountableUnion</span><span class="id"> d</span><span class="id"> T}</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> isSigmaRing</span> (<span class="id">d</span><span class="id"> :</span><span class="id"> measure_display</span>)<span class="id"> T</span><span class="id"> of</span><span class="id"> Pointed</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurable0</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> set0</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurableD</span><span class="id"> :</span><span class="id"> setDI_closed</span><span class="id"> measurable</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">bigcupT_measurable</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat,</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">\bigcup_i</span> (<span class="id">F</span><span class="id"> i</span>))<br/>
<span class="id">}</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span><span class="id"> T</span><span class="id"> of</span><span class="id"> isSigmaRing</span><span class="id"> d</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> m0</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> set0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> measurable0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mI</span><span class="id"> :</span><span class="id"> setI_closed</span><span class="id"> measurable</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span> (<span class="id">sedDI_closedP</span><span class="id"> measurable</span>).<span class="id">1</span><span class="id"> measurableD</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mD</span><span class="id"> :</span><span class="id"> semi_setD_closed</span><span class="id"> measurable</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> setDI_semi_setD_closed;</span><span class="id"> exact:</span><span class="id"> measurableD</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isSemiRingOfSets</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> m0</span><span class="id"> mI</span><span class="id"> mD</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> hasMeasurableCountableUnion</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> bigcupT_measurable</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=</span><span class="id">&quot;measurableType&quot;</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> Measurable</span><span class="id"> d</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{T</span><span class="id"> of</span><span class="id"> AlgebraOfSets</span><span class="id"> d</span><span class="id"> T</span><span class="id"> &amp;</span><span class="id"> hasMeasurableCountableUnion</span><span class="id"> d</span><span class="id"> T</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> isRingOfSets</span> (<span class="id">d</span><span class="id"> :</span><span class="id"> measure_display</span>)<span class="id"> T</span><span class="id"> of</span><span class="id"> Pointed</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurable0</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> set0</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurableU</span><span class="id"> :</span><span class="id"> setU_closed</span><span class="id"> measurable;</span><br/>
&nbsp;&nbsp;<span class="id">measurableD</span><span class="id"> :</span><span class="id"> setDI_closed</span><span class="id"> measurable;</span><br/>
<span class="id">}</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span><span class="id"> T</span><span class="id"> of</span><span class="id"> isRingOfSets</span><span class="id"> d</span><span class="id"> T</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> C</span><span class="id"> D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mI</span><span class="id"> :</span><span class="id"> setI_closed</span><span class="id"> measurable</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span> (<span class="id">sedDI_closedP</span><span class="id"> measurable</span>).<span class="id">1</span><span class="id"> measurableD</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mD</span><span class="id"> :</span><span class="id"> semi_setD_closed</span><span class="id"> measurable</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> setDI_semi_setD_closed;</span><span class="id"> exact:</span><span class="id"> measurableD</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@isSemiRingOfSets</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> measurable</span><span class="id"> measurable0</span><span class="id"> mI</span><span class="id"> mD</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> SemiRingOfSets_isRingOfSets</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> measurableU</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> isRingOfSets_setY</span> (<span class="id">d</span><span class="id"> :</span><span class="id"> measure_display</span>)<span class="id"> T</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">of</span><span class="id"> Pointed</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_nonempty</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> !=set0</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_setY</span><span class="id"> :</span><span class="id"> setY_closed</span><span class="id"> measurable</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_setI</span><span class="id"> :</span><span class="id"> setI_closed</span><span class="id"> measurable</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span><span class="id"> T</span><span class="id"> of</span><span class="id"> isRingOfSets_setY</span><span class="id"> d</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> m0</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [A</span><span class="id"> mA]</span><span class="id"> :=</span><span class="id"> measurable_nonempty</span>.<br/>
<span class="id">have</span><span class="id"> :=</span><span class="id"> measurable_setY</span><span class="id"> mA</span><span class="id"> mA</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setYK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mU</span><span class="id"> :</span><span class="id"> setU_closed</span><span class="id"> measurable</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mA</span><span class="id"> mB;</span><span class="id"> rewrite</span><span class="id"> -setYU</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurable_setY;</span><span class="id"> [exact:</span><span class="id"> measurable_setY|exact:</span><span class="id"> measurable_setI]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mD</span><span class="id"> :</span><span class="id"> setDI_closed</span><span class="id"> measurable</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mA</span><span class="id"> mB;</span><span class="id"> rewrite</span><span class="id"> -setYD</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurable_setY</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurable_setI</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isRingOfSets</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> m0</span><span class="id"> mU</span><span class="id"> mD</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> isAlgebraOfSets</span> (<span class="id">d</span><span class="id"> :</span><span class="id"> measure_display</span>)<span class="id"> T</span><span class="id"> of</span><span class="id"> Pointed</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurable0</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> set0</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurableU</span><span class="id"> :</span><span class="id"> setU_closed</span><span class="id"> measurable;</span><br/>
&nbsp;&nbsp;<span class="id">measurableC</span><span class="id"> :</span><span class="id"> setC_closed</span><span class="id"> measurable</span><br/>
<span class="id">}</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span><span class="id"> T</span><span class="id"> of</span><span class="id"> isAlgebraOfSets</span><span class="id"> d</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mD</span><span class="id"> :</span><span class="id"> setDI_closed</span><span class="id"> measurable</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mA</span><span class="id"> mB;</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> -[A]setCK</span><span class="id"> -setCU</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> do</span><span class="id"> ?[apply:</span><span class="id"> measurableU</span><span class="id"> |</span><span class="id"> apply:</span><span class="id"> measurableC]</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> T_isRingOfSets</span><span class="id"> :=</span><span class="id"> @isRingOfSets</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> measurable0</span><span class="id"> measurableU</span><span class="id"> mD</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurableT</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> [set:</span><span class="id"> T]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setC0;</span><span class="id"> apply:</span><span class="id"> measurableC;</span><span class="id"> exact:</span><span class="id"> measurable0</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> RingOfSets_isAlgebraOfSets</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> measurableT</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> isAlgebraOfSets_setD</span> (<span class="id">d</span><span class="id"> :</span><span class="id"> measure_display</span>)<span class="id"> T</span><span class="id"> of</span><span class="id"> Pointed</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurableT</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurableD</span><span class="id"> :</span><span class="id"> setDI_closed</span><span class="id"> measurable</span><br/>
<span class="id">}</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span><span class="id"> T</span><span class="id"> of</span><span class="id"> isAlgebraOfSets_setD</span><span class="id"> d</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> m0</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">setDT</span><span class="id"> setT</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> measurableD;</span><span class="id"> exact:</span><span class="id"> measurableT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mU</span><span class="id"> :</span><span class="id"> setU_closed</span><span class="id"> measurable</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mA</span><span class="id"> mB</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">setCK</span><span class="id"> A</span>)<span class="id"> -setCD</span><span class="id"> -!setTD;</span><span class="id"> apply:</span><span class="id"> measurableD;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> measurableT</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> do</span><span class="id"> 2</span><span class="id"> apply:</span><span class="id"> measurableD</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurableT</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isRingOfSets</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> m0</span><span class="id"> mU</span><span class="id"> measurableD</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> RingOfSets_isAlgebraOfSets</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> measurableT</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> isMeasurable</span> (<span class="id">d</span><span class="id"> :</span><span class="id"> measure_display</span>)<span class="id"> T</span><span class="id"> of</span><span class="id"> Pointed</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurable0</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> set0</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurableC</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">~`</span><span class="id"> A</span>)<span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_bigcup</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat,</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">\bigcup_i</span> (<span class="id">F</span><span class="id"> i</span>))<br/>
<span class="id">}</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span><span class="id"> T</span><span class="id"> of</span><span class="id"> isMeasurable</span><span class="id"> d</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Obligation</span><span class="vernacular"> Tactic</span><span class="id"> :=</span><span class="id"> idtac</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mU</span><span class="id"> :</span><span class="id"> setU_closed</span><span class="id"> measurable</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mA</span><span class="id"> mB;</span><span class="id"> rewrite</span><span class="id"> -bigcup2E</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurable_bigcup</span><span class="id"> =&gt;</span><span class="id"> -[//|[//|i]];</span><span class="id"> exact:</span><span class="id"> measurable0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mC</span><span class="id"> :</span><span class="id"> setC_closed</span><span class="id"> measurable</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> apply:</span><span class="id"> measurableC</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @isAlgebraOfSets</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> measurable0</span><span class="id"> mU</span><span class="id"> mC</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@hasMeasurableCountableUnion</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> measurable_bigcup</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">measurable</span><span class="id"> set0</span>)<span class="id"> =&gt;</span><span class="id"> solve</span><span class="id"> [apply:</span><span class="id"> measurable0]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">measurable</span><span class="id"> setT</span>)<span class="id"> =&gt;</span><span class="id"> solve</span><span class="id"> [apply:</span><span class="id"> measurableT]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ringofsets_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigsetU_measurable</span><span class="id"> I</span><span class="id"> r</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> r</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> mF;</span><span class="id"> elim/big_ind</span><span class="id"> :</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurableU</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fin_bigcup_measurable</span><span class="id"> I</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Pchoice:</span><span class="id"> I</span><span class="id"> =&gt;</span><span class="id"> I</span><span class="gallina-kwd"> in</span><span class="id"> D</span><span class="id"> F</span><span class="id"> *</span><span class="id"> =&gt;</span><span class="id"> Dfin</span><span class="id"> Fm</span>.<br/>
<span class="id">rewrite</span><span class="id"> -bigsetU_fset_set//</span><span class="id"> big_seq;</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable</span><span class="id"> =&gt;</span><span class="id"> i</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> in_fset_set</span><span class="id"> ?inE//</span><span class="id"> =&gt;</span><span class="id"> *;</span><span class="id"> apply:</span><span class="id"> Fm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurableD</span><span class="id"> :</span><span class="id"> setDI_closed</span> (<span class="id">@measurable</span><span class="id"> d</span><span class="id"> T</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mA</span><span class="id"> mB;</span><span class="id"> case:</span> (<span class="id">semi_measurableD</span><span class="id"> A</span><span class="id"> B</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> [D</span><span class="id"> [Dfin</span><span class="id"> Dl</span><span class="id"> -&gt;</span><span class="id"> _]]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> fin_bigcup_measurable</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ringofsets_lemmas</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> algebraofsets_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> algebraOfSetsType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurableC</span><span class="id"> A</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">~`</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> mA;</span><span class="id"> rewrite</span><span class="id"> -setTD;</span><span class="id"> exact:</span><span class="id"> measurableD</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigsetI_measurable</span><span class="id"> I</span><span class="id"> r</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">\big[setI/setT]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> r</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mF;</span><span class="id"> rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> X]setCK</span><span class="id"> setC_bigsetI;</span><span class="id"> apply:</span><span class="id"> measurableC</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> Pi;</span><span class="id"> apply/measurableC/mF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fin_bigcap_measurable</span><span class="id"> I</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">\bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Pchoice:</span><span class="id"> I</span><span class="id"> =&gt;</span><span class="id"> I</span><span class="gallina-kwd"> in</span><span class="id"> D</span><span class="id"> F</span><span class="id"> *</span><span class="id"> =&gt;</span><span class="id"> Dfin</span><span class="id"> Fm</span>.<br/>
<span class="id">rewrite</span><span class="id"> -bigsetI_fset_set//</span><span class="id"> big_seq;</span><span class="id"> apply:</span><span class="id"> bigsetI_measurable</span><span class="id"> =&gt;</span><span class="id"> i</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> in_fset_set</span><span class="id"> ?inE//</span><span class="id"> =&gt;</span><span class="id"> *;</span><span class="id"> apply:</span><span class="id"> Fm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurableID</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">A</span><span class="id"> `\`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span><span class="id"> /measurableC;</span><span class="id"> rewrite</span><span class="id"> setCI</span><span class="id"> =&gt;</span><span class="id"> /</span>(<span class="id">measurableI</span><span class="id"> A</span>)<span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> mA</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIUr</span><span class="id"> setICr</span><span class="id"> set0U</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> algebraofsets_lemmas</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> sigmaring_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> nat</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigcup_measurable</span><span class="id"> F</span><span class="id"> P</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> P</span><span class="id"> k</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> k</span>))<span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> PF;</span><span class="id"> rewrite</span><span class="id"> bigcup_mkcond;</span><span class="id"> apply:</span><span class="id"> bigcupT_measurable</span><span class="id"> =&gt;</span><span class="id"> k</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> exact:</span><span class="id"> PF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigcap_measurable</span><span class="id"> F</span><span class="id"> P</span><span class="id"> :</span><span class="id"> P</span><span class="id"> !=set0</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> P</span><span class="id"> k</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> k</span>))<span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">\bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [j</span><span class="id"> Pj]</span><span class="id"> PF;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">setD_bigcup</span><span class="id"> F</span><span class="id"> Pj</span>).<br/>
<span class="id">apply:</span><span class="id"> measurableD;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> PF</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_measurable</span><span class="id"> =&gt;</span><span class="id"> k/=</span><span class="id"> [Pk</span><span class="id"> kj];</span><span class="id"> apply:</span><span class="id"> measurableD;</span><span class="id"> exact:</span><span class="id"> PF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigcapT_measurable</span><span class="id"> F</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> k</span>))<span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">\bigcap_i</span><span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> PF;</span><span class="id"> apply:</span><span class="id"> bigcap_measurable</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> 1</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> sigmaring_lemmas</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> countable_measurable</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> t</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> measurable</span><span class="id"> [set</span><span class="id"> t]</span>)<span class="id"> -&gt;</span><span class="id"> countable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> m1;</span><span class="id"> have</span><span class="id"> [-&gt;//|/set0P[r</span><span class="id"> Ar]/countable_injP[f</span><span class="id"> injf]]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> A</span><span class="id"> set0</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">injpinv_image</span> (<span class="id">cst</span><span class="id"> r</span>)<span class="id"> injf</span>).<br/>
<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> X]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> \bigcup_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> A</span>)<span class="id"> [set</span><span class="id"> 'pinv_</span>(<span class="id">cst</span><span class="id"> r</span>)<span class="id"> A</span><span class="id"> f</span><span class="id"> x]</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_measurable</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /=</span><span class="id"> [s</span><span class="id"> As</span><span class="id"> &lt;-]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split=&gt;</span><span class="id"> [_</span><span class="id"> [_</span><span class="id"> [s</span><span class="id"> As</span><span class="id"> &lt;-]]</span><span class="id"> &lt;-|_</span><span class="id"> [_</span><span class="id"> [s</span><span class="id"> As</span><span class="id"> &lt;-]]</span><span class="id"> -&gt;];</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">f</span><span class="id"> s</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> sigma_ring_lambda_system</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigmaRingType_lambda_system</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">lambda_system</span><span class="id"> D</span><span class="id"> [set</span><span class="id"> X</span><span class="id"> |</span><span class="id"> measurable</span><span class="id"> X</span><span class="id"> /\</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> D]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mD;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> /=[]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> B</span><span class="id"> A</span><span class="id"> AB/=</span><span class="id"> [mB</span><span class="id"> BD]</span><span class="id"> [mA</span><span class="id"> AD];</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> measurableD</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subset_trans</span><span class="id"> BD;</span><span class="id"> exact:</span><span class="id"> subDsetl</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> /=</span><span class="id"> F</span><span class="id"> _</span><span class="id"> mFD;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_measurable</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> exact:</span> (<span class="id">mFD</span><span class="id"> _</span>).<span class="id">1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_sub</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> exact:</span> (<span class="id">mFD</span><span class="id"> _</span>).<span class="id">2</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> sigma_ring_lambda_system</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigcupT_measurable_rat</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> rat</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">\bigcup_i</span><span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Fm;</span><span class="id"> have</span><span class="id"> /ppcard_eqP[f]</span><span class="id"> :=</span><span class="id"> card_rat</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">reindex_bigcup</span><span class="id"> f^-1%FUN</span><span class="id"> setT</span>)<span class="id">//=;</span><span class="id"> exact:</span><span class="id"> bigcupT_measurable</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> measurable_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> nat</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_algebra_measurable</span><span class="id"> :</span><span class="id"> sigma_algebra</span><span class="id"> setT</span> (<span class="id">@measurable</span><span class="id"> d</span><span class="id"> T</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> [A|];</span><span class="id"> [exact:</span><span class="id"> measurableD|exact:</span><span class="id"> bigcupT_measurable]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bigcap_measurableType</span><span class="id"> F</span><span class="id"> P</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> P</span><span class="id"> k</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> k</span>))<span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">\bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> P</span>)<span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> PF;</span><span class="id"> rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> X]setCK</span><span class="id"> setC_bigcap;</span><span class="id"> apply:</span><span class="id"> measurableC</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_measurable</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> Pk;</span><span class="id"> exact/measurableC/PF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> measurable_lemmas</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> discrete_measurable_unit</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> discrete_measurable_unit</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> unit</span>)<span class="id"> :=</span><span class="id"> [set:</span><span class="id"> set</span><span class="id"> unit]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> discrete_measurable0</span><span class="id"> :</span><span class="id"> discrete_measurable_unit</span><span class="id"> set0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> discrete_measurableC</span><span class="id"> X</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">discrete_measurable_unit</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> discrete_measurable_unit</span> (<span class="id">~`</span><span class="id"> X</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> discrete_measurableU</span> (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> unit</span>)<span class="id">^nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> discrete_measurable_unit</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">discrete_measurable_unit</span> (<span class="id">\bigcup_i</span><span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @isMeasurable</span>.<span class="id">Build</span><span class="id"> default_measure_display</span><span class="id"> unit</span><br/>
&nbsp;&nbsp;<span class="id">discrete_measurable_unit</span><span class="id"> discrete_measurable0</span><br/>
&nbsp;&nbsp;<span class="id">discrete_measurableC</span><span class="id"> discrete_measurableU</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> discrete_measurable_unit</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> discrete_measurable_bool</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> discrete_measurable_bool</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> bool</span>)<span class="id"> :=</span><span class="id"> [set:</span><span class="id"> set</span><span class="id"> bool]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> discrete_measurable0</span><span class="id"> :</span><span class="id"> discrete_measurable_bool</span><span class="id"> set0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> discrete_measurableC</span><span class="id"> X</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">discrete_measurable_bool</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> discrete_measurable_bool</span> (<span class="id">~`</span><span class="id"> X</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> discrete_measurableU</span> (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> bool</span>)<span class="id">^nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> discrete_measurable_bool</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">discrete_measurable_bool</span> (<span class="id">\bigcup_i</span><span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @isMeasurable</span>.<span class="id">Build</span><span class="id"> default_measure_display</span><span class="id"> bool</span><br/>
&nbsp;&nbsp;<span class="id">discrete_measurable_bool</span><span class="id"> discrete_measurable0</span><br/>
&nbsp;&nbsp;<span class="id">discrete_measurableC</span><span class="id"> discrete_measurableU</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> discrete_measurable_bool</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> discrete_measurable_nat</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> discrete_measurable_nat</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> nat</span>)<span class="id"> :=</span><span class="id"> [set:</span><span class="id"> set</span><span class="id"> nat]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> discrete_measurable_nat0</span><span class="id"> :</span><span class="id"> discrete_measurable_nat</span><span class="id"> set0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> discrete_measurable_natC</span><span class="id"> X</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">discrete_measurable_nat</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> discrete_measurable_nat</span> (<span class="id">~`</span><span class="id"> X</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> discrete_measurable_natU</span> (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> nat</span>)<span class="id">^nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> discrete_measurable_nat</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">discrete_measurable_nat</span> (<span class="id">\bigcup_i</span><span class="id"> F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasurable</span>.<span class="id">Build</span><span class="id"> default_measure_display</span><span class="id"> nat</span><br/>
&nbsp;&nbsp;<span class="id">discrete_measurable_nat0</span><span class="id"> discrete_measurable_natC</span><span class="id"> discrete_measurable_natU</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> discrete_measurable_nat</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> sigma_display</span><span class="id"> {T}</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> -&gt;</span><span class="id"> measure_display</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> g_sigma_algebraType</span><span class="id"> {T}</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :=</span><span class="id"> T</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.2.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed into `g_sigma_algebraType`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> salgebraType</span><span class="id"> :=</span><span class="id"> g_sigma_algebraType</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> g_salgebra_instance</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> pointedType</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_algebraC</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> &lt;&lt;s</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> &lt;&lt;s</span><span class="id"> G</span><span class="id"> &gt;&gt;</span> (<span class="id">~`</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sGA;</span><span class="id"> rewrite</span><span class="id"> -setTD;</span><span class="id"> exact:</span><span class="id"> sigma_algebraCD</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Pointed</span>.<span class="id">on</span> (<span class="id">g_sigma_algebraType</span><span class="id"> G</span>).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @isMeasurable</span>.<span class="id">Build</span> (<span class="id">sigma_display</span><span class="id"> G</span>)<br/>
&nbsp;&nbsp;(<span class="id">g_sigma_algebraType</span><span class="id"> G</span>)<br/>
&nbsp;&nbsp;<span class="id">&lt;&lt;s</span><span class="id"> G</span><span class="id"> &gt;&gt;</span> (<span class="id">@sigma_algebra0</span><span class="id"> _</span><span class="id"> setT</span><span class="id"> G</span>) (<span class="id">@sigma_algebraC</span>)<br/>
&nbsp;&nbsp;(<span class="id">@sigma_algebra_bigcup</span><span class="id"> _</span><span class="id"> setT</span><span class="id"> G</span>).<br/>
<br/>
<span class="vernacular">End</span><span class="id"> g_salgebra_instance</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;G .-sigma&quot;</span><span class="id"> :=</span> (<span class="id">sigma_display</span><span class="id"> G</span>)<span class="id"> :</span><span class="id"> measure_display_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;G .-sigma.-measurable&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">measurable</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span> (<span class="id">g_sigma_algebraType</span><span class="id"> G</span>)))<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_g_measurableTypeE</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> pointedType</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">sigma_algebra</span><span class="id"> setT</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> G</span>.<span class="id">-sigma</span>.<span class="id">-measurable</span><span class="id"> =</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> sigma_algebra_id</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> measurable_fun</span><span class="id"> d</span><span class="id"> d'</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">U</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> Y,</span><span class="id"> measurable</span><span class="id"> Y</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">D</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> Y</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measurable_fun</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d1</span><span class="id"> d2</span><span class="id"> d3</span> (<span class="id">T1</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d1</span>) (<span class="id">T2</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T3</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d3</span>).<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> D</span><span class="id"> E</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T1</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_id</span><span class="id"> D</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> D</span><span class="id"> id</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> mD</span><span class="id"> A</span><span class="id"> mA;</span><span class="id"> apply:</span><span class="id"> measurableI</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_comp</span><span class="id"> F</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> T3</span>)<span class="id"> E</span> (<span class="id">g</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> g</span><span class="id"> @`</span><span class="id"> E</span><span class="id"> `&lt;=`</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> F</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> E</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> \o</span><span class="id"> g</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mF</span><span class="id"> FgE</span><span class="id"> mf</span><span class="id"> mg</span><span class="id"> /=</span><span class="id"> mE</span><span class="id"> A</span><span class="id"> mA</span>.<br/>
<span class="id">rewrite</span><span class="id"> comp_preimage</span>.<br/>
<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> _</span><span class="id"> `&amp;`</span><span class="id"> _</span><span class="id"> =</span><span class="id"> E</span><span class="id"> `&amp;`</span><span class="id"> g</span><span class="id"> @^-1`</span> (<span class="id">F</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> A</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> [|?</span><span class="id"> [?]</span><span class="id"> []//]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x/=</span><span class="id"> [Ex</span><span class="id"> Afgx];</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> FgE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/mg</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_measurable_fun</span><span class="id"> D</span> (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> D,</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> g}</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> D</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> D</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> fg</span><span class="id"> mf</span><span class="id"> mD</span><span class="id"> A</span><span class="id"> mA;</span><span class="id"> rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> X]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> D</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> A</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;<span class="id">[exact:</span><span class="id"> mf|exact/esym/eq_preimage]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_cst</span><span class="id"> D</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> T2</span>)<span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> D</span> (<span class="id">cst</span><span class="id"> r</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> _</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> mD</span><span class="id"> /=</span><span class="id"> Y</span><span class="id"> mY;</span><span class="id"> rewrite</span><span class="id"> preimage_cst;</span><span class="id"> case:</span><span class="id"> ifPn;</span><span class="id"> rewrite</span><span class="id"> ?setIT</span><span class="id"> ?setI0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_fun_bigcup</span> (<span class="id">E</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T1</span>)<span class="id">^nat</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> measurable</span> (<span class="id">E</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span> (<span class="id">\bigcup_i</span><span class="id"> E</span><span class="id"> i</span>)<span class="id"> f</span><span class="id"> &lt;-&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> measurable_fun</span> (<span class="id">E</span><span class="id"> i</span>)<span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mE;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [|mf</span><span class="id"> /=</span><span class="id"> _</span><span class="id"> A</span><span class="id"> mA];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setI_bigcupl;</span><span class="id"> apply:</span><span class="id"> bigcup_measurable</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> mf</span><span class="id"> i</span><span class="id"> _</span><span class="id"> A</span><span class="id"> /mf</span><span class="id"> =&gt;</span><span class="id"> /</span>(_ (<span class="id">bigcup_measurable</span> (<span class="gallina-kwd">fun</span><span class="id"> k</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> mE</span><span class="id"> k</span>))).<br/>
<span class="id">move=&gt;</span><span class="id"> /</span>(<span class="id">measurableI</span> (<span class="id">E</span><span class="id"> i</span>))<span class="id">-/</span>(_ (<span class="id">mE</span><span class="id"> i</span>)).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setICA</span><span class="id"> setIA</span> (<span class="id">@setIidr</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">E</span><span class="id"> i</span>))<span class="id">//;</span><span class="id"> exact:</span><span class="id"> bigcup_sup</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_funU</span><span class="id"> D</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>)<span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> E</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span> (<span class="id">D</span><span class="id"> `|`</span><span class="id"> E</span>)<span class="id"> f</span><span class="id"> &lt;-&gt;</span><span class="id"> measurable_fun</span><span class="id"> D</span><span class="id"> f</span><span class="id"> /\</span><span class="id"> measurable_fun</span><span class="id"> E</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mD</span><span class="id"> mE;</span><span class="id"> rewrite</span><span class="id"> -bigcup2E;</span><span class="id"> apply:</span> (<span class="id">iff_trans</span> (<span class="id">measurable_fun_bigcup</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [//|[//|//=]]</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> [mf|[Df</span><span class="id"> Dg]</span><span class="id"> [//|[//|/=</span><span class="id"> _</span><span class="id"> _</span><span class="id"> Y</span><span class="id"> mY]]];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> set0I</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split;</span><span class="id"> [exact:</span> (<span class="id">mf</span><span class="id"> 0%N</span>)<span class="id">|exact:</span> (<span class="id">mf</span><span class="id"> 1%N</span>)<span class="id">]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_funS</span><span class="id"> E</span><span class="id"> D</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> E</span><span class="id"> -&gt;</span><span class="id"> D</span><span class="id"> `&lt;=`</span><span class="id"> E</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> E</span><span class="id"> f</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> D</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mE</span><span class="id"> DE</span><span class="id"> mf</span><span class="id"> mD;</span><span class="id"> have</span><span class="id"> mC</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">E</span><span class="id"> `\`</span><span class="id"> D</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> measurableD</span>.<br/>
<span class="id">move:</span> (<span class="id">mD</span>).<br/>
<span class="id">have</span><span class="id"> :=</span><span class="id"> measurable_funU</span><span class="id"> f</span><span class="id"> mD</span><span class="id"> mC</span>.<br/>
<span class="id">suff</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> D</span><span class="id"> `|`</span> (<span class="id">E</span><span class="id"> `\`</span><span class="id"> D</span>)<span class="id"> =</span><span class="id"> E</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [[]]</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setDUK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_fun_if</span> (<span class="id">g</span><span class="id"> h</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>)<span class="id"> D</span> (<span class="id">mD</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> bool</span>) (<span class="id">mf</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> D</span><span class="id"> f</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span> (<span class="id">D</span><span class="id"> `&amp;`</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> true]</span>))<span class="id"> g</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span> (<span class="id">D</span><span class="id"> `&amp;`</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> false]</span>))<span class="id"> h</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> D</span> (<span class="gallina-kwd">fun</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> f</span><span class="id"> t</span><span class="gallina-kwd"> then</span><span class="id"> g</span><span class="id"> t</span><span class="gallina-kwd"> else</span><span class="id"> h</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mx</span><span class="id"> my</span><span class="id"> /=</span><span class="id"> _</span><span class="id"> B</span><span class="id"> mB;</span><span class="id"> rewrite</span> (_<span class="id"> :</span><span class="id"> _</span><span class="id"> @^-1`</span><span class="id"> B</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> true]</span>)<span class="id"> `&amp;`</span> (<span class="id">g</span><span class="id"> @^-1`</span><span class="id"> B</span>))<span class="id"> `|`</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> false]</span>)<span class="id"> `&amp;`</span> (<span class="id">h</span><span class="id"> @^-1`</span><span class="id"> B</span>))).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setIUr;</span><span class="id"> apply:</span><span class="id"> measurableU</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIA;</span><span class="id"> apply:</span><span class="id"> mx</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIA;</span><span class="id"> apply:</span><span class="id"> my</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
<span class="id">apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> [t</span><span class="id"> /=|</span><span class="id"> t</span><span class="id"> /=</span><span class="id"> []</span><span class="id"> []</span><span class="id"> -&gt;//]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> ft;</span><span class="id"> [left|right]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_fun_set0</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>)<span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> set0</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> set0I</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_fun_set1</span><span class="id"> a</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>)<span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> [set</span><span class="id"> a]</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> set1I;</span><span class="id"> case:</span><span class="id"> ifP</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> measurable_fun</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">measurable_fun</span><span class="id"> _</span> (<span class="id">fun=&gt;</span><span class="id"> _</span>))<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> measurable_cst]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">measurable_fun</span><span class="id"> _</span> (<span class="id">cst</span><span class="id"> _</span>))<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> measurable_cst]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">measurable_fun</span><span class="id"> _</span><span class="id"> id</span>)<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> measurable_id]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> eq_measurable_fun</span><span class="id"> {d1</span><span class="id"> d2</span><span class="id"> T1</span><span class="id"> T2</span><span class="id"> D}</span><span class="id"> f</span><span class="id"> {g}</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `eq_measurable_fun`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> measurable_fun_ext</span><span class="id"> :=</span><span class="id"> eq_measurable_fun</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.3&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `measurable_id`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> measurable_fun_id</span><span class="id"> :=</span><span class="id"> measurable_id</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.3&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `measurable_cst`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> measurable_fun_cst</span><span class="id"> :=</span><span class="id"> measurable_cst</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.3&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `measurable_comp`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> measurable_fun_comp</span><span class="id"> :=</span><span class="id"> measurable_comp</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measurable_fun_measurableType</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d1</span><span class="id"> d2</span><span class="id"> d3</span> (<span class="id">T1</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d1</span>) (<span class="id">T2</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T3</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d3</span>).<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> D</span><span class="id"> E</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T1</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurableT_comp</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> T3</span>)<span class="id"> E</span> (<span class="id">g</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> [set:</span><span class="id"> T2]</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> E</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> \o</span><span class="id"> g</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> measurable_comp</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_funTS</span><span class="id"> D</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> [set:</span><span class="id"> T1]</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> D</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> measurable_funS</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_restrict</span><span class="id"> D</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>)<span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> E</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span> (<span class="id">E</span><span class="id"> `&amp;`</span><span class="id"> D</span>)<span class="id"> f</span><span class="id"> &lt;-&gt;</span><span class="id"> measurable_fun</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> \_</span><span class="id"> D</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mD</span><span class="id"> mE;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> mf</span><span class="id"> _</span><span class="id"> /=</span><span class="id"> Y</span><span class="id"> mY</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> preimage_restrict;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> ptX;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> set0U</span><span class="id"> setIA;</span><span class="id"> apply:</span><span class="id"> mf</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setIUr;</span><span class="id"> apply:</span><span class="id"> measurableU</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurableI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurableC</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIA;</span><span class="id"> apply:</span><span class="id"> mf</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">-</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> mf</span><span class="id"> mE</span><span class="id"> _</span><span class="id"> mY;</span><span class="id"> rewrite</span><span class="id"> preimage_restrict;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> ptY;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> set0U</span><span class="id"> setIA</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setUIr</span><span class="id"> setvU</span><span class="id"> setTI</span><span class="id"> setIUr</span><span class="id"> =&gt;</span><span class="id"> /</span>(<span class="id">measurableI</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mD</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIUr</span><span class="id"> setIA</span><span class="id"> setIAC</span><span class="id"> setICr</span><span class="id"> set0I</span><span class="id"> set0U</span><span class="id"> setICA</span><span class="id"> setIA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_restrictT</span><span class="id"> D</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>)<span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> D</span><span class="id"> f</span><span class="id"> &lt;-&gt;</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T1]</span> (<span class="id">f</span><span class="id"> \_</span><span class="id"> D</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> mD;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> measurable_restrict</span><span class="id"> f</span><span class="id"> mD</span><span class="id"> measurableT;</span><span class="id"> rewrite</span><span class="id"> setTI</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_fun_ifT</span> (<span class="id">g</span><span class="id"> h</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> bool</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mf</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T1]</span><span class="id"> f</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> [set:</span><span class="id"> T1]</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T1]</span><span class="id"> h</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> [set:</span><span class="id"> T1]</span> (<span class="gallina-kwd">fun</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> f</span><span class="id"> t</span><span class="gallina-kwd"> then</span><span class="id"> g</span><span class="id"> t</span><span class="gallina-kwd"> else</span><span class="id"> h</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> mx</span><span class="id"> my;</span><span class="id"> apply:</span><span class="id"> measurable_fun_if</span><span class="id"> =&gt;</span><span class="id"> //;</span><br/>
&nbsp;&nbsp;<span class="id">[exact:</span><span class="id"> measurable_funS</span><span class="id"> mx|exact:</span><span class="id"> measurable_funS</span><span class="id"> my]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> measurable_fun_bool</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> bool</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> measurable_fun_TF</span><span class="id"> D</span><span class="id"> f</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">D</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> true]</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">D</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> false]</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> D</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mT</span><span class="id"> mF</span><span class="id"> mD</span><span class="id"> /=</span><span class="id"> Y</span><span class="id"> mY</span>.<br/>
<span class="id">have</span><span class="id"> :=</span><span class="id"> @subsetT</span><span class="id"> _</span><span class="id"> Y;</span><span class="id"> rewrite</span><span class="id"> setT_bool</span><span class="id"> =&gt;</span><span class="id"> YT</span>.<br/>
<span class="id">move:</span><span class="id"> mY;</span><span class="id"> have</span><span class="id"> [-&gt;</span><span class="id"> _|-&gt;</span><span class="id"> _|-&gt;</span><span class="id"> _</span><span class="id"> |-&gt;</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> subset_set2</span><span class="id"> YT</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> preimage0</span><span class="id"> ?setI0</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> mT</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> mF</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setT_bool</span><span class="id"> preimage_setT</span><span class="id"> setIT</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_fun_bool</span><span class="id"> D</span><span class="id"> f</span><span class="id"> b</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">D</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> b]</span>)<span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> D</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mb</span><span class="id"> mD;</span><span class="id"> have</span><span class="id"> mDb</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">D</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> ~~</span><span class="id"> b]</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> [set</span><span class="id"> ~~</span><span class="id"> b]</span><span class="id"> =</span><span class="id"> [set~</span><span class="id"> b]</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> -[]</span><span class="id"> /=;</span><span class="id"> case:</span><span class="id"> b</span><span class="id"> {mb}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -preimage_setC;</span><span class="id"> exact:</span><span class="id"> measurableID</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> b</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="gallina-kwd"> in</span><span class="id"> mb</span><span class="id"> mDb</span><span class="id"> *;</span><span class="id"> exact:</span><span class="id"> measurable_fun_TF</span>.<br/>
Qed.</div></details>
<span class="id">#[global]</span><span class="vernacular"> Arguments</span><span class="id"> measurable_fun_bool</span><span class="id"> {D</span><span class="id"> f}</span><span class="id"> _</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_and</span><span class="id"> D</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> D</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> D</span><span class="id"> g</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> D</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> &amp;&amp;</span><span class="id"> g</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mf</span><span class="id"> mg</span><span class="id"> mD;</span><span class="id"> apply:</span> (<span class="id">measurable_fun_bool</span><span class="id"> true</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> X]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> D</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> true]</span><span class="id"> `&amp;`</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">D</span><span class="id"> `&amp;`</span><span class="id"> g</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> true]</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIACA</span><span class="id"> setIid;</span><span class="id"> congr</span> (_<span class="id"> `&amp;`</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /andP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurableI;</span><span class="id"> [exact:</span><span class="id"> mf|exact:</span><span class="id"> mg]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_neg</span><span class="id"> D</span><span class="id"> f</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> D</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> D</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> ~~</span><span class="id"> f</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mf</span><span class="id"> mD;</span><span class="id"> apply:</span> (<span class="id">measurable_fun_bool</span><span class="id"> true</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> X]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span> (<span class="id">D</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> false]</span>)).<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> mf</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [x</span><span class="id"> [Dx/=</span><span class="id"> /negbTE]|x</span><span class="id"> [Dx/=</span><span class="id"> -&gt;]]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_or</span><span class="id"> D</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> D</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> D</span><span class="id"> g</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> D</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> ||</span><span class="id"> g</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mf</span><span class="id"> mg</span>.<br/>
<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> measurable_fun</span><span class="id"> _</span><span class="id"> X]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> ~~</span> (<span class="id">~~</span><span class="id"> f</span><span class="id"> x</span><span class="id"> &amp;&amp;</span><span class="id"> ~~</span><span class="id"> g</span><span class="id"> x</span>))).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurable_neg;</span><span class="id"> apply:</span><span class="id"> measurable_and;</span><span class="id"> exact:</span><span class="id"> measurable_neg</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/funext=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -negb_or</span><span class="id"> negbK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> measurable_fun_bool</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> measurable_fun_measurableType</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">measurable_fun</span><span class="id"> _</span> (<span class="id">fun=&gt;</span><span class="id"> _</span>))<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> measurable_cst]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">measurable_fun</span><span class="id"> _</span> (<span class="id">cst</span><span class="id"> _</span>))<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> measurable_cst]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">measurable_fun</span><span class="id"> _</span><span class="id"> id</span>)<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> measurable_id]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> eq_measurable_fun</span><span class="id"> {d1</span><span class="id"> d2</span><span class="id"> T1</span><span class="id"> T2</span><span class="id"> D}</span><span class="id"> f</span><span class="id"> {g}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> measurable_fun_bool</span><span class="id"> {d1</span><span class="id"> T1</span><span class="id"> D</span><span class="id"> f}</span><span class="id"> b</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.3&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `measurableT_comp`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> measurable_funT_comp</span><span class="id"> :=</span><span class="id"> measurableT_comp</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measurability</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> preimage_class</span> (<span class="id">aT</span><span class="id"> rT</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> aT</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> rT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> rT</span>))<span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> aT</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> D</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> B</span><span class="id"> |</span><span class="id"> B</span><span class="gallina-kwd"> in</span><span class="id"> G]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> preimage_class_measurable_fun</span><span class="id"> d</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> pointedType</span>) (<span class="id">rT</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;(<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> aT</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> rT</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">g_sigma_algebraType</span> (<span class="id">preimage_class</span><span class="id"> D</span><span class="id"> f</span><span class="id"> measurable</span>)))<span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> mD</span><span class="id"> A</span><span class="id"> mA;</span><span class="id"> apply:</span><span class="id"> sub_sigma_algebra;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_algebra_preimage_class</span> (<span class="id">aT</span><span class="id"> rT</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> rT</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> aT</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> rT</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">sigma_algebra</span><span class="id"> setT</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> sigma_algebra</span><span class="id"> D</span> (<span class="id">preimage_class</span><span class="id"> D</span><span class="id"> f</span><span class="id"> G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case=&gt;</span><span class="id"> h0</span><span class="id"> hC</span><span class="id"> hU;</span><span class="id"> split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> set0</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> preimage_set0</span><span class="id"> setI0</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> A;</span><span class="id"> rewrite</span><span class="id"> /preimage_class</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> -[B</span><span class="id"> mB</span><span class="id"> &lt;-{A}]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">~`</span><span class="id"> B</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setTD;</span><span class="id"> exact:</span><span class="id"> hC</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> split=&gt;</span><span class="id"> [[Dx</span><span class="id"> Bfx]|[Dx]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[]</span><span class="id"> _</span><span class="id"> /Bfx</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /not_andP[]</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> F;</span><span class="id"> rewrite</span><span class="id"> /preimage_class</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> mF</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> {}mF</span><span class="id"> n</span><span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> G</span><span class="id"> x</span><span class="id"> /\</span><span class="id"> D</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> x</span><span class="id"> =</span><span class="id"> F</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> mF</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> -[B</span><span class="id"> mB</span><span class="id"> &lt;-];</span><span class="gallina-kwd"> exists</span><span class="id"> B</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [F'</span><span class="id"> mF']</span><span class="id"> :=</span><span class="id"> @choice</span><span class="id"> _</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> G</span><span class="id"> y</span><span class="id"> /\</span><span class="id"> D</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> y</span><span class="id"> =</span><span class="id"> F</span><span class="id"> x</span>)<span class="id"> mF</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">\bigcup_k</span> (<span class="id">F'</span><span class="id"> k</span>))<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> hU</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> exact:</span> (<span class="id">mF'</span><span class="id"> n</span>).<span class="id">1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> preimage_bigcup</span><span class="id"> setI_bigcupr;</span><span class="id"> apply:</span><span class="id"> eq_bigcupr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">mF'</span><span class="id"> i</span>).<span class="id">2</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> image_class</span> (<span class="id">aT</span><span class="id"> rT</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> aT</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> rT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> aT</span>))<span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> rT</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span><span class="id"> |</span><span class="id"> G</span> (<span class="id">D</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> B</span>)<span class="id">]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_algebra_image_class</span> (<span class="id">aT</span><span class="id"> rT</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> aT</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> rT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> aT</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">sigma_algebra</span><span class="id"> D</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> sigma_algebra</span><span class="id"> setT</span> (<span class="id">image_class</span><span class="id"> D</span><span class="id"> f</span><span class="id"> G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [G0</span><span class="id"> GC</span><span class="id"> GU];</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> /image_class</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> preimage_set0</span><span class="id"> setI0</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> /=</span><span class="id"> GfAD;</span><span class="id"> rewrite</span><span class="id"> setTD</span><span class="id"> -preimage_setC</span><span class="id"> -setDE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> _</span><span class="id"> `\`</span><span class="id"> _</span><span class="id"> =</span><span class="id"> D</span><span class="id"> `\`</span> (<span class="id">D</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> A</span>))<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> GC</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> split=&gt;</span><span class="id"> [[Dx</span><span class="id"> fAx]|[Dx</span><span class="id"> fADx]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[]</span><span class="id"> _</span><span class="id"> /fAx</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> contra_not</span><span class="id"> fADx</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> F</span><span class="id"> /=</span><span class="id"> mF;</span><span class="id"> rewrite</span><span class="id"> preimage_bigcup</span><span class="id"> setI_bigcupr;</span><span class="id"> exact:</span><span class="id"> GU</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_algebra_preimage_classE</span><span class="id"> aT</span> (<span class="id">rT</span><span class="id"> :</span><span class="id"> pointedType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> aT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> rT</span>) (<span class="id">G'</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> rT</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">&lt;&lt;s</span><span class="id"> D,</span><span class="id"> preimage_class</span><span class="id"> D</span><span class="id"> f</span><span class="id"> G'</span><span class="id"> &gt;&gt;</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">preimage_class</span><span class="id"> D</span><span class="id"> f</span> (<span class="id">G'</span>.<span class="id">-sigma</span>.<span class="id">-measurable</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> mG</span><span class="id"> :</span><span class="id"> sigma_algebra</span><span class="id"> D</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">preimage_class</span><span class="id"> D</span><span class="id"> f</span> (<span class="id">G'</span>.<span class="id">-sigma</span>.<span class="id">-measurable</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact/sigma_algebra_preimage_class/sigma_algebra_measurable</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> subset_preimage</span><span class="id"> :</span><span class="id"> preimage_class</span><span class="id"> D</span><span class="id"> f</span><span class="id"> G'</span><span class="id"> `&lt;=`</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">preimage_class</span><span class="id"> D</span><span class="id"> f</span> (<span class="id">G'</span>.<span class="id">-sigma</span>.<span class="id">-measurable</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> [B</span><span class="id"> CCB</span><span class="id"> &lt;-{A}];</span><span class="gallina-kwd"> exists</span><span class="id"> B</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> sub_sigma_algebra</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> smallest_sub</span>.<br/>
<span class="id">have</span><span class="id"> G'pre</span><span class="id"> A'</span><span class="id"> :</span><span class="id"> G'</span><span class="id"> A'</span><span class="id"> -&gt;</span> (<span class="id">preimage_class</span><span class="id"> D</span><span class="id"> f</span><span class="id"> G'</span>) (<span class="id">D</span><span class="id"> `&amp;`</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> A'</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="gallina-kwd"> exists</span><span class="id"> A'</span>.<br/>
<span class="id">pose</span><span class="id"> I</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> aT</span>)<span class="id"> :=</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> preimage_class</span><span class="id"> D</span><span class="id"> f</span><span class="id"> G'</span><span class="id"> &gt;&gt;</span>.<br/>
<span class="id">have</span><span class="id"> G'sfun</span><span class="id"> :</span><span class="id"> G'</span><span class="id"> `&lt;=`</span><span class="id"> image_class</span><span class="id"> D</span><span class="id"> f</span><span class="id"> I</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> A'</span><span class="id"> /G'pre[B</span><span class="id"> G'B</span><span class="id"> h];</span><span class="id"> apply:</span><span class="id"> sub_sigma_algebra;</span><span class="gallina-kwd"> exists</span><span class="id"> B</span>.<br/>
<span class="id">have</span><span class="id"> sG'sfun</span><span class="id"> :</span><span class="id"> &lt;&lt;s</span><span class="id"> G'</span><span class="id"> &gt;&gt;</span><span class="id"> `&lt;=`</span><span class="id"> image_class</span><span class="id"> D</span><span class="id"> f</span><span class="id"> I</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> smallest_sub</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> sigma_algebra_image_class</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> smallest_sigma_algebra</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> [B</span><span class="id"> mB</span><span class="id"> &lt;-];</span><span class="id"> exact:</span><span class="id"> sG'sfun</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurability</span><span class="id"> d</span><span class="id"> d'</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">rT</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> aT</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> rT</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> rT</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">@measurable</span><span class="id"> _</span><span class="id"> rT</span><span class="id"> =</span><span class="id"> &lt;&lt;s</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> -&gt;</span><span class="id"> preimage_class</span><span class="id"> D</span><span class="id"> f</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> @measurable</span><span class="id"> _</span><span class="id"> aT</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> D</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sG_rT</span><span class="id"> fG_aT</span><span class="id"> mD</span>.<br/>
<span class="id">suff</span><span class="id"> h</span><span class="id"> :</span><span class="id"> preimage_class</span><span class="id"> D</span><span class="id"> f</span> (<span class="id">@measurable</span><span class="id"> _</span><span class="id"> rT</span>)<span class="id"> `&lt;=`</span><span class="id"> @measurable</span><span class="id"> _</span><span class="id"> aT</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> mA;</span><span class="id"> apply:</span><span class="id"> h;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> preimage_class</span><span class="id"> D</span><span class="id"> f</span> (<span class="id">@measurable</span><span class="id"> _</span><span class="id"> rT</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&lt;&lt;s</span><span class="id"> D,</span><span class="id"> preimage_class</span><span class="id"> D</span><span class="id"> f</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [in</span><span class="id"> LHS]sG_rT</span><span class="id"> [in</span><span class="id"> RHS]sigma_algebra_preimage_classE</span>.<br/>
<span class="id">apply:</span><span class="id"> smallest_sub</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> mA;</span><span class="id"> exact:</span><span class="id"> measurableD</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> F</span><span class="id"> h;</span><span class="id"> exact:</span><span class="id"> bigcupT_measurable</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> measurability</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> subset_sigma_subadditive</span><span class="id"> {T}</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> numFieldType}</span><br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> `&lt;=`</span><span class="id"> \bigcup_n</span><span class="id"> F</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> \sum_</span>(<span class="id">n</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> n</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> additivity</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> semi_additive2</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> A</span><span class="id"> B,</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> =</span><span class="id"> set0</span><span class="id"> -&gt;</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> +</span><span class="id"> mu</span><span class="id"> B</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> semi_additive</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> F</span><span class="id"> n,</span><br/>
&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> k</span><span class="id"> :</span><span class="id"> nat,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> k</span>))<span class="id"> -&gt;</span><span class="id"> trivIset</span><span class="id"> setT</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> k</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> semi_sigma_additive</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> F,</span> (<span class="gallina-kwd">forall</span><span class="id"> i</span><span class="id"> :</span><span class="id"> nat,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> trivIset</span><span class="id"> setT</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">\bigcup_n</span><span class="id"> F</span><span class="id"> n</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> @</span><span class="id"> \oo</span><span class="id"> --&gt;</span><span class="id"> mu</span> (<span class="id">\bigcup_n</span><span class="id"> F</span><span class="id"> n</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> additive2</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> A</span><span class="id"> B,</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> =</span><span class="id"> set0</span><span class="id"> -&gt;</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> +</span><span class="id"> mu</span><span class="id"> B</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> additive</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> F,</span> (<span class="gallina-kwd">forall</span><span class="id"> i</span><span class="id"> :</span><span class="id"> nat,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> trivIset</span><span class="id"> setT</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> mu</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> sigma_additive</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> F,</span> (<span class="gallina-kwd">forall</span><span class="id"> i</span><span class="id"> :</span><span class="id"> nat,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> trivIset</span><span class="id"> setT</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> @</span><span class="id"> \oo</span><span class="id"> --&gt;</span><span class="id"> mu</span> (<span class="id">\bigcup_n</span><span class="id"> F</span><span class="id"> n</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> subadditive</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> n,</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> `I_n</span><span class="id"> k</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> k</span>))<span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> `&lt;=`</span><span class="id"> \big[setU/set0]_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> k</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> \sum_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> k</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> measurable_subset_sigma_subadditive</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> n</span>))<span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">subset_sigma_subadditive</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> F</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> semi_additiveW</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> semi_additive</span><span class="id"> -&gt;</span><span class="id"> semi_additive2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mu0</span><span class="id"> amx</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mA</span><span class="id"> mB</span><span class="id"> +</span><span class="id"> AB;</span><span class="id"> rewrite</span><span class="id"> -bigcup2inE</span><span class="id"> bigcup_mkord</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /</span>(<span class="id">amx</span> (<span class="id">bigcup2</span><span class="id"> A</span><span class="id"> B</span>))<span class="id">-&gt;</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">big_ord_recl,</span><span class="id"> big_ord0</span>)<span class="id">/=</span><span class="id"> adde0</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [|[|[]]]//=</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [|[|i]]</span><span class="id"> [|[|j]]/=</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">AB,</span><span class="id"> setI0,</span><span class="id"> set0I,</span><span class="id"> setIC</span>)<span class="id"> =&gt;</span><span class="id"> -[]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> additivity</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.1.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `subadditive`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> sub_additive</span><span class="id"> :=</span><span class="id"> subadditive</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.1.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `measurable_subset_sigma_subadditive`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> sigma_sub_additive</span><span class="id"> :=</span><span class="id"> measurable_subset_sigma_subadditive</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ring_additivity</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> semi_additiveE</span><span class="id"> :</span><span class="id"> semi_additive</span><span class="id"> mu</span><span class="id"> =</span><span class="id"> additive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> propeqE;</span><span class="id"> split=&gt;</span><span class="id"> [sa</span><span class="id"> A</span><span class="id"> mA</span><span class="id"> tA</span><span class="id"> n|+</span><span class="id"> A</span><span class="id"> m</span><span class="id"> mA</span><span class="id"> tA</span><span class="id"> UAm];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move-&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> sa</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> bigsetU_measurable</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> semi_additive2E</span><span class="id"> :</span><span class="id"> semi_additive2</span><span class="id"> mu</span><span class="id"> =</span><span class="id"> additive2</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> propeqE;</span><span class="id"> split=&gt;</span><span class="id"> [amu</span><span class="id"> A</span><span class="id"> B</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?|amu</span><span class="id"> A</span><span class="id"> B</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> _</span><span class="id"> ?];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> amu</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> amu</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurableU</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> additive2P</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> semi_additive</span><span class="id"> mu</span><span class="id"> &lt;-&gt;</span><span class="id"> additive2</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mu0;</span><span class="id"> rewrite</span><span class="id"> -semi_additive2E;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> semi_additiveW</span>.<br/>
<span class="id">rewrite</span><span class="id"> semi_additiveE</span><span class="id"> semi_additive2E</span><span class="id"> =&gt;</span><span class="id"> muU</span><span class="id"> A</span><span class="id"> Am</span><span class="id"> Atriv</span><span class="id"> n</span>.<br/>
<span class="id">elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> IHn];</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">big_ord_recr,</span><span class="id"> big_ord0</span>)<span class="id"> ?mu0//=</span>.<br/>
<span class="id">rewrite</span><span class="id"> muU</span><span class="id"> ?IHn//=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable</span>.<br/>
<span class="id">rewrite</span><span class="id"> -bigcup_mkord</span><span class="id"> -subset0</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> [[/=</span><span class="id"> m</span><span class="id"> +</span><span class="id"> Amx]</span><span class="id"> Anx]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">Atriv</span><span class="id"> m</span><span class="id"> n</span>)<span class="id"> ?ltnn//=;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ring_additivity</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> semi_sigma_additive_is_additive</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> semi_sigma_additive</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> semi_additive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mu0</span><span class="id"> samu</span><span class="id"> A</span><span class="id"> n</span><span class="id"> Am</span><span class="id"> Atriv</span><span class="id"> UAm</span>.<br/>
<span class="id">have</span><span class="id"> :=</span><span class="id"> samu</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span> (<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id">%N</span><span class="gallina-kwd"> then</span><span class="id"> A</span><span class="id"> i</span><span class="gallina-kwd"> else</span><span class="id"> set0</span>).<br/>
<span class="id">rewrite</span> (<span class="id">bigcup_splitn</span><span class="id"> n</span>)<span class="id"> bigcup0</span><span class="id"> ?setU0;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -ltn_subRL</span><span class="id"> subnn</span>.<br/>
<span class="id">under</span><span class="id"> eq_bigr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> ltn_ord</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> _</span><span class="id"> UAm</span>)<span class="id">/</span>(<span class="id">@cvg_lim</span><span class="id"> _</span>)<span class="id"> &lt;-//;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> case:</span><span class="id"> ifP</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> do</span><span class="id"> 2![case:</span><span class="id"> ifP]</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> do</span><span class="id"> ?by</span><span class="id"> rewrite</span> (<span class="id">setI0,</span><span class="id"> set0I</span>)<span class="id"> =&gt;</span><span class="id"> -[]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /Atriv;</span><span class="id"> apply</span>.<br/>
<span class="id">apply:</span><span class="id"> lim_near_cst</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> near=&gt;</span><span class="id"> i</span>.<br/>
<span class="id">have</span><span class="id"> /subnKC&lt;-</span><span class="id"> :</span> (<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> i</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> near:</span><span class="id"> i;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
<span class="id">transitivity</span> (<span class="id">\sum_</span>(<span class="id">j</span><span class="id"> &lt;</span><span class="id"> n</span><span class="id"> +</span> (<span class="id">i</span><span class="id"> -</span><span class="id"> n</span>))<span class="id"> mu</span> (<span class="gallina-kwd">if</span> (<span class="id">j</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id">%N</span><span class="gallina-kwd"> then</span><span class="id"> A</span><span class="id"> j</span><span class="gallina-kwd"> else</span><span class="id"> set0</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_mkord</span>.<br/>
<span class="id">rewrite</span><span class="id"> big_split_ord/=;</span><span class="id"> under</span><span class="id"> eq_bigr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> ltn_ord</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> +</span><span class="id"> X]big1</span><span class="id"> ?adde0//</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> -ltn_subRL</span><span class="id"> subnn</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> semi_sigma_additiveE</span><br/>
&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>)<span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">semi_sigma_additive</span><span class="id"> mu</span><span class="id"> =</span><span class="id"> sigma_additive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> propeqE;</span><span class="id"> split=&gt;</span><span class="id"> [amu</span><span class="id"> A</span><span class="id"> mA</span><span class="id"> tA|amu</span><span class="id"> A</span><span class="id"> mA</span><span class="id"> tA</span><span class="id"> mbigcupA];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> amu</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> amu</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> bigcupT_measurable</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_additive_is_additive</span><br/>
&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> sigma_additive</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> additive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mu0;</span><span class="id"> rewrite</span><span class="id"> -semi_sigma_additiveE</span><span class="id"> -semi_additiveE</span>.<br/>
<span class="id">exact:</span><span class="id"> semi_sigma_additive_is_additive</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> isContent</span><span class="id"> d</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">measure_ge0</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measure_semi_additive</span><span class="id"> :</span><span class="id"> semi_additive</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> Content</span><span class="id"> d</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>)<span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> &amp;</span><span class="id"> isContent</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="vernacular">Notation</span><span class="id"> content</span><span class="id"> :=</span><span class="id"> Content</span>.<span class="id">type</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'content' 'set' T '-&gt;' '\bar' R }&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">content</span><span class="id"> T</span><span class="id"> R</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> T,</span><span class="id"> R</span><span class="gallina-kwd"> at</span><span class="id"> next</span><span class="id"> level,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;{ 'content'  'set'  T  '-&gt;'  '\bar'  R }&quot;</span>)<span class="id"> :</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> measure_ge0</span><span class="id"> {d</span><span class="id"> T</span><span class="id"> R}</span><span class="id"> _</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> content_signed</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>).<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> content_snum_subproof</span><span class="id"> S</span><span class="id"> :</span><span class="id"> Signed</span>.<span class="id">spec</span><span class="id"> 0</span><span class="id"> ?=0</span><span class="id"> &gt;=0</span> (<span class="id">mu</span><span class="id"> S</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> measure_ge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> content_snum</span><span class="id"> S</span><span class="id"> :=</span><span class="id"> Signed</span>.<span class="id">mk</span> (<span class="id">content_snum_subproof</span><span class="id"> S</span>).<br/>
<br/>
<span class="vernacular">End</span><span class="id"> content_signed</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> content_on_semiring_of_sets</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure0</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> /[!big_ord0]</span><span class="id"> -&gt;//</span><span class="id"> :=</span><span class="id"> @measure_semi_additive</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mu</span> (<span class="id">fun=&gt;</span><span class="id"> set0</span>)<span class="id"> 0%N</span>.<br/>
<span class="id">exact:</span><span class="id"> trivIset_set0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> measure0</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> measure_ge0</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> measure_semi_additive</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_semi_additive_ord</span> (<span class="id">n</span><span class="id"> :</span><span class="id"> nat</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> 'I_n</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span> (<span class="id">k</span><span class="id"> :</span><span class="id"> 'I_n</span>)<span class="id">,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> k</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">trivIset</span><span class="id"> setT</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> k</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> pose</span><span class="id"> F'</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> nat</span>)<span class="id"> :=</span><span class="id"> oapp</span><span class="id"> F</span><span class="id"> set0</span> (<span class="id">insub</span><span class="id"> i</span>).<br/>
<span class="id">have</span><span class="id"> FE</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> 'I_n</span>)<span class="id"> :</span><span class="id"> F</span><span class="id"> i</span><span class="id"> =</span> (<span class="id">F'</span><span class="id"> \o</span><span class="id"> val</span>)<span class="id"> i</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /F'/=</span><span class="id"> valK/=</span>.<br/>
<span class="id">rewrite</span> (<span class="id">eq_bigr</span> (<span class="id">F'</span><span class="id"> \o</span><span class="id"> val</span>))<span class="id">//</span> (<span class="id">eq_bigr</span> (<span class="id">mu</span><span class="id"> \o</span><span class="id"> F'</span><span class="id"> \o</span><span class="id"> val</span>))<span class="id">//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> FE</span>.<br/>
<span class="id">rewrite</span><span class="id"> -measure_semi_additive//</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> k;</span><span class="id"> rewrite</span><span class="id"> /F';</span><span class="id"> case:</span><span class="id"> insubP</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="id">-</span><span class="id"> apply/trivIsetP=&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /F'</span>.<br/>
&nbsp;&nbsp;<span class="id">do</span><span class="id"> 2?[case:</span><span class="id"> insubP;</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">set0I,</span><span class="id"> setI0</span>)<span class="id">//=</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> _</span><span class="id"> &lt;-]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/trivIsetP:</span><span class="id"> tF;</span><span class="id"> apply</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">eq_bigr</span> (<span class="id">F'</span><span class="id"> \o</span><span class="id"> val</span>))<span class="gallina-kwd"> in</span><span class="id"> mUF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_semi_additive_ord_I</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">n</span><span class="id"> :</span><span class="id"> nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> k,</span> (<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> k</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">trivIset</span><span class="id"> `I_n</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> k</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mF</span><span class="id"> tF;</span><span class="id"> apply:</span><span class="id"> measure_semi_additive_ord</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> k;</span><span class="id"> apply:</span><span class="id"> mF</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> trivIset_comp//</span><span class="id"> ?</span>(<span class="id">image_eq</span><span class="id"> [surjfun</span><span class="id"> of</span><span class="id"> val]</span>)<span class="id">//;</span><span class="id"> apply:</span><span class="id"> 'inj_val</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> content_fin_bigcup</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">trivIset</span><span class="id"> D</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> D</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/choicePpointed:</span><span class="id"> I</span><span class="id"> =&gt;</span><span class="id"> I</span><span class="gallina-kwd"> in</span><span class="id"> D</span><span class="id"> F</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !emptyE</span><span class="id"> =&gt;</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> fsbig_set0</span><span class="id"> bigcup0</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> [n</span><span class="id"> /ppcard_eqP[f]]</span><span class="id"> Ftriv</span><span class="id"> Fm</span><span class="id"> UFm</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">image_eq</span><span class="id"> [surjfun</span><span class="id"> of</span><span class="id"> f^-1%FUN]</span>)<span class="id">/=</span><span class="gallina-kwd"> in</span><span class="id"> UFm</span><span class="id"> Ftriv</span><span class="id"> *</span>.<br/>
<span class="id">rewrite</span><span class="id"> bigcup_image</span><span class="id"> fsbig_image//=</span><span class="id"> bigcup_mkord</span><span class="id"> -fsbig_ord/=</span><span class="gallina-kwd"> in</span><span class="id"> UFm</span><span class="id"> *</span>.<br/>
<span class="id">rewrite</span> (<span class="id">@measure_semi_additive_ord_I</span> (<span class="id">F</span><span class="id"> \o</span><span class="id"> f^-1</span>))<span class="id">//=</span><span class="id"> 1?trivIset_comp//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> k</span><span class="id"> kn;</span><span class="id"> apply:</span><span class="id"> Fm;</span><span class="id"> exact:</span><span class="id"> funS</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_semi_additive2</span><span class="id"> :</span><span class="id"> semi_additive2</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/semi_additiveW</span>. Qed.</div></details>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> measure_semi_additive2</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> content_on_semiring_of_sets</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> measure0</span><span class="id"> {d</span><span class="id"> T</span><span class="id"> R}</span><span class="id"> _</span>.<br/>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span><br/>
&nbsp;&nbsp;(<span class="id">is_true</span> (<span class="id">0%R</span><span class="id"> &lt;=</span> (_<span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> _}</span>)<span class="id"> _</span>)<span class="id">%E</span>)<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> measure_ge0]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span><br/>
&nbsp;&nbsp;((_<span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> _}</span>)<span class="id"> set0</span><span class="id"> =</span><span class="id"> 0%R</span>)<span class="id">%E</span><span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> measure0]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="id">#[global]</span><br/>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> measure_semi_additive2</span><span class="id"> measure_semi_additive</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> content_on_ring_of_sets</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)(<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measureU</span><span class="id"> :</span><span class="id"> additive2</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -semi_additive2E</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_bigsetU</span><span class="id"> :</span><span class="id"> additive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -semi_additiveE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_fin_bigcup</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">trivIset</span><span class="id"> D</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> D</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Dfin</span><span class="id"> Ftriv</span><span class="id"> Fm;</span><span class="id"> rewrite</span><span class="id"> content_fin_bigcup//</span>.<br/>
<span class="id">exact:</span><span class="id"> fin_bigcup_measurable</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_bigsetU_ord_cond</span><span class="id"> n</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> 'I_n}</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> 'I_n</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i</span><span class="id"> :</span><span class="id"> 'I_n,</span><span class="id"> P</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> trivIset</span><span class="id"> P</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> =</span> (<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id">%E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mF</span><span class="id"> tF;</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">big_mkcond</span><span class="id"> P</span>)<span class="id">/=</span><span class="id"> measure_semi_additive_ord//</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span> (<span class="id">fun_if</span><span class="id"> mu</span>)<span class="id"> measure0</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> k;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> mF</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -patch_pred</span><span class="id"> trivIset_restr</span><span class="id"> setIT</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable=&gt;</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> mF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_bigsetU_ord</span><span class="id"> n</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> 'I_n}</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> 'I_n</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i</span><span class="id"> :</span><span class="id"> 'I_n,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> trivIset</span><span class="id"> setT</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> =</span> (<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id">%E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> mF</span><span class="id"> tF;</span><span class="id"> rewrite</span><span class="id"> measure_bigsetU_ord_cond//;</span><span class="id"> apply:</span><span class="id"> sub_trivIset</span><span class="id"> tF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_fbigsetU</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> {fset</span><span class="id"> I}</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> trivIset</span><span class="id"> [set`</span><span class="id"> A]</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> A</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> =</span> (<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> A</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id">%E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> mF</span><span class="id"> tF;</span><span class="id"> rewrite</span><span class="id"> -bigcup_fset</span><span class="id"> measure_fin_bigcup//</span><span class="id"> -fsbig_seq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> content_on_ring_of_sets</span>.<br/>
<br/>
<span class="id">#[global]</span><br/>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> measureU</span><span class="id"> measure_bigsetU</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> Content_isMeasure</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> of</span><span class="id"> Content</span><span class="id"> d</span><span class="id"> mu</span><span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">measure_semi_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=measure</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> Measure</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{mu</span><span class="id"> of</span><span class="id"> Content</span><span class="id"> d</span><span class="id"> mu</span><span class="id"> &amp;</span><span class="id"> Content_isMeasure</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'measure' 'set' T '-&gt;' '\bar' R }&quot;</span><span class="id"> :=</span> (<span class="id">measure</span><span class="id"> T%type</span><span class="id"> R</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> T,</span><span class="id"> R</span><span class="gallina-kwd"> at</span><span class="id"> next</span><span class="id"> level,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;{ 'measure'  'set'  T  '-&gt;'  '\bar'  R }&quot;</span>)<span class="id"> :</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_signed</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>).<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_snum_subproof</span><span class="id"> S</span><span class="id"> :</span><span class="id"> Signed</span>.<span class="id">spec</span><span class="id"> 0</span><span class="id"> ?=0</span><span class="id"> &gt;=0</span> (<span class="id">mu</span><span class="id"> S</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> measure_ge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> measure_snum</span><span class="id"> S</span><span class="id"> :=</span><span class="id"> Signed</span>.<span class="id">mk</span> (<span class="id">measure_snum_subproof</span><span class="id"> S</span>).<br/>
<br/>
<span class="vernacular">End</span><span class="id"> measure_signed</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> isMeasure</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">measure0</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measure_ge0</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">measure_semi_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> of</span><span class="id"> isMeasure</span><span class="id"> _</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> semi_additive_mu</span><span class="id"> :</span><span class="id"> semi_additive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> semi_sigma_additive_is_additive</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measure0</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measure_semi_sigma_additive</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isContent</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><br/>
&nbsp;&nbsp;<span class="id">measure_ge0</span><span class="id"> semi_additive_mu</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Content_isMeasure</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><br/>
&nbsp;&nbsp;<span class="id">measure_semi_sigma_additive</span>.<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_measure</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">m1</span><span class="id"> m2</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">m1</span><span class="id"> =</span><span class="id"> m2</span><span class="id"> :&gt;</span> (<span class="id">set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>))<span class="id"> -&gt;</span><span class="id"> m1</span><span class="id"> =</span><span class="id"> m2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move:</span><span class="id"> m1</span><span class="id"> m2</span><span class="id"> =&gt;</span><span class="id"> [m1</span><span class="id"> [[m10</span><span class="id"> m1ge0</span><span class="id"> [m1sa]]]]</span><span class="id"> [m2</span><span class="id"> [[+</span><span class="id"> +</span><span class="id"> [+]]]]</span><span class="id"> /=</span><span class="id"> m1m2</span>.<br/>
<span class="id">rewrite</span><span class="id"> -{}m1m2</span><span class="id"> =&gt;</span><span class="id"> m10'</span><span class="id"> m1ge0'</span><span class="id"> m1sa';</span><span class="id"> f_equal</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (_<span class="id"> :</span><span class="id"> m10'</span><span class="id"> =</span><span class="id"> m10</span>)<span class="id">//</span> (_<span class="id"> :</span><span class="id"> m1ge0'</span><span class="id"> =</span><span class="id"> m1ge0</span>)<span class="id">//</span> (_<span class="id"> :</span><span class="id"> m1sa'</span><span class="id"> =</span><span class="id"> m1sa</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>).<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_semi_bigcup</span><span class="id"> A</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> i</span><span class="id"> :</span><span class="id"> nat,</span><span class="id"> measurable</span> (<span class="id">A</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">trivIset</span><span class="id"> setT</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">\bigcup_n</span><span class="id"> A</span><span class="id"> n</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\bigcup_n</span><span class="id"> A</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">A</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Am</span><span class="id"> Atriv</span><span class="id"> /measure_semi_sigma_additive/cvg_lim&lt;-//</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> measure_lemmas</span>.<br/>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (_<span class="id"> set0</span><span class="id"> =</span><span class="id"> 0%R</span>)<span class="id"> =&gt;</span><span class="id"> solve</span><span class="id"> [apply:</span><span class="id"> measure0]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">is_true</span> (<span class="id">0%:E</span><span class="id"> &lt;=</span><span class="id"> _</span>))<span class="id"> =&gt;</span><span class="id"> solve</span><span class="id"> [apply:</span><span class="id"> measure_ge0]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_sigma_additive</span><span class="id"> :</span><span class="id"> sigma_additive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -semi_sigma_additiveE</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> measure_semi_sigma_additive</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_bigcup</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> nat</span>)<span class="id"> F</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">trivIset</span><span class="id"> D</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> mu</span> (<span class="id">\bigcup_</span>(<span class="id">n</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> F</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span><span class="id"> |</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> D</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mF</span><span class="id"> tF;</span><span class="id"> rewrite</span><span class="id"> bigcup_mkcond</span><span class="id"> measure_semi_bigcup</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> [in</span><span class="id"> RHS]eseries_mkcond;</span><span class="id"> apply:</span><span class="id"> eq_eseriesr</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> ifPn</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> /set_mem;</span><span class="id"> exact:</span><span class="id"> mF</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move/trivIset_mkcond</span><span class="id"> :</span><span class="id"> tF</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -bigcup_mkcond;</span><span class="id"> exact:</span><span class="id"> bigcup_measurable</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> measure_lemmas</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> measure_bigcup</span><span class="id"> {d</span><span class="id"> R</span><span class="id"> T}</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">sigma_additive</span><span class="id"> _</span>)<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> measure_sigma_additive]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> pushforward</span><span class="id"> d1</span><span class="id"> d2</span> (<span class="id">T1</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d1</span>) (<span class="id">T2</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d2</span>)<br/>
&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">m</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>)<br/>
&nbsp;&nbsp;<span class="id">of</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T1]</span><span class="id"> f</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> m</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> A</span>).<br/>
<span class="vernacular">Arguments</span><span class="id"> pushforward</span><span class="id"> {d1</span><span class="id"> d2</span><span class="id"> T1</span><span class="id"> T2</span><span class="id"> R}</span><span class="id"> m</span><span class="id"> {f}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> pushforward_measure</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span><span class="id"> d'</span> (<span class="id">T1</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">T2</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">m</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> mf</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T1]</span><span class="id"> f</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> pushforward0</span><span class="id"> :</span><span class="id"> pushforward</span><span class="id"> m</span><span class="id"> mf</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /pushforward</span><span class="id"> preimage_set0</span><span class="id"> measure0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> pushforward_ge0</span><span class="id"> A</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> pushforward</span><span class="id"> m</span><span class="id"> mf</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measure_ge0;</span><span class="id"> rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> X]setIT;</span><span class="id"> apply:</span><span class="id"> mf</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> pushforward_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span> (<span class="id">pushforward</span><span class="id"> m</span><span class="id"> mf</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> rewrite</span><span class="id"> /pushforward</span><span class="id"> preimage_bigcup</span>.<br/>
<span class="id">apply:</span><span class="id"> measure_semi_sigma_additive</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> X]setTI;</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
<span class="id">-</span><span class="id"> apply/trivIsetP</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _</span><span class="id"> ij;</span><span class="id"> rewrite</span><span class="id"> -preimage_setI</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/trivIsetP</span><span class="id"> :</span><span class="id"> tF</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> ij</span>)<span class="id"> -&gt;//;</span><span class="id"> rewrite</span><span class="id"> preimage_set0</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -preimage_bigcup</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> X]setTI;</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><br/>
&nbsp;&nbsp;(<span class="id">pushforward</span><span class="id"> m</span><span class="id"> mf</span>)<span class="id"> pushforward0</span><span class="id"> pushforward_ge0</span><span class="id"> pushforward_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> pushforward_measure</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> dirac_measure</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">a</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> dirac</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span> (<span class="id">\1_A</span><span class="id"> a</span>)<span class="id">%:E</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> dirac0</span><span class="id"> :</span><span class="id"> dirac</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /dirac</span><span class="id"> indic0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> dirac_ge0</span><span class="id"> B</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> dirac</span><span class="id"> B</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /dirac</span><span class="id"> indicE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> dirac_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> dirac</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> rewrite</span><span class="id"> /dirac</span><span class="id"> indicE;</span><span class="id"> have</span><span class="id"> [|aFn]</span><span class="id"> /=</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">a</span><span class="id"> \in</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> -[n</span><span class="id"> _</span><span class="id"> Fna]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> naF</span><span class="id"> m</span><span class="id"> :</span><span class="id"> m</span><span class="id"> !=</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> a</span><span class="id"> \notin</span><span class="id"> F</span><span class="id"> m</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> mn;</span><span class="id"> rewrite</span><span class="id"> notin_setE</span><span class="id"> =&gt;</span><span class="id"> Fma</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move/trivIsetP</span><span class="id"> :</span><span class="id"> tF</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> _</span><span class="id"> Logic</span>.<span class="id">I</span><span class="id"> Logic</span>.<span class="id">I</span><span class="id"> mn</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> a</span>)<span class="id">[+</span><span class="id"> _];</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/cvg_ballP</span><span class="id"> =&gt;</span><span class="id"> _/posnumP[e];</span><span class="id"> near=&gt;</span><span class="id"> m</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> mn</span><span class="id"> :</span> (<span class="id">n</span><span class="id"> &lt;</span><span class="id"> m</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> near:</span><span class="id"> m;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<span class="id">+1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> big_mkord</span> (<span class="id">bigID</span> (<span class="id">xpred1</span> (<span class="id">Ordinal</span><span class="id"> mn</span>)))<span class="id">//=</span><span class="id"> big_pred1_eq/=</span><span class="id"> big1/=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> adde0</span><span class="id"> indicE</span><span class="id"> mem_set//;</span><span class="id"> exact:</span><span class="id"> ballxx</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> j</span><span class="id"> ij;</span><span class="id"> rewrite</span><span class="id"> indicE</span> (<span class="id">negbTE</span> (<span class="id">naF</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> @</span><span class="id"> \oo</span><span class="id"> --&gt;</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> cst</span><span class="id"> 0</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> cvg_cst</span>.<br/>
<span class="id">apply/funext</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> big1//</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> indicE;</span><span class="id"> apply/eqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqe</span><span class="id"> pnatr_eq0</span><span class="id"> eqb0;</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> aFn</span><span class="id"> =&gt;</span><span class="id"> /[!inE]</span><span class="id"> aFn;</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><br/>
&nbsp;&nbsp;<span class="id">dirac</span><span class="id"> dirac0</span><span class="id"> dirac_ge0</span><span class="id"> dirac_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> dirac_measure</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> dirac</span><span class="id"> {d</span><span class="id"> T}</span><span class="id"> _</span><span class="id"> {R}</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;\d_ a&quot;</span><span class="id"> :=</span> (<span class="id">dirac</span><span class="id"> a</span>)<span class="id"> :</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> dirac_lemmas_realFieldType</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> diracE</span><span class="id"> a</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> \d_a</span><span class="id"> A</span><span class="id"> =</span> (<span class="id">a</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id">%:R%:E</span><span class="id"> :&gt;</span><span class="id"> \bar</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /dirac</span><span class="id"> indicE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dirac0</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> \d_a</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> :&gt;</span><span class="id"> \bar</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> diracE</span><span class="id"> in_set0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> diracT</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> \d_a</span><span class="id"> setT</span><span class="id"> =</span><span class="id"> 1</span><span class="id"> :&gt;</span><span class="id"> \bar</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> diracE</span><span class="id"> in_setT</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> dirac_lemmas_realFieldType</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> dirac_lemmas</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_card_sum</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\esum_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> 1</span><span class="id"> =</span> (<span class="id">#|`</span><span class="id"> fset_set</span><span class="id"> A|%:R</span>)<span class="id">%:E</span><span class="id"> :&gt;</span><span class="id"> \bar</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> finA;</span><span class="id"> rewrite</span><span class="id"> esum_fset//</span> (<span class="id">eq_fsbigr</span> (<span class="id">cst</span><span class="id"> 1</span>))<span class="id">//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> card_fset_sum1//</span><span class="id"> natr_sum</span><span class="id"> -sumEFin</span><span class="id"> fsbig_finite</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> finite_card_dirac</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\esum_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> \d_</span><span class="id"> i</span><span class="id"> A</span><span class="id"> =</span> (<span class="id">#|`</span><span class="id"> fset_set</span><span class="id"> A|%:R</span>)<span class="id">%:E</span><span class="id"> :&gt;</span><span class="id"> \bar</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> finA;</span><span class="id"> rewrite</span><span class="id"> esum_fset//</span> (<span class="id">eq_fsbigr</span> (<span class="id">cst</span><span class="id"> 1</span>))<span class="id">//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> card_fset_sum1//</span><span class="id"> natr_sum</span><span class="id"> -sumEFin</span><span class="id"> fsbig_finite</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> iA;</span><span class="id"> rewrite</span><span class="id"> diracE</span><span class="id"> iA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infinite_card_dirac</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> infinite_set</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\esum_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> A</span>)<span class="id"> \d_</span><span class="id"> i</span><span class="id"> A</span><span class="id"> =</span><span class="id"> +oo</span><span class="id"> :&gt;</span><span class="id"> \bar</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> infA;</span><span class="id"> apply/eqyP</span><span class="id"> =&gt;</span><span class="id"> r</span><span class="id"> r0</span>.<br/>
<span class="id">have</span><span class="id"> [B</span><span class="id"> BA</span><span class="id"> Br]</span><span class="id"> :=</span><span class="id"> infinite_set_fset</span><span class="id"> `|ceil</span><span class="id"> r|</span><span class="id"> infA</span>.<br/>
<span class="id">apply:</span><span class="id"> esum_ge;</span><span class="gallina-kwd"> exists</span><span class="id"> [set`</span><span class="id"> B]</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span> (<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span><span class="id"> `|ceil</span><span class="id"> r|%:R%:E</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> lee_fin</span><span class="id"> natr_absz</span><span class="id"> gtr0_norm</span><span class="id"> -?ceil_gt0//</span><span class="id"> ceil_ge</span>.<br/>
<span class="id">move:</span><span class="id"> Br;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">@ler_nat</span><span class="id"> R</span>)<span class="id"> -lee_fin</span><span class="id"> =&gt;</span><span class="id"> /le_trans;</span><span class="id"> apply</span>.<br/>
<span class="id">rewrite</span> (<span class="id">eq_fsbigr</span> (<span class="id">cst</span><span class="id"> 1</span>))<span class="id">/=;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> /[!inE]</span><span class="id"> /BA</span><span class="id"> /mem_set</span><span class="id"> iA;</span><span class="id"> rewrite</span><span class="id"> diracE</span><span class="id"> iA</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> fsbig_finite//=</span><span class="id"> card_fset_sum1</span><span class="id"> sumEFin</span><span class="id"> natr_sum//</span><span class="id"> set_fsetK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> dirac_lemmas</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_sum</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">m</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}^nat</span>) (<span class="id">n</span><span class="id"> :</span><span class="id"> nat</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> msum</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> \sum_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> m</span><span class="id"> k</span><span class="id"> A</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> msum0</span><span class="id"> :</span><span class="id"> msum</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /msum</span><span class="id"> big1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> msum_ge0</span><span class="id"> B</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> msum</span><span class="id"> B</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /msum;</span><span class="id"> apply:</span><span class="id"> sume_ge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> msum_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> msum</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> X]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lim</span> ((<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> msum</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> @</span><span class="id"> \oo</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> is_cvg_ereal_nneg_natsum</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> sume_ge0</span>.<br/>
<span class="id">rewrite</span><span class="id"> nneseries_sum//;</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> i</span><span class="id"> _</span>.<br/>
<span class="id">exact:</span><span class="id"> measure_semi_bigcup</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> msum</span><br/>
&nbsp;&nbsp;<span class="id">msum0</span><span class="id"> msum_ge0</span><span class="id"> msum_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> measure_sum</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> msum</span><span class="id"> {d</span><span class="id"> T</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_zero</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mzero</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> mzero0</span><span class="id"> :</span><span class="id"> mzero</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mzero_ge0</span><span class="id"> B</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mzero</span><span class="id"> B</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mzero_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> mzero</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> @</span><span class="id"> \oo--&gt;</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> cst</span><span class="id"> 0</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> cvg_cst</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/funext</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> big1</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mzero</span><br/>
&nbsp;&nbsp;<span class="id">mzero0</span><span class="id"> mzero_ge0</span><span class="id"> mzero_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> measure_zero</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> mzero</span><span class="id"> {d</span><span class="id"> T</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> msum_mzero</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">m_</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}^nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">msum</span><span class="id"> m_</span><span class="id"> 0</span><span class="id"> =</span><span class="id"> mzero</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/funext</span><span class="id"> =&gt;</span><span class="id"> A/=;</span><span class="id"> rewrite</span><span class="id"> /msum</span><span class="id"> big_ord0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_add</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">m1</span><span class="id"> m2</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> measure_add</span><span class="id"> :=</span><span class="id"> msum</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> is</span><span class="id"> 0%N</span><span class="gallina-kwd"> then</span><span class="id"> m1</span><span class="gallina-kwd"> else</span><span class="id"> m2</span>)<span class="id"> 2</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_addE</span><span class="id"> A</span><span class="id"> :</span><span class="id"> measure_add</span><span class="id"> A</span><span class="id"> =</span><span class="id"> m1</span><span class="id"> A</span><span class="id"> +</span><span class="id"> m2</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /measure_add/=</span><span class="id"> /msum</span><span class="id"> 2!big_ord_recl/=</span><span class="id"> big_ord0</span><span class="id"> adde0</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> measure_add</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_scale</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> {nonneg</span><span class="id"> R}</span>) (<span class="id">m</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mscale</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> r%:num%:E</span><span class="id"> *</span><span class="id"> m</span><span class="id"> A</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> mscale0</span><span class="id"> :</span><span class="id"> mscale</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /mscale</span><span class="id"> measure0</span><span class="id"> mule0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mscale_ge0</span><span class="id"> B</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mscale</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /mscale</span><span class="id"> mule_ge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mscale_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> mscale</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> @</span><span class="id"> \oo</span><span class="id"> --&gt;</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span> (<span class="id">r%:num</span>)<span class="id">%:E</span><span class="id"> *</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> m</span> (<span class="id">F</span><span class="id"> i</span>)))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/funext</span><span class="id"> =&gt;</span><span class="id"> k;</span><span class="id"> rewrite</span><span class="id"> ge0_sume_distrr</span>.<br/>
<span class="id">rewrite</span><span class="id"> /mscale;</span><span class="id"> have</span><span class="id"> [-&gt;|r0]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> r%:num</span><span class="id"> 0%R</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mul0e</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> @</span><span class="id"> \oo</span><span class="id"> --&gt;</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> cst</span><span class="id"> 0</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> cvg_cst</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> mul0e</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> cvgeMl</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measure_semi_sigma_additive</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mscale</span><br/>
&nbsp;&nbsp;<span class="id">mscale0</span><span class="id"> mscale_ge0</span><span class="id"> mscale_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> measure_scale</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> mscale</span><span class="id"> {d</span><span class="id"> T</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_series</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">m</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}^nat</span>) (<span class="id">n</span><span class="id"> :</span><span class="id"> nat</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mseries</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> \sum_</span>(<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> k</span><span class="id"> &lt;oo</span>)<span class="id"> m</span><span class="id"> k</span><span class="id"> A</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> mseries0</span><span class="id"> :</span><span class="id"> mseries</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /mseries</span><span class="id"> ereal_series</span><span class="id"> eseries0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mseries_ge0</span><span class="id"> B</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mseries</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /mseries</span><span class="id"> ereal_series</span><span class="id"> nneseries_esum//;</span><span class="id"> exact:</span><span class="id"> esum_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mseries_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> mseries</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> X]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">lim</span> ((<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mseries</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> @</span><span class="id"> \oo</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [in</span><span class="id"> LHS]/mseries</span>.<br/>
&nbsp;&nbsp;<span class="id">transitivity</span> (<span class="id">\sum_</span>(<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> k</span><span class="id"> &lt;oo</span>)<span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span>)<span class="id"> m</span><span class="id"> k</span> (<span class="id">F</span><span class="id"> i</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> 2!ereal_series</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">@eq_eseriesr</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> m</span><span class="id"> k</span> (<span class="id">\bigcup_n0</span><span class="id"> F</span><span class="id"> n0</span>)))<span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> ni</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> measure_semi_bigcup</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ereal_series</span><span class="id"> nneseries_interchange//</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">@eq_eseriesr</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span><span class="id"> |</span> (<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> i</span>)<span class="id">%N</span>)<span class="id"> m</span><span class="id"> i</span> (<span class="id">F</span><span class="id"> j</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> k</span><span class="id"> &lt;oo</span>)<span class="id"> m</span><span class="id"> k</span> (<span class="id">F</span><span class="id"> i</span>))).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> ereal_series</span>.<br/>
<span class="id">apply:</span><span class="id"> is_cvg_ereal_nneg_natsum</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> _</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /mseries</span><span class="id"> ereal_series;</span><span class="id"> exact:</span><span class="id"> nneseries_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mseries</span><br/>
&nbsp;&nbsp;<span class="id">mseries0</span><span class="id"> mseries_ge0</span><span class="id"> mseries_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> measure_series</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> mseries</span><span class="id"> {d</span><span class="id"> T</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mrestr</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>) (<span class="id">mD</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span>)<span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> X</span><span class="id"> =&gt;</span><span class="id"> f</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> D</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_restr</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">mD</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> restr</span><span class="id"> :=</span> (<span class="id">mrestr</span><span class="id"> mu</span><span class="id"> mD</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> restr0</span><span class="id"> :</span><span class="id"> restr</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0%E</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /mrestr</span><span class="id"> set0I</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> restr_ge0</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> _</span>)<span class="id"> :</span> (<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> restr</span><span class="id"> A</span>)<span class="id">%E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /restr;</span><span class="id"> apply:</span><span class="id"> measure_ge0;</span><span class="id"> exact:</span><span class="id"> measurableI</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> restr_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> restr</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mU;</span><span class="id"> pose</span><span class="id"> FD</span><span class="id"> i</span><span class="id"> :=</span><span class="id"> F</span><span class="id"> i</span><span class="id"> `&amp;`</span><span class="id"> D</span>.<br/>
<span class="id">have</span><span class="id"> mFD</span><span class="id"> i</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">FD</span><span class="id"> i</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">have</span><span class="id"> tFD</span><span class="id"> :</span><span class="id"> trivIset</span><span class="id"> setT</span><span class="id"> FD</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/trivIsetP</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _</span><span class="id"> ij</span>.<br/>
&nbsp;&nbsp;<span class="id">move/trivIsetP</span><span class="id"> :</span><span class="id"> tF</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> i</span><span class="id"> j</span><span class="id"> Logic</span>.<span class="id">I</span><span class="id"> Logic</span>.<span class="id">I</span><span class="id"> ij</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /FD</span><span class="id"> setIACA</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> set0I</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /restr</span><span class="id"> setI_bigcupl;</span><span class="id"> exact:</span><span class="id"> measure_sigma_additive</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> restr</span><br/>
&nbsp;&nbsp;<span class="id">restr0</span><span class="id"> restr_ge0</span><span class="id"> restr_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> measure_restr</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> counting</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> `[&lt;</span><span class="id"> finite_set</span><span class="id"> X</span><span class="id"> &gt;]</span><span class="gallina-kwd"> then</span> (<span class="id">#|`</span><span class="id"> fset_set</span><span class="id"> X</span><span class="id"> |</span>)<span class="id">%:R%:E</span><span class="gallina-kwd"> else</span><span class="id"> +oo</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> counting</span><span class="id"> {T</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_count</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">mD</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> counting</span><span class="id"> :=</span> (<span class="id">@counting</span><span class="id"> T</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> counting0</span><span class="id"> :</span><span class="id"> counting</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /counting</span><span class="id"> asboolT//</span><span class="id"> fset_set0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> counting_ge0</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> counting</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /counting;</span><span class="id"> case:</span><span class="id"> ifPn;</span><span class="id"> rewrite</span><span class="id"> ?lee_fin//</span><span class="id"> lee_pinfty</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> counting_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> counting</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mU</span>.<br/>
<span class="id">have</span><span class="id"> [[i</span><span class="id"> Fi]|infinF]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="gallina-kwd">exists</span><span class="id"> k,</span><span class="id"> infinite_set</span> (<span class="id">F</span><span class="id"> k</span>)).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> counting</span> (<span class="id">\bigcup_n</span><span class="id"> F</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> +oo</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /counting</span><span class="id"> asboolF//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra_not</span><span class="id"> Fi;</span><span class="id"> exact/sub_finite_set/bigcup_sup</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/cvgeyPge</span><span class="id"> =&gt;</span><span class="id"> M;</span><span class="id"> near=&gt;</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> ni</span><span class="id"> :</span> (<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> near:</span><span class="id"> n;</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<span class="id">+1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">bigID</span> (<span class="id">xpred1</span><span class="id"> i</span>))<span class="id">/=</span><span class="id"> big_mkord</span> (<span class="id">big_pred1</span> (<span class="id">Ordinal</span><span class="id"> ni</span>))<span class="id">//=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> +</span><span class="id"> _]/</span>(<span class="id">counting</span><span class="id"> _</span>)<span class="id"> asboolF//</span><span class="id"> addye</span><span class="id"> ?leey//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> gt_eqF//</span> (<span class="id">@lt_le_trans</span><span class="id"> _</span><span class="id"> _</span><span class="id"> 0</span>)<span class="id">//;</span><span class="id"> exact:</span><span class="id"> sume_ge0</span>.<br/>
<span class="id">have</span><span class="id"> {infinF}finF</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> finite_set</span> (<span class="id">F</span><span class="id"> i</span>)<span class="gallina-kwd"> by</span><span class="id"> exact/not_forallP</span>.<br/>
<span class="id">pose</span><span class="id"> u</span><span class="id"> :</span><span class="id"> nat^nat</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> #|`</span><span class="id"> fset_set</span> (<span class="id">F</span><span class="id"> n</span>)<span class="id"> |</span>.<br/>
<span class="id">have</span><span class="id"> sumFE</span><span class="id"> n</span><span class="id"> :</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> counting</span> (<span class="id">F</span><span class="id"> i</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">#|`</span><span class="id"> fset_set</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> k</span>)<span class="id"> |%:R%:E</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -trivIset_sum_card//</span><span class="id"> natr_sum</span><span class="id"> -sumEFin</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /counting</span><span class="id"> asboolT</span>.<br/>
<span class="id">have</span><span class="id"> [cvg_u|dvg_u]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">cvg</span> (<span class="id">nseries</span><span class="id"> u</span><span class="id"> @</span><span class="id"> \oo</span>)).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [N</span><span class="id"> _</span><span class="id"> Nu]</span><span class="id"> :</span><span class="id"> \forall</span><span class="id"> n</span><span class="id"> \near</span><span class="id"> \oo,</span><span class="id"> u</span><span class="id"> n</span><span class="id"> =</span><span class="id"> 0%N</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> cvg_nseries_near</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> X]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> N</span>)<span class="id"> counting</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> \bigcup_i</span> (<span class="id">F</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> \big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> N</span>)<span class="id"> F</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">bigcupID</span> (<span class="id">`I_N</span>))<span class="id"> setTI</span><span class="id"> bigcup_mkord</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> `|`</span><span class="id"> X]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> set0</span>)<span class="id"> ?setU0//</span><span class="id"> bigcup0//</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> [_</span><span class="id"> /negP]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -leqNgt</span><span class="id"> =&gt;</span><span class="id"> /Nu/eqP/[!cardfs_eq0]/eqP/fset_set_set0</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /counting</span><span class="id"> /=</span><span class="id"> asboolT</span><span class="id"> ?sumFE//</span><span class="id"> -bigcup_mkord;</span><span class="id"> exact:</span><span class="id"> bigcup_finite</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">cvg_shiftn</span><span class="id"> N</span>)<span class="id">/=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (_<span class="id"> :</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> _</span>)<span class="id"> =</span> (<span class="id">fun=&gt;</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> N</span>)<span class="id"> counting</span> (<span class="id">F</span><span class="id"> i</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> cvg_cst</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/funext</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> /index_iota</span><span class="id"> subn0</span> (<span class="id">addnC</span><span class="id"> n</span>)<span class="id"> iotaD</span><span class="id"> big_cat/=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> +</span><span class="id"> X]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> 0</span>)<span class="id"> ?adde0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{1}</span>(<span class="id">subn0</span><span class="id"> N</span>)<span class="id"> big_mkord</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> add0n</span><span class="id"> big_seq</span><span class="id"> big1//</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> /[!mem_iota]</span><span class="id"> =&gt;</span><span class="id"> /andP[NI</span><span class="id"> iNn]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /counting</span><span class="id"> asboolT//=</span><span class="id"> -/</span>(<span class="id">u</span><span class="id"> _</span>)<span class="id"> Nu</span>.<br/>
<span class="id">have</span><span class="id"> {dvg_u}cvg_F</span><span class="id"> :</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> counting</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> @</span><span class="id"> \oo</span><span class="id"> --&gt;</span><span class="id"> +oo</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (_<span class="id"> :</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> _</span>)<span class="id"> =</span><span class="id"> [sequence</span> (<span class="id">\sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>) (<span class="id">u</span><span class="id"> i</span>))<span class="id">%:R%:E]_n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact/cvgenyP/dvg_nseries</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/funext</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> /=;</span><span class="id"> under</span><span class="id"> eq_bigr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /counting</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> asboolT//;</span><span class="id"> over</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> sumEFin</span><span class="id"> natr_sum</span><span class="id"> big_mkord</span>.<br/>
<span class="id">have</span><span class="id"> [UFoo|/contrapT[k</span><span class="id"> UFk]]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="id">infinite_set</span> (<span class="id">\bigcup_n</span><span class="id"> F</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /counting</span><span class="id"> asboolF//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> big_mkord</span>.<br/>
<span class="id">suff:</span><span class="id"> false</span><span class="gallina-kwd"> by</span><span class="id"> []</span>.<br/>
<span class="id">move:</span><span class="id"> cvg_F</span><span class="id"> =&gt;/cvgeyPge/</span>(_<span class="id"> k</span>.<span class="id">+1%:R</span>)<span class="id"> [K</span><span class="id"> _]</span><span class="id"> /</span>(_<span class="id"> K</span> (<span class="id">leqnn</span><span class="id"> _</span>))<span class="id"> /=;</span><span class="id"> apply:</span><span class="id"> contra_leT</span><span class="id"> =&gt;</span><span class="id"> _</span>.<br/>
<span class="id">rewrite</span><span class="id"> sumFE</span><span class="id"> lte_fin</span><span class="id"> ltr_nat</span><span class="id"> ltnS</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> k</span><span class="id"> =</span><span class="id"> #|`</span><span class="id"> fset_set</span> (<span class="id">\bigcup_n</span><span class="id"> F</span><span class="id"> n</span>)<span class="id"> |</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/esym/card_eq_fsetP;</span><span class="id"> rewrite</span><span class="id"> fset_setK//;</span><span class="gallina-kwd"> exists</span><span class="id"> k</span>.<br/>
<span class="id">apply/fsubset_leq_card;</span><span class="id"> rewrite</span><span class="id"> -fset_set_sub</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /=</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> -bigcup_mkord</span><span class="id"> =&gt;</span><span class="id"> -[m</span><span class="id"> _</span><span class="id"> Fmt];</span><span class="gallina-kwd"> exists</span><span class="id"> m</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -bigcup_mkord;</span><span class="id"> exact:</span><span class="id"> bigcup_finite</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> k</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> counting</span><br/>
&nbsp;&nbsp;<span class="id">counting0</span><span class="id"> counting_ge0</span><span class="id"> counting_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> measure_count</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> big_trivIset</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> D</span><span class="id"> T</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> R</span>)<br/>
&nbsp;&nbsp;&nbsp;(<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> trivIset</span><span class="id"> D</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> idx</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> fset_set</span><span class="id"> D</span>)<span class="id"> F</span> (<span class="id">A</span><span class="id"> i</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">X</span><span class="id"> &lt;-</span> (<span class="id">A</span><span class="id"> @`</span><span class="id"> fset_set</span><span class="id"> D</span>)<span class="id">%fset</span>)<span class="id"> F</span><span class="id"> X</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/Pchoice:</span><span class="id"> R</span><span class="id"> =&gt;</span><span class="id"> R</span><span class="gallina-kwd"> in</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> F</span><span class="id"> *</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> Dfin</span><span class="id"> Atriv</span><span class="id"> F0;</span><span class="id"> symmetry</span>.<br/>
<span class="id">pose</span><span class="id"> D'</span><span class="id"> :=</span><span class="id"> [fset</span><span class="id"> i</span><span class="gallina-kwd"> in</span><span class="id"> fset_set</span><span class="id"> D</span><span class="id"> |</span><span class="id"> A</span><span class="id"> i</span><span class="id"> !=</span><span class="id"> set0]%fset</span>.<br/>
<span class="id">transitivity</span> (<span class="id">\big[op/idx]_</span>(<span class="id">X</span><span class="id"> &lt;-</span> (<span class="id">A</span><span class="id"> @`</span><span class="id"> D'</span>)<span class="id">%fset</span>)<span class="id"> F</span><span class="id"> X</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> perm_big_supp;</span><span class="id"> rewrite</span><span class="id"> uniq_perm</span><span class="id"> ?filter_uniq//=</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> X;</span><span class="id"> rewrite</span><span class="id"> !mem_filter;</span><span class="id"> case:</span> (<span class="id">eqVneq</span> (<span class="id">F</span><span class="id"> X</span>)<span class="id"> idx</span>)<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> FXNidx</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/imfsetP/imfsetP=&gt;</span><span class="id"> -[i/=];</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">inE,</span><span class="id"> in_fset_set</span>)<span class="id">//=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> Di</span><span class="id"> XAi;</span><span class="gallina-kwd"> exists</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> !</span>(<span class="id">inE,</span><span class="id"> in_fset_set</span>)<span class="id">//=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">mem_set</span><span class="id"> Di</span>)<span class="id">/=</span><span class="id"> -XAi;</span><span class="id"> apply:</span><span class="id"> contra_neq</span><span class="id"> FXNidx</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /andP[Di</span><span class="id"> AiN0]</span><span class="id"> XAi;</span><span class="gallina-kwd"> exists</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> ?in_fset_set</span>.<br/>
<span class="id">rewrite</span><span class="id"> big_imfset//=;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> i</span><span class="id"> j;</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">inE,</span><span class="id"> in_fset_set</span>)<span class="id">//=</span><span class="id"> =&gt;</span><span class="id"> /andP[+</span><span class="id"> +]</span><span class="id"> /andP[+</span><span class="id"> +]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !inE</span><span class="id"> =&gt;</span><span class="id"> Di</span><span class="id"> /set0P[x</span><span class="id"> Aix]</span><span class="id"> Dj</span><span class="id"> _</span><span class="id"> Aij</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">Atriv</span><span class="id"> _</span><span class="id"> _</span><span class="id"> Di</span><span class="id"> Dj</span>)<span class="id">;</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> -Aij</span>.<br/>
<span class="id">apply:</span><span class="id"> perm_big_supp;</span><span class="id"> rewrite</span><span class="id"> uniq_perm</span><span class="id"> ?filter_uniq//=</span><span class="id"> =&gt;</span><span class="id"> i</span>.<br/>
<span class="id">rewrite</span><span class="id"> !mem_filter;</span><span class="id"> case:</span> (<span class="id">eqVneq</span> (<span class="id">F</span> (<span class="id">A</span><span class="id"> i</span>))<span class="id"> idx</span>)<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> FAiidx</span>.<br/>
<span class="id">rewrite</span><span class="id"> !</span>(<span class="id">in_fset_set,</span><span class="id"> inE</span>)<span class="id">//=;</span><span class="id"> case:</span> (<span class="id">boolP</span> (<span class="id">i</span><span class="id"> \in</span><span class="id"> D</span>))<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> Di</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra_neq</span><span class="id"> FAiidx</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> covering</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span> (<span class="id">C</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> I,</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> I</span>)).<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span> (<span class="id">P</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> I,</span><span class="id"> set</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span> (<span class="id">I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> covered_by</span><span class="id"> C</span><span class="id"> P</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> I</span><span class="id"> D</span><span class="id"> A,</span><span class="id"> [/\</span><span class="id"> C</span><span class="id"> I</span><span class="id"> D,</span><span class="id"> P</span><span class="id"> I</span><span class="id"> D</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> X</span><span class="id"> =</span><span class="id"> \bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> A</span><span class="id"> i]]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> covered_bySr</span><span class="id"> C</span><span class="id"> P</span><span class="id"> P'</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> I</span><span class="id"> D</span><span class="id"> A,</span><span class="id"> P</span><span class="id"> I</span><span class="id"> D</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> P'</span><span class="id"> I</span><span class="id"> D</span><span class="id"> A</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">covered_by</span><span class="id"> C</span><span class="id"> P</span><span class="id"> `&lt;=`</span><span class="id"> covered_by</span><span class="id"> C</span><span class="id"> P'</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> PP'</span><span class="id"> X</span><span class="id"> [I</span><span class="id"> [D</span><span class="id"> [A</span><span class="id"> [CX</span><span class="id"> PX</span><span class="id"> -&gt;]]]];</span><span class="gallina-kwd"> exists</span><span class="id"> I,</span><span class="id"> D,</span><span class="id"> A;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> PP'</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> covered_byP</span><span class="id"> C</span><span class="id"> P</span><span class="id"> I</span><span class="id"> D</span><span class="id"> A</span><span class="id"> :</span><span class="id"> C</span><span class="id"> I</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> I</span><span class="id"> D</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">covered_by</span><span class="id"> C</span><span class="id"> P</span> (<span class="id">\bigcup_</span>(<span class="id">i</span> <span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> A</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> CID</span><span class="id"> PIDA;</span><span class="gallina-kwd"> exists</span><span class="id"> I,</span><span class="id"> D,</span><span class="id"> A</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> covered_by_finite</span><span class="id"> P</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> I</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<span class="id"> A,</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> i</span><span class="id"> =</span><span class="id"> set0</span>)<span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> I</span><span class="id"> D</span><span class="id"> A</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> pointedType</span>)<span class="id"> D</span><span class="id"> A,</span><span class="id"> finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> I</span><span class="id"> D</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P</span><span class="id"> nat</span><span class="id"> `I_#|`</span><span class="id"> fset_set</span><span class="id"> D|</span> (<span class="id">A</span><span class="id"> \o</span><span class="id"> nth</span><span class="id"> point</span> (<span class="id">fset_set</span><span class="id"> D</span>)))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">covered_by</span> (<span class="id">@finite_set</span>)<span class="id"> P</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set</span><span class="id"> X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> n</span><span class="id"> A,</span><span class="id"> [/\</span><span class="id"> P</span><span class="id"> nat</span><span class="id"> `I_n</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> X</span><span class="id"> =</span><span class="id"> \bigcup_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> A</span><span class="id"> i]]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> P0</span><span class="id"> Pc;</span><span class="id"> apply/predeqP=&gt;</span><span class="id"> X;</span><span class="id"> rewrite</span><span class="id"> /covered_by</span><span class="id"> /cover/=;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [n</span><span class="id"> [A</span><span class="id"> [Am</span><span class="id"> -&gt;]]];</span><span class="gallina-kwd"> exists</span><span class="id"> nat,</span><span class="id"> `I_n,</span><span class="id"> A;</span><span class="id"> split</span>.<br/>
<span class="id">case;</span><span class="id"> elim/Ppointed=&gt;</span><span class="id"> I</span><span class="id"> [D</span><span class="id"> [A</span><span class="id"> [Dfin</span><span class="id"> Am</span><span class="id"> -&gt;]]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> 0%N,</span> (<span class="id">fun=&gt;</span><span class="id"> set0</span>)<span class="id">;</span><span class="id"> split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> II0;</span><span class="id"> apply:</span><span class="id"> P0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> //=</span><span class="id"> emptyE</span><span class="id"> II0</span><span class="id"> !bigcup0</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> #|`fset_set</span><span class="id"> D|,</span> (<span class="id">A</span><span class="id"> \o</span><span class="id"> nth</span><span class="id"> point</span> (<span class="id">fset_set</span><span class="id"> D</span>)).<br/>
<span class="id">split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> Pc</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -bigsetU_fset_set//</span> (<span class="id">big_nth</span><span class="id"> point</span>)<span class="id"> big_mkord</span><span class="id"> bigcup_mkord</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> covered_by_countable</span><span class="id"> P</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> I</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<span class="id"> A,</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> i</span><span class="id"> =</span><span class="id"> set0</span>)<span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> I</span><span class="id"> D</span><span class="id"> A</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> I</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_surj</span><span class="id"> [set:</span><span class="id"> nat]</span><span class="id"> D</span><span class="id"> f</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P</span><span class="id"> I</span><span class="id"> D</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> nat</span><span class="id"> [set:</span><span class="id"> nat]</span> (<span class="id">A</span><span class="id"> \o</span><span class="id"> f</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">covered_by</span> (<span class="id">@countable</span>)<span class="id"> P</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set</span><span class="id"> X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> A,</span><span class="id"> [/\</span><span class="id"> P</span><span class="id"> nat</span><span class="id"> [set:</span><span class="id"> nat]</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> X</span><span class="id"> =</span><span class="id"> \bigcup_i</span><span class="id"> A</span><span class="id"> i]]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> P0</span><span class="id"> Pc;</span><span class="id"> apply/predeqP=&gt;</span><span class="id"> X;</span><span class="id"> rewrite</span><span class="id"> /covered_by</span><span class="id"> /cover/=;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [A</span><span class="id"> [Am</span><span class="id"> -&gt;]];</span><span class="gallina-kwd"> exists</span><span class="id"> nat,</span><span class="id"> [set:</span><span class="id"> nat],</span><span class="id"> A;</span><span class="id"> split</span>.<br/>
<span class="id">case;</span><span class="id"> elim/Ppointed=&gt;</span><span class="id"> I</span><span class="id"> [D</span><span class="id"> [A</span><span class="id"> [Dcnt</span><span class="id"> Am</span><span class="id"> -&gt;]]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">fun=&gt;</span><span class="id"> set0</span>)<span class="id">;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> P0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> emptyE</span><span class="id"> bigcup_set0</span><span class="id"> bigcup0</span>.<br/>
<span class="id">have</span><span class="id"> /pfcard_geP[-&gt;|[f]]</span><span class="id"> :=</span><span class="id"> Dcnt</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">fun=&gt;</span><span class="id"> set0</span>)<span class="id">;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> P0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !bigcup_set0</span><span class="id"> bigcup0</span>.<br/>
<span class="id">pose</span><span class="id"> g</span><span class="id"> :=</span><span class="id"> [splitsurjfun</span><span class="id"> of</span><span class="id"> split</span><span class="id"> f]</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">A</span><span class="id"> \o</span><span class="id"> g</span>)<span class="id">;</span><span class="id"> split=&gt;</span><span class="id"> /=;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> Pc</span><span class="id"> Am</span>.<br/>
<span class="id">apply/predeqP=&gt;</span><span class="id"> x;</span><span class="id"> split=&gt;</span><span class="id"> [[i</span><span class="id"> Di</span><span class="id"> Aix]|[n</span><span class="id"> _</span><span class="id"> Afnx]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">g^-1%FUN</span><span class="id"> i</span>)<span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> invK//</span><span class="id"> inE</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">g</span><span class="id"> n</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> funS</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> covering</span>.<br/>
<br/>
<span class="vernacular">Module</span><span class="id"> SetRing</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> type</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<span class="id"> :=</span><span class="id"> T</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> display</span><span class="id"> :</span><span class="id"> measure_display</span><span class="id"> -&gt;</span><span class="id"> measure_display</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> SetRing</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d}</span>.<br/>
<br/>
<span class="vernacular">Notation</span><span class="id"> rT</span><span class="id"> :=</span> (<span class="id">type</span><span class="id"> T</span>).<br/>
<span class="id">#[export]</span><br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Pointed</span>.<span class="id">on</span><span class="id"> rT</span>.<br/>
<span class="id">#[export]</span><br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isRingOfSets</span>.<span class="id">Build</span> (<span class="id">display</span><span class="id"> d</span>)<span class="id"> rT</span><br/>
&nbsp;&nbsp;(<span class="id">@setring0</span><span class="id"> T</span><span class="id"> measurable</span>) (<span class="id">@setringU</span><span class="id"> T</span><span class="id"> measurable</span>) (<span class="id">@setringDI</span><span class="id"> T</span><span class="id"> measurable</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;d .-ring&quot;</span><span class="id"> :=</span> (<span class="id">display</span><span class="id"> d</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 1,</span><span class="id"> format</span> <span class="id">&quot;d .-ring&quot;</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;d .-ring.-measurable&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;((<span class="id">d%mdisp</span>.<span class="id">-ring</span>).<span class="id">-measurable</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span> (<span class="id">type</span><span class="id"> _</span>))).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Definition</span><span class="id"> measurable_fin_trivIset</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> A</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> A</span><span class="id"> =</span><span class="id"> \bigcup_</span>(<span class="id">X</span><span class="gallina-kwd"> in</span><span class="id"> B</span>)<span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span><span class="id"> B</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> X,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> B</span><span class="id"> &amp;</span><span class="id"> trivIset</span><span class="id"> B</span><span class="id"> id]]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ring_measurableE</span><span class="id"> :</span><span class="id"> d</span>.<span class="id">-ring</span>.<span class="id">-measurable</span><span class="id"> =</span><span class="id"> measurable_fin_trivIset</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/seteqP;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> [B</span><span class="id"> [-&gt;</span><span class="id"> Bm</span><span class="id"> Bfin</span><span class="id"> Btriv]];</span><span class="id"> apply:</span><span class="id"> fin_bigcup_measurable</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> Di;</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest;</span><span class="id"> apply:</span><span class="id"> Bm</span>.<br/>
<span class="id">have</span><span class="id"> mdW</span><span class="id"> A</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable_fin_trivIset</span><span class="id"> A</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> Am;</span><span class="gallina-kwd"> exists</span><span class="id"> [set</span><span class="id"> A];</span><span class="id"> split;</span><span class="id"> do</span><span class="id"> ?by</span><span class="id"> [rewrite</span><span class="id"> bigcup_set1|move=&gt;</span><span class="id"> ?</span><span class="id"> -&gt;|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="id">have</span><span class="id"> mdI</span><span class="id"> :</span><span class="id"> setI_closed</span><span class="id"> measurable_fin_trivIset</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [A</span><span class="id"> [-&gt;</span><span class="id"> Am</span><span class="id"> Afin</span><span class="id"> Atriv]]</span><span class="id"> [B</span><span class="id"> [-&gt;</span><span class="id"> Bm</span><span class="id"> Bfin</span><span class="id"> Btriv]]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setI_bigcupl;</span><span class="id"> under</span><span class="id"> eq_bigcupr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> setI_bigcupr</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -bigcup_setX</span><span class="id"> -</span>(<span class="id">bigcup_image</span><span class="id"> _</span><span class="id"> _</span><span class="id"> id</span>).<br/>
&nbsp;&nbsp;<span class="id">eexists;</span><span class="id"> split;</span><span class="id"> [reflexivity</span><span class="id"> |</span><span class="id"> |</span><span class="id"> exact/finite_image/finite_setX</span><span class="id"> |]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> [X</span><span class="id"> [?</span><span class="id"> ?]</span><span class="id"> &lt;-];</span><span class="id"> apply:</span><span class="id"> measurableI;</span><span class="id"> [apply:</span><span class="id"> Am|apply:</span><span class="id"> Bm]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> trivIset_sets</span><span class="id"> =&gt;</span><span class="id"> -[a</span><span class="id"> b]</span><span class="id"> [a'</span><span class="id"> b']/=</span><span class="id"> [Xa</span><span class="id"> Xb]</span><span class="id"> [Xa'</span><span class="id"> Xb'];</span><span class="id"> rewrite</span><span class="id"> setIACA</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [x</span><span class="id"> [Ax</span><span class="id"> Bx]];</span><span class="id"> rewrite</span> (<span class="id">Atriv</span><span class="id"> a</span><span class="id"> a'</span>)<span class="id"> 1?</span>(<span class="id">Btriv</span><span class="id"> b</span><span class="id"> b'</span>)<span class="id">//;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
<span class="id">have</span><span class="id"> mdisj_bigcap</span><span class="id"> :</span><span class="id"> finN0_bigcap_closed</span><span class="id"> measurable_fin_trivIset</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id">exact/finN0_bigcap_closedP/mdI</span>.<br/>
<span class="id">have</span><span class="id"> mDbigcup</span><span class="id"> I</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> A</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">B</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">measurable_fin_trivIset</span> (<span class="id">A</span><span class="id"> `\`</span><span class="id"> \bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> B</span><span class="id"> i</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [-&gt;|/set0P</span><span class="id"> D0]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> D</span><span class="id"> set0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> bigcup0//</span><span class="id"> setD0</span><span class="id"> =&gt;</span><span class="id"> *;</span><span class="id"> apply:</span><span class="id"> mdW</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> Dfin</span><span class="id"> Am</span><span class="id"> Bm;</span><span class="id"> rewrite</span><span class="id"> -bigcupDr//;</span><span class="id"> apply:</span><span class="id"> mdisj_bigcap=&gt;</span><span class="id"> //</span><span class="id"> i</span><span class="id"> Di</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [F</span><span class="id"> [Ffin</span><span class="id"> Fm</span><span class="id"> -&gt;</span><span class="id"> ?]]</span><span class="id"> :=</span><span class="id"> semi_measurableD</span><span class="id"> A</span> (<span class="id">B</span><span class="id"> i</span>)<span class="id"> Am</span> (<span class="id">Bm</span><span class="id"> _</span><span class="id"> Di</span>)<span class="id">;</span><span class="gallina-kwd"> exists</span><span class="id"> F</span>.<br/>
<span class="id">have</span><span class="id"> mdU</span><span class="id"> :</span><span class="id"> fin_trivIset_closed</span><span class="id"> measurable_fin_trivIset</span>.<br/>
&nbsp;&nbsp;<span class="id">elim/Pchoice=&gt;</span><span class="id"> I</span><span class="id"> D</span><span class="id"> F</span><span class="id"> Dfin</span><span class="id"> Ftriv</span><span class="id"> Fm</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /</span>(_<span class="id"> _</span> (<span class="id">set_mem</span><span class="id"> _</span>))<span class="id">/cid-/</span>(<span class="id">all_sig_cond_dep</span> (<span class="id">fun=&gt;</span><span class="id"> set0</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[G</span><span class="id"> /</span>(_<span class="id"> _</span> (<span class="id">mem_set</span><span class="id"> _</span>))<span class="id">GP]</span><span class="id"> :=</span><span class="id"> Fm</span><span class="id"> _</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_bigcupr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> Di</span><span class="id"> do</span><span class="id"> case:</span> (<span class="id">GP</span><span class="id"> i</span><span class="id"> Di</span>)<span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -bigcup_setX_dep</span><span class="id"> -</span>(<span class="id">bigcup_image</span><span class="id"> _</span><span class="id"> _</span><span class="id"> id</span>)<span class="id">;</span><span class="id"> eexists;</span><span class="id"> split=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> [i</span><span class="id"> [Di</span><span class="id"> Gi]</span><span class="id"> &lt;-];</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> +</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> GP</span><span class="id"> i</span>.<span class="id">1</span><span class="id"> Di;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> finite_image;</span><span class="id"> apply:</span><span class="id"> finite_setXR=&gt;</span><span class="id"> //</span><span class="id"> i</span><span class="id"> Di;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> GP</span><span class="id"> i</span><span class="id"> Di</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> trivIset_sets</span><span class="id"> =&gt;</span><span class="id"> -[i</span><span class="id"> X]</span><span class="id"> [j</span><span class="id"> Y]</span><span class="id"> /=</span><span class="id"> [Di</span><span class="id"> Gi]</span><span class="id"> [Dj</span><span class="id"> Gj]</span><span class="id"> XYN0</span>.<br/>
&nbsp;&nbsp;<span class="id">suff</span><span class="id"> eqij</span><span class="id"> :</span><span class="id"> i</span><span class="id"> =</span><span class="id"> j</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> {i}eqij</span><span class="gallina-kwd"> in</span><span class="id"> Di</span><span class="id"> Gi</span><span class="id"> *;</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> _</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> XYN0</span>)<span class="id">-&gt;]</span><span class="id"> :=</span><span class="id"> GP</span><span class="id"> j</span><span class="id"> Dj</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> Ftriv</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> have</span><span class="id"> [-&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> GP</span><span class="id"> j</span><span class="id"> Dj;</span><span class="id"> have</span><span class="id"> [-&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> GP</span><span class="id"> i</span><span class="id"> Di</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> XYN0</span><span class="id"> =&gt;</span><span class="id"> [x</span><span class="id"> [Xx</span><span class="id"> Yx]];</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> split;</span><span class="id"> [exists</span><span class="id"> X|exists</span><span class="id"> Y]</span>.<br/>
<span class="id">have</span><span class="id"> mdDI</span><span class="id"> :</span><span class="id"> setDI_closed</span><span class="id"> measurable_fin_trivIset</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mA</span><span class="id"> mB;</span><span class="id"> have</span><span class="id"> [F</span><span class="id"> [-&gt;</span><span class="id"> Fm</span><span class="id"> Ffin</span><span class="id"> Ftriv]]</span><span class="id"> :=</span><span class="id"> mA</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [F'</span><span class="id"> [-&gt;</span><span class="id"> F'm</span><span class="id"> F'fin</span><span class="id"> F'triv]]</span><span class="id"> :=</span><span class="id"> mB</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [-&gt;|/set0P</span><span class="id"> F'N0]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> F'</span><span class="id"> set0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> bigcup_set0</span><span class="id"> setD0;</span><span class="gallina-kwd"> exists</span><span class="id"> F</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setD_bigcupl;</span><span class="id"> apply:</span><span class="id"> mdU</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> trivIset_setIr</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> X</span><span class="id"> DX;</span><span class="id"> rewrite</span><span class="id"> -bigcupDr//;</span><span class="id"> apply:</span><span class="id"> mdisj_bigcap</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> Y</span><span class="id"> DY;</span><span class="id"> case:</span> (<span class="id">semi_measurableD</span><span class="id"> X</span><span class="id"> Y</span>)<span class="id">;</span><span class="id"> [exact:</span><span class="id"> Fm|exact:</span><span class="id"> F'm|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> G</span><span class="id"> [Gfin</span><span class="id"> Gm</span><span class="id"> -&gt;</span><span class="id"> Gtriv];</span><span class="gallina-kwd"> exists</span><span class="id"> G</span>.<br/>
<span class="id">apply:</span><span class="id"> smallest_sub</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> mdW</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mA</span><span class="id"> mB;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">setUIDK</span><span class="id"> B</span><span class="id"> A</span>)<span class="id"> setUA</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> `|`</span><span class="id"> _]setUidl//</span>.<br/>
<span class="id">rewrite</span><span class="id"> -bigcup2inE;</span><span class="id"> apply:</span><span class="id"> mdU</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [|[]]//</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> mdDI</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [|[]]//</span><span class="id"> [|[]]//=</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [];</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> ?setIA</span><span class="id"> =&gt;</span><span class="id"> X</span><span class="id"> []</span><span class="id"> []//</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_subring</span><span class="id"> :</span> (<span class="id">d</span>.<span class="id">-measurable</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>))<span class="id"> `&lt;=`</span><span class="id"> d</span>.<span class="id">-ring</span>.<span class="id">-measurable</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /measurable</span><span class="id"> =&gt;</span><span class="id"> X</span><span class="id"> Xmeas</span><span class="id"> /=</span><span class="id"> M</span><span class="id"> /=</span><span class="id"> [_];</span><span class="id"> apply</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ring_finite_set</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span>)<span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> finite_set</span><span class="id"> B,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> X,</span><span class="id"> B</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> !=set0</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">trivIset</span><span class="id"> B</span><span class="id"> id,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T,</span><span class="id"> X</span><span class="id"> \in</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> X</span>)<span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> =</span><span class="id"> \bigcup_</span>(<span class="id">X</span><span class="gallina-kwd"> in</span><span class="id"> B</span>)<span class="id"> X]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> ring_measurableE</span><span class="id"> =&gt;</span><span class="id"> -[B</span><span class="id"> [-&gt;</span><span class="id"> Bm</span><span class="id"> Bfin</span><span class="id"> Btriv]]</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">B</span><span class="id"> `&amp;`</span><span class="id"> [set</span><span class="id"> X</span><span class="id"> |</span><span class="id"> X</span><span class="id"> !=</span><span class="id"> set0]</span>)<span class="id">;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> sub_finite_set</span><span class="id"> Bfin;</span><span class="id"> exact:</span><span class="id"> subIsetl</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?/=</span><span class="id"> [_</span><span class="id"> /set0P]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> Y/=</span><span class="id"> [XB</span><span class="id"> _]</span><span class="id"> [YB</span><span class="id"> _];</span><span class="id"> exact:</span><span class="id"> Btriv</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> X/=</span><span class="id"> /[!inE]</span><span class="id"> -[]</span><span class="id"> /Bm</span>.<br/>
<span class="id">rewrite</span><span class="id"> bigcup_mkcondr;</span><span class="id"> apply:</span><span class="id"> eq_bigcupr</span><span class="id"> =&gt;</span><span class="id"> X</span><span class="id"> Bx;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> notin_setE/=</span><span class="id"> =&gt;</span><span class="id"> /negP/negPn/eqP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> decomp</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span>)<span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> A</span><span class="id"> ==</span><span class="id"> set0</span><span class="gallina-kwd"> then</span><span class="id"> [set</span><span class="id"> set0]</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> pselect</span> (<span class="id">measurable</span><span class="id"> A</span>)<span class="id"> is</span><span class="id"> left</span><span class="id"> mA</span><span class="gallina-kwd"> then</span><span class="id"> projT1</span> (<span class="id">cid</span> (<span class="id">ring_finite_set</span><span class="id"> mA</span>))<br/>
&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="id"> [set</span><span class="id"> A]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> decomp_finite_set</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span>)<span class="id"> :</span><span class="id"> finite_set</span> (<span class="id">decomp</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /decomp;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> A0;</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> X</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> ?</span><span class="id"> []</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> decomp_triv</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span>)<span class="id"> :</span><span class="id"> trivIset</span> (<span class="id">decomp</span><span class="id"> A</span>)<span class="id"> id</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /decomp;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> _;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> j/=</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="id">case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> Am;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> ?</span><span class="id"> []</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> /=</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> decomp_triv</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_decomp_neq0</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> !=set0</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> X,</span><span class="id"> decomp</span><span class="id"> A</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> !=set0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /set0P</span><span class="id"> AN0;</span><span class="id"> rewrite</span><span class="id"> /decomp/=</span> (<span class="id">negPf</span><span class="id"> AN0</span>).<br/>
<span class="id">case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> Am;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> ?</span><span class="id"> []</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> -&gt;;</span><span class="id"> exact/set0P</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> decomp_neq0</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span>)<span class="id"> X</span><span class="id"> :</span><span class="id"> A</span><span class="id"> !=set0</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> \in</span><span class="id"> decomp</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> !=set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /all_decomp_neq0/</span>(_<span class="id"> X</span>)<span class="id"> /[!inE]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> decomp_measurable</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span>) (<span class="id">X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> \in</span><span class="id"> decomp</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> X</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /decomp;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> _;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> Am</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> ?</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> _</span><span class="id"> +</span><span class="id"> _];</span><span class="id"> apply</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cover_decomp</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span>)<span class="id"> :</span><span class="id"> \bigcup_</span>(<span class="id">X</span><span class="gallina-kwd"> in</span><span class="id"> decomp</span><span class="id"> A</span>)<span class="id"> X</span><span class="id"> =</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /decomp;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> [/eqP-&gt;|_];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> bigcup0</span>.<br/>
<span class="id">case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> Am;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> ?</span><span class="id"> []</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> bigcup_set1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> decomp_sub</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span>) (<span class="id">X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> X</span><span class="id"> \in</span><span class="id"> decomp</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /decomp;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> _;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE/=</span><span class="id"> =&gt;</span><span class="id"> -&gt;//</span>.<br/>
<span class="id">case:</span><span class="id"> pselect</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> Am;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> D</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> -&gt;]</span><span class="id"> /[!inE]</span><span class="id"> XD;</span><span class="id"> apply:</span><span class="id"> bigcup_sup</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> decomp_set0</span><span class="id"> :</span><span class="id"> decomp</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> set0]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /decomp</span><span class="id"> eqxx</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> decompN0</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span>)<span class="id"> :</span><span class="id"> decomp</span><span class="id"> A</span><span class="id"> !=</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /decomp;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> [_|AN0];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/set0P;</span><span class="gallina-kwd"> exists</span><span class="id"> set0</span>.<br/>
<span class="id">case:</span><span class="id"> pselect=&gt;</span><span class="id"> //=</span><span class="id"> Am;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/set0P;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span>.<br/>
<span class="id">case:</span><span class="id"> cid=&gt;</span><span class="id"> //=</span><span class="id"> D</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> Aeq];</span><span class="id"> apply:</span><span class="id"> contra_neq</span><span class="id"> AN0;</span><span class="id"> rewrite</span><span class="id"> Aeq</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> bigcup_set0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> measure</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numDomainType</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<br/>
&nbsp;&nbsp;(<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span>)<span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> \sum_</span>(<span class="id">X</span><span class="id"> \in</span><span class="id"> decomp</span><span class="id"> A</span>)<span class="id"> mu</span><span class="id"> X</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> content</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realFieldType}</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> Rmu</span><span class="id"> :=</span> (<span class="id">measure</span><span class="id"> mu</span>).<br/>
<span class="vernacular">Arguments</span><span class="id"> big_trivIset</span><span class="id"> {I</span><span class="id"> D</span><span class="id"> T</span><span class="id"> R</span><span class="id"> idx</span><span class="id"> op}</span><span class="id"> A</span><span class="id"> F</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Rmu_fin_bigcup</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> trivIset</span><span class="id"> D</span><span class="id"> F</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">Rmu</span> (<span class="id">\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> D</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Dfin</span><span class="id"> Ftriv</span><span class="id"> Fm;</span><span class="id"> rewrite</span><span class="id"> /measure</span>.<br/>
<span class="id">have</span><span class="id"> mUD</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">\bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> fin_bigcup_measurable</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> *;</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest</span>.<br/>
&nbsp;&nbsp;<span class="id">exact/Fm/mem_set</span>.<br/>
<span class="id">have</span><span class="id"> [-&gt;|/set0P[i0</span><span class="id"> Di0]]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> D</span><span class="id"> set0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> bigcup_set0</span><span class="id"> decomp_set0</span><span class="id"> fsbig_set0</span><span class="id"> fsbig_set1</span>.<br/>
<span class="id">set</span><span class="id"> E</span><span class="id"> :=</span><span class="id"> decomp</span><span class="id"> _;</span><span class="id"> have</span><span class="id"> Em</span><span class="id"> X</span><span class="id"> :=</span><span class="id"> decomp_measurable</span><span class="id"> mUD</span><span class="id"> X</span>.<br/>
<span class="id">transitivity</span> (<span class="id">\sum_</span>(<span class="id">X</span><span class="id"> \in</span><span class="id"> E</span>)<span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> D</span>)<span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> i</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> eq_fsbigr</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> X</span><span class="id"> XE;</span><span class="id"> have</span><span class="id"> XDF</span><span class="id"> :</span><span class="id"> X</span><span class="id"> =</span><span class="id"> \bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>) (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> i</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -setI_bigcupr</span><span class="id"> setIidl//;</span><span class="id"> exact:</span><span class="id"> decomp_sub</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [in</span><span class="id"> LHS]XDF</span><span class="id"> content_fin_bigcup//;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> trivIset_setIl</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> /mem_set</span><span class="id"> Di;</span><span class="id"> apply:</span><span class="id"> measurableI;</span><span class="id"> [exact:</span><span class="id"> Em|exact:</span><span class="id"> Fm]</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -XDF;</span><span class="id"> exact:</span><span class="id"> Em</span>.<br/>
<span class="id">rewrite</span><span class="id"> exchange_fsbig</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> decomp_finite_set</span>.<br/>
<span class="id">apply:</span><span class="id"> eq_fsbigr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> Di;</span><span class="id"> have</span><span class="id"> Feq</span><span class="id"> :</span><span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \bigcup_</span>(<span class="id">X</span><span class="gallina-kwd"> in</span><span class="id"> E</span>) (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> F</span><span class="id"> i</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -setI_bigcupl</span><span class="id"> setIidr//</span><span class="id"> cover_decomp</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/bigcup_sup;</span><span class="id"> exact:</span><span class="id"> set_mem</span>.<br/>
<span class="id">rewrite</span><span class="id"> -content_fin_bigcup</span><span class="id"> -?Feq//;</span><span class="id"> [exact/decomp_finite_set|</span><span class="id"> |</span><span class="id"> |exact/Fm]</span>.<br/>
<span class="id">-</span><span class="id"> exact/trivIset_setIr/decomp_triv</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> /=</span><span class="id"> XE;</span><span class="id"> apply:</span><span class="id"> measurableI;</span><span class="id"> [apply:</span><span class="id"> Em;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> Fm]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> RmuE</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> Rmu</span><span class="id"> A</span><span class="id"> =</span><span class="id"> mu</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Am;</span><span class="id"> rewrite</span><span class="id"> -[A</span><span class="gallina-kwd"> in</span><span class="id"> LHS]</span>(<span class="id">@bigcup_set1</span><span class="id"> _</span><span class="id"> unit</span><span class="id"> _</span><span class="id"> tt</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Rmu_fin_bigcup//</span><span class="id"> ?fsbig_set1//</span><span class="id"> =&gt;</span><span class="id"> -[]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> Rmu0</span><span class="id"> :</span><span class="id"> Rmu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">bigcup_set0</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> :</span><span class="id"> void</span><span class="id"> =&gt;</span><span class="id"> set0</span>)).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Rmu_fin_bigcup//</span><span class="id"> fsbig_set0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Rmu_ge0</span><span class="id"> A</span><span class="id"> :</span><span class="id"> Rmu</span><span class="id"> A</span><span class="id"> &gt;=</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> sume_ge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Rmu_additive</span><span class="id"> :</span><span class="id"> semi_additive</span><span class="id"> Rmu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/</span>(<span class="id">additive2P</span><span class="id"> Rmu0</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> A</span><span class="id"> B</span><span class="id"> /ring_finite_set[/=</span><span class="id"> {}A</span><span class="id"> [?</span><span class="id"> _</span><span class="id"> Atriv</span><span class="id"> Am</span><span class="id"> -&gt;]]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /ring_finite_set[/=</span><span class="id"> {}B</span><span class="id"> [?</span><span class="id"> _</span><span class="id"> Btriv</span><span class="id"> Bm</span><span class="id"> -&gt;]]</span>.<br/>
<span class="id">rewrite</span><span class="id"> -subset0</span><span class="id"> =&gt;</span><span class="id"> coverAB0</span>.<br/>
<span class="id">have</span><span class="id"> AUBfin</span><span class="id"> :</span><span class="id"> finite_set</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> finite_setU</span>.<br/>
<span class="id">have</span><span class="id"> AUBtriv</span><span class="id"> :</span><span class="id"> trivIset</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> id</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> []</span><span class="id"> ABX</span><span class="id"> []</span><span class="id"> ABY;</span><span class="id"> do</span><span class="id"> ?by</span><span class="id"> [exact:</span><span class="id"> Atriv|exact:</span><span class="id"> Btriv]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [u</span><span class="id"> [Xu</span><span class="id"> Yu]];</span><span class="id"> case:</span> (<span class="id">coverAB0</span><span class="id"> u</span>)<span class="id">;</span><span class="id"> split;</span><span class="id"> [exists</span><span class="id"> X|exists</span><span class="id"> Y]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [u</span><span class="id"> [Xu</span><span class="id"> Yu]];</span><span class="id"> case:</span> (<span class="id">coverAB0</span><span class="id"> u</span>)<span class="id">;</span><span class="id"> split;</span><span class="id"> [exists</span><span class="id"> Y|exists</span><span class="id"> X]</span>.<br/>
<span class="id">rewrite</span><span class="id"> -bigcup_setU</span><span class="id"> !Rmu_fin_bigcup//=</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> fsbigU//=</span><span class="id"> =&gt;</span><span class="id"> [X</span><span class="id"> /=</span><span class="id"> [XA</span><span class="id"> XB]];</span><span class="id"> have</span><span class="id"> [-&gt;//|/set0P[x</span><span class="id"> Xx]]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> X</span><span class="id"> set0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">coverAB0</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> split;</span><span class="gallina-kwd"> exists</span><span class="id"> X</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> /set_mem</span><span class="id"> [|]</span><span class="id"> /mem_set</span><span class="id"> ?;</span><span class="id"> [exact:</span><span class="id"> Am|exact:</span><span class="id"> Bm]</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">#[export]</span><br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isContent</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> Rmu</span><span class="id"> Rmu_ge0</span><span class="id"> Rmu_additive</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> content</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> SetRing</span>.<br/>
<span class="vernacular">Module</span><span class="vernacular"> Exports</span>.<br/>
<span class="id">HB</span>.<span class="id">reexport</span>.<br/>
<span class="id">HB</span>.<span class="id">reexport</span><span class="id"> SetRing</span>.<br/>
<span class="vernacular">End</span><span class="vernacular"> Exports</span>.<br/>
<span class="vernacular">End</span><span class="id"> SetRing</span>.<br/>
<span class="vernacular">Export</span><span class="id"> SetRing</span>.<span class="vernacular">Exports</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;d .-ring&quot;</span><span class="id"> :=</span> (<span class="id">SetRing</span>.<span class="id">display</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 1,</span><span class="id"> format</span> <span class="id">&quot;d .-ring&quot;</span>)<span class="id"> :</span><span class="id"> measure_display_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;d .-ring.-measurable&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;((<span class="id">d%mdisp</span>.<span class="id">-ring</span>).<span class="id">-measurable</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span> (<span class="id">SetRing</span>.<span class="id">type</span><span class="id"> _</span>)))<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_measure</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> measurable</span><span class="id"> &amp;,</span><span class="id"> {homo</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> A</span><span class="id"> B</span><span class="id"> /</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> B</span><span class="id"> &gt;-&gt;</span> (<span class="id">A</span><span class="id"> &lt;=</span><span class="id"> B</span>)<span class="id">%E}}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B;</span><span class="id"> rewrite</span><span class="id"> ?inE</span><span class="id"> =&gt;</span><span class="id"> mA</span><span class="id"> mB</span><span class="id"> AB;</span><span class="id"> have</span><span class="id"> [|muBfin]</span><span class="id"> :=</span><span class="id"> leP</span><span class="id"> +oo%E</span> (<span class="id">mu</span><span class="id"> B</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> leye_eq</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> leey</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[leRHS]SetRing</span>.<span class="id">RmuE//</span><span class="id"> -[B]</span>(<span class="id">setDUK</span><span class="id"> AB</span>)<span class="id"> measureU/=</span><span class="id"> ?setDIK//</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> SetRing</span>.<span class="id">RmuE</span><span class="id"> ?leeDl</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> sub_gen_smallest</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measurableD;</span><span class="id"> exact:</span><span class="id"> sub_gen_smallest</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_le0</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> 0</span>)<span class="id">%E</span><span class="id"> =</span> (<span class="id">mu</span><span class="id"> A</span><span class="id"> ==</span><span class="id"> 0</span>)<span class="id">%E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> ltgtP</span> (<span class="id">measure_ge0</span><span class="id"> mu</span><span class="id"> A</span>). Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> more_content_semiring_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> content_subadditive</span><span class="id"> :</span><span class="id"> subadditive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> X</span><span class="id"> A</span><span class="id"> n</span><span class="id"> Am</span><span class="id"> Xm</span><span class="id"> XA;</span><span class="id"> pose</span><span class="id"> B</span><span class="id"> i</span><span class="id"> :=</span><span class="id"> A\_`I_n</span><span class="id"> i</span><span class="id"> `&amp;`</span><span class="id"> X</span>.<br/>
<span class="id">have</span><span class="id"> XE</span><span class="id"> :</span><span class="id"> X</span><span class="id"> =</span><span class="id"> \big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> B</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -big_distrl/=</span><span class="id"> setIidr//</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /XA/=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -!bigcup_mkord</span><span class="id"> =&gt;</span><span class="id"> -[k</span><span class="id"> nk</span><span class="id"> Ax];</span><span class="gallina-kwd"> exists</span><span class="id"> k;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> patchT</span><span class="id"> ?inE</span>.<br/>
<span class="id">have</span><span class="id"> Bm</span><span class="id"> i</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">B</span><span class="id"> i</span>).<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">ltnP</span><span class="id"> i</span><span class="id"> n</span>)<span class="id"> =&gt;</span><span class="id"> ltin;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /B</span><span class="id"> patchC</span><span class="id"> ?inE</span><span class="id"> ?set0I//=</span><span class="id"> leq_gtF</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /B</span><span class="id"> ?patchT</span><span class="id"> ?inE//;</span><span class="id"> apply:</span><span class="id"> measurableI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> Am</span>.<br/>
<span class="id">have</span><span class="id"> subBA</span><span class="id"> i</span><span class="id"> :</span><span class="id"> B</span><span class="id"> i</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /B/patch;</span><span class="id"> case:</span><span class="id"> ifP;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> set0I//=</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> ?</span>.<br/>
<span class="id">have</span><span class="id"> subDUB</span><span class="id"> i</span><span class="id"> :</span><span class="id"> seqDU</span><span class="id"> B</span><span class="id"> i</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> i</span><span class="gallina-kwd"> by</span> <span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> [/subBA]</span>.<br/>
<span class="id">have</span><span class="id"> DUBm</span><span class="id"> i</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">seqDU</span><span class="id"> B</span><span class="id"> i</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">SetRing</span>.<span class="id">type</span><span class="id"> T</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> measurableD;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> sub_gen_smallest</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest</span>.<br/>
<span class="id">have</span><span class="id"> DU0</span><span class="id"> i</span><span class="id"> :</span> (<span class="id">i</span><span class="id"> &gt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> seqDU</span><span class="id"> B</span><span class="id"> i</span><span class="id"> =</span><span class="id"> set0</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> leni;</span><span class="id"> rewrite</span><span class="id"> -subset0</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> [];</span><span class="id"> rewrite</span><span class="id"> /B</span><span class="id"> patchC</span><span class="id"> ?inE/=</span><span class="id"> ?leq_gtF//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case</span>.<br/>
<span class="id">rewrite</span><span class="id"> -SetRing</span>.<span class="id">RmuE//</span><span class="id"> XE</span><span class="id"> bigsetU_seqDU</span><span class="id"> measure_bigsetU//</span>.<br/>
<span class="id">rewrite</span><span class="id"> [leRHS]</span>(<span class="id">big_ord_widen</span><span class="id"> n</span> (<span class="id">mu</span><span class="id"> \o</span><span class="id"> A</span>))<span class="id">//=</span><span class="id"> [leRHS]big_mkcond/=</span>.<br/>
<span class="id">rewrite</span><span class="id"> lee_sum</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> ltnP</span><span class="id"> =&gt;</span><span class="id"> ltin;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> DU0</span><span class="id"> ?measure0</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[leRHS]SetRing</span>.<span class="id">RmuE;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> Am</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> le_measure</span><span class="id"> ?inE//=;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest;</span><span class="id"> apply:</span><span class="id"> Am</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> content_sub_fsum</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> D</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">A_</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">finite_set</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> D</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">A_</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> `&lt;=`</span><span class="id"> \bigcup_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> D</span>)<span class="id"> A_</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> \in</span><span class="id"> D</span>)<span class="id"> mu</span> (<span class="id">A_</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/choicePpointed:</span><span class="id"> I</span><span class="id"> =&gt;</span><span class="id"> I</span><span class="gallina-kwd"> in</span><span class="id"> A_</span><span class="id"> D</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !emptyE</span><span class="id"> bigcup_set0//</span><span class="id"> subset0</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> measure0</span><span class="id"> fsbig_set0</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> Dfin</span><span class="id"> A_m</span><span class="id"> Am</span><span class="id"> Asub;</span><span class="id"> have</span><span class="id"> [n</span><span class="id"> /ppcard_eqP[f]]</span><span class="id"> :=</span><span class="id"> Dfin</span>.<br/>
<span class="id">rewrite</span> (<span class="id">reindex_fsbig</span><span class="id"> f^-1%FUN</span><span class="id"> `I_n</span>)<span class="id">//=</span><span class="id"> -fsbig_ord</span>.<br/>
<span class="id">rewrite</span> (<span class="id">@content_subadditive</span><span class="id"> A</span> (<span class="id">A_</span><span class="id"> \o</span><span class="id"> f^-1%FUN</span>))<span class="id">//=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> ltin;</span><span class="id"> apply:</span><span class="id"> A_m;</span><span class="id"> apply:</span><span class="id"> funS</span>.<br/>
<span class="id">rewrite</span> (<span class="id">fsbig_ord</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">A_</span><span class="id"> \o</span><span class="id"> f^-1%FUN</span>))<span class="id">/=</span><span class="id"> -</span>(<span class="id">reindex_fsbig</span><span class="id"> _</span><span class="id"> _</span><span class="id"> D</span>)<span class="id">//=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> fsbig_setU</span>.<br/>
Qed.</div></details>
<br/>
<br/>
<span class="vernacular">End</span><span class="id"> more_content_semiring_lemmas</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.1.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `content_sub_additive`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> content_sub_additive</span><span class="id"> :=</span><span class="id"> content_subadditive</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> content_ring_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> content_ring_sup_sigma_additive</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> measurable</span> (<span class="id">A</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">\bigcup_i</span><span class="id"> A</span><span class="id"> i</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">trivIset</span><span class="id"> [set:</span><span class="id"> nat]</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">A</span><span class="id"> i</span>)<span class="id"> &lt;=</span><span class="id"> mu</span> (<span class="id">\bigcup_i</span><span class="id"> A</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Am</span><span class="id"> UAm</span><span class="id"> At;</span><span class="id"> rewrite</span><span class="id"> lime_le//;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> is_cvg_nneseries</span>.<br/>
<span class="id">near=&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> big_mkord</span><span class="id"> -measure_bigsetU//=</span><span class="id"> le_measure</span><span class="id"> ?inE//=</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> bigsetU_measurable</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -bigcup_mkord;</span><span class="id"> apply:</span><span class="id"> bigcup_sub</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> lein;</span><span class="id"> apply:</span><span class="id"> bigcup_sup</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> content_ring_sigma_additive</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable_subset_sigma_subadditive</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> semi_sigma_additive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mu_sub</span><span class="id"> A</span><span class="id"> Am</span><span class="id"> Atriv</span><span class="id"> UAm</span>.<br/>
<span class="id">suff</span><span class="id"> &lt;-</span><span class="id"> :</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">A</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> mu</span> (<span class="id">\bigcup_n</span><span class="id"> A</span><span class="id"> n</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> is_cvg_nneseries</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le</span><span class="id"> mu_sub//</span><span class="id"> ?content_ring_sup_sigma_additive</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> content_ring_lemmas</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ring_sigma_subadditive_content</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> Rmu</span><span class="id"> :=</span> (<span class="id">SetRing</span>.<span class="id">measure</span><span class="id"> mu</span>).<br/>
<span class="vernacular">Import</span><span class="id"> SetRing</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ring_sigma_subadditive</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable_subset_sigma_subadditive</span><span class="id"> mu</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_subset_sigma_subadditive</span><span class="id"> Rmu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> muS;</span><span class="id"> move=&gt;</span><span class="id"> /=</span><span class="id"> D</span><span class="id"> A</span><span class="id"> Am</span><span class="id"> Dm</span><span class="id"> Dsub</span>.<br/>
<span class="id">rewrite</span><span class="id"> /Rmu</span><span class="id"> -</span>(<span class="id">eq_eseriesr</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> esum_fset</span><span class="id"> _</span><span class="id"> _</span>))<span class="id">//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> exact:</span><span class="id"> decomp_finite_set</span>.<br/>
<span class="id">rewrite</span><span class="id"> nneseries_esum</span><span class="id"> ?esum_esum//=;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> esum_ge0</span>.<br/>
<span class="id">set</span><span class="id"> K</span><span class="id"> :=</span><span class="id"> _</span><span class="id"> `*``</span><span class="id"> _</span>.<br/>
<span class="id">have</span><span class="id"> /ppcard_eqP[f]</span><span class="id"> :</span> (<span class="id">K</span><span class="id"> #=</span><span class="id"> [set:</span><span class="id"> nat]</span>)<span class="id">%card</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> cardXR_eq_nat</span><span class="id"> =&gt;</span><span class="id"> [|i]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (_<span class="id"> :</span><span class="id"> [set</span><span class="id"> _</span><span class="id"> |</span><span class="id"> true]</span><span class="id"> =</span><span class="id"> setT</span>)<span class="id">//;</span><span class="id"> exact/predeqP</span>.<br/>
&nbsp;&nbsp;<span class="id">split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/finite_set_countable;</span><span class="id"> exact:</span><span class="id"> decomp_finite_set</span>.<br/>
&nbsp;&nbsp;<span class="id">exact/set0P/decompN0</span>.<br/>
<span class="id">have</span><span class="id"> {Dsub}</span><span class="id"> :</span><span class="id"> D</span><span class="id"> `&lt;=`</span><span class="id"> \bigcup_</span>(<span class="id">k</span><span class="gallina-kwd"> in</span><span class="id"> K</span>)<span class="id"> k</span>.<span class="id">2</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">subset_trans</span><span class="id"> Dsub</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> bigcup_sub</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -[A</span><span class="id"> i]cover_decomp;</span><span class="id"> apply:</span><span class="id"> bigcup_sub</span><span class="id"> =&gt;</span><span class="id"> X/=</span><span class="id"> XAi</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> Xx;</span><span class="gallina-kwd"> exists</span> (<span class="id">i,</span><span class="id"> X</span>).<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">image_eq</span><span class="id"> [bij</span><span class="id"> of</span><span class="id"> f^-1%FUN]</span>)<span class="id">/=</span>.<br/>
<span class="id">rewrite</span> (<span class="id">esum_set_image</span><span class="id"> _</span><span class="id"> f^-1</span>)<span class="id">//=</span><span class="id"> bigcup_image</span><span class="id"> =&gt;</span><span class="id"> Dsub</span>.<br/>
<span class="id">have</span><span class="id"> DXsub</span><span class="id"> X</span><span class="id"> :</span><span class="id"> X</span><span class="id"> \in</span><span class="id"> decomp</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> \bigcup_i</span> ((<span class="id">f^-1%FUN</span><span class="id"> i</span>).<span class="id">2</span><span class="id"> `&amp;`</span><span class="id"> X</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> XD;</span><span class="id"> rewrite</span><span class="id"> -setI_bigcupl</span><span class="id"> -[Y</span><span class="gallina-kwd"> in</span><span class="id"> Y</span><span class="id"> `&lt;=`</span><span class="id"> _]</span>(<span class="id">setIidr</span> (<span class="id">decomp_sub</span><span class="id"> XD</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> setSI</span>.<br/>
<span class="id">have</span><span class="id"> mf</span><span class="id"> i</span><span class="id"> :</span><span class="id"> measurable</span> ((<span class="id">f^-1</span>)<span class="id">%function</span><span class="id"> i</span>).<span class="id">2</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [_</span><span class="id"> /mem_set/decomp_measurable]</span><span class="id"> :=</span><span class="id"> 'invS_f</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> setT</span><span class="id"> i</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply;</span><span class="id"> exact:</span><span class="id"> Am</span>.<br/>
<span class="id">have</span><span class="id"> mfD</span><span class="id"> i</span><span class="id"> X</span><span class="id"> :</span><span class="id"> X</span><span class="id"> \in</span><span class="id"> decomp</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (((<span class="id">f^-1</span>)<span class="id">%FUN</span><span class="id"> i</span>).<span class="id">2</span><span class="id"> `&amp;`</span><span class="id"> X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> XD;</span><span class="id"> apply:</span><span class="id"> measurableI;</span><span class="id"> [exact:</span><span class="id"> mf|exact:</span> (<span class="id">decomp_measurable</span><span class="id"> _</span><span class="id"> XD</span>)<span class="id">]</span>.<br/>
<span class="id">apply:</span> (<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span>)<span class="id"> \sum_</span>(<span class="id">X</span><span class="id"> &lt;-</span><span class="id"> fset_set</span> (<span class="id">decomp</span><span class="id"> D</span>))<span class="id"> mu</span> ((<span class="id">f^-1%FUN</span><span class="id"> i</span>).<span class="id">2</span><span class="id"> `&amp;`</span><span class="id"> X</span>))).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> nneseries_sum//</span><span class="id"> fsbig_finite/=;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> decomp_finite_set</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [leLHS]big_seq</span><span class="id"> [leRHS]big_seq</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> lee_sum//</span><span class="id"> =&gt;</span><span class="id"> X</span><span class="id"> /[!in_fset_set];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> decomp_finite_set</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> XD;</span><span class="id"> have</span><span class="id"> Xm</span><span class="id"> :=</span><span class="id"> decomp_measurable</span><span class="id"> Dm</span><span class="id"> XD</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> muS</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> [i|];</span><span class="id"> [exact:</span><span class="id"> mfD|exact:</span><span class="id"> DXsub]</span>.<br/>
<span class="id">apply:</span><span class="id"> lee_lim</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> do</span><span class="id"> ?apply:</span><span class="id"> is_cvg_nneseries=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> sume_ge0</span>.<br/>
<span class="id">near=&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> [n</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> &lt;=</span><span class="id"> n]big_mkcond;</span><span class="id"> apply:</span><span class="id"> lee_sum</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _</span>.<br/>
<span class="id">rewrite</span><span class="id"> ifT</span><span class="id"> ?inE//</span>.<br/>
<span class="id">under</span><span class="id"> eq_big_seq</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> in_fset_set=&gt;</span><span class="id"> [xD|];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> decomp_finite_set</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -RmuE//;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> mfD</span>.<br/>
&nbsp;&nbsp;<span class="id">over</span>.<br/>
<span class="id">rewrite</span><span class="id"> -fsbig_finite/=;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> decomp_finite_set</span>.<br/>
<span class="id">rewrite</span><span class="id"> -measure_fin_bigcup//=</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> -setI_bigcupr</span> (<span class="id">cover_decomp</span><span class="id"> D</span>)<span class="id"> -[leRHS]RmuE//</span><span class="id"> ?le_measure</span><span class="id"> ?inE//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurableI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest;</span><span class="id"> apply:</span><span class="id"> mf</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest;</span><span class="id"> apply:</span><span class="id"> mf</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> decomp_finite_set</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> trivIset_setIl;</span><span class="id"> apply:</span><span class="id"> decomp_triv</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> /=</span><span class="id"> XD;</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest;</span><span class="id"> apply:</span><span class="id"> mfD;</span><span class="id"> rewrite</span><span class="id"> inE</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ring_semi_sigma_additive</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable_subset_sigma_subadditive</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> semi_sigma_additive</span><span class="id"> Rmu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> mu_sub;</span><span class="id"> exact/content_ring_sigma_additive/ring_sigma_subadditive</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> semiring_sigma_additive</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable_subset_sigma_subadditive</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> semi_sigma_additive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /ring_semi_sigma_additive</span><span class="id"> Rmu_sigmadd</span><span class="id"> F</span><span class="id"> Fmeas</span><span class="id"> Ftriv</span><span class="id"> cupFmeas</span>.<br/>
<span class="id">have</span><span class="id"> Fringmeas</span><span class="id"> i</span><span class="id"> :</span><span class="id"> d</span>.<span class="id">-ring</span>.<span class="id">-measurable</span> (<span class="id">F</span><span class="id"> i</span>)<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measurable_subring</span>.<br/>
<span class="id">have</span><span class="id"> :=</span><span class="id"> Rmu_sigmadd</span><span class="id"> F</span><span class="id"> Fringmeas</span><span class="id"> Ftriv</span> (<span class="id">measurable_subring</span><span class="id"> cupFmeas</span>).<br/>
<span class="id">rewrite</span><span class="id"> SetRing</span>.<span class="id">RmuE//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> under</span><span class="id"> eq_bigr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> SetRing</span>.<span class="id">RmuE//=</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ring_sigma_subadditive_content</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.1.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `ring_sigma_subadditive`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> ring_sigma_sub_additive</span><span class="id"> :=</span><span class="id"> ring_sigma_subadditive</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="id">#[key=</span><span class="id">&quot;mu&quot;</span><span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> Content_SigmaSubAdditive_isMeasure</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> of</span><span class="id"> Content</span><span class="id"> d</span><span class="id"> mu</span><span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">measure_sigma_subadditive</span><span class="id"> :</span><span class="id"> measurable_subset_sigma_subadditive</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> of</span><span class="id"> Content_SigmaSubAdditive_isMeasure</span><span class="id"> d</span><span class="id"> R</span><span class="id"> T</span><span class="id"> mu</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Content_isMeasure</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><br/>
&nbsp;&nbsp;(<span class="id">semiring_sigma_additive</span> (<span class="id">measure_sigma_subadditive</span>)).<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.1.0&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;renamed `Content_SigmaSubAdditive_isMeasure.Build`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'Content_SubSigmaAdditive_isMeasure.Build' d R T mu&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">@Content_SigmaSubAdditive_isMeasure</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> R</span><span class="id"> T</span><span class="id"> mu</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> d,</span><span class="id"> R,</span><span class="id"> T,</span><span class="id"> mu</span><span class="gallina-kwd"> at</span><span class="id"> next</span><span class="id"> level,</span><span class="id"> only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.1.0&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;renamed `measure_sigma_subadditive`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> measure_sigma_sub_additive</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Content_SigmaSubAdditive_isMeasure</span>.<span class="id">measure_sigma_subadditive</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> more_premeasure_ring_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Import</span><span class="id"> SetRing</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_sigma_subadditive</span><span class="id"> :</span><span class="id"> measurable_subset_sigma_subadditive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> X</span><span class="id"> A</span><span class="id"> Am</span><span class="id"> Xm</span><span class="id"> XA;</span><span class="id"> pose</span><span class="id"> B</span><span class="id"> i</span><span class="id"> :=</span><span class="id"> A</span><span class="id"> i</span><span class="id"> `&amp;`</span><span class="id"> X</span>.<br/>
<span class="id">have</span><span class="id"> XE</span><span class="id"> :</span><span class="id"> X</span><span class="id"> =</span><span class="id"> \bigcup_i</span><span class="id"> B</span><span class="id"> i</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setI_bigcupl</span><span class="id"> setIidr</span>.<br/>
<span class="id">have</span><span class="id"> Bm</span><span class="id"> i</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">B</span><span class="id"> i</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /B;</span><span class="id"> apply:</span><span class="id"> measurableI</span>.<br/>
<span class="id">have</span><span class="id"> subBA</span><span class="id"> i</span><span class="id"> :</span><span class="id"> B</span><span class="id"> i</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> i</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /B</span>.<br/>
<span class="id">have</span><span class="id"> subDUB</span><span class="id"> i</span><span class="id"> :</span><span class="id"> seqDU</span><span class="id"> B</span><span class="id"> i</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> i</span><span class="gallina-kwd"> by</span> <span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> [/subBA]</span>.<br/>
<span class="id">have</span><span class="id"> DUBm</span><span class="id"> i</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">seqDU</span><span class="id"> B</span><span class="id"> i</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">SetRing</span>.<span class="id">type</span><span class="id"> T</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurableD</span><span class="id"> =&gt;</span><span class="id"> //;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">do</span><span class="id"> 1?apply:</span><span class="id"> bigsetU_measurable</span><span class="id"> =&gt;</span><span class="id"> *;</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest</span>.<br/>
<span class="id">rewrite</span><span class="id"> XE;</span><span class="id"> move:</span> (<span class="id">XE</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> seqDU_bigcup_eq</span>.<br/>
<span class="id">under</span><span class="id"> eq_bigcupr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> -[seqDU</span><span class="id"> B</span><span class="id"> _]cover_decomp//</span>.<br/>
<span class="id">rewrite</span><span class="id"> -bigcup_setX_dep;</span><span class="id"> set</span><span class="id"> K</span><span class="id"> :=</span><span class="id"> _</span><span class="id"> `*``</span><span class="id"> _</span>.<br/>
<span class="id">have</span><span class="id"> /ppcard_eqP[f]</span><span class="id"> :</span> (<span class="id">K</span><span class="id"> #=</span><span class="id"> [set:</span><span class="id"> nat]</span>)<span class="id">%card</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> cardXR_eq_nat=&gt;</span><span class="id"> //</span><span class="id"> i;</span><span class="id"> split;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/set0P;</span><span class="id"> rewrite</span><span class="id"> decompN0</span>.<br/>
&nbsp;&nbsp;<span class="id">exact/finite_set_countable/decomp_finite_set</span>.<br/>
<span class="id">pose</span><span class="id"> f'</span><span class="id"> :=</span><span class="id"> f^-1%FUN;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">image_eq</span><span class="id"> [bij</span><span class="id"> of</span><span class="id"> f']</span>)<span class="id">/=</span><span class="id"> bigcup_image/=</span>.<br/>
<span class="id">pose</span><span class="id"> g</span><span class="id"> n</span><span class="id"> :=</span> (<span class="id">f'</span><span class="id"> n</span>).<span class="id">2;</span><span class="id"> have</span><span class="id"> fVtriv</span><span class="id"> :</span><span class="id"> trivIset</span><span class="id"> [set:</span><span class="id"> nat]</span><span class="id"> g</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /g</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [/=</span><span class="id"> _</span><span class="id"> f'iB]</span><span class="id"> :</span><span class="id"> K</span> (<span class="id">f'</span><span class="id"> i</span>)<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> funS</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [/=</span><span class="id"> _</span><span class="id"> f'jB]</span><span class="id"> :</span><span class="id"> K</span> (<span class="id">f'</span><span class="id"> j</span>)<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> funS</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [f'ij|f'ij]</span><span class="id"> :=</span><span class="id"> eqVneq</span> (<span class="id">f'</span><span class="id"> i</span>).<span class="id">1</span> (<span class="id">f'</span><span class="id"> j</span>).<span class="id">1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /</span>(<span class="id">decomp_triv</span><span class="id"> f'iB</span>)<span class="id">/=;</span><span class="id"> rewrite</span><span class="id"> f'ij</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> f'jB</span>)<span class="id"> f'ij2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> 'inj_f';</span><span class="id"> rewrite</span><span class="id"> ?inE//=</span><span class="id"> -!/</span>(<span class="id">f'</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> move:</span><span class="id"> f'ij</span><span class="id"> f'ij2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">f'</span><span class="id"> i</span>) (<span class="id">f'</span><span class="id"> j</span>)<span class="id"> =&gt;</span><span class="id"> [?</span><span class="id"> ?]</span><span class="id"> [?</span><span class="id"> ?]//=</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> [x</span><span class="id"> [f'ix</span><span class="id"> f'jx]];</span><span class="id"> have</span><span class="id"> Bij</span><span class="id"> :=</span><span class="id"> @trivIset_seqDU</span><span class="id"> _</span><span class="id"> B</span> (<span class="id">f'</span><span class="id"> i</span>).<span class="id">1</span> (<span class="id">f'</span><span class="id"> j</span>).<span class="id">1</span><span class="id"> I</span><span class="id"> I</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Bij</span><span class="id"> ?eqxx//</span><span class="gallina-kwd"> in</span><span class="id"> f'ij;</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move/mem_set</span><span class="id"> :</span><span class="id"> f'iB</span><span class="id"> =&gt;</span><span class="id"> /decomp_sub;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move/mem_set</span><span class="id"> :</span><span class="id"> f'jB</span><span class="id"> =&gt;</span><span class="id"> /decomp_sub;</span><span class="id"> apply</span>.<br/>
<span class="id">have</span><span class="id"> g_inj</span><span class="id"> :</span><span class="id"> set_inj</span><span class="id"> [set</span><span class="id"> i</span><span class="id"> |</span><span class="id"> g</span><span class="id"> i</span><span class="id"> !=</span><span class="id"> set0]</span><span class="id"> g</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> trivIset_inj=&gt;</span><span class="id"> [i</span><span class="id"> /set0P//|];</span><span class="id"> apply:</span><span class="id"> sub_trivIset</span><span class="id"> fVtriv</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> XEbig;</span><span class="id"> rewrite</span><span class="id"> measure_semi_bigcup//=</span><span class="id"> -?XEbig//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> i;</span><span class="id"> have</span><span class="id"> [/=</span><span class="id"> _</span><span class="id"> /mem_set]</span><span class="id"> :</span><span class="id"> K</span> (<span class="id">f'</span><span class="id"> i</span>)<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> funS</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> decomp_measurable</span>.<br/>
<span class="id">rewrite</span><span class="id"> [leLHS]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span><span class="id"> |</span><span class="id"> g</span><span class="id"> i</span><span class="id"> !=</span><span class="id"> set0</span>)<span class="id"> mu</span> (<span class="id">g</span><span class="id"> i</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !nneseries_esum//</span><span class="id"> esum_mkcond</span><span class="id"> [RHS]esum_mkcond;</span><span class="id"> apply:</span><span class="id"> eq_esum</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> ifT</span><span class="id"> ?inE//=;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> notin_setE</span><span class="id"> /=</span><span class="id"> -/</span>(<span class="id">g</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> /negP/negPn/eqP</span><span class="id"> -&gt;</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">esum_pred_image</span><span class="id"> mu</span><span class="id"> g</span>)<span class="id">//</span>.<br/>
<span class="id">rewrite</span><span class="id"> [leLHS]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> \esum_</span>(<span class="id">X</span><span class="gallina-kwd"> in</span><span class="id"> range</span><span class="id"> g</span>)<span class="id"> mu</span><span class="id"> X</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> esum_mkcond</span><span class="id"> [RHS]esum_mkcond;</span><span class="id"> apply:</span><span class="id"> eq_esum</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> Y</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> ifPn;</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">inE,</span><span class="id"> notin_setE</span>)<span class="id">/=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [i</span><span class="id"> giN0</span><span class="id"> giY];</span><span class="id"> rewrite</span><span class="id"> ifT//</span><span class="id"> ?inE//=;</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> Ngx;</span><span class="id"> case:</span><span class="id"> ifPn;</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">inE,</span><span class="id"> notin_setE</span>)<span class="id">//=</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> [i</span><span class="id"> _</span><span class="id"> giY];</span><span class="id"> apply:</span><span class="id"> contra_not_eq</span><span class="id"> Ngx;</span><span class="id"> rewrite</span><span class="id"> -giY</span><span class="id"> =&gt;</span><span class="id"> mugi</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> contra_neq</span><span class="id"> mugi</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> measure0</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> range</span><span class="id"> g</span><span class="id"> =</span><span class="id"> \bigcup_i</span> (<span class="id">decomp</span> (<span class="id">seqDU</span><span class="id"> B</span><span class="id"> i</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply/predeqP</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> Y;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [[n</span><span class="id"> _</span><span class="id"> gnY]|[n</span><span class="id"> _</span><span class="id"> /=</span><span class="id"> YBn]]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [/=</span><span class="id"> _</span><span class="id"> f'nB]</span><span class="id"> :</span><span class="id"> K</span> (<span class="id">f'</span><span class="id"> n</span>)<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> funS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">f'</span><span class="id"> n</span>).<span class="id">1</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> -gnY</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">f</span> (<span class="id">n,</span><span class="id"> Y</span>))<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> /g</span><span class="id"> /f'</span><span class="id"> funK//=</span><span class="id"> inE</span>.<br/>
<span class="id">rewrite</span><span class="id"> esum_bigcup//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [-&gt;|/set0P</span><span class="id"> DUBiN0]</span><span class="id"> :=</span><span class="id"> eqVneq</span> (<span class="id">seqDU</span><span class="id"> B</span><span class="id"> i</span>)<span class="id"> set0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> decomp_set0</span><span class="id"> ?set_fset1</span><span class="id"> =&gt;</span><span class="id"> /negP[]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/eqP/predeqP=&gt;</span><span class="id"> x;</span><span class="id"> split=&gt;</span><span class="id"> [[Y/=-&gt;]|-&gt;]//;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> measure0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> set0</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [-&gt;|/set0P</span><span class="id"> DUBjN0]</span><span class="id"> :=</span><span class="id"> eqVneq</span> (<span class="id">seqDU</span><span class="id"> B</span><span class="id"> j</span>)<span class="id"> set0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> decomp_set0</span><span class="id"> ?set_fset1</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /negP[]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/eqP/predeqP=&gt;</span><span class="id"> x;</span><span class="id"> split=&gt;</span><span class="id"> [[Y/=-&gt;]|-&gt;]//=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> measure0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> set0</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [Y</span><span class="id"> /=</span><span class="id"> [/[dup]</span><span class="id"> +]]</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /mem_set</span><span class="id"> /decomp_sub</span><span class="id"> YBi</span><span class="id"> /mem_set</span><span class="id"> +</span><span class="id"> /mem_set</span><span class="id"> /decomp_sub</span><span class="id"> YBj</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /</span>(<span class="id">decomp_neq0</span><span class="id"> DUBiN0</span>)<span class="id"> [y</span><span class="id"> Yy]</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">@trivIset_seqDU</span><span class="id"> _</span><span class="id"> B</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> [exact:</span><span class="id"> YBi|exact:</span><span class="id"> YBj]</span>.<br/>
<span class="id">rewrite</span><span class="id"> nneseries_esum//</span><span class="id"> set_true</span><span class="id"> le_esum//</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _</span>.<br/>
<span class="id">rewrite</span><span class="id"> [leLHS]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> \in</span><span class="id"> decomp</span> (<span class="id">seqDU</span><span class="id"> B</span><span class="id"> i</span>))<span class="id"> mu</span><span class="id"> j</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> esum_fset//;</span><span class="id"> exact:</span><span class="id"> decomp_finite_set</span>.<br/>
<span class="id">rewrite</span><span class="id"> -SetRing</span>.<span class="id">Rmu_fin_bigcup//=;</span><span class="id"> last</span><span class="id"> 3</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> decomp_finite_set</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> decomp_triv</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> decomp_measurable</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[leRHS]SetRing</span>.<span class="id">RmuE//</span><span class="id"> le_measure//;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> cover_decomp</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> apply:</span><span class="id"> fin_bigcup_measurable;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> decomp_finite_set</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> j</span><span class="id"> /mem_set</span><span class="id"> jdec;</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> decomp_measurable</span><span class="id"> jdec</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> apply:</span><span class="id"> sub_gen_smallest;</span><span class="id"> exact:</span><span class="id"> Am</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> more_premeasure_ring_lemmas</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_sigma_subadditive_tail</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> N</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> n</span>))<span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> `&lt;=`</span><span class="id"> \bigcup_</span>(<span class="id">n</span><span class="gallina-kwd"> in</span><span class="id"> ~`</span><span class="id"> `I_N</span>)<span class="id"> F</span><span class="id"> n</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> \sum_</span>(<span class="id">N</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> n</span>))<span class="id">%E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mF</span><span class="id"> mA</span><span class="id"> AF;</span><span class="id"> rewrite</span><span class="id"> eseries_cond</span><span class="id"> eseries_mkcondr</span>.<br/>
<span class="id">rewrite</span> (<span class="id">@eq_eseriesr</span><span class="id"> _</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> mu</span> (<span class="gallina-kwd">if</span> (<span class="id">N</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="gallina-kwd"> then</span><span class="id"> F</span><span class="id"> n</span><span class="gallina-kwd"> else</span><span class="id"> set0</span>))).<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> measure_sigma_subadditive</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> case:</span><span class="id"> ifPn</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> move:</span><span class="id"> AF;</span><span class="id"> rewrite</span><span class="id"> bigcup_mkcond</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_bigcupr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> mem_not_I</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> o</span><span class="id"> _;</span><span class="id"> rewrite</span> (<span class="id">fun_if</span><span class="id"> mu</span>)<span class="id"> measure0</span>.<br/>
Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.1.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `measure_sigma_subadditive_tail`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> measure_sigma_sub_additive_tail</span><span class="id"> :=</span><span class="id"> measure_sigma_subadditive_tail</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ring_sigma_content</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> Rmu</span><span class="id"> :=</span> (<span class="id">SetRing</span>.<span class="id">measure</span><span class="id"> mu</span>).<br/>
<span class="vernacular">Import</span><span class="id"> SetRing</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> ring_sigma_content</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> Rmu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/ring_semi_sigma_additive/measure_sigma_subadditive</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Content_isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> Rmu</span><br/>
&nbsp;&nbsp;<span class="id">ring_sigma_content</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> ring_sigma_content</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> fin_num_fun</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numDomainType</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> U,</span><span class="id"> measurable</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> U</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fin_num_fun_lty</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> algebraOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> fin_num_fun</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> setT</span><span class="id"> &lt;</span><span class="id"> +oo</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> h;</span><span class="id"> rewrite</span><span class="id"> ltey_eq</span><span class="id"> h</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lty_fin_num_fun</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> algebraOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> setT</span><span class="id"> &lt;</span><span class="id"> +oo</span><span class="id"> -&gt;</span><span class="id"> fin_num_fun</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> h</span><span class="id"> U</span><span class="id"> mU;</span><span class="id"> rewrite</span><span class="id"> fin_real//</span> (<span class="id">lt_le_trans</span><span class="id"> _</span> (<span class="id">measure_ge0</span><span class="id"> mu</span><span class="id"> U</span>))<span class="id">//=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_lt_trans</span><span class="id"> _</span><span class="id"> h</span>)<span class="id">//=</span><span class="id"> le_measure//</span><span class="id"> inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> sfinite_measure</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> s</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}^nat,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> fin_num_fun</span> (<span class="id">s</span><span class="id"> n</span>)<span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> U,</span><span class="id"> measurable</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> U</span><span class="id"> =</span><span class="id"> mseries</span><span class="id"> s</span><span class="id"> 0</span><span class="id"> U</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> sigma_finite</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numDomainType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat,</span><span class="id"> A</span><span class="id"> =</span><span class="id"> \bigcup_</span>(<span class="id">i</span><span class="id"> :</span><span class="id"> nat</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>)<span class="id"> /\</span><span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>)<span class="id"> &lt;</span><span class="id"> +oo</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fin_num_fun_sigma_finite</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> algebraOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> mu</span><span class="id"> set0</span><span class="id"> &lt;</span><span class="id"> +oo</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">fin_num_fun</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> sigma_finite</span><span class="id"> setT</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> muoo;</span><span class="gallina-kwd"> exists</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> [set</span><span class="id"> 0%N]</span><span class="gallina-kwd"> then</span><span class="id"> setT</span><span class="gallina-kwd"> else</span><span class="id"> set0</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -bigcup_mkcondr</span><span class="id"> setTI</span><span class="id"> bigcup_const//;</span><span class="gallina-kwd"> exists</span><span class="id"> 0%N</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> split;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> fin_num_fun_lty</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sfinite_measure_sigma_finite</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">sigma_finite</span><span class="id"> setT</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> sfinite_measure</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [F</span><span class="id"> UF</span><span class="id"> mF];</span><span class="id"> rewrite</span><span class="id"> /sfinite_measure</span>.<br/>
<span class="id">have</span><span class="id"> mDF</span><span class="id"> k</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">seqDU</span><span class="id"> F</span><span class="id"> k</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> measurableD;</span><span class="id"> first</span><span class="id"> exact:</span> (<span class="id">mF</span><span class="id"> k</span>).<span class="id">1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> exact:</span> (<span class="id">mF</span><span class="id"> i</span>).<span class="id">1</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="gallina-kwd">fun</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> [the</span><span class="id"> measure</span><span class="id"> _</span><span class="id"> _</span><span class="id"> of</span><span class="id"> mrestr</span><span class="id"> mu</span> (<span class="id">mDF</span><span class="id"> k</span>)<span class="id">]</span>)<span class="id"> =&gt;</span><span class="id"> [n|U</span><span class="id"> mU]</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> lty_fin_num_fun</span><span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /mrestr</span><span class="id"> setTI</span> (<span class="id">@le_lt_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">mu</span> (<span class="id">F</span><span class="id"> n</span>)))<span class="id">//</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> apply:</span><span class="id"> le_measure;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> subDsetl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">*</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> apply:</span><span class="id"> measurableD;</span><span class="id"> first</span><span class="id"> exact:</span> (<span class="id">mF</span><span class="id"> n</span>).<span class="id">1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> exact:</span> (<span class="id">mF</span><span class="id"> i</span>).<span class="id">1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">*</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> exact:</span> (<span class="id">mF</span><span class="id"> n</span>).<span class="id">1</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> exact:</span> (<span class="id">mF</span><span class="id"> n</span>).<span class="id">2</span>.<br/>
<span class="id">rewrite</span><span class="id"> /mseries/=</span><span class="id"> /mrestr/=;</span><span class="id"> apply/esym/cvg_lim</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> mu</span><span class="id"> X]setIT</span><span class="id"> UF</span><span class="id"> seqDU_bigcup_eq</span><span class="id"> setI_bigcupr</span>.<br/>
<span class="id">apply:</span> (<span class="id">@measure_sigma_additive</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mu</span> (<span class="gallina-kwd">fun</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> U</span><span class="id"> `&amp;`</span><span class="id"> seqDU</span><span class="id"> F</span><span class="id"> k</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">exact/trivIset_setIl/trivIset_seqDU</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> isSFinite</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">s_finite</span><span class="id"> :</span><span class="id"> sfinite_measure</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> SFiniteMeasure</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{mu</span><span class="id"> of</span><span class="id"> @Measure</span><span class="id"> _</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> &amp;</span><span class="id"> isSFinite</span><span class="id"> _</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> s_finite</span><span class="id"> {d</span><span class="id"> T</span><span class="id"> R}</span><span class="id"> _</span>.<br/>
<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.1.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `isSFinite.Build`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span> <span class="id">&quot;Measure_isSFinite_subdef.Build&quot;</span><span class="id"> :=</span> (<span class="id">@isSFinite</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>) (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.1.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `s_finite`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> sfinite_measure_subdef</span><span class="id"> :=</span><span class="id"> s_finite</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'sfinite_measure' 'set' T '-&gt;' '\bar' R }&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">SFiniteMeasure</span>.<span class="id">type</span><span class="id"> T</span><span class="id"> R</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> T,</span><span class="id"> R</span><span class="gallina-kwd"> at</span><span class="id"> next</span><span class="id"> level,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;{ 'sfinite_measure'  'set'  T  '-&gt;'  '\bar'  R }&quot;</span>)<span class="id"> :</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> isSigmaFinite</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> {</span><span class="id"> sigma_finiteT</span><span class="id"> :</span><span class="id"> sigma_finite</span><span class="id"> setT</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=</span><span class="id">&quot;sigma_finite_content&quot;</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> SigmaFiniteContent</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> mu</span><span class="id"> of</span><span class="id"> @Content</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> &amp;</span><span class="id"> isSigmaFinite</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> sigma_finiteT</span><span class="id"> {d</span><span class="id"> T</span><span class="id"> R}</span><span class="id"> s</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> sigma_finiteT</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'sigma_finite_content' 'set' T '-&gt;' '\bar' R }&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">sigma_finite_content</span><span class="id"> T</span><span class="id"> R</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> T,</span><span class="id"> R</span><span class="gallina-kwd"> at</span><span class="id"> next</span><span class="id"> level,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;{ 'sigma_finite_content'  'set'  T  '-&gt;'  '\bar'  R }&quot;</span>)<br/>
&nbsp;&nbsp;<span class="id">:</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=</span><span class="id">&quot;sigma_finite_measure&quot;</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> SigmaFiniteMeasure</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> mu</span><span class="id"> of</span><span class="id"> @SFiniteMeasure</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> &amp;</span><span class="id"> isSigmaFinite</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'sigma_finite_measure' 'set' T '-&gt;' '\bar' R }&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">sigma_finite_measure</span><span class="id"> T</span><span class="id"> R</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> T,</span><span class="id"> R</span><span class="gallina-kwd"> at</span><span class="id"> next</span><span class="id"> level,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;{ 'sigma_finite_measure'  'set'  T  '-&gt;'  '\bar'  R }&quot;</span>)<br/>
&nbsp;&nbsp;<span class="id">:</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> Measure_isSigmaFinite</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> of</span><span class="id"> isMeasure</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mu</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> sigma_finiteT</span><span class="id"> :</span><span class="id"> sigma_finite</span><span class="id"> setT</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> of</span><span class="id"> @Measure_isSigmaFinite</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sfinite</span><span class="id"> :</span><span class="id"> sfinite_measure</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> sfinite_measure_sigma_finite;</span><span class="id"> exact:</span><span class="id"> sigma_finiteT</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @isSFinite</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mu</span><span class="id"> sfinite</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @isSigmaFinite</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mu</span><span class="id"> sigma_finiteT</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_finite_mzero</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">sigma_finite</span><span class="id"> setT</span> (<span class="id">@mzero</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> fin_num_fun_sigma_finite</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> measure0</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@isSigmaFinite</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mzero</span> (<span class="id">@sigma_finite_mzero</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sfinite_mzero</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">sfinite_measure</span> (<span class="id">@mzero</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> sfinite_measure_sigma_finite;</span><span class="id"> exact:</span><span class="id"> sigma_finite_mzero</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@isSFinite</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mzero</span> (<span class="id">@sfinite_mzero</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> isFinite</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numDomainType</span>)<br/>
&nbsp;&nbsp;(<span class="id">k</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> {</span><span class="id"> fin_num_measure</span><span class="id"> :</span><span class="id"> fin_num_fun</span><span class="id"> k</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> FinNumFun</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>)<span class="id"> :=</span><span class="id"> {</span><span class="id"> k</span><span class="id"> of</span><span class="id"> isFinite</span><span class="id"> _</span><span class="id"> T</span><span class="id"> R</span><span class="id"> k</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.1.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `isFinite.Build`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'@SigmaFinite_isFinite.Build' d T R k&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">@isFinite</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> k</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> d,</span><span class="id"> T,</span><span class="id"> R,</span><span class="id"> k</span><span class="gallina-kwd"> at</span><span class="id"> next</span><span class="id"> level,</span><span class="id"> only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> FiniteMeasure</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> k</span><span class="id"> of</span><span class="id"> @SigmaFiniteMeasure</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> k</span><span class="id"> &amp;</span><span class="id"> isFinite</span><span class="id"> _</span><span class="id"> T</span><span class="id"> R</span><span class="id"> k</span><span class="id"> }</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> fin_num_measure</span><span class="id"> {d</span><span class="id"> T</span><span class="id"> R}</span><span class="id"> _</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'finite_measure' 'set' T '-&gt;' '\bar' R }&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">FiniteMeasure</span>.<span class="id">type</span><span class="id"> T</span><span class="id"> R</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> T,</span><span class="id"> R</span><span class="gallina-kwd"> at</span><span class="id"> next</span><span class="id"> level,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;{ 'finite_measure'  'set'  T  '-&gt;'  '\bar'  R }&quot;</span>)<span class="id"> :</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> Measure_isFinite</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">k</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<br/>
&nbsp;&nbsp;<span class="id">of</span><span class="id"> isMeasure</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> k</span><span class="id"> :=</span><span class="id"> {</span><span class="id"> fin_num_measure</span><span class="id"> :</span><span class="id"> fin_num_fun</span><span class="id"> k</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<span class="id"> k</span><br/>
&nbsp;&nbsp;<span class="id">of</span><span class="id"> Measure_isFinite</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> k</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> sfinite</span><span class="id"> :</span><span class="id"> sfinite_measure</span><span class="id"> k</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> sfinite_measure_sigma_finite</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> fin_num_fun_sigma_finite;</span><span class="id"> [rewrite</span><span class="id"> measure0|exact:</span><span class="id"> fin_num_measure]</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @isSFinite</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> k</span><span class="id"> sfinite</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> sigma_finite</span><span class="id"> :</span><span class="id"> sigma_finite</span><span class="id"> setT</span><span class="id"> k</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> fin_num_fun_sigma_finite;</span><span class="id"> [rewrite</span><span class="id"> measure0|exact:</span><span class="id"> fin_num_measure]</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @isSigmaFinite</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> k</span><span class="id"> sigma_finite</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> finite</span><span class="id"> :</span><span class="id"> fin_num_fun</span><span class="id"> k</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> fin_num_measure</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @isFinite</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> k</span><span class="id"> finite</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> Measure_isSFinite</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">k</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> of</span><span class="id"> isMeasure</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> k</span><span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">s_finite</span><span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> s</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}^nat,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> U,</span><span class="id"> measurable</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> k</span><span class="id"> U</span><span class="id"> =</span><span class="id"> mseries</span><span class="id"> s</span><span class="id"> 0</span><span class="id"> U</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;<span class="id">k</span><span class="id"> of</span><span class="id"> Measure_isSFinite</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> k</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> sfinite</span><span class="id"> :</span><span class="id"> sfinite_measure</span><span class="id"> k</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [s</span><span class="id"> sE]</span><span class="id"> :=</span><span class="id"> s_finite</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=&gt;</span><span class="id"> n;</span><span class="id"> exact:</span><span class="id"> fin_num_measure</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @isSFinite</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> k</span><span class="id"> sfinite</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> sfinite_measure</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {sfinite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> s</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id">^nat</span><span class="id"> :=</span><span class="id"> let:</span><span class="id"> exist2</span><span class="id"> x</span><span class="id"> _</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> cid2</span> (<span class="id">s_finite</span><span class="id"> mu</span>)<span class="gallina-kwd"> in</span><span class="id"> x</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> s0</span><span class="id"> n</span><span class="id"> :</span><span class="id"> s</span><span class="id"> n</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /s;</span><span class="id"> case:</span><span class="id"> cid2</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> s_ge0</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> s</span><span class="id"> n</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /s;</span><span class="id"> case:</span><span class="id"> cid2</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> s_semi_sigma_additive</span><span class="id"> n</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span> (<span class="id">s</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /s;</span><span class="id"> case:</span><span class="id"> cid2</span><span class="id"> =&gt;</span><span class="id"> s'</span><span class="id"> s'1</span><span class="id"> s'2;</span><span class="id"> exact:</span><span class="id"> measure_semi_sigma_additive</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> @isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">s</span><span class="id"> n</span>) (<span class="id">s0</span><span class="id"> n</span>) (<span class="id">s_ge0</span><span class="id"> n</span>)<br/>
&nbsp;&nbsp;(<span class="id">@s_semi_sigma_additive</span><span class="id"> n</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> s_fin</span><span class="id"> n</span><span class="id"> :</span><span class="id"> fin_num_fun</span> (<span class="id">s</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /s;</span><span class="id"> case:</span><span class="id"> cid2</span><span class="id"> =&gt;</span><span class="id"> F</span><span class="id"> finF</span><span class="id"> muE;</span><span class="id"> exact:</span><span class="id"> finF</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> @Measure_isFinite</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span> (<span class="id">s</span><span class="id"> n</span>) (<span class="id">s_fin</span><span class="id"> n</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> sfinite_measure_seq</span><span class="id"> :</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}^nat</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [the</span><span class="id"> {finite_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span><span class="id"> of</span><span class="id"> s</span><span class="id"> n]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sfinite_measure_seqP</span><span class="id"> U</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> U</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> U</span><span class="id"> =</span><span class="id"> mseries</span><span class="id"> sfinite_measure_seq</span><span class="id"> O</span><span class="id"> U</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> mU;</span><span class="id"> rewrite</span><span class="id"> /mseries</span><span class="id"> /=</span><span class="id"> /s;</span><span class="id"> case:</span><span class="id"> cid2</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> xfin</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> sfinite_measure</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mfrestr</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>) (<span class="id">mD</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span>)<span class="id"> of</span><span class="id"> f</span><span class="id"> D</span><span class="id"> &lt;</span><span class="id"> +oo</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">mrestr</span><span class="id"> f</span><span class="id"> mD</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_frestr</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">mD</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> moo</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> D</span><span class="id"> &lt;</span><span class="id"> +oo</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> restr</span><span class="id"> :=</span> (<span class="id">mfrestr</span><span class="id"> mD</span><span class="id"> moo</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Measure</span>.<span class="id">on</span><span class="id"> restr</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> restr_fin</span><span class="id"> :</span><span class="id"> fin_num_fun</span><span class="id"> restr</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> U</span><span class="id"> mU;</span><span class="id"> rewrite</span><span class="id"> /restr</span><span class="id"> /mrestr</span><span class="id"> ge0_fin_numE</span><span class="id"> ?measure_ge0//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_lt_trans</span><span class="id"> _</span><span class="id"> moo</span>)<span class="id">//</span><span class="id"> le_measure//</span><span class="id"> ?inE//;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Measure_isFinite</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> restr</span><span class="id"> restr_fin</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> measure_frestr</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> isSubProbability</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;(<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> {</span><span class="id"> sprobability_setT</span><span class="id"> :</span><span class="id"> P</span><span class="id"> setT</span><span class="id"> &lt;=</span><span class="id"> 1%E</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=subprobability</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> SubProbability</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;<span class="id">:=</span><span class="id"> {mu</span><span class="id"> of</span><span class="id"> @FiniteMeasure</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> &amp;</span><span class="id"> isSubProbability</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.1.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `isSubProbability.Build`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'FiniteMeasure_isSubProbability.Build' d T R P&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">@isSubProbability</span>.<span class="id">Build</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> P</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> d,</span><span class="id"> T,</span><span class="id"> R,</span><span class="id"> P</span><span class="gallina-kwd"> at</span><span class="id"> next</span><span class="id"> level,</span><span class="id"> only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> Measure_isSubProbability</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> of</span><span class="id"> isMeasure</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> P</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> sprobability_setT</span><span class="id"> :</span><span class="id"> P</span><span class="id"> setT</span><span class="id"> &lt;=</span><span class="id"> 1%E</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;<span class="id">P</span><span class="id"> of</span><span class="id"> Measure_isSubProbability</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> P</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> finite</span><span class="id"> :</span><span class="id"> @Measure_isFinite</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> P</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split;</span><span class="id"> apply:</span><span class="id"> lty_fin_num_fun</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_lt_trans</span> (<span class="id">@sprobability_setT</span>))<span class="id">//</span><span class="id"> ltey</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> finite</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @isSubProbability</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> P</span><span class="id"> sprobability_setT</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> isProbability</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;(<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> {</span><span class="id"> probability_setT</span><span class="id"> :</span><span class="id"> P</span><span class="id"> setT</span><span class="id"> =</span><span class="id"> 1%E</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=probability</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> Probability</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{P</span><span class="id"> of</span><span class="id"> @SubProbability</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> P</span><span class="id"> &amp;</span><span class="id"> isProbability</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> P</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">gen_eqMixin</span> (<span class="id">probability</span><span class="id"> T</span><span class="id"> R</span>).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">gen_choiceMixin</span> (<span class="id">probability</span><span class="id"> T</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> probability_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> probability</span><span class="id"> T</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> probability_le1</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">@probability_setT</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> P</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> le_measure</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> ?in_setE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> probability_setC</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> P</span> (<span class="id">~`</span><span class="id"> A</span>)<span class="id"> =</span><span class="id"> 1</span><span class="id"> -</span><span class="id"> P</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">@probability_setT</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> P</span>)<span class="id"> -</span>(<span class="id">setvU</span><span class="id"> A</span>)<span class="id"> measureU</span><span class="id"> ?addeK</span><span class="id"> ?setICl//</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> fin_num_measure</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurableC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> probability_lemmas</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> Measure_isProbability</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> of</span><span class="id"> isMeasure</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> P</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> probability_setT</span><span class="id"> :</span><span class="id"> P</span><span class="id"> setT</span><span class="id"> =</span><span class="id"> 1%E</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;<span class="id">P</span><span class="id"> of</span><span class="id"> Measure_isProbability</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> P</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> subprobability</span><span class="id"> :</span><span class="id"> @Measure_isSubProbability</span><span class="id"> d</span><span class="id"> T</span><span class="id"> R</span><span class="id"> P</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> probability_setT</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> subprobability</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @isProbability</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> P</span><span class="id"> probability_setT</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> mnormalize</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> probability</span><span class="id"> T</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mnormalize</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> evidence</span><span class="id"> :=</span><span class="id"> mu</span><span class="id"> [set:</span><span class="id"> T]</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span> (<span class="id">evidence</span><span class="id"> ==</span><span class="id"> 0</span>)<span class="id"> ||</span> (<span class="id">evidence</span><span class="id"> ==</span><span class="id"> +oo</span>)<span class="gallina-kwd"> then</span><span class="gallina-kwd"> fun</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> P</span><span class="id"> U</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="gallina-kwd"> fun</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> mu</span><span class="id"> U</span><span class="id"> *</span> (<span class="id">fine</span><span class="id"> evidence</span>)<span class="id">^-1%:E</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> mnormalize0</span><span class="id"> :</span><span class="id"> mnormalize</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /mnormalize;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> measure0</span><span class="id"> mul0e</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mnormalize_ge0</span><span class="id"> U</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mnormalize</span><span class="id"> U</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /mnormalize;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> case:</span><span class="id"> ifPn</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> mnormalize_sigma_additive</span><span class="id"> :</span><span class="id"> semi_sigma_additive</span><span class="id"> mnormalize</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> rewrite</span><span class="id"> /mnormalize/=</span>.<br/>
<span class="id">case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> [_|_];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> measure_semi_sigma_additive</span>.<br/>
<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> @</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> \*</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">cst</span> (<span class="id">fine</span> (<span class="id">mu</span><span class="id"> setT</span>))<span class="id">^-1%:E</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/funext</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> -ge0_sume_distrl</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> cvgeMr</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measure_semi_sigma_additive</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mnormalize</span><br/>
&nbsp;&nbsp;<span class="id">mnormalize0</span><span class="id"> mnormalize_ge0</span><span class="id"> mnormalize_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> mnormalize1</span><span class="id"> :</span><span class="id"> mnormalize</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> =</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /mnormalize;</span><span class="id"> case:</span><span class="id"> ifPn;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> probability_setT</span>.<br/>
<span class="id">rewrite</span><span class="id"> negb_or</span><span class="id"> =&gt;</span><span class="id"> /andP[ft0</span><span class="id"> ftoo]</span>.<br/>
<span class="id">have</span><span class="id"> ?</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> setT</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ge0_fin_numE//</span><span class="id"> ltey</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{1}</span>(<span class="id">@fineK</span><span class="id"> _</span> (<span class="id">mu</span><span class="id"> setT</span>))<span class="id">//</span><span class="id"> -EFinM</span><span class="id"> divrr//</span><span class="id"> ?unitfE</span><span class="id"> fine_eq0</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Measure_isProbability</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mnormalize</span><span class="id"> mnormalize1</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> mnormalize</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> pdirac</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> x</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Measure_isProbability</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">@dirac</span><span class="id"> _</span><span class="id"> T</span><span class="id"> x</span><span class="id"> R</span>) (<span class="id">diracT</span><span class="id"> R</span><span class="id"> x</span>).<br/>
<br/>
<span class="vernacular">End</span><span class="id"> pdirac</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">isPointed</span>.<span class="id">Build</span> (<span class="id">probability</span><span class="id"> T</span><span class="id"> R</span>)<span class="id"> [the</span><span class="id"> probability</span><span class="id"> _</span><span class="id"> _</span><span class="id"> of</span><span class="id"> dirac</span><span class="id"> point]</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> dist_sigma_algebra_instance</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mset</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> [set</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> probability</span><span class="id"> T</span><span class="id"> R</span><span class="id"> |</span><span class="id"> mu</span><span class="id"> U</span><span class="id"> &lt;</span><span class="id"> r%:E]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lt0_mset</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span> (<span class="id">r</span><span class="id"> &lt;</span><span class="id"> 0</span>)<span class="id">%R</span><span class="id"> -&gt;</span><span class="id"> mset</span><span class="id"> U</span><span class="id"> r</span><span class="id"> =</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> r0;</span><span class="id"> apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x/=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/negP;</span><span class="id"> rewrite</span><span class="id"> -leNgt</span> (<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span><span class="id"> 0</span>)<span class="id">//</span><span class="id"> lee_fin</span><span class="id"> ltW</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gt1_mset</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> U</span><span class="id"> -&gt;</span> (<span class="id">1</span><span class="id"> &lt;</span><span class="id"> r</span>)<span class="id">%R</span><span class="id"> -&gt;</span><span class="id"> mset</span><span class="id"> U</span><span class="id"> r</span><span class="id"> =</span><span class="id"> [set:</span><span class="id"> probability</span><span class="id"> T</span><span class="id"> R]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mU</span><span class="id"> r1;</span><span class="id"> apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x/=</span><span class="id"> _</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /mset/=</span> (<span class="id">le_lt_trans</span> (<span class="id">probability_le1</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> pset</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span> (<span class="id">probability</span><span class="id"> T</span><span class="id"> R</span>))<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> mset</span><span class="id"> U</span><span class="id"> r</span><span class="id"> |</span><span class="id"> r</span><span class="gallina-kwd"> in</span><span class="id"> `[0%R,1%R]</span><span class="id"> &amp;</span><span class="id"> U</span><span class="gallina-kwd"> in</span><span class="id"> measurable]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> pprobability</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> pset</span>.<span class="id">-sigma</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[the</span><span class="id"> measurableType</span><span class="id"> _</span><span class="id"> of</span><span class="id"> g_sigma_algebraType</span><span class="id"> pset]</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> dist_sigma_algebra_instance</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_finite_counting</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">sigma_finite</span><span class="id"> [set:</span><span class="id"> nat]</span> (<span class="id">@counting</span><span class="id"> _</span><span class="id"> R</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">exists</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> `I_n</span>.<span class="id">+1</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/seteqP;</span><span class="id"> split=&gt;</span><span class="id"> //x</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> k;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> /counting/=</span><span class="id"> asboolT//</span><span class="id"> ltry</span>.<br/>
Qed.</div></details>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@isSigmaFinite</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">@counting</span><span class="id"> _</span><span class="id"> R</span>) (<span class="id">sigma_finite_counting</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> content_semiRingOfSetsType</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>).<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">mA</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span>) (<span class="id">mB</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> B</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measureIl</span><span class="id"> :</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> le_measure</span><span class="id"> ?inE//;</span><span class="id"> apply:</span><span class="id"> measurableI</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measureIr</span><span class="id"> :</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> le_measure</span><span class="id"> ?inE//;</span><span class="id"> apply:</span><span class="id"> measurableI</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subset_measure0</span><span class="id"> :</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> B</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> B0;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -measure_le0</span><span class="id"> -B0</span><span class="id"> le_measure</span><span class="id"> ?inE</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> content_semiRingOfSetsType</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> content_ringOfSetsType</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measureDI</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> A</span><span class="id"> =</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `\`</span><span class="id"> B</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span><span class="id"> mB;</span><span class="id"> rewrite</span><span class="id"> -measure_semi_additive2</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setDDr</span><span class="id"> setDv</span><span class="id"> setD0</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurableD</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measurableU;</span><span class="id"> [exact:</span><span class="id"> measurableD</span><span class="id"> |exact:</span><span class="id"> measurableI]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> setIACA</span><span class="id"> setICl</span><span class="id"> setI0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measureD</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> A</span><span class="id"> &lt;</span><span class="id"> +oo</span><span class="id"> -&gt;</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `\`</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> -</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span><span class="id"> mB</span><span class="id"> mAoo</span>.<br/>
<span class="id">rewrite</span> (<span class="id">measureDI</span><span class="id"> mA</span><span class="id"> mB</span>)<span class="id"> addeK//</span><span class="id"> fin_numE</span><span class="id"> 1?gt_eqF</span><span class="id"> 1?lt_eqF//</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">le_lt_trans</span><span class="id"> _</span><span class="id"> mAoo</span>)<span class="id">//</span><span class="id"> le_measure</span><span class="id"> //</span><span class="id"> ?inE//;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">lt_le_trans</span><span class="id"> _</span> (<span class="id">measure_ge0</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measureU2</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> +</span><span class="id"> mu</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> -bigcup2inE</span><span class="id"> bigcup_mkord</span>.<br/>
<span class="id">rewrite</span> (<span class="id">le_trans</span> (<span class="id">@content_subadditive</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mu</span><span class="id"> _</span> (<span class="id">bigcup2</span><span class="id"> A</span><span class="id"> B</span>)<span class="id"> 2%N</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>))<span class="id">//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> -[//|[//|[|]]]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable</span><span class="id"> =&gt;</span><span class="id"> -[]</span><span class="id"> [//|[//|[|]]]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_ord_recr/=</span><span class="id"> big_ord_recr/=</span><span class="id"> big_ord0</span><span class="id"> add0e</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> content_ringOfSetsType</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measureU</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measureUfinr</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> B</span><span class="id"> &lt;</span><span class="id"> +oo</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> +</span><span class="id"> mu</span><span class="id"> B</span><span class="id"> -</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Am</span><span class="id"> Bm</span><span class="id"> mBfin;</span><span class="id"> rewrite</span><span class="id"> -[B</span><span class="gallina-kwd"> in</span><span class="id"> LHS]</span>(<span class="id">setDUK</span> (<span class="id">@subIsetl</span><span class="id"> _</span><span class="id"> _</span><span class="id"> A</span>))<span class="id"> setUA</span>.<br/>
<span class="id">rewrite</span><span class="id"> [A</span><span class="id"> `|`</span><span class="id"> _]setUidl;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> subIsetr</span>.<br/>
<span class="id">rewrite</span><span class="id"> measureU//=;</span><span class="id"> [|rewrite</span><span class="id"> setDIr</span><span class="id"> setDv</span><span class="id"> set0U</span><span class="id"> ?setDIK//</span>..<span class="id">]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> measureD//</span><span class="id"> ?setIA</span><span class="id"> ?setIid</span><span class="id"> 1?setIC</span><span class="id"> ?addeA//;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurableD</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measureUfinl</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> &lt;</span><span class="id"> +oo</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> +</span><span class="id"> mu</span><span class="id"> B</span><span class="id"> -</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> setUC</span><span class="id"> measureUfinr//</span><span class="id"> setIC</span><span class="id"> [mu</span><span class="id"> B</span><span class="id"> +</span><span class="id"> _]addeC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> null_set_setU</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> A</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> B</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span><span class="id"> mB</span><span class="id"> A0</span><span class="id"> B0;</span><span class="id"> rewrite</span><span class="id"> measureUfinl/=</span><span class="id"> ?A0//=</span><span class="id"> ?B0</span><span class="id"> ?add0e</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> oppe_eq0</span><span class="id"> -measure_le0/=</span><span class="id"> -A0</span><span class="id"> measureIl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measureU0</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> B</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> mu</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span><span class="id"> mB</span><span class="id"> B0;</span><span class="id"> rewrite</span><span class="id"> measureUfinr/=</span><span class="id"> ?B0//</span><span class="id"> adde0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">@subset_measure0</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> B</span>)<span class="id"> ?sube0//;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> measureU</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_measureU</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> mu'</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id">:</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> A</span><span class="id"> =</span><span class="id"> mu'</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> B</span><span class="id"> =</span><span class="id"> mu'</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> mu'</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> mu'</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span><span class="id"> mB</span><span class="id"> muA</span><span class="id"> muB</span><span class="id"> muAB;</span><span class="id"> have</span><span class="id"> [mu'ANoo|]</span><span class="id"> :=</span><span class="id"> ltP</span> (<span class="id">mu'</span><span class="id"> A</span>)<span class="id"> +oo</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !measureUfinl/=</span><span class="id"> ?muA</span><span class="id"> ?muB</span><span class="id"> ?muAB</span>.<br/>
<span class="id">rewrite</span><span class="id"> leye_eq</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> mu'A;</span><span class="id"> transitivity</span> (<span class="id">+oo</span><span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id">;</span><span class="id"> apply/eqP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -leye_eq</span><span class="id"> -mu'A</span><span class="id"> -muA</span><span class="id"> le_measure</span><span class="id"> ?inE//=;</span><span class="id"> apply:</span><span class="id"> measurableU</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> -leye_eq</span><span class="id"> -mu'A</span><span class="id"> le_measure</span><span class="id"> ?inE//=;</span><span class="id"> apply:</span><span class="id"> measurableU</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_continuity</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nondecreasing_cvg_mu</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ^nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">\bigcup_n</span><span class="id"> F</span><span class="id"> n</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">nondecreasing_seq</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> \o</span><span class="id"> F</span><span class="id"> @</span><span class="id"> \oo</span><span class="id"> --&gt;</span><span class="id"> mu</span> (<span class="id">\bigcup_n</span><span class="id"> F</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mF</span><span class="id"> mbigcupF</span><span class="id"> ndF</span>.<br/>
<span class="id">have</span><span class="id"> Binter</span><span class="id"> :</span><span class="id"> trivIset</span><span class="id"> setT</span> (<span class="id">seqD</span><span class="id"> F</span>)<span class="id"> :=</span><span class="id"> trivIset_seqD</span><span class="id"> ndF</span>.<br/>
<span class="id">have</span><span class="id"> FBE</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> n,</span><span class="id"> F</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> =</span><span class="id"> F</span><span class="id"> n</span><span class="id"> `|`</span><span class="id"> seqD</span><span class="id"> F</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> :=</span><span class="id"> setU_seqD</span><span class="id"> ndF</span>.<br/>
<span class="id">have</span><span class="id"> FE</span><span class="id"> n</span><span class="id"> :</span><span class="id"> \big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>.<span class="id">+1</span>) (<span class="id">seqD</span><span class="id"> F</span>)<span class="id"> i</span><span class="id"> =</span><span class="id"> F</span><span class="id"> n</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">nondecreasing_bigsetU_seqD</span><span class="id"> n</span><span class="id"> ndF</span>.<br/>
<span class="id">rewrite</span><span class="id"> -eq_bigcup_seqD</span>.<br/>
<span class="id">have</span><span class="id"> mB</span><span class="id"> i</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">seqD</span><span class="id"> F</span><span class="id"> i</span>)<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> *</span><span class="id"> //=;</span><span class="id"> exact:</span><span class="id"> measurableD</span>.<br/>
<span class="id">apply:</span><span class="id"> cvg_trans</span> (<span class="id">measure_semi_sigma_additive</span><span class="id"> _</span><span class="id"> mB</span><span class="id"> Binter</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eq_bigcup_seqD</span>.<br/>
<span class="id">apply:</span> (<span class="id">@cvg_trans</span><span class="id"> _</span> (<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id"> mu</span> (<span class="id">seqD</span><span class="id"> F</span><span class="id"> i</span>)<span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> X</span><span class="id"> @</span><span class="id"> \oo]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> mu</span><span class="id"> \o</span><span class="id"> F</span>)<span class="id"> //</span><span class="id"> funeqE</span><span class="id"> =&gt;</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -measure_semi_additive</span><span class="id"> ?FE//</span><span class="id"> =&gt;</span><span class="id"> -[|]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> S</span><span class="id"> [n</span><span class="id"> _]</span><span class="id"> nS;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> m</span><span class="id"> nm</span>.<br/>
<span class="id">under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">big_mkord</span><span class="id"> predT</span> (<span class="id">mu</span><span class="id"> \o</span><span class="id"> seqD</span><span class="id"> F</span>)).<br/>
<span class="id">exact/</span>(<span class="id">nS</span><span class="id"> m</span>.<span class="id">+1</span>)<span class="id">/</span>(<span class="id">leq_trans</span><span class="id"> nm</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nonincreasing_cvg_mu</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> algebraOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ^nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">F</span><span class="id"> 0%N</span>)<span class="id"> &lt;</span><span class="id"> +oo</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">\bigcap_n</span><span class="id"> F</span><span class="id"> n</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">nonincreasing_seq</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> \o</span><span class="id"> F</span><span class="id"> @</span><span class="id"> \oo</span><span class="id"> --&gt;</span><span class="id"> mu</span> (<span class="id">\bigcap_n</span><span class="id"> F</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F0pos</span><span class="id"> mF</span><span class="id"> mbigcapF</span><span class="id"> niF;</span><span class="id"> pose</span><span class="id"> G</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> F</span><span class="id"> O</span><span class="id"> `\`</span><span class="id"> F</span><span class="id"> n</span>.<br/>
<span class="id">have</span><span class="id"> ?</span><span class="id"> :</span><span class="id"> mu</span> (<span class="id">F</span><span class="id"> 0%N</span>)<span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ge0_fin_numE</span>.<br/>
<span class="id">have</span><span class="id"> F0E</span><span class="id"> r</span><span class="id"> :</span><span class="id"> mu</span> (<span class="id">F</span><span class="id"> 0%N</span>)<span class="id"> -</span> (<span class="id">mu</span> (<span class="id">F</span><span class="id"> 0%N</span>)<span class="id"> -</span><span class="id"> r</span>)<span class="id"> =</span><span class="id"> r</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oppeB</span><span class="id"> ?addeA</span><span class="id"> ?subee</span><span class="id"> ?add0e//</span><span class="id"> fin_num_adde_defr</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[x</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> x]</span><span class="id"> F0E</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> \o</span><span class="id"> F</span><span class="id"> =</span><span class="gallina-kwd"> fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> mu</span> (<span class="id">F</span><span class="id"> 0%N</span>)<span class="id"> -</span> (<span class="id">mu</span> (<span class="id">F</span><span class="id"> 0%N</span>)<span class="id"> -</span><span class="id"> mu</span> (<span class="id">F</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> funext</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> F0E</span>.<br/>
<span class="id">apply:</span><span class="id"> cvgeB;</span><span class="id"> rewrite</span><span class="id"> ?fin_num_adde_defr//;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> cvg_cst</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> \bigcap_n</span><span class="id"> F</span><span class="id"> n</span><span class="id"> =</span><span class="id"> F</span><span class="id"> 0%N</span><span class="id"> `&amp;`</span><span class="id"> \bigcap_n</span><span class="id"> F</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIidr//;</span><span class="id"> exact:</span><span class="id"> bigcap_inf</span>.<br/>
<span class="id">rewrite</span><span class="id"> -measureD</span><span class="id"> //</span><span class="id"> setDE</span><span class="id"> setC_bigcap</span><span class="id"> setI_bigcupr</span><span class="id"> -[x</span><span class="gallina-kwd"> in</span><span class="id"> bigcup</span><span class="id"> _</span><span class="id"> x]/G</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> mu</span> (<span class="id">F</span><span class="id"> 0%N</span>)<span class="id"> -</span><span class="id"> mu</span> (<span class="id">F</span><span class="id"> n</span>))<span class="id"> =</span><span class="id"> mu</span><span class="id"> \o</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> funext</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> measureD//</span><span class="id"> setIidr//;</span><span class="id"> exact/subsetPset/niF</span>.<br/>
<span class="id">apply:</span><span class="id"> nondecreasing_cvg_mu</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> apply:</span><span class="id"> measurableD;</span><span class="id"> exact:</span><span class="id"> mF</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> -setI_bigcupr;</span><span class="id"> apply:</span><span class="id"> measurableI;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> mF</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -@setC_bigcap;</span><span class="id"> exact:</span><span class="id"> measurableC</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> m</span><span class="id"> NM;</span><span class="id"> apply/subsetPset;</span><span class="id"> apply:</span><span class="id"> setDS;</span><span class="id"> apply/subsetPset/niF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> measure_continuity</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> lim_sup_set</span><span class="id"> T</span> (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>)<span class="id"> :=</span><span class="id"> \bigcap_n</span><span class="id"> \bigcup_</span>(<span class="id">j</span><span class="id"> &gt;=</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> j</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> borel_cantelli_realFieldType</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {d}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d}</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realFieldType}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lim_sup_set_ub</span><span class="id"> F</span><span class="id"> n</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> k</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">lim_sup_set</span><span class="id"> F</span>)<span class="id"> &lt;=</span><span class="id"> mu</span> (<span class="id">\bigcup_</span>(<span class="id">k</span><span class="id"> &gt;=</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> k</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mF;</span><span class="id"> rewrite</span><span class="id"> /lim_sup_set</span><span class="id"> le_measure//</span><span class="id"> ?inE/=</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> bigcap_measurable</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> bigcup_measurable</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> bigcup_measurable</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> bigcap_inf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lim_sup_set_cvg</span><span class="id"> F</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> k</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\bigcup_</span>(<span class="id">k</span><span class="id"> &gt;=</span><span class="id"> 0</span>)<span class="id"> F</span><span class="id"> k</span>)<span class="id"> &lt;</span><span class="id"> +oo</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\bigcup_</span>(<span class="id">k</span><span class="id"> &gt;=</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> k</span>)<span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span><span class="id"> --&gt;</span><span class="id"> mu</span> (<span class="id">lim_sup_set</span><span class="id"> F</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mF</span><span class="id"> mFoo;</span><span class="id"> apply:</span><span class="id"> nonincreasing_cvg_mu</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> apply:</span><span class="id"> bigcup_measurable</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> /=</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> mF</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> bigcap_measurable</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> k</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_measurable</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> /=</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> mF</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> m</span><span class="id"> n</span><span class="id"> mn;</span><span class="id"> apply/subsetPset</span><span class="id"> =&gt;</span><span class="id"> t</span><span class="id"> [k</span><span class="id"> /=</span><span class="id"> nk</span><span class="id"> Akt]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span> (<span class="id">leq_trans</span><span class="id"> mn</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> borel_cantelli_realFieldType</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> lim_sup_set_cvg</span><span class="id"> {d</span><span class="id"> T</span><span class="id"> R}</span><span class="id"> mu</span><span class="id"> F</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> borel_cantelli</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>)<span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lim_sup_set_cvg0</span><span class="id"> F</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> k</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">n</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> n</span>)<span class="id"> &lt;</span><span class="id"> +oo</span><span class="id"> -&gt;</span><span class="id"> mu</span> (<span class="id">lim_sup_set</span><span class="id"> F</span>)<span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mF</span><span class="id"> bigUoo;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le</span><span class="id"> measure_ge0</span><span class="id"> andbT</span>.<br/>
<span class="id">have</span><span class="id"> /cvg_lim</span><span class="id"> &lt;-</span><span class="id"> //</span><span class="id"> :</span> (<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> n</span>))<span class="id">%E</span><span class="id"> @[i</span><span class="id"> --&gt;</span><span class="id"> \oo]</span><span class="id"> --&gt;</span><span class="id"> 0%E</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> nneseries_tail_cvg</span>.<br/>
<span class="id">apply:</span><span class="id"> lime_ge;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/cvg_ex;</span><span class="gallina-kwd"> exists</span><span class="id"> 0;</span><span class="id"> exact:</span><span class="id"> nneseries_tail_cvg</span>.<br/>
<span class="id">apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span> (<span class="id">le_trans</span> (<span class="id">lim_sup_set_ub</span><span class="id"> mu</span><span class="id"> n</span><span class="id"> mF</span>))<span class="id">//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measure_sigma_subadditive_tail</span><span class="id"> =&gt;</span><span class="id"> //;</span><br/>
&nbsp;&nbsp;<span class="id">[exact:</span><span class="id"> bigcup_measurable|rewrite</span><span class="id"> -setC_I]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> borel_cantelli</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> g_sigma_algebra_measure_unique_trace</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">mD</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span>).<br/>
<span class="vernacular">Let</span><span class="id"> H</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> X</span><span class="id"> |</span><span class="id"> G</span><span class="id"> X</span><span class="id"> /\</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> D]</span> .<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">Hm</span><span class="id"> :</span><span class="id"> H</span><span class="id"> `&lt;=`</span><span class="id"> measurable</span>) (<span class="id">setIH</span><span class="id"> :</span><span class="id"> setI_closed</span><span class="id"> H</span>).<br/>
<span class="vernacular">Variables</span><span class="id"> m1</span><span class="id"> m2</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> m1m2D</span><span class="id"> :</span><span class="id"> m1</span><span class="id"> D</span><span class="id"> =</span><span class="id"> m2</span><span class="id"> D</span>.<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">m1m2</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> H</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> m1</span><span class="id"> A</span><span class="id"> =</span><span class="id"> m2</span><span class="id"> A</span>) (<span class="id">m1oo</span><span class="id"> :</span> (<span class="id">m1</span><span class="id"> D</span><span class="id"> &lt;</span><span class="id"> +oo</span>)<span class="id">%E</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> g_sigma_algebra_measure_unique_trace</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> X,</span> (<span class="id">&lt;&lt;s</span><span class="id"> D,</span><span class="id"> H</span><span class="id"> &gt;&gt;</span>)<span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> D</span>)<span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> X,</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> H</span><span class="id"> &gt;&gt;</span><span class="id"> X</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">m1</span><span class="id"> X</span><span class="id"> =</span><span class="id"> m2</span><span class="id"> X</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sDHD;</span><span class="id"> set</span><span class="id"> E</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> |</span><span class="id"> [/\</span><span class="id"> measurable</span><span class="id"> A,</span><span class="id"> m1</span><span class="id"> A</span><span class="id"> =</span><span class="id"> m2</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> D]</span><span class="id"> ]</span>.<br/>
<span class="id">have</span><span class="id"> HE</span><span class="id"> :</span><span class="id"> H</span><span class="id"> `&lt;=`</span><span class="id"> E</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> HX;</span><span class="id"> rewrite</span><span class="id"> /E</span><span class="id"> /=;</span><span class="id"> split;</span><span class="id"> [exact:</span><span class="id"> Hm|exact:</span><span class="id"> m1m2|case:</span><span class="id"> HX]</span>.<br/>
<span class="id">have</span><span class="id"> setDE</span><span class="id"> :</span><span class="id"> setSD_closed</span><span class="id"> E</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> BA</span><span class="id"> [mA</span><span class="id"> m1m2A</span><span class="id"> AD]</span><span class="id"> [mB</span><span class="id"> m1m2B</span><span class="id"> BD];</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> measurableD</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> measureD//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_lt_trans</span><span class="id"> _</span><span class="id"> m1oo</span>)<span class="id">//;</span><span class="id"> apply:</span><span class="id"> le_measure</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> /[!inE]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setIidr//=</span><span class="id"> m1m2A</span><span class="id"> m1m2B</span><span class="id"> measureD//</span><span class="id"> ?setIidr//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_lt_trans</span><span class="id"> _</span><span class="id"> m1oo</span>)<span class="id">//=</span><span class="id"> -m1m2A;</span><span class="id"> apply:</span><span class="id"> le_measure</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> /[!inE]</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setDE;</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left</span>.<br/>
<span class="id">have</span><span class="id"> ndE</span><span class="id"> :</span><span class="id"> ndseq_closed</span><span class="id"> E</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> ndA</span><span class="id"> EA;</span><span class="id"> split;</span><span class="id"> have</span><span class="id"> mA</span><span class="id"> n</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">A</span><span class="id"> n</span>)<span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> EA</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> bigcupT_measurable</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> transitivity</span> (<span class="id">limn</span> (<span class="id">m1</span><span class="id"> \o</span><span class="id"> A</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/esym/cvg_lim=&gt;//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact/</span>(<span class="id">nondecreasing_cvg_mu</span><span class="id"> mA</span><span class="id"> _</span><span class="id"> ndA</span>)<span class="id">/bigcupT_measurable</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transitivity</span> (<span class="id">limn</span> (<span class="id">m2</span><span class="id"> \o</span><span class="id"> A</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/congr_lim/funext</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> EA</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/cvg_lim</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact/</span>(<span class="id">nondecreasing_cvg_mu</span><span class="id"> mA</span><span class="id"> _</span><span class="id"> ndA</span>)<span class="id">/bigcupT_measurable</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> bigcup_sub</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> EA</span><span class="id"> n</span>.<br/>
<span class="id">have</span><span class="id"> sDHE</span><span class="id"> :</span><span class="id"> &lt;&lt;s</span><span class="id"> D,</span><span class="id"> H</span><span class="id"> &gt;&gt;</span><span class="id"> `&lt;=`</span><span class="id"> E</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> lambda_system_subset</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> [move=&gt;</span><span class="id"> ?</span><span class="id"> []|split]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> /sDHE[]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> g_sigma_algebra_measure_unique_trace</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> g_sigma_algebra_measure_unique_trace</span><span class="id"> {d</span><span class="id"> R</span><span class="id"> T}</span><span class="id"> G</span><span class="id"> D</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.2.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `g_sigma_algebra_measure_unique_trace`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> g_salgebra_measure_unique_trace</span><span class="id"> :=</span><span class="id"> g_sigma_algebra_measure_unique_trace</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> boole_inequality</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Theorem</span><span class="id"> Boole_inequality</span> (<span class="id">A</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ^nat</span>)<span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span> (<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">A</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> A</span><span class="id"> i</span>)<span class="id"> &lt;=</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">A</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Am;</span><span class="id"> rewrite</span><span class="id"> content_subadditive//</span><span class="id"> -bigcup_mkord</span>.<br/>
<span class="id">exact:</span><span class="id"> fin_bigcup_measurable</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> boole_inequality</span>.<br/>
<span class="vernacular">Notation</span><span class="id"> le_mu_bigsetU</span><span class="id"> :=</span><span class="id"> Boole_inequality</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> sigma_finite_lemma</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sigma_finiteP</span><span class="id"> :</span><span class="id"> sigma_finite</span><span class="id"> A</span><span class="id"> mu</span><span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> F,</span><span class="id"> [/\</span><span class="id"> A</span><span class="id"> =</span><span class="id"> \bigcup_i</span><span class="id"> F</span><span class="id"> i,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">nondecreasing_seq</span><span class="id"> F</span><span class="id"> &amp;</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>)<span class="id"> /\</span><span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>)<span class="id"> &lt;</span><span class="id"> +oo]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [[F</span><span class="id"> AUF</span><span class="id"> mF]|[F</span><span class="id"> [?</span><span class="id"> ?</span><span class="id"> ?]]];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> F</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id">;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> AUF;</span><span class="id"> apply/seteqP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subset_bigcup</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> bigsetU_sup</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigcup_sub</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> bigsetU_bigcup</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> ij;</span><span class="id"> exact/subsetPset/subset_bigsetU</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> exact:</span> (<span class="id">mF</span><span class="id"> j</span>).<span class="id">1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">le_lt_trans</span> (<span class="id">Boole_inequality</span><span class="id"> _</span><span class="id"> _</span>))<span class="id">//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> exact:</span> (<span class="id">mF</span><span class="id"> _</span>).<span class="id">1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/lte_sum_pinfty</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> exact:</span> (<span class="id">mF</span><span class="id"> j</span>).<span class="id">2</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> sigma_finite_lemma</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> generalized_boole_inequality</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Theorem</span><span class="id"> generalized_Boole_inequality</span> (<span class="id">A</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ^nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> measurable</span> (<span class="id">A</span><span class="id"> i</span>))<span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">\bigcup_n</span><span class="id"> A</span><span class="id"> n</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\bigcup_n</span><span class="id"> A</span><span class="id"> n</span>)<span class="id"> &lt;=</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">A</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Am</span><span class="id"> UAm;</span><span class="id"> rewrite</span><span class="id"> measure_sigma_subadditive</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> generalized_boole_inequality</span>.<br/>
<span class="vernacular">Notation</span><span class="id"> le_mu_bigcup</span><span class="id"> :=</span><span class="id"> generalized_Boole_inequality</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> negligible</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> negligible</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> N</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> A,</span><span class="id"> [/\</span><span class="id"> measurable</span><span class="id"> A,</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> &amp;</span><span class="id"> N</span><span class="id"> `&lt;=`</span><span class="id"> A]</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;mu .-negligible&quot;</span><span class="id"> :=</span> (<span class="id">negligible</span><span class="id"> mu</span>).<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> negligibleP</span><span class="id"> A</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> mu</span>.<span class="id">-negligible</span><span class="id"> A</span><span class="id"> &lt;-&gt;</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [[B</span><span class="id"> [mB</span><span class="id"> mB0</span><span class="id"> AB]]|mA0];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> A;</span><span class="id"> split</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -measure_le0</span><span class="id"> -mB0</span><span class="id"> le_measure</span><span class="id"> ?inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> negligible_set0</span><span class="id"> :</span><span class="id"> mu</span>.<span class="id">-negligible</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/negligibleP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_negligible</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> mu</span>.<span class="id">-negligible</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> =</span><span class="id"> 0%E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> mA</span><span class="id"> /negligibleP</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> negligibleS</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> mu</span>.<span class="id">-negligible</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> mu</span>.<span class="id">-negligible</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> BA</span><span class="id"> [N</span><span class="id"> [mN</span><span class="id"> N0</span><span class="id"> AN]];</span><span class="gallina-kwd"> exists</span><span class="id"> N;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> subset_trans</span><span class="id"> AN</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> negligibleI</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">mu</span>.<span class="id">-negligible</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> mu</span>.<span class="id">-negligible</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> mu</span>.<span class="id">-negligible</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [N</span><span class="id"> [mN</span><span class="id"> N0</span><span class="id"> AN]]</span><span class="id"> [M</span><span class="id"> [mM</span><span class="id"> M0</span><span class="id"> BM]];</span><span class="gallina-kwd"> exists</span> (<span class="id">N</span><span class="id"> `&amp;`</span><span class="id"> M</span>)<span class="id">;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -measure_le0</span><span class="id"> -N0</span><span class="id"> le_measure</span><span class="id"> ?inE//;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> setISS</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> negligible</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;mu .-negligible&quot;</span><span class="id"> :=</span> (<span class="id">negligible</span><span class="id"> mu</span>)<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> measure_is_complete</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">mu</span>.<span class="id">-negligible</span><span class="id"> `&lt;=`</span><span class="id"> measurable</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> negligible_ringOfSetsType</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> negligibleU</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">mu</span>.<span class="id">-negligible</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> mu</span>.<span class="id">-negligible</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> mu</span>.<span class="id">-negligible</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [N</span><span class="id"> [mN</span><span class="id"> N0</span><span class="id"> AN]]</span><span class="id"> [M</span><span class="id"> [mM</span><span class="id"> M0</span><span class="id"> BM]];</span><span class="gallina-kwd"> exists</span> (<span class="id">N</span><span class="id"> `|`</span><span class="id"> M</span>)<span class="id">;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurableU</span>.<br/>
<span class="id">-</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -measure_le0</span><span class="id"> -N0</span><span class="id"> -[leRHS]adde0</span><span class="id"> -M0</span><span class="id"> -bigsetU_bigcup2</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> le_trans</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> apply:</span> (<span class="id">@content_subadditive</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">bigcup2</span><span class="id"> N</span><span class="id"> M</span>)<span class="id"> 2%N</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">*</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [|[|[|]]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">*</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /bigcup2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i0;</span><span class="id"> case:</span><span class="id"> ifPn</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> big_ord_recr/=</span><span class="id"> big_ord_recr/=</span><span class="id"> big_ord0</span><span class="id"> add0e</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> setUSS</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> negligible_bigsetU</span> (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>)<span class="id"> s</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> P</span><span class="id"> k</span><span class="id"> -&gt;</span><span class="id"> mu</span>.<span class="id">-negligible</span> (<span class="id">F</span><span class="id"> k</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span>.<span class="id">-negligible</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">k</span><span class="id"> &lt;-</span><span class="id"> s</span><span class="id"> |</span><span class="id"> P</span><span class="id"> k</span>)<span class="id"> F</span><span class="id"> k</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> PF;</span><span class="id"> elim/big_ind</span><span class="id"> :</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> //;</span><br/>
&nbsp;&nbsp;<span class="id">[exact:</span><span class="id"> negligible_set0|exact:</span><span class="id"> negligibleU]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> negligible_ringOfSetsType</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> negligible_bigcup</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> mu</span>.<span class="id">-negligible</span> (<span class="id">F</span><span class="id"> k</span>))<span class="id"> -&gt;</span><span class="id"> mu</span>.<span class="id">-negligible</span> (<span class="id">\bigcup_k</span><span class="id"> F</span><span class="id"> k</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mF;</span><span class="gallina-kwd"> exists</span> (<span class="id">\bigcup_k</span><span class="id"> sval</span> (<span class="id">cid</span> (<span class="id">mF</span><span class="id"> k</span>)))<span class="id">;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> bigcupT_measurable</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> k;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> svalP</span> (<span class="id">cid</span> (<span class="id">mF</span><span class="id"> k</span>)).<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> seqDU_bigcup_eq</span><span class="id"> measure_bigcup//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> measurableD;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> A</span><span class="id"> []</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> A</span><span class="id"> []</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> eseries0//</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> _</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [mFk</span><span class="id"> mFk0</span><span class="id"> ?]</span><span class="id"> :=</span><span class="id"> svalP</span> (<span class="id">cid</span> (<span class="id">mF</span><span class="id"> k</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> measureD//=</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> rewrite</span><span class="id"> mFk0</span><span class="id"> sub0e</span><span class="id"> eqe_oppLRP</span><span class="id"> oppe0;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -measure_le0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -[leRHS]mFk0</span><span class="id"> le_measure//=</span><span class="id"> ?inE//;</span><span class="id"> apply:</span><span class="id"> measurableI</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> A</span><span class="id"> []</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> A</span><span class="id"> []</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mFk0</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> subset_bigcup</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /sval/=;</span><span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> cid</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> A</span><span class="id"> []</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> ae</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> almost_everywhere</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :=</span><span class="id"> mu</span>.<span class="id">-negligible</span> (<span class="id">~`</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> |</span><span class="id"> P</span><span class="id"> x]</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> almost_everywhereT</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> :</span><span class="id"> almost_everywhere</span><span class="id"> mu</span><span class="id"> setT</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /almost_everywhere</span><span class="id"> setCT;</span><span class="id"> exact:</span><span class="id"> negligible_set0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> almost_everywhereS</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">almost_everywhere</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> almost_everywhere</span><span class="id"> mu</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> AB;</span><span class="id"> apply:</span><span class="id"> negligibleS;</span><span class="id"> exact:</span><span class="id"> subsetC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> almost_everywhereI</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">almost_everywhere</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> almost_everywhere</span><span class="id"> mu</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">almost_everywhere</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /almost_everywhere</span><span class="id"> =&gt;</span><span class="id"> mA</span><span class="id"> mB;</span><span class="id"> rewrite</span><span class="id"> setCI;</span><span class="id"> exact:</span><span class="id"> negligibleU</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">#[global]</span><br/>
<span class="vernacular">Instance</span><span class="id"> ae_filter_ringOfSetsType</span><span class="id"> d</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> d}</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> :</span><span class="id"> Filter</span> (<span class="id">almost_everywhere</span><span class="id"> mu</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> split;</span><span class="id"> [exact:</span><span class="id"> almost_everywhereT|exact:</span><span class="id"> almost_everywhereI|</span><br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> almost_everywhereS]</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">#[global]</span><br/>
<span class="vernacular">Instance</span><span class="id"> ae_properfilter_algebraOfSetsType</span><span class="id"> d</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> algebraOfSetsType</span><span class="id"> d}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> &gt;</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> ProperFilter</span> (<span class="id">almost_everywhere</span><span class="id"> mu</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> muT;</span><span class="id"> split=&gt;</span><span class="id"> [|];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> ae_filter_ringOfSetsType</span>.<br/>
<span class="id">rewrite</span><span class="id"> /almost_everywhere</span><span class="id"> setC0</span><span class="id"> =&gt;</span><span class="id"> /</span>(<span class="id">measure_negligible</span><span class="id"> measurableT</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> move/eqP;</span><span class="id"> rewrite</span><span class="id"> -measure_le0</span><span class="id"> leNgt</span><span class="id"> =&gt;</span><span class="id"> /negP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ae</span>.<br/>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">Filter</span> (<span class="id">almost_everywhere</span><span class="id"> _</span>))<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">apply:</span><span class="id"> ae_filter_ringOfSetsType</span>)<span class="id"> :</span><span class="id"> typeclass_instances</span>.<br/>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">ProperFilter</span> (<span class="id">almost_everywhere</span><span class="id"> _</span>))<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">apply:</span><span class="id"> ae_properfilter_algebraOfSetsType</span>)<span class="id"> :</span><span class="id"> typeclass_instances</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> almost_everywhere_notation</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<br/>
&nbsp;&nbsp;<span class="id">&amp;</span> (<span class="id">phantom</span><span class="gallina-kwd"> Prop</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span>))<span class="id"> :=</span><span class="id"> almost_everywhere</span><span class="id"> mu</span><span class="id"> P</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'ae' m , P }&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">almost_everywhere_notation</span><span class="id"> m</span> (<span class="id">inPhantom</span><span class="id"> P</span>))<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> aeW</span><span class="id"> {d}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d}</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realFieldType}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> {ae</span><span class="id"> mu,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> aP;</span><span class="id"> have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> P</span><span class="id"> =</span><span class="id"> setT</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> t;</span><span class="id"> split</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/negligibleP;</span><span class="id"> [rewrite</span><span class="id"> setCT|rewrite</span><span class="id"> setCT</span><span class="id"> measure0]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> ae_eq</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> f</span><span class="id"> g</span><span class="id"> h</span><span class="id"> i</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> ae_eq</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :=</span><span class="id"> {ae</span><span class="id"> mu,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> D</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> =</span><span class="id"> g</span><span class="id"> x}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ae_eq0</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> D</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> ae_eq</span><span class="id"> f</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> mD</span><span class="id"> D0;</span><span class="gallina-kwd"> exists</span><span class="id"> D;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> t/=</span><span class="id"> /not_implyP[]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ae_eq_comp</span> (<span class="id">j</span><span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">ae_eq</span><span class="id"> f</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> ae_eq</span> (<span class="id">j</span><span class="id"> \o</span><span class="id"> f</span>) (<span class="id">j</span><span class="id"> \o</span><span class="id"> g</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /[apply]</span><span class="id"> /=</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ae_eq_funeposneg</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> ae_eq</span><span class="id"> f</span><span class="id"> g</span><span class="id"> &lt;-&gt;</span><span class="id"> ae_eq</span><span class="id"> f^\+</span><span class="id"> g^\+</span><span class="id"> /\</span><span class="id"> ae_eq</span><span class="id"> f^\-</span><span class="id"> g^\-</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [fg|[]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /funepos</span><span class="id"> /funeneg;</span><span class="id"> split;</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> fg</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /[apply]</span><span class="id"> -&gt;</span>.<br/>
<span class="id">apply:</span><span class="id"> filterS2</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> +</span><span class="id"> +</span><span class="id"> Dx</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> Dx</span>)<span class="id"> fg</span><span class="id"> /</span>(_<span class="id"> Dx</span>)<span class="id"> gf</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">funeposneg</span><span class="id"> f</span>) (<span class="id">funeposneg</span><span class="id"> g</span>)<span class="id"> fg</span><span class="id"> gf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ae_eq_refl</span><span class="id"> f</span><span class="id"> :</span><span class="id"> ae_eq</span><span class="id"> f</span><span class="id"> f</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/aeW</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ae_eq_sym</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> ae_eq</span><span class="id"> f</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> ae_eq</span><span class="id"> g</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> +</span><span class="id"> Dx</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> Dx</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ae_eq_trans</span><span class="id"> f</span><span class="id"> g</span><span class="id"> h</span><span class="id"> :</span><span class="id"> ae_eq</span><span class="id"> f</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> ae_eq</span><span class="id"> g</span><span class="id"> h</span><span class="id"> -&gt;</span><span class="id"> ae_eq</span><span class="id"> f</span><span class="id"> h</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterS2</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> +</span><span class="id"> +</span><span class="id"> Dx</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> Dx</span>)<span class="id"> -&gt;;</span><span class="id"> exact</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ae_eq_sub</span><span class="id"> f</span><span class="id"> g</span><span class="id"> h</span><span class="id"> i</span><span class="id"> :</span><span class="id"> ae_eq</span><span class="id"> f</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> ae_eq</span><span class="id"> h</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> ae_eq</span> (<span class="id">f</span><span class="id"> \-</span><span class="id"> h</span>) (<span class="id">g</span><span class="id"> \-</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterS2</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> +</span><span class="id"> +</span><span class="id"> Dx</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> Dx</span>)<span class="id"> -&gt;</span><span class="id"> /</span>(_<span class="id"> Dx</span>)<span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ae_eq_mul2r</span><span class="id"> f</span><span class="id"> g</span><span class="id"> h</span><span class="id"> :</span><span class="id"> ae_eq</span><span class="id"> f</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> ae_eq</span> (<span class="id">f</span><span class="id"> \*</span><span class="id"> h</span>) (<span class="id">g</span><span class="id"> \*</span><span class="id"> h</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /[apply]</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ae_eq_mul2l</span><span class="id"> f</span><span class="id"> g</span><span class="id"> h</span><span class="id"> :</span><span class="id"> ae_eq</span><span class="id"> f</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> ae_eq</span> (<span class="id">h</span><span class="id"> \*</span><span class="id"> f</span>) (<span class="id">h</span><span class="id"> \*</span><span class="id"> g</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /[apply]</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ae_eq_mul1l</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> ae_eq</span><span class="id"> f</span> (<span class="id">cst</span><span class="id"> 1</span>)<span class="id"> -&gt;</span><span class="id"> ae_eq</span><span class="id"> g</span> (<span class="id">g</span><span class="id"> \*</span><span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /[apply]</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> mule1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ae_eq_abse</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> ae_eq</span><span class="id"> f</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> ae_eq</span> (<span class="id">abse</span><span class="id"> \o</span><span class="id"> f</span>) (<span class="id">abse</span><span class="id"> \o</span><span class="id"> g</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /[apply]</span><span class="id"> /=</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ae_eq</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ae_eq_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> sigmaRingType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ae_eq_subset</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> B</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> ae_eq</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> f</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> ae_eq</span><span class="id"> mu</span><span class="id"> B</span><span class="id"> f</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> BA</span><span class="id"> [N</span><span class="id"> [mN</span><span class="id"> N0</span><span class="id"> fg]];</span><span class="gallina-kwd"> exists</span><span class="id"> N;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subset_trans</span><span class="id"> fg;</span><span class="id"> apply:</span><span class="id"> subsetC</span><span class="id"> =&gt;</span><span class="id"> z</span><span class="id"> /=</span><span class="id"> /[swap]</span><span class="id"> /BA</span><span class="id"> ?</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ae_eq_lemmas</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> sigma_subadditive</span><span class="id"> {T}</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> numFieldType}</span><br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="gallina-kwd"> forall</span> (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ^nat</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\bigcup_n</span> (<span class="id">F</span><span class="id"> n</span>))<span class="id"> &lt;=</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">mixin</span><span class="vernacular"> Record</span><span class="id"> isOuterMeasure</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>) (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">outer_measure0</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">outer_measure_ge0</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">le_outer_measure</span><span class="id"> :</span><span class="id"> {homo</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> A</span><span class="id"> B</span><span class="id"> /</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> B</span><span class="id"> &gt;-&gt;</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> B}</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">outer_measure_sigma_subadditive</span><span class="id"> :</span><span class="id"> sigma_subadditive</span><span class="id"> mu</span><span class="id"> }</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=outer_measure</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> OuterMeasure</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>) (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{mu</span><span class="id"> &amp;</span><span class="id"> isOuterMeasure</span><span class="id"> R</span><span class="id"> T</span><span class="id"> mu}</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'outer_measure' 'set' T '-&gt;' '\bar' R }&quot;</span><span class="id"> :=</span> (<span class="id">outer_measure</span><span class="id"> R</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> T,</span><span class="id"> R</span><span class="gallina-kwd"> at</span><span class="id"> next</span><span class="id"> level,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;{ 'outer_measure'  'set'  T  '-&gt;'  '\bar'  R }&quot;</span>)<span class="id"> :</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (_<span class="id"> set0</span><span class="id"> =</span><span class="id"> 0%R</span>)<span class="id"> =&gt;</span><span class="id"> solve</span><span class="id"> [apply:</span><span class="id"> outer_measure0]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">sigma_subadditive</span><span class="id"> _</span>)<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> outer_measure_sigma_subadditive]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> outer_measure0</span><span class="id"> {R</span><span class="id"> T}</span><span class="id"> _</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> outer_measure_ge0</span><span class="id"> {R</span><span class="id"> T}</span><span class="id"> _</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> le_outer_measure</span><span class="id"> {R</span><span class="id"> T}</span><span class="id"> _</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> outer_measure_sigma_subadditive</span><span class="id"> {R</span><span class="id"> T}</span><span class="id"> _</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">factory</span><span class="vernacular"> Record</span><span class="id"> isSubsetOuterMeasure</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">outer_measure0</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">outer_measure_ge0</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> ;</span><br/>
&nbsp;&nbsp;<span class="id">subset_outer_measure_sigma_subadditive</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> A</span><span class="id"> F,</span><span class="id"> subset_sigma_subadditive</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> F}</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">builders</span><span class="vernacular"> Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> T</span><span class="id"> mu</span><span class="id"> of</span><span class="id"> isSubsetOuterMeasure</span><span class="id"> R</span><span class="id"> T</span><span class="id"> mu</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_outer_measure</span><span class="id"> :</span><span class="id"> {homo</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> A</span><span class="id"> B</span><span class="id"> /</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> B</span><span class="id"> &gt;-&gt;</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> B}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> AB;</span><span class="id"> pose</span><span class="id"> B_</span><span class="id"> k</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> k</span><span class="id"> is</span><span class="id"> 0%N</span><span class="gallina-kwd"> then</span><span class="id"> B</span><span class="gallina-kwd"> else</span><span class="id"> set0</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> B</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">n</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">B_</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> nneseries_recl;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> outer_measure_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> eseries_cond/=</span><span class="id"> eseries0</span><span class="id"> ?adde0//</span><span class="id"> =&gt;</span><span class="id"> -[|]//=</span><span class="id"> k</span><span class="id"> _</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> outer_measure0</span>.<br/>
<span class="id">apply:</span><span class="id"> subset_outer_measure_sigma_subadditive</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> bigcup_recl/=</span><span class="id"> bigcup0</span><span class="id"> ?setU0//</span><span class="id"> =&gt;</span><span class="id"> -[/negP|]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> outer_measure_sigma_subadditive</span><span class="id"> :</span><span class="id"> sigma_subadditive</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> F;</span><span class="id"> exact:</span><span class="id"> subset_outer_measure_sigma_subadditive</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isOuterMeasure</span>.<span class="id">Build</span><span class="id"> R</span><span class="id"> T</span><span class="id"> mu</span><span class="id"> outer_measure0</span><br/>
&nbsp;&nbsp;<span class="id">outer_measure_ge0</span><span class="id"> le_outer_measure</span><span class="id"> outer_measure_sigma_subadditive</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> outer_measure_sigma_subadditive_tail</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {outer_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> N</span> (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ^nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">mu</span> (<span class="id">\bigcup_</span>(<span class="id">n</span><span class="gallina-kwd"> in</span><span class="id"> ~`</span><span class="id"> `I_N</span>) (<span class="id">F</span><span class="id"> n</span>))<span class="id"> &lt;=</span><span class="id"> \sum_</span>(<span class="id">N</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id">%E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> bigcup_mkcond</span>.<br/>
<span class="id">have</span><span class="id"> :=</span><span class="id"> outer_measure_sigma_subadditive</span><span class="id"> mu</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> \in</span><span class="id"> ~`</span><span class="id"> `I_N</span><span class="gallina-kwd"> then</span><span class="id"> F</span><span class="id"> n</span><span class="gallina-kwd"> else</span><span class="id"> set0</span>).<br/>
<span class="id">move/le_trans;</span><span class="id"> apply</span>.<br/>
<span class="id">rewrite</span><span class="id"> [in</span><span class="id"> leRHS]eseries_cond</span><span class="id"> [in</span><span class="id"> leRHS]eseries_mkcondr;</span><span class="id"> apply:</span><span class="id"> lee_nneseries</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> outer_measure_ge0</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> fun_if;</span><span class="id"> case:</span><span class="id"> ifPn</span><span class="id"> =&gt;</span><span class="id"> Nk;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mem_not_I</span><span class="id"> Nk</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mem_not_I</span> (<span class="id">negbTE</span><span class="id"> Nk</span>)<span class="id"> outer_measure0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> outer_measureU</span>.<br/>
<span class="vernacular">Context</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {outer_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> outer_measure_subadditive</span> (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>)<span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> F</span><span class="id"> i</span>)<span class="id"> &lt;=</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">F</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> F'</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span> (<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id">%N</span><span class="gallina-kwd"> then</span><span class="id"> F</span><span class="id"> k</span><span class="gallina-kwd"> else</span><span class="id"> set0</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">big_mkord</span><span class="id"> xpredT</span><span class="id"> F</span>)<span class="id"> big_nat</span> (<span class="id">eq_bigr</span><span class="id"> F'</span>)<span class="id">//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> k</span><span class="id"> /=</span><span class="id"> kn;</span><span class="id"> rewrite</span><span class="id"> /F'</span><span class="id"> kn</span>.<br/>
<span class="id">rewrite</span><span class="id"> -big_nat</span><span class="id"> big_mkord</span>.<br/>
<span class="id">have</span><span class="id"> :=</span><span class="id"> outer_measure_sigma_subadditive</span><span class="id"> mu</span><span class="id"> F'</span>.<br/>
<span class="id">rewrite</span> (<span class="id">bigcup_splitn</span><span class="id"> n</span>) (_<span class="id"> :</span><span class="id"> bigcup</span><span class="id"> _</span><span class="id"> _</span><span class="id"> =</span><span class="id"> set0</span>)<span class="id"> ?setU0;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> bigcup0</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /F'</span><span class="id"> /=</span><span class="id"> ltnNge</span><span class="id"> leq_addr</span>.<br/>
<span class="id">move/le_trans;</span><span class="id"> apply</span>.<br/>
<span class="id">rewrite</span> (<span class="id">nneseries_split</span><span class="id"> _</span><span class="id"> n</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> outer_measure_ge0</span>.<br/>
<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> +</span><span class="id"> X]eseries0</span><span class="id"> ?adde0;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> k</span><span class="id"> nk</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /F'</span><span class="id"> ltnNge</span><span class="id"> nk/=</span><span class="id"> outer_measure0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_mkord;</span><span class="id"> apply:</span><span class="id"> lee_sum</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /F'</span><span class="id"> ltn_ord</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> outer_measureU2</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> +</span><span class="id"> mu</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> :=</span><span class="id"> outer_measure_subadditive</span> (<span class="id">bigcup2</span><span class="id"> A</span><span class="id"> B</span>)<span class="id"> 2</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !big_ord_recl/=</span><span class="id"> !big_ord0</span><span class="id"> setU0</span><span class="id"> adde0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> outer_measureU</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_outer_measureIC</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realFieldType</span>)<span class="id"> T</span><br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {outer_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">A</span><span class="id"> X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> X</span><span class="id"> &lt;=</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> B</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ^nat</span><span class="id"> :=</span><span class="id"> bigcup2</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span>) (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A</span>).<br/>
<span class="id">have</span><span class="id"> cvg_mu</span><span class="id"> :</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">B</span><span class="id"> i</span>))<span class="id"> @</span><span class="id"> \oo</span><span class="id"> --&gt;</span><span class="id"> mu</span> (<span class="id">B</span><span class="id"> 0%N</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">B</span><span class="id"> 1%N</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -2!cvg_shiftS</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="id"> @</span><span class="id"> \oo</span><span class="id"> --&gt;</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span> (<span class="id">fun=&gt;</span><span class="id"> mu</span> (<span class="id">B</span><span class="id"> 0%N</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">B</span><span class="id"> 1%N</span>)))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> funeqE</span><span class="id"> =&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> 2!big_ord_recl</span><span class="id"> /=</span><span class="id"> big1</span><span class="id"> ?adde0</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /B</span><span class="id"> /bigcup2</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> cvg_cst</span>.<br/>
<span class="id">have</span><span class="id"> :=</span><span class="id"> outer_measure_sigma_subadditive</span><span class="id"> mu</span><span class="id"> B</span>.<br/>
<span class="id">suff</span><span class="id"> :</span><span class="id"> \bigcup_n</span><span class="id"> B</span><span class="id"> n</span><span class="id"> =</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> -&gt;</span><span class="id"> /le_trans;</span><span class="id"> apply;</span><span class="id"> under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> big_mkord</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">cvg_lim</span><span class="id"> _</span><span class="id"> cvg_mu</span>).<br/>
<span class="id">transitivity</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> 2</span>)<span class="id"> B</span><span class="id"> i</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">bigcup_splitn</span><span class="id"> 2</span>)<span class="id"> //</span><span class="id"> -bigcup_mkord</span><span class="id"> setUidl//</span><span class="id"> =&gt;</span><span class="id"> t</span><span class="id"> -[]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> 2!big_ord_recl</span><span class="id"> big_ord0</span><span class="id"> setU0</span><span class="id"> /=</span><span class="id"> -setIUr</span><span class="id"> setUCr</span><span class="id"> setIT</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> caratheodory_measurable</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> X,</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> X</span><span class="id"> =</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;mu .-caratheodory&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="id">caratheodory_measurable</span><span class="id"> mu</span>)<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_caratheodory_measurable</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>)<span class="id"> T</span><br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {outer_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> X,</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A</span>)<span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> X</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span>.<span class="id">-caratheodory</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> suf</span><span class="id"> X;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le;</span><span class="id"> apply/andP;</span><span class="id"> split;</span><br/>
&nbsp;&nbsp;<span class="id">[exact:</span><span class="id"> le_outer_measureIC</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> suf]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> caratheodory_theorem_sigma_algebra</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> {outer_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> outer_measure_bigcup_lim</span> (<span class="id">A</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ^nat</span>)<span class="id"> X</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> \bigcup_k</span><span class="id"> A</span><span class="id"> k</span>)<span class="id"> &lt;=</span><span class="id"> \sum_</span>(<span class="id">k</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> k</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">outer_measure_sigma_subadditive</span><span class="id"> mu</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> n</span>))).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/le_outer_measure;</span><span class="id"> rewrite</span><span class="id"> setI_bigcupr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> M</span><span class="id"> :=</span><span class="id"> mu</span>.<span class="id">-caratheodory</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_measurable_set0</span><span class="id"> :</span><span class="id"> M</span><span class="id"> set0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> setI0</span><span class="id"> outer_measure0</span><span class="id"> add0e</span><span class="id"> setC0</span><span class="id"> setIT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_measurable_setC</span><span class="id"> A</span><span class="id"> :</span><span class="id"> M</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> M</span> (<span class="id">~`</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> MA</span><span class="id"> X;</span><span class="id"> rewrite</span><span class="id"> setCK</span><span class="id"> addeC</span><span class="id"> -MA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_measurable_setU_le</span> (<span class="id">X</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">mu</span>.<span class="id">-caratheodory</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> mu</span>.<span class="id">-caratheodory</span><span class="id"> B</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>))<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>))<span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> X</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span><span class="id"> mB;</span><span class="id"> pose</span><span class="id"> Y</span><span class="id"> :=</span><span class="id"> X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> `|`</span><span class="id"> X</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A</span>.<br/>
<span class="id">have</span><span class="id"> /</span>(<span class="id">leeD2r</span> (<span class="id">mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>))))<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mu</span><span class="id"> Y</span><span class="id"> &lt;=</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A</span>).<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> Z</span><span class="id"> :=</span><span class="id"> bigcup2</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span>) (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> Y</span><span class="id"> =</span><span class="id"> \bigcup_k</span><span class="id"> Z</span><span class="id"> k</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> t;</span><span class="id"> split=&gt;</span><span class="id"> [[?|?]|[]];</span><span class="id"> [by</span><span class="gallina-kwd"> exists</span><span class="id"> O|by</span><span class="gallina-kwd"> exists</span><span class="id"> 1%N|]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [_</span><span class="id"> ?|[_</span><span class="id"> ?|//]];</span><span class="id"> [left|right]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">le_trans</span> (<span class="id">outer_measure_sigma_subadditive</span><span class="id"> mu</span><span class="id"> Z</span>))<span class="id">//</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> le_eqVlt;</span><span class="id"> apply/orP;</span><span class="id"> left;</span><span class="id"> apply/eqP</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/cvg_lim</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">cvg_shiftn</span><span class="id"> 2</span>)<span class="id">/=;</span><span class="id"> apply:</span><span class="id"> cvg_near_cst</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> k;</span><span class="id"> rewrite</span><span class="id"> big_mkord</span><span class="id"> addn2</span><span class="id"> 2!big_ord_recl</span><span class="id"> big1</span><span class="id"> ?adde0//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> outer_measure0</span>.<br/>
<span class="id">have</span><span class="id"> /le_trans</span><span class="id"> :</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>))<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>))<span class="id"> &lt;=</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mu</span><span class="id"> Y</span><span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setIUr</span> (_<span class="id"> :</span><span class="id"> X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> `|`</span><span class="id"> X</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> =</span><span class="id"> Y</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /Y</span><span class="id"> -[in</span><span class="id"> LHS]</span>(<span class="id">setIT</span><span class="id"> B</span>)<span class="id"> -</span>(<span class="id">setUCr</span><span class="id"> A</span>)<span class="id"> 2!setIUr</span><span class="id"> setUC</span><span class="id"> -[in</span><span class="id"> RHS]setIA</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setUC</span><span class="id"> setUA;</span><span class="id"> congr</span> (_<span class="id"> `|`</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setUidPl</span><span class="id"> setICA;</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> right</span>.<br/>
<span class="id">suff</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A</span>)<span class="id"> +</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span> (<span class="id">~`</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)))<span class="id"> =</span><span class="id"> mu</span><span class="id"> X</span><span class="gallina-kwd"> by</span><span class="id"> exact</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setCU</span><span class="id"> setIA</span><span class="id"> -</span>(<span class="id">setIA</span><span class="id"> X</span>)<span class="id"> setICA</span> (<span class="id">setIC</span><span class="id"> B</span>)<span class="id"> -addeA</span><span class="id"> -mB</span><span class="id"> -mA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_measurable_setU</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> M</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> M</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> M</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span><span class="id"> mB</span><span class="id"> X;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> le_outer_measureIC</span><span class="id"> andTb</span><span class="id"> caratheodory_measurable_setU_le</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_measurable_bigsetU</span> (<span class="id">A</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ^nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> M</span> (<span class="id">A</span><span class="id"> n</span>))<span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> n,</span><span class="id"> M</span> (<span class="id">\big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> A</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> MA</span><span class="id"> n;</span><span class="id"> elim/big_ind</span><span class="id"> :</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> caratheodory_measurable_set0</span>.<br/>
<span class="id">exact:</span><span class="id"> caratheodory_measurable_setU</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_measurable_setI</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> M</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> M</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> M</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span><span class="id"> mB;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">setCK</span><span class="id"> A</span>)<span class="id"> -</span>(<span class="id">setCK</span><span class="id"> B</span>)<span class="id"> -setCU</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/caratheodory_measurable_setC/caratheodory_measurable_setU;</span><br/>
&nbsp;&nbsp;<span class="id">exact/caratheodory_measurable_setC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_measurable_setD</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> M</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> M</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> M</span> (<span class="id">A</span><span class="id"> `\`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span><span class="id"> mB;</span><span class="id"> rewrite</span><span class="id"> setDE;</span><span class="id"> apply:</span><span class="id"> caratheodory_measurable_setI</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">exact:</span><span class="id"> caratheodory_measurable_setC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> additive_ext_lemmas</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>.<br/>
<span class="vernacular">Hypothesis</span> (<span class="id">mA</span><span class="id"> :</span><span class="id"> M</span><span class="id"> A</span>) (<span class="id">mB</span><span class="id"> :</span><span class="id"> M</span><span class="id"> B</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> caratheodory_decomp</span><span class="id"> X</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> X</span><span class="id"> =</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> B</span>)<span class="id"> +</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mA</span><span class="id"> mB</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> +</span><span class="id"> _</span><span class="id"> +</span><span class="id"> X</span><span class="id"> =</span><span class="id"> _]mB</span><span class="id"> addeA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> caratheodory_decompIU</span><span class="id"> X</span><span class="id"> :</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>))<span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> caratheodory_decomp</span><span class="id"> -!addeA;</span><span class="id"> congr</span> (<span class="id">mu</span><span class="id"> _</span><span class="id"> +</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -!setIA;</span><span class="id"> congr</span> (_<span class="id"> `&amp;`</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIC;</span><span class="id"> apply/setIidPl;</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left;</span><span class="id"> exact:</span><span class="id"> subsetUl</span>.<br/>
<span class="id">rewrite</span><span class="id"> addeA</span><span class="id"> addeC</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> mu</span><span class="id"> X</span><span class="id"> +</span><span class="id"> _]</span>(_<span class="id"> :</span><span class="id"> _</span><span class="id"> =</span><span class="id"> set0</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -setIA</span><span class="id"> -setCU</span><span class="id"> -setIA</span><span class="id"> setICr</span><span class="id"> setI0</span>.<br/>
<span class="id">rewrite</span><span class="id"> outer_measure0</span><span class="id"> add0e</span><span class="id"> addeC</span><span class="id"> -!setIA;</span><span class="id"> congr</span> (<span class="id">mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> _</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIC;</span><span class="id"> apply/setIidPl;</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> right;</span><span class="id"> exact:</span><span class="id"> subsetUr</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIC;</span><span class="id"> apply/setIidPl;</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left;</span><span class="id"> exact:</span><span class="id"> subsetUl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> disjoint_caratheodoryIU</span><span class="id"> X</span><span class="id"> :</span><span class="id"> [disjoint</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> B]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>))<span class="id"> =</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /eqP</span><span class="id"> AB;</span><span class="id"> rewrite</span><span class="id"> caratheodory_decomp</span><span class="id"> -setIA</span><span class="id"> AB</span><span class="id"> setI0</span><span class="id"> outer_measure0</span>.<br/>
<span class="id">rewrite</span><span class="id"> add0e</span><span class="id"> addeC</span><span class="id"> -setIA</span><span class="id"> -setCU</span><span class="id"> -setIA</span><span class="id"> setICr</span><span class="id"> setI0</span><span class="id"> outer_measure0</span><span class="id"> add0e</span>.<br/>
<span class="id">rewrite</span><span class="id"> -!setIA;</span><span class="id"> congr</span> (<span class="id">mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> _</span> )<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> _</span>)).<br/>
<span class="id">rewrite</span> (<span class="id">setIC</span><span class="id"> A</span>)<span class="id"> setIA</span><span class="id"> setIC;</span><span class="id"> apply/setIidPl</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIUl</span><span class="id"> setICr</span><span class="id"> setU0</span><span class="id"> subsetI;</span><span class="id"> move/disjoints_subset</span><span class="gallina-kwd"> in</span><span class="id"> AB;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> setIA</span><span class="id"> setIC;</span><span class="id"> apply/setIidPl;</span><span class="id"> rewrite</span><span class="id"> setIUl</span><span class="id"> setICr</span><span class="id"> set0U</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> AB;</span><span class="id"> rewrite</span><span class="id"> setIC</span><span class="id"> =&gt;</span><span class="id"> /disjoints_subset</span><span class="id"> =&gt;</span><span class="id"> AB;</span><span class="id"> rewrite</span><span class="id"> subsetI;</span><span class="id"> split</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> additive_ext_lemmas</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_additive</span> (<span class="id">A</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ^nat</span>)<span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> M</span> (<span class="id">A</span><span class="id"> n</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">trivIset</span><span class="id"> setT</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> n</span><span class="id"> X,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> \big[setU/set0]_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> A</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> MA</span><span class="id"> ta;</span><span class="id"> elim=&gt;</span><span class="id"> [|n</span><span class="id"> ih]</span><span class="id"> X;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !big_ord0</span><span class="id"> setI0</span><span class="id"> outer_measure0</span>.<br/>
<span class="id">rewrite</span><span class="id"> big_ord_recr</span><span class="id"> /=</span><span class="id"> disjoint_caratheodoryIU</span><span class="id"> //</span><span class="id"> ?ih</span><span class="id"> ?big_ord_recr</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> caratheodory_measurable_bigsetU</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply/eqP/</span>(<span class="id">@trivIset_bigsetUI</span><span class="id"> _</span><span class="id"> predT</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> /predT</span><span class="id"> /=</span><span class="id"> trueE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_lime_le</span> (<span class="id">A</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ^nat</span>)<span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> M</span> (<span class="id">A</span><span class="id"> n</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">trivIset</span><span class="id"> setT</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> X,</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">k</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> k</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> \bigcup_k</span><span class="id"> A</span><span class="id"> k</span>)<span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> X</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> MA</span><span class="id"> tA</span><span class="id"> X</span>.<br/>
<span class="id">set</span><span class="id"> A'</span><span class="id"> :=</span><span class="id"> \bigcup_k</span><span class="id"> A</span><span class="id"> k;</span><span class="id"> set</span><span class="id"> B</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \big[setU/set0]_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>) (<span class="id">A</span><span class="id"> k</span>).<br/>
<span class="id">suff</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> n,</span><span class="id"> \sum_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> k</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A'</span>)<span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> XA;</span><span class="id"> rewrite</span> (_<span class="id"> :</span><span class="id"> limn</span><span class="id"> _</span><span class="id"> =</span><span class="id"> ereal_sup</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> k</span>))<span class="id"> @`</span><span class="id"> setT</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">under</span><span class="id"> eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> big_mkord</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/cvg_lim</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> ereal_nondecreasing_cvgn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">lee_sum_nneg_ord</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> n</span>))<span class="id"> xpredT</span>)<span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> outer_measure_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">move</span><span class="id"> XAx</span><span class="id"> :</span> (<span class="id">mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A'</span>))<span class="id"> =&gt;</span><span class="id"> [x|</span><span class="id"> |]</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> -leeBrDr</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> ub_ereal_sup</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> _</span><span class="id"> [n</span><span class="id"> _]</span><span class="id"> &lt;-</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> EFinN</span><span class="id"> leeBrDr</span><span class="id"> //</span><span class="id"> -XAx</span><span class="id"> XA</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> suff</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> X</span><span class="id"> =</span><span class="id"> +oo</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> leey</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -leye_eq</span><span class="id"> -XAx</span><span class="id"> le_outer_measure</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> addeNy</span><span class="id"> leNye</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> n</span>.<br/>
<span class="id">apply:</span> (<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">\sum_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> k</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> B</span><span class="id"> n</span>))).<br/>
&nbsp;&nbsp;<span class="id">apply/leeD2l/le_outer_measure;</span><span class="id"> apply:</span><span class="id"> setIS;</span><span class="id"> exact/subsetC/bigsetU_bigcup</span>.<br/>
<span class="id">rewrite</span><span class="id"> [in</span><span class="id"> leRHS]</span>(<span class="id">caratheodory_measurable_bigsetU</span><span class="id"> MA</span><span class="id"> n</span>)<span class="id"> leeD2r//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> caratheodory_additive</span>.<br/>
Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.0&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;renamed `caratheodory_lime_le`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> caratheodory_lim_lee</span><span class="id"> :=</span><span class="id"> caratheodory_lime_le</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_measurable_trivIset_bigcup</span> (<span class="id">A</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ^nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> M</span> (<span class="id">A</span><span class="id"> n</span>))<span class="id"> -&gt;</span><span class="id"> trivIset</span><span class="id"> setT</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> M</span> (<span class="id">\bigcup_k</span> (<span class="id">A</span><span class="id"> k</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> MA</span><span class="id"> tA;</span><span class="id"> apply:</span><span class="id"> le_caratheodory_measurable</span><span class="id"> =&gt;</span><span class="id"> X</span><span class="id"> /=</span>.<br/>
<span class="id">have</span><span class="id"> /</span>(<span class="id">leeD2r</span> (<span class="id">mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> \bigcup_k</span><span class="id"> A</span><span class="id"> k</span>)))<span class="id"> :=</span><span class="id"> outer_measure_bigcup_lim</span><span class="id"> A</span><span class="id"> X</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/le_trans;</span><span class="id"> apply;</span><span class="id"> exact:</span><span class="id"> caratheodory_lime_le</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_measurable_bigcup</span> (<span class="id">A</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id"> ^nat</span>)<span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> M</span> (<span class="id">A</span><span class="id"> n</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">M</span> (<span class="id">\bigcup_k</span> (<span class="id">A</span><span class="id"> k</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> MA;</span><span class="id"> rewrite</span><span class="id"> -eq_bigcup_seqD_bigsetU</span>.<br/>
<span class="id">apply/caratheodory_measurable_trivIset_bigcup;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> trivIset_seqD</span><span class="id"> =&gt;</span><span class="id"> m</span><span class="id"> n</span><span class="id"> mn;</span><span class="id"> exact/subsetPset/subset_bigsetU</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> [|n</span><span class="id"> /=];</span><span class="id"> [|</span><span class="id"> apply/caratheodory_measurable_setD</span><span class="id"> =&gt;</span><span class="id"> //];</span><br/>
&nbsp;&nbsp;<span class="id">exact/caratheodory_measurable_bigsetU</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> caratheodory_theorem_sigma_algebra</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> caratheodory_type</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> caratheodory_display</span><span class="id"> R</span><span class="id"> T</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>)<span class="id"> -&gt;</span><span class="id"> measure_display</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> caratheodory_sigma_algebra</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> pointedType</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> {outer_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Pointed</span>.<span class="id">on</span> (<span class="id">caratheodory_type</span><span class="id"> mu</span>).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> @isMeasurable</span>.<span class="id">Build</span> (<span class="id">caratheodory_display</span><span class="id"> mu</span>)<br/>
&nbsp;&nbsp;(<span class="id">caratheodory_type</span><span class="id"> mu</span>)<span class="id"> mu</span>.<span class="id">-caratheodory</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">caratheodory_measurable_set0</span><span class="id"> mu</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">@caratheodory_measurable_setC</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mu</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">@caratheodory_measurable_bigcup</span><span class="id"> _</span><span class="id"> _</span><span class="id"> mu</span>).<br/>
<br/>
<span class="vernacular">End</span><span class="id"> caratheodory_sigma_algebra</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;mu .-cara&quot;</span><span class="id"> :=</span> (<span class="id">caratheodory_display</span><span class="id"> mu</span>)<span class="id"> :</span><span class="id"> measure_display_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;mu .-cara.-measurable&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">measurable</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span> (<span class="id">caratheodory_type</span><span class="id"> mu</span>)))<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> caratheodory_measure</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> pointedType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {outer_measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Let</span><span class="id"> U</span><span class="id"> :=</span><span class="id"> caratheodory_type</span><span class="id"> mu</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_measure0</span><span class="id"> :</span><span class="id"> mu</span> (<span class="id">set0</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> outer_measure0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_measure_ge0</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> outer_measure_ge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_measure_sigma_additive</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">semi_sigma_additive</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> _</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> mA</span><span class="id"> tA</span><span class="id"> mbigcupA;</span><span class="id"> set</span><span class="id"> B</span><span class="id"> :=</span><span class="id"> \bigcup_k</span><span class="id"> A</span><span class="id"> k</span>.<br/>
<span class="id">suff</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> X,</span><span class="id"> mu</span><span class="id"> X</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">k</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> k</span>)<span class="id"> +</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> B</span>).<br/>
&nbsp;&nbsp;<span class="id">move/</span>(_<span class="id"> B</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> setICr</span><span class="id"> outer_measure0</span><span class="id"> adde0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (_<span class="id"> :</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> _</span>)<span class="id"> =</span><span class="gallina-kwd"> fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">k</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> mu</span> (<span class="id">A</span><span class="id"> k</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> funeqE</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> big_mkord;</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> congr</span> (<span class="id">mu</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIC;</span><span class="id"> apply/setIidPl;</span><span class="id"> exact:</span><span class="id"> bigcup_sup</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> -&gt;;</span><span class="id"> have</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> n</span> (_<span class="id"> :</span><span class="id"> xpredT</span><span class="id"> n</span>)<span class="id"> =&gt;</span><span class="id"> outer_measure_ge0</span><span class="id"> mu</span> (<span class="id">A</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;<span class="id">move/</span>(<span class="id">@is_cvg_nneseries</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> 0</span>)<span class="id"> =&gt;</span><span class="id"> /cvg_ex[l]</span><span class="id"> hl</span>.<br/>
&nbsp;&nbsp;<span class="id">under</span><span class="id"> [in</span><span class="id"> X</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> --&gt;</span><span class="id"> X]eq_fun</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">big_mkord</span><span class="id"> xpredT</span> (<span class="id">mu</span><span class="id"> \o</span><span class="id"> A</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/cvg_lim</span><span class="id"> :</span> (<span class="id">hl</span>)<span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> X</span>.<br/>
<span class="id">have</span><span class="id"> mB</span><span class="id"> :</span><span class="id"> mu</span>.<span class="id">-cara</span>.<span class="id">-measurable</span><span class="id"> B</span><span class="id"> :=</span><span class="id"> caratheodory_measurable_bigcup</span><span class="id"> mA</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le</span> (<span class="id">caratheodory_lime_le</span><span class="id"> mA</span><span class="id"> tA</span><span class="id"> X</span>)<span class="id"> andbT</span>.<br/>
<span class="id">have</span><span class="id"> /</span>(<span class="id">leeD2r</span> (<span class="id">mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> B</span>)))<span class="id"> :=</span><span class="id"> outer_measure_bigcup_lim</span><span class="id"> mu</span><span class="id"> A</span><span class="id"> X</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -le_caratheodory_measurable</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> -mB</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><br/>
&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">caratheodory_type</span><span class="id"> mu</span>)<span class="id"> -&gt;</span><span class="id"> _</span>)<br/>
&nbsp;&nbsp;<span class="id">caratheodory_measure0</span><span class="id"> caratheodory_measure_ge0</span><br/>
&nbsp;&nbsp;<span class="id">caratheodory_measure_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_is_complete_caratheodory</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measure_is_complete</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">caratheodory_type</span><span class="id"> mu</span>)<span class="id"> -&gt;</span><span class="id"> _</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> B</span><span class="id"> [A</span><span class="id"> [mA</span><span class="id"> muA0</span><span class="id"> BA]];</span><span class="id"> apply:</span><span class="id"> le_caratheodory_measurable</span><span class="id"> =&gt;</span><span class="id"> X</span>.<br/>
<span class="id">suff</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> add0e</span><span class="id"> le_outer_measure</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left</span>.<br/>
<span class="id">have</span><span class="id"> muB0</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> B</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le</span><span class="id"> outer_measure_ge0</span><span class="id"> andbT</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">le_trans</span> (<span class="id">le_outer_measure</span><span class="id"> mu</span><span class="id"> _</span><span class="id"> _</span><span class="id"> BA</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -muA0</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le</span><span class="id"> outer_measure_ge0</span><span class="id"> andbT</span>.<br/>
<span class="id">have</span><span class="id"> :</span><span class="id"> X</span><span class="id"> `&amp;`</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> B</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> right</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/</span>(<span class="id">le_outer_measure</span><span class="id"> mu</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> muB0</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> caratheodory_measure</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> epsilon_trick</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">A</span><span class="id"> :</span> (<span class="id">\bar</span><span class="id"> R</span>)<span class="id">^nat</span>)<span class="id"> e</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> nat</span>)<span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> A</span><span class="id"> n</span>)<span class="id"> -&gt;</span> (<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> e</span>)<span class="id">%R</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>) (<span class="id">A</span><span class="id"> i</span><span class="id"> +</span> (<span class="id">e</span><span class="id"> /</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> i</span>.<span class="id">+1</span>)<span class="id">%:R</span>)<span class="id">%:E</span>)<span class="id"> &lt;=</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> A</span><span class="id"> i</span><span class="id"> +</span><span class="id"> e%:E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> A0</span><span class="id"> /nonnegP[{}e]</span>.<br/>
<span class="id">rewrite</span> (<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">lim</span> ((<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span> (<span class="id">\sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>)<span class="id"> A</span><span class="id"> i</span>)<span class="id"> +</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>) (<span class="id">e%:num</span><span class="id"> /</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> i</span>.<span class="id">+1</span>)<span class="id">%:R</span>)<span class="id">%:E</span>)<span class="id"> @</span><span class="id"> \oo</span>)))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> nneseriesD</span><span class="id"> //</span><span class="id"> limeD</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> leeD2l</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> lee_lim</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="id"> exact:</span><span class="id"> is_cvg_nneseries</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="id"> exact:</span><span class="id"> is_cvg_nneseries</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> near=&gt;</span><span class="id"> n;</span><span class="id"> exact:</span><span class="id"> lee_sum_nneg_subset</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> is_cvg_nneseries</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> is_cvg_nneseries</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> adde_def_nneseries</span>.<br/>
<span class="id">suff</span><span class="id"> cvggeo</span><span class="id"> :</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>) (<span class="id">e%:num</span><span class="id"> /</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> i</span>.<span class="id">+1</span>)<span class="id">%:R</span>)<span class="id">%:E</span>)<span class="id"> @</span><span class="id"> \oo</span><span class="id"> --&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">e%:num%:E</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> limeD</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> leeD2l</span><span class="id"> //</span> (<span class="id">cvg_lim</span><span class="id"> _</span><span class="id"> cvggeo</span>).<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> is_cvg_nneseries</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> is_cvg_nneseries</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> lee_fin</span><span class="id"> divr_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">cvg_lim</span><span class="id"> _</span><span class="id"> cvggeo</span>)<span class="id"> //=</span><span class="id"> fin_num_adde_defl</span>.<br/>
<span class="id">rewrite</span> (_<span class="id"> :</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> _</span>)<span class="id"> =</span><span class="id"> EFin</span><span class="id"> \o</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> \sum_</span>(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span>) (<span class="id">e%:num</span><span class="id"> /</span> (<span class="id">2</span><span class="id"> ^</span> (<span class="id">i</span><span class="id"> +</span><span class="id"> 1</span>))<span class="id">%:R</span>))<span class="id">%R</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> funeqE</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> /=;</span><span class="id"> rewrite</span> (<span class="id">@big_morph</span><span class="id"> _</span><span class="id"> _</span><span class="id"> EFin</span><span class="id"> 0</span><span class="id"> adde</span>)<span class="id">//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> [in</span><span class="id"> RHS]eq_bigr</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> addn1</span>.<br/>
<span class="id">apply:</span><span class="id"> cvg_comp;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply</span><span class="id"> cvg_refl</span>.<br/>
<span class="id">have</span><span class="id"> :=</span><span class="id"> cvg_geometric_series_half</span><span class="id"> e%:num</span><span class="id"> O</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> expr0</span><span class="id"> divr1;</span><span class="id"> apply:</span><span class="id"> cvg_trans</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> epsilon_trick0</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">eps</span><span class="id"> :</span><span class="id"> R</span>) (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> nat</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> eps</span>)<span class="id">%R</span><span class="id"> -&gt;</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span><span class="id"> |</span><span class="id"> P</span><span class="id"> i</span>) (<span class="id">eps</span><span class="id"> /</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> i</span>.<span class="id">+1</span>)<span class="id">%:R</span>)<span class="id">%:E</span><span class="id"> &lt;=</span><span class="id"> eps%:E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> epspos;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> epsilon_trick</span><span class="id"> P</span> (<span class="id">fun=&gt;</span><span class="id"> lexx</span><span class="id"> 0</span>)<span class="id"> epspos</span>.<br/>
<span class="comment">(*&nbsp;TODO:&nbsp;breaks&nbsp;coq&nbsp;8.15&nbsp;and&nbsp;below&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;(under&nbsp;eq_eseriesr&nbsp;&nbsp;do&nbsp;rewrite&nbsp;add0e)&nbsp;=&gt;&nbsp;/le_trans;&nbsp;apply.&nbsp;*)</span><br/>
<span class="id">rewrite</span> (<span class="id">@eq_eseriesr</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> 0</span><span class="id"> +</span><span class="id"> _</span>) (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span> (<span class="id">eps/</span>(<span class="id">2^n</span>.<span class="id">+1</span>)<span class="id">%:R</span>)<span class="id">%:E</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/le_trans;</span><span class="id"> apply;</span><span class="id"> rewrite</span><span class="id"> eseries0</span><span class="id"> ?add0e;</span><span class="id"> [exact:</span><span class="id"> lexx</span><span class="id"> |</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> add0e</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> measurable_cover</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> measurable_cover</span><span class="id"> X</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> F</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span><span class="id"> |</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> /\</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> \bigcup_k</span> (<span class="id">F</span><span class="id"> k</span>)<span class="id">]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cover_measurable</span><span class="id"> X</span><span class="id"> F</span><span class="id"> :</span><span class="id"> measurable_cover</span><span class="id"> X</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> k,</span><span class="id"> measurable</span> (<span class="id">F</span><span class="id"> k</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> +</span><span class="id"> k;</span><span class="id"> rewrite</span><span class="id"> /measurable_cover</span><span class="id"> =&gt;</span><span class="id"> -[]</span><span class="id"> /</span>(_<span class="id"> k</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cover_subset</span><span class="id"> X</span><span class="id"> F</span><span class="id"> :</span><span class="id"> measurable_cover</span><span class="id"> X</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> \bigcup_k</span> (<span class="id">F</span><span class="id"> k</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> measurable_cover</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_uncurry</span> (<span class="id">T1</span><span class="id"> T2</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">G</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> *</span><span class="id"> T2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span> (<span class="id">G</span><span class="id"> x</span>.<span class="id">1</span><span class="id"> x</span>.<span class="id">2</span>)<span class="id"> &lt;-&gt;</span><span class="id"> measurable</span> (<span class="id">uncurry</span><span class="id"> G</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> x</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> outer_measure_construction</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>.<br/>
<span class="vernacular">Hypothesis</span> (<span class="id">measure0</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>) (<span class="id">measure_ge0</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> X,</span><span class="id"> mu</span><span class="id"> X</span><span class="id"> &gt;=</span><span class="id"> 0</span>).<br/>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> measure_ge0</span><span class="id"> measure0</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mu_ext</span> (<span class="id">X</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ereal_inf</span><span class="id"> [set</span><span class="id"> \sum_</span>(<span class="id">k</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">A</span><span class="id"> k</span>)<span class="id"> |</span><span class="id"> A</span><span class="gallina-kwd"> in</span><span class="id"> measurable_cover</span><span class="id"> X]</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;mu^*&quot;</span><span class="id"> :=</span><span class="id"> mu_ext</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_mu_ext</span><span class="id"> :</span><span class="id"> {homo</span><span class="id"> mu^*</span><span class="id"> :</span><span class="id"> A</span><span class="id"> B</span><span class="id"> /</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> B</span><span class="id"> &gt;-&gt;</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> B}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> AB;</span><span class="id"> apply/le_ereal_inf</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> [B'</span><span class="id"> [mB'</span><span class="id"> BB']]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> &lt;-{x};</span><span class="gallina-kwd"> exists</span><span class="id"> B'</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> subset_trans</span><span class="id"> AB</span><span class="id"> BB'</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mu_ext_ge0</span><span class="id"> A</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mu^*</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> lb_ereal_inf</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> [B</span><span class="id"> [mB</span><span class="id"> AB]</span><span class="id"> &lt;-{x}];</span><span class="id"> rewrite</span><span class="id"> lime_ge</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> is_cvg_nneseries</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> near=&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> sume_ge0</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mu_ext0</span><span class="id"> :</span><span class="id"> mu^*</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le;</span><span class="id"> apply/andP;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> exact/mu_ext_ge0</span>.<br/>
<span class="id">rewrite</span><span class="id"> /mu_ext;</span><span class="id"> apply:</span><span class="id"> ereal_inf_lbound;</span><span class="gallina-kwd"> exists</span> (<span class="id">fun=&gt;</span><span class="id"> set0</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> split</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> lim_near_cst</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> near=&gt;</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> big1</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mu_ext_sigma_subadditive</span><span class="id"> :</span><span class="id"> sigma_subadditive</span><span class="id"> mu^*</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> A;</span><span class="id"> have</span><span class="id"> [[i</span><span class="id"> ioo]|]</span><span class="id"> :=</span><span class="id"> pselect</span> (<span class="gallina-kwd">exists</span><span class="id"> i,</span><span class="id"> mu^*</span> (<span class="id">A</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> +oo</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">eseries_pinfty</span><span class="id"> _</span><span class="id"> _</span><span class="id"> ioo</span>)<span class="id"> ?leey//</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -ltNye</span> (<span class="id">lt_le_trans</span><span class="id"> _</span> (<span class="id">mu_ext_ge0</span><span class="id"> _</span>)).<br/>
<span class="id">rewrite</span><span class="id"> -forallNE</span><span class="id"> =&gt;</span><span class="id"> Aoo</span>.<br/>
<span class="id">suff</span><span class="id"> add2e</span> (<span class="id">e</span><span class="id"> :</span><span class="id"> {posnum</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mu^*</span> (<span class="id">\bigcup_n</span><span class="id"> A</span><span class="id"> n</span>)<span class="id"> &lt;=</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span>)<span class="id"> mu^*</span> (<span class="id">A</span><span class="id"> i</span>)<span class="id"> +</span><span class="id"> e%:num%:E</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/lee_addgt0Pr</span><span class="id"> =&gt;</span><span class="id"> _/posnumP[]</span>.<br/>
<span class="id">rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">epsilon_trick</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>))<span class="id">//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> exact:</span><span class="id"> mu_ext_ge0</span>.<br/>
<span class="id">pose</span><span class="id"> P</span><span class="id"> n</span> (<span class="id">B</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>)<span class="id"> :=</span><span class="id"> measurable_cover</span> (<span class="id">A</span><span class="id"> n</span>)<span class="id"> B</span><span class="id"> /\</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">k</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">B</span><span class="id"> k</span>)<span class="id"> &lt;=</span><span class="id"> mu^*</span> (<span class="id">A</span><span class="id"> n</span>)<span class="id"> +</span> (<span class="id">e%:num</span><span class="id"> /</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id">%:R</span>)<span class="id">%:E</span>.<br/>
<span class="id">have</span><span class="id"> [G</span><span class="id"> PG]</span><span class="id"> :</span><span class="id"> {G</span><span class="id"> :</span> ((<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>)<span class="id">^nat</span><span class="id"> &amp;</span><span class="gallina-kwd"> forall</span><span class="id"> n,</span><span class="id"> P</span><span class="id"> n</span> (<span class="id">G</span><span class="id"> n</span>)<span class="id">}</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">@choice</span><span class="id"> _</span><span class="id"> _</span><span class="id"> P</span>)<span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> /P</span><span class="id"> /mu_ext</span>.<br/>
&nbsp;&nbsp;<span class="id">set</span><span class="id"> S</span><span class="id"> :=</span> (<span class="id">X</span><span class="gallina-kwd"> in</span><span class="id"> ereal_inf</span><span class="id"> X</span>)<span class="id">;</span><span class="id"> move</span><span class="id"> infS</span><span class="id"> :</span> (<span class="id">ereal_inf</span><span class="id"> S</span>)<span class="id"> =&gt;</span><span class="id"> iS</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> iS</span><span class="id"> infS</span><span class="id"> =&gt;</span><span class="id"> [r</span><span class="id"> Sr|Soo|Soo]</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> have</span><span class="id"> en1</span><span class="id"> :</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> e%:num</span><span class="id"> /</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id">%:R</span>)<span class="id">%R</span><span class="gallina-kwd"> by</span><span class="id"> []</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /</span>(<span class="id">lb_ereal_inf_adherent</span><span class="id"> en1</span>)<span class="id"> :</span><span class="id"> ereal_inf</span><span class="id"> S</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> fin_num</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> Sr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> [x</span><span class="id"> [B</span><span class="id"> [mB</span><span class="id"> AnB</span><span class="id"> muBx]</span><span class="id"> xS]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> B;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> muBx</span><span class="id"> -Sr;</span><span class="id"> exact/ltW</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> Aoo</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> /mu^*</span><span class="id"> Soo</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> suff</span><span class="id"> :</span><span class="id"> lbound</span><span class="id"> S</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> move/lb_ereal_inf;</span><span class="id"> rewrite</span><span class="id"> Soo</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /=</span><span class="id"> _</span><span class="id"> [B</span><span class="id"> [mB</span><span class="id"> AnB]</span><span class="id"> &lt;-];</span><span class="id"> exact:</span><span class="id"> nneseries_ge0</span>.<br/>
<span class="id">have</span><span class="id"> muG_ge0</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span> (<span class="id">mu</span><span class="id"> \o</span><span class="id"> uncurry</span><span class="id"> G</span>)<span class="id"> x</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> measure_ge0</span>.<br/>
<span class="id">apply:</span> (<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">\esum_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> setT</span>) (<span class="id">mu</span><span class="id"> \o</span><span class="id"> uncurry</span><span class="id"> G</span>)<span class="id"> i</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /mu_ext;</span><span class="id"> apply:</span><span class="id"> ereal_inf_lbound</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /card_esym/ppcard_eqP[f]</span><span class="id"> :=</span><span class="id"> card_nat2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">uncurry</span><span class="id"> G</span><span class="id"> \o</span><span class="id"> f</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> [i|];</span><span class="id"> first</span><span class="id"> exact/measurable_uncurry/</span>(<span class="id">PG</span> (<span class="id">f</span><span class="id"> i</span>).<span class="id">1</span>).<span class="id">1</span>.<span class="id">1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">@subset_trans</span><span class="id"> _</span>  (<span class="id">\bigcup_n</span><span class="id"> \bigcup_k</span><span class="id"> G</span><span class="id"> n</span><span class="id"> k</span>))<span class="id"> =&gt;</span><span class="id"> [t</span><span class="id"> [i</span><span class="id"> _]|]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /</span>(<span class="id">cover_subset</span> (<span class="id">PG</span><span class="id"> i</span>).<span class="id">1</span>)<span class="id"> -[j</span><span class="id"> _</span><span class="id"> ?];</span><span class="gallina-kwd"> exists</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> j</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> [i</span><span class="id"> _</span><span class="id"> [j</span><span class="id"> _</span><span class="id"> Bijt]];</span><span class="gallina-kwd"> exists</span> (<span class="id">f^-1%FUN</span> (<span class="id">i,</span><span class="id"> j</span>))<span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> invK</span><span class="id"> ?inE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">esum_pred_image</span> (<span class="id">mu</span><span class="id"> \o</span><span class="id"> uncurry</span><span class="id"> G</span>)<span class="id"> _</span><span class="id"> xpredT</span>)<span class="id"> ?[fun=&gt;</span><span class="id"> _]set_true//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> image_eq</span>.<br/>
<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> esum</span><span class="id"> _</span><span class="id"> _</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span>)<span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> &lt;oo</span> )<span class="id"> mu</span> (<span class="id">G</span><span class="id"> i</span><span class="id"> j</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> J</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> set</span> (<span class="id">nat</span><span class="id"> *</span><span class="id"> nat</span>)<span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> [set</span> (<span class="id">i,</span><span class="id"> j</span>)<span class="id"> |</span><span class="id"> j</span><span class="gallina-kwd"> in</span><span class="id"> setT]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> setT</span><span class="id"> =</span><span class="id"> \bigcup_k</span><span class="id"> J</span><span class="id"> k</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> -[a</span><span class="id"> b];</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span><span class="id"> a</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> b</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> esum_bigcupT</span><span class="id"> /=;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> apply/trivIsetP</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> _</span><span class="id"> _</span><span class="id"> ij</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> -[n</span><span class="id"> m]</span><span class="id"> /=;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> -[]</span><span class="id"> [_]</span><span class="id"> _</span><span class="id"> [&lt;-{n}</span><span class="id"> _]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [m'</span><span class="id"> _]</span><span class="id"> []</span><span class="id"> /esym/eqP;</span><span class="id"> rewrite</span> (<span class="id">negbTE</span><span class="id"> ij</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /=</span><span class="id"> [n</span><span class="id"> m];</span><span class="id"> apply:</span><span class="id"> measure_ge0;</span><span class="id"> exact:</span> (<span class="id">cover_measurable</span> (<span class="id">PG</span><span class="id"> n</span>).<span class="id">1</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">image_id</span><span class="id"> [set:</span><span class="id"> nat]</span>)<span class="id"> -fun_true</span><span class="id"> esum_pred_image//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> esum_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> eq_eseriesr</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> j</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">esum_pred_image</span> (<span class="id">mu</span><span class="id"> \o</span><span class="id"> uncurry</span><span class="id"> G</span>) (<span class="id">pair</span><span class="id"> j</span>)<span class="id"> predT</span>)<span class="id">//=;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> exact:</span> (<span class="id">@can_inj</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> snd</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> congr</span><span class="id"> esum;</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> -[a</span><span class="id"> b];</span><span class="id"> split;</span><span class="id"> move=&gt;</span><span class="id"> [i</span><span class="id"> _</span><span class="id"> &lt;-];</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<br/>
<span class="id">apply:</span><span class="id"> lee_lim</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> is_cvg_nneseries</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> nneseries_ge0</span><span class="id"> =&gt;</span><span class="id"> m</span><span class="id"> _;</span><span class="id"> exact:</span> (<span class="id">muG_ge0</span> (<span class="id">n,</span><span class="id"> m</span>)).<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> is_cvg_nneseries</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> adde_ge0</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> mu_ext_ge0</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> near=&gt;</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> lee_sum</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> exact:</span> (<span class="id">PG</span><span class="id"> i</span>).<span class="id">2</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> outer_measure_construction</span>.<br/>
<span class="vernacular">Declare</span><span class="vernacular"> Scope</span><span class="id"> measure_scope</span>.<br/>
<span class="vernacular">Delimit</span><span class="vernacular"> Scope</span><span class="id"> measure_scope</span><span class="gallina-kwd"> with</span><span class="id"> mu</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;mu ^*&quot;</span><span class="id"> :=</span> (<span class="id">mu_ext</span><span class="id"> mu</span>)<span class="id"> :</span><span class="id"> measure_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> measure_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> outer_measure_of_content</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isOuterMeasure</span>.<span class="id">Build</span><br/>
&nbsp;&nbsp;<span class="id">R</span><span class="id"> T</span><span class="id"> _</span> (<span class="id">@mu_ext0</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">measure0</span><span class="id"> mu</span>) (<span class="id">measure_ge0</span><span class="id"> mu</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu_ext_ge0</span> (<span class="id">measure_ge0</span><span class="id"> mu</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">le_mu_ext</span><span class="id"> mu</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu_ext_sigma_subadditive</span> (<span class="id">measure_ge0</span><span class="id"> mu</span>)).<br/>
<br/>
<span class="vernacular">End</span><span class="id"> outer_measure_of_content</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> g_sigma_algebra_measure_unique</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> Gm</span><span class="id"> :</span><span class="id"> G</span><span class="id"> `&lt;=`</span><span class="id"> measurable</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> g</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>.<br/>
<span class="vernacular">Hypotheses</span><span class="id"> Gg</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> G</span> (<span class="id">g</span><span class="id"> i</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> g_cover</span><span class="id"> :</span><span class="id"> \bigcup_k</span> (<span class="id">g</span><span class="id"> k</span>)<span class="id"> =</span><span class="id"> setT</span>.<br/>
<span class="vernacular">Variables</span><span class="id"> m1</span><span class="id"> m2</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> g_sigma_algebra_measure_unique_cover</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n</span><span class="id"> A,</span><span class="id"> &lt;&lt;s</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> m1</span> (<span class="id">g</span><span class="id"> n</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="id"> =</span><span class="id"> m2</span> (<span class="id">g</span><span class="id"> n</span><span class="id"> `&amp;`</span><span class="id"> A</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> A,</span><span class="id"> &lt;&lt;s</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> m1</span><span class="id"> A</span><span class="id"> =</span><span class="id"> m2</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> GT</span><span class="id"> :</span><span class="id"> ringOfSetsType</span><span class="id"> G</span>.<span class="id">-sigma:=</span><span class="id"> g_sigma_algebraType</span><span class="id"> G</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> sGm1m2;</span><span class="id"> pose</span><span class="id"> g'</span><span class="id"> k</span><span class="id"> :=</span><span class="id"> \bigcup_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> k</span>)<span class="id"> g</span><span class="id"> i</span>.<br/>
<span class="id">have</span><span class="id"> sGm</span><span class="id"> :=</span><span class="id"> smallest_sub</span> (<span class="id">@sigma_algebra_measurable</span><span class="id"> _</span><span class="id"> T</span>)<span class="id"> Gm</span>.<br/>
<span class="id">have</span><span class="id"> Gg'</span><span class="id"> i</span><span class="id"> :</span><span class="id"> &lt;&lt;s</span><span class="id"> G</span><span class="id"> &gt;&gt;</span> (<span class="id">g'</span><span class="id"> i</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">@fin_bigcup_measurable</span><span class="id"> _</span><span class="id"> GT</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> sub_sigma_algebra</span>.<br/>
<span class="id">have</span><span class="id"> sG'm1m2</span><span class="id"> n</span><span class="id"> A</span><span class="id"> :</span><span class="id"> &lt;&lt;s</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> m1</span> (<span class="id">g'</span><span class="id"> n</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="id"> =</span><span class="id"> m2</span> (<span class="id">g'</span><span class="id"> n</span><span class="id"> `&amp;`</span><span class="id"> A</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> sGA;</span><span class="id"> rewrite</span><span class="id"> setI_bigcupl</span><span class="id"> bigcup_mkord</span>.<br/>
&nbsp;&nbsp;<span class="id">elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> IHn]</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> sGA</span><span class="id"> *;</span><span class="id"> rewrite</span> (<span class="id">big_ord0,</span><span class="id"> big_ord_recr</span>)<span class="id"> ?measure0//=</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sGgA</span><span class="id"> i</span><span class="id"> :</span><span class="id"> &lt;&lt;s</span><span class="id"> G</span><span class="id"> &gt;&gt;</span> (<span class="id">g</span><span class="id"> i</span><span class="id"> `&amp;`</span><span class="id"> A</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">@measurableI</span><span class="id"> _</span><span class="id"> GT</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> sub_sigma_algebra</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> eq_measureU;</span><span class="id"> rewrite</span><span class="id"> ?sGm1m2</span><span class="id"> ?IHn//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -big_distrl</span><span class="id"> -setIA</span><span class="id"> big_distrl/=</span><span class="id"> IHn//</span><span class="id"> setICA</span><span class="id"> setIid</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact/sGm</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> bigsetU_measurable</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> apply/sGm</span>.<br/>
<span class="id">have</span><span class="id"> g'_cover</span><span class="id"> :</span><span class="id"> \bigcup_k</span> (<span class="id">g'</span><span class="id"> k</span>)<span class="id"> =</span><span class="id"> setT</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -subTset</span><span class="id"> -g_cover</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> [k</span><span class="id"> _</span><span class="id"> gx];</span><span class="gallina-kwd"> exists</span><span class="id"> k</span>.<span class="id">+1</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="id">have</span><span class="id"> nd_g'</span><span class="id"> :</span><span class="id"> nondecreasing_seq</span><span class="id"> g'</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> m</span><span class="id"> n</span><span class="id"> lemn;</span><span class="id"> rewrite</span><span class="id"> subsetEset</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> [k</span><span class="id"> km</span><span class="id"> gx];</span><span class="gallina-kwd"> exists</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> leq_trans</span><span class="id"> lemn</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> gA</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> A</span><span class="id"> =</span><span class="id"> \bigcup_n</span> (<span class="id">g'</span><span class="id"> n</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setI_bigcupl</span><span class="id"> g'_cover</span><span class="id"> setTI</span>.<br/>
<span class="id">transitivity</span> (<span class="id">lim</span> (<span class="id">m1</span> (<span class="id">g'</span><span class="id"> n</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply/esym/cvg_lim</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> nondecreasing_cvg_mu</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> measurableI;</span><span class="id"> exact/sGm</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> bigcupT_measurable</span><span class="id"> =&gt;</span><span class="id"> k;</span><span class="id"> apply:</span><span class="id"> measurableI;</span><span class="id"> exact/sGm</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> apply/subsetPset;</span><span class="id"> apply:</span><span class="id"> setSI;</span><span class="id"> exact/subsetPset/nd_g'</span>.<br/>
<span class="id">transitivity</span> (<span class="id">lim</span> (<span class="id">m2</span> (<span class="id">g'</span><span class="id"> n</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="id"> @[n</span><span class="id"> --&gt;</span><span class="id"> \oo]</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/congr_lim/funext</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> sG'm1m2</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact/sGm</span>.<br/>
<span class="id">apply/cvg_lim</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> nondecreasing_cvg_mu</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> k;</span><span class="id"> apply:</span><span class="id"> measurableI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact/sGm</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> bigcupT_measurable</span><span class="id"> =&gt;</span><span class="id"> k;</span><span class="id"> apply:</span><span class="id"> measurableI;</span><span class="id"> exact/sGm</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> b</span><span class="id"> ab;</span><span class="id"> apply/subsetPset;</span><span class="id"> apply:</span><span class="id"> setSI;</span><span class="id"> exact/subsetPset/nd_g'</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> setIG</span><span class="id"> :</span><span class="id"> setI_closed</span><span class="id"> G</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> m1m2</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> G</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> m1</span><span class="id"> A</span><span class="id"> =</span><span class="id"> m2</span><span class="id"> A</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> m1goo</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> k,</span> (<span class="id">m1</span> (<span class="id">g</span><span class="id"> k</span>)<span class="id"> &lt;</span><span class="id"> +oo</span>)<span class="id">%E</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> g_sigma_algebra_measure_unique</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> E,</span><span class="id"> &lt;&lt;s</span><span class="id"> G</span><span class="id"> &gt;&gt;</span><span class="id"> E</span><span class="id"> -&gt;</span><span class="id"> m1</span><span class="id"> E</span><span class="id"> =</span><span class="id"> m2</span><span class="id"> E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> G_</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> X</span><span class="id"> |</span><span class="id"> G</span><span class="id"> X</span><span class="id"> /\</span><span class="id"> X</span><span class="id"> `&lt;=`</span><span class="id"> g</span><span class="id"> n]</span>. <span class="comment">(*&nbsp;"trace"&nbsp;*)</span><br/>
<span class="id">have</span><span class="id"> G_E</span><span class="id"> n</span><span class="id"> :</span><span class="id"> G_</span><span class="id"> n</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> g</span><span class="id"> n</span><span class="id"> `&amp;`</span><span class="id"> C</span><span class="id"> |</span><span class="id"> C</span><span class="gallina-kwd"> in</span><span class="id"> G]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> [GX</span><span class="id"> Xgn]</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> X</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> setIidr</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /G_</span><span class="id"> =&gt;</span><span class="id"> X</span><span class="id"> [Y</span><span class="id"> GY</span><span class="id"> &lt;-{X}];</span><span class="id"> split;</span><span class="id"> [exact:</span><span class="id"> setIG|apply:</span><span class="id"> subIset;</span><span class="id"> left]</span>.<br/>
<span class="id">have</span><span class="id"> gIsGE</span><span class="id"> n</span><span class="id"> :</span><span class="id"> [set</span><span class="id"> g</span><span class="id"> n</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> |</span><span class="id"> A</span><span class="gallina-kwd"> in</span><span class="id"> &lt;&lt;s</span><span class="id"> G</span><span class="id"> &gt;&gt;]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&lt;&lt;s</span><span class="id"> g</span><span class="id"> n,</span><span class="id"> preimage_class</span> (<span class="id">g</span><span class="id"> n</span>)<span class="id"> id</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> sigma_algebra_preimage_classE</span><span class="id"> eqEsubset;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> /=</span><span class="id"> [Y</span><span class="id"> sGY</span><span class="id"> &lt;-];</span><span class="gallina-kwd"> exists</span><span class="id"> Y</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> preimage_id</span><span class="id"> setIC</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> [Y</span><span class="id"> mY</span><span class="id"> &lt;-]</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> Y</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> preimage_id</span><span class="id"> setIC</span>.<br/>
<span class="id">have</span><span class="id"> preimg_gGE</span><span class="id"> n</span><span class="id"> :</span><span class="id"> preimage_class</span> (<span class="id">g</span><span class="id"> n</span>)<span class="id"> id</span><span class="id"> G</span><span class="id"> =</span><span class="id"> G_</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [_</span><span class="id"> [Y</span><span class="id"> GY</span><span class="id"> &lt;-]|]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> preimage_id</span><span class="id"> G_E</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> Y</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> setIC</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> [GX</span><span class="id"> Xgn];</span><span class="gallina-kwd"> exists</span><span class="id"> X</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> preimage_id</span><span class="id"> setIidr</span>.<br/>
<span class="id">apply:</span><span class="id"> g_sigma_algebra_measure_unique_cover</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> n</span><span class="id"> A</span><span class="id"> sGA;</span><span class="id"> apply:</span> (<span class="id">g_sigma_algebra_measure_unique_trace</span><span class="id"> G</span> (<span class="id">g</span><span class="id"> n</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> Gm</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> [?</span><span class="id"> _];</span><span class="id"> exact/Gm</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> [?</span><span class="id"> ?]</span><span class="id"> [?</span><span class="id"> ?];</span><span class="id"> split;</span><span class="id"> [exact:</span><span class="id"> setIG|apply:</span><span class="id"> subIset;</span><span class="id"> tauto]</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> m1m2</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> [?</span><span class="id"> ?];</span><span class="id"> exact:</span><span class="id"> m1m2</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> X;</span><span class="id"> rewrite</span><span class="id"> -/</span>(<span class="id">G_</span><span class="id"> n</span>)<span class="id"> -preimg_gGE</span><span class="id"> -gIsGE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> B</span><span class="id"> sGB</span><span class="id"> &lt;-{X};</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -/</span>(<span class="id">G_</span><span class="id"> n</span>)<span class="id"> -preimg_gGE</span><span class="id"> -gIsGE;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> g_sigma_algebra_measure_unique</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> g_sigma_algebra_measure_unique</span><span class="id"> {d</span><span class="id"> R</span><span class="id"> T}</span><span class="id"> G</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.2.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `g_sigma_algebra_measure_unique_cover`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> g_salgebra_measure_unique_cover</span><span class="id"> :=</span><span class="id"> g_sigma_algebra_measure_unique_cover</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.2.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `g_sigma_algebra_measure_unique`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> g_salgebra_measure_unique</span><span class="id"> :=</span><span class="id"> g_sigma_algebra_measure_unique</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_unique</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>).<br/>
<span class="vernacular">Variables</span>  (<span class="id">G</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T</span>)) (<span class="id">g</span><span class="id"> :</span> (<span class="id">set</span><span class="id"> T</span>)<span class="id">^nat</span>).<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">mG</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> =</span><span class="id"> &lt;&lt;s</span><span class="id"> G</span><span class="id"> &gt;&gt;</span>) (<span class="id">setIG</span><span class="id"> :</span><span class="id"> setI_closed</span><span class="id"> G</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> Gg</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> G</span> (<span class="id">g</span><span class="id"> i</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> g_cover</span><span class="id"> :</span><span class="id"> \bigcup_k</span> (<span class="id">g</span><span class="id"> k</span>)<span class="id"> =</span><span class="id"> setT</span>.<br/>
<span class="vernacular">Variables</span><span class="id"> m1</span><span class="id"> m2</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> m1m2</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> G</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> m1</span><span class="id"> A</span><span class="id"> =</span><span class="id"> m2</span><span class="id"> A</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> m1goo</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> k,</span> (<span class="id">m1</span> (<span class="id">g</span><span class="id"> k</span>)<span class="id"> &lt;</span><span class="id"> +oo</span>)<span class="id">%E</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_unique</span><span class="id"> A</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> m1</span><span class="id"> A</span><span class="id"> =</span><span class="id"> m2</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA;</span><span class="id"> apply:</span> (<span class="id">g_sigma_algebra_measure_unique</span><span class="id"> G</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -?mG//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mG;</span><span class="id"> exact:</span><span class="id"> sub_sigma_algebra</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> measure_unique</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> measure_unique</span><span class="id"> {d</span><span class="id"> R</span><span class="id"> T}</span><span class="id"> G</span><span class="id"> g</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_mu_extE</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> X</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> mu^*</span><span class="id"> X</span><span class="id"> =</span><span class="id"> mu</span><span class="id"> X</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mX;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le;</span><span class="id"> apply/andP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> ereal_inf_lbound;</span><span class="gallina-kwd"> exists</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> is</span><span class="id"> 0%N</span><span class="gallina-kwd"> then</span><span class="id"> X</span><span class="gallina-kwd"> else</span><span class="id"> set0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> [[]//</span><span class="id"> _|t</span><span class="id"> Xt];</span><span class="gallina-kwd"> exists</span><span class="id"> 0%N</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/cvg_lim</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> -cvg_shiftS</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> [sequence</span><span class="id"> _]_n</span><span class="id"> =</span><span class="id"> cst</span> (<span class="id">mu</span><span class="id"> X</span>))<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> cvg_cst</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> funeqE</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> big_nat_recl//=</span><span class="id"> big1</span><span class="id"> ?adde0</span>.<br/>
<span class="id">apply/lb_ereal_inf</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> [A</span><span class="id"> [mA</span><span class="id"> XA]</span><span class="id"> &lt;-{x}]</span>.<br/>
<span class="id">have</span><span class="id"> XUA</span><span class="id"> :</span><span class="id"> X</span><span class="id"> =</span><span class="id"> \bigcup_n</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> t;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [Xt|[i</span><span class="id"> _</span><span class="id"> []//]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [i</span><span class="id"> _</span><span class="id"> Ait]</span><span class="id"> :=</span><span class="id"> XA</span><span class="id"> _</span><span class="id"> Xt;</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<br/>
<span class="id">apply:</span> (<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;oo</span>)<span class="id"> mu</span> (<span class="id">X</span><span class="id"> `&amp;`</span><span class="id"> A</span><span class="id"> i</span>))).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> measure_sigma_subadditive//=</span><span class="id"> -?XUA</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i;</span><span class="id"> apply:</span><span class="id"> measurableI</span>.<br/>
<span class="id">apply:</span><span class="id"> lee_lim;</span><span class="id"> [exact:</span><span class="id"> is_cvg_nneseries|exact:</span><span class="id"> is_cvg_nneseries|]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> lee_sum</span><span class="id"> =&gt;</span><span class="id"> i</span> <span class="id"> _;</span><span class="id"> exact:</span><span class="id"> measureIr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> Rmu_ext</span>.<br/>
<span class="vernacular">Import</span><span class="id"> SetRing</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Rmu_ext</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {content</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">measure</span><span class="id"> mu</span>)<span class="id">^*</span><span class="id"> =</span><span class="id"> mu^*</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/funeqP</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> X;</span><span class="id"> rewrite</span><span class="id"> /mu_ext/=;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_le</span>.<br/>
<span class="id">rewrite</span><span class="id"> ?lb_ereal_inf//</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> [F</span><span class="id"> [Fm</span><span class="id"> XS]</span><span class="id"> &lt;-];</span><span class="id"> rewrite</span><span class="id"> ereal_inf_lbound//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> F;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> i;</span><span class="id"> exact:</span><span class="id"> sub_gen_smallest</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">eq_eseriesr</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> RmuE</span><span class="id"> _</span> (<span class="id">Fm</span><span class="id"> _</span>))).<br/>
<span class="id">pose</span><span class="id"> K</span><span class="id"> :=</span><span class="id"> [set:</span><span class="id"> nat]</span><span class="id"> `*``</span><span class="gallina-kwd"> fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> decomp</span> (<span class="id">F</span><span class="id"> i</span>).<br/>
<span class="id">have</span><span class="id"> /ppcard_eqP[f]</span><span class="id"> :</span> (<span class="id">K</span><span class="id"> #=</span><span class="id"> [set:</span><span class="id"> nat]</span>)<span class="id">%card</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> cardXR_eq_nat</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i;</span><span class="id"> split;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/set0P;</span><span class="id"> rewrite</span><span class="id"> decompN0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> finite_set_countable</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> decomp_finite_set</span>.<br/>
<span class="id">pose</span><span class="id"> g</span><span class="id"> i</span><span class="id"> :=</span> (<span class="id">f^-1%FUN</span><span class="id"> i</span>).<span class="id">2;</span><span class="gallina-kwd"> exists</span><span class="id"> g;</span><span class="id"> first</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> k;</span><span class="id"> have</span><span class="id"> [/=</span><span class="id"> _</span><span class="id"> /mem_set]</span><span class="id"> :</span><span class="id"> K</span> (<span class="id">f^-1%FUN</span><span class="id"> k</span>)<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> funS</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> decomp_measurable</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> /XS</span><span class="id"> [k</span><span class="id"> _];</span><span class="id"> rewrite</span><span class="id"> -[F</span><span class="id"> k]cover_decomp</span><span class="id"> =&gt;</span><span class="id"> -[D</span><span class="id"> /=</span><span class="id"> DFk</span><span class="id"> Di]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">f</span> (<span class="id">k,</span><span class="id"> D</span>))<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> /g</span><span class="id"> invK//</span><span class="id"> inE</span>.<br/>
<span class="id">rewrite</span><span class="id"> !nneseries_esum//=</span><span class="id"> /measure</span><span class="id"> ?set_true</span>.<br/>
<span class="id">transitivity</span> (<span class="id">\esum_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> setT</span>)<span class="id"> \sum_</span>(<span class="id">X0</span><span class="id"> \in</span><span class="id"> decomp</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> mu</span><span class="id"> X0</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_esum</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> fsbig_finite//;</span><span class="id"> exact:</span><span class="id"> decomp_finite_set</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">eq_esum</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> esum_fset</span><span class="id"> _</span><span class="id"> _</span>))<span class="id">//;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> decomp_finite_set</span>.<br/>
<span class="id">rewrite</span><span class="id"> esum_esum//=</span> (<span class="id">reindex_esum</span><span class="id"> K</span><span class="id"> setT</span><span class="id"> f</span>)<span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_esum</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> Ki;</span><span class="id"> rewrite</span><span class="id"> /g</span><span class="id"> funK</span><span class="id"> ?inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Rmu_ext</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_Rmu_extE</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> X</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">d</span>.<span class="id">-ring</span>.<span class="id">-measurable</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> mu^*</span><span class="id"> X</span><span class="id"> =</span><span class="id"> SetRing</span>.<span class="id">measure</span><span class="id"> mu</span><span class="id"> X</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Xm/=;</span><span class="id"> rewrite</span><span class="id"> -Rmu_ext/=</span><span class="id"> measurable_mu_extE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> measure_extension</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Let</span><span class="id"> Rmu</span><span class="id"> :=</span><span class="id"> SetRing</span>.<span class="id">measure</span><span class="id"> mu</span>.<br/>
<span class="vernacular">Notation</span><span class="id"> rT</span><span class="id"> :=</span> (<span class="id">SetRing</span>.<span class="id">type</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_caratheodory</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">d</span>.<span class="id">-measurable</span>).<span class="id">-sigma</span>.<span class="id">-measurable</span><span class="id"> `&lt;=`</span><span class="id"> mu^*</span>.<span class="id">-cara</span>.<span class="id">-measurable</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">suff:</span><span class="id"> &lt;&lt;s</span><span class="id"> d</span>.<span class="id">-ring</span>.<span class="id">-measurable</span><span class="id"> &gt;&gt;</span><span class="id"> `&lt;=`</span><span class="id"> mu^*</span>.<span class="id">-cara</span>.<span class="id">-measurable</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subset_trans;</span><span class="id"> apply:</span><span class="id"> sub_smallest2r</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> sub_smallest</span>.<br/>
<span class="id">apply:</span><span class="id"> smallest_sub</span>.<br/>
&nbsp;&nbsp;<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> [by</span><span class="id"> move=&gt;</span><span class="id"> X</span><span class="id"> mX;</span><span class="id"> rewrite</span><span class="id"> setTD;</span><span class="id"> exact:</span><span class="id"> measurableC</span><span class="id"> |</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> u_</span><span class="id"> mu_;</span><span class="id"> exact:</span><span class="id"> bigcupT_measurable]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> mA;</span><span class="id"> apply</span><span class="id"> le_caratheodory_measurable</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> X</span>.<br/>
<span class="id">apply</span><span class="id"> lb_ereal_inf</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> [B</span><span class="id"> [mB</span><span class="id"> XB]</span><span class="id"> &lt;-]</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">eq_eseriesr</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> SetRing</span>.<span class="id">RmuE</span><span class="id"> _</span> (<span class="id">mB</span><span class="id"> _</span>)))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">have</span><span class="id"> RmB</span><span class="id"> i</span><span class="id"> :</span><span class="id"> measurable</span> (<span class="id">B</span><span class="id"> i</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> sub_gen_smallest</span>.<br/>
<span class="id">set</span><span class="id"> BA</span><span class="id"> :=</span><span class="id"> eseries</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> Rmu</span> (<span class="id">B</span><span class="id"> n</span><span class="id"> `&amp;`</span><span class="id"> A</span>)).<br/>
<span class="id">set</span><span class="id"> BNA</span><span class="id"> :=</span><span class="id"> eseries</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> Rmu</span> (<span class="id">B</span><span class="id"> n</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A</span>)).<br/>
<span class="id">apply:</span> (<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">limn</span><span class="id"> BA</span><span class="id"> +</span><span class="id"> limn</span><span class="id"> BNA</span>))<span class="id">;</span><span class="id"> [apply:</span><span class="id"> leeD|]</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span> (_<span class="id"> :</span><span class="id"> BA</span><span class="id"> =</span><span class="id"> eseries</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> mu_ext</span><span class="id"> mu</span> (<span class="id">B</span><span class="id"> n</span><span class="id"> `&amp;`</span><span class="id"> A</span>)))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> funeqE</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> measurable_Rmu_extE</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">mu_ext</span><span class="id"> mu</span> (<span class="id">\bigcup_k</span> (<span class="id">B</span><span class="id"> k</span><span class="id"> `&amp;`</span><span class="id"> A</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> le_mu_ext;</span><span class="id"> rewrite</span><span class="id"> -setI_bigcupl;</span><span class="id"> exact:</span><span class="id"> setISS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> outer_measure_sigma_subadditive</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span> (_<span class="id"> :</span><span class="id"> BNA</span><span class="id"> =</span><span class="id"> eseries</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> mu_ext</span><span class="id"> mu</span> (<span class="id">B</span><span class="id"> n</span><span class="id"> `\`</span><span class="id"> A</span>)))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> funeqE</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> measurable_Rmu_extE</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> measurableD</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">mu_ext</span><span class="id"> mu</span> (<span class="id">\bigcup_k</span> (<span class="id">B</span><span class="id"> k</span><span class="id"> `\`</span><span class="id"> A</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> le_mu_ext;</span><span class="id"> rewrite</span><span class="id"> -setI_bigcupl;</span><span class="id"> exact:</span><span class="id"> setISS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> outer_measure_sigma_subadditive</span>.<br/>
<span class="id">have</span><span class="id"> ?</span><span class="id"> :</span><span class="id"> cvg</span> (<span class="id">BNA</span><span class="id"> @</span><span class="id"> \oo</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> is_cvg_nneseries</span>.<br/>
<span class="id">have</span><span class="id"> ?</span><span class="id"> :</span><span class="id"> cvg</span> (<span class="id">BA</span><span class="id"> @</span><span class="id"> \oo</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> is_cvg_nneseries</span>.<br/>
<span class="id">have</span><span class="id"> ?</span><span class="id"> :</span><span class="id"> cvg</span> (<span class="id">eseries</span> (<span class="id">Rmu</span><span class="id"> \o</span><span class="id"> B</span>)<span class="id"> @</span><span class="id"> \oo</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> is_cvg_nneseries</span>.<br/>
<span class="id">have</span><span class="id"> [def|]</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">lim</span> (<span class="id">BA</span><span class="id"> @</span><span class="id"> \oo</span>)<span class="id"> +?</span><span class="id"> lim</span> (<span class="id">BNA</span><span class="id"> @</span><span class="id"> \oo</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /adde_def</span><span class="id"> negb_and</span><span class="id"> !negbK=&gt;</span><span class="id"> /orP[/andP[BAoo</span><span class="id"> BNAoo]|/andP[BAoo</span><span class="id"> BNAoo]]</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> suff</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> limn</span> (<span class="id">eseries</span> (<span class="id">Rmu</span><span class="id"> \o</span><span class="id"> B</span>))<span class="id"> =</span><span class="id"> +oo</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> leey</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -leye_eq</span><span class="id"> -</span>(<span class="id">eqP</span><span class="id"> BAoo</span>)<span class="id">;</span><span class="id"> apply/lee_lim</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">near=&gt;</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> lee_sum</span><span class="id"> =&gt;</span><span class="id"> m</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> le_measure;</span><span class="id"> rewrite</span><span class="id"> /mkset;</span><span class="gallina-kwd"> by</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[rewrite</span><span class="id"> inE;</span><span class="id"> exact:</span><span class="id"> measurableI</span><span class="id"> |</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> |</span><span class="id"> apply:</span><span class="id"> subIset;</span><span class="id"> left]</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> suff</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> limn</span> (<span class="id">eseries</span> (<span class="id">Rmu</span><span class="id"> \o</span><span class="id"> B</span>))<span class="id"> =</span><span class="id"> +oo</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> leey</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -leye_eq</span><span class="id"> -</span>(<span class="id">eqP</span><span class="id"> BNAoo</span>)<span class="id">;</span><span class="id"> apply/lee_lim</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> near=&gt;</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> lee_sum</span><span class="id"> =&gt;</span><span class="id"> m</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -setDE;</span><span class="id"> apply:</span><span class="id"> le_measure;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /mkset</span><span class="id"> ?inE//;</span><span class="id"> apply:</span><span class="id"> measurableD</span>.<br/>
<span class="id">rewrite</span><span class="id"> -limeD</span><span class="id"> //</span> (_<span class="id"> :</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> _</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eseries</span> (<span class="gallina-kwd">fun</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> Rmu</span> (<span class="id">B</span><span class="id"> k</span><span class="id"> `&amp;`</span><span class="id"> A</span>)<span class="id"> +</span><span class="id"> Rmu</span> (<span class="id">B</span><span class="id"> k</span><span class="id"> `&amp;`</span><span class="id"> ~`</span><span class="id"> A</span>)))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> funeqE</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> -big_split</span><span class="id"> /=;</span><span class="id"> exact:</span><span class="id"> eq_bigr</span>.<br/>
<span class="id">apply/lee_lim</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/is_cvg_nneseries</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> adde_ge0</span>.<br/>
<span class="id">near=&gt;</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> lee_sum</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -measure_semi_additive2</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> le_measure;</span><span class="id"> rewrite</span><span class="id"> /mkset</span><span class="id"> ?inE//;</span><span class="id"> [|by</span><span class="id"> rewrite</span><span class="id"> -setIUr</span><span class="id"> setUCr</span><span class="id"> setIT]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> measurableU;</span><span class="id"> [exact:measurableI|rewrite</span><span class="id"> -setDE;</span><span class="id"> exact:measurableD]</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> measurableI</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setDE;</span><span class="id"> exact:</span><span class="id"> measurableD</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> measurableU;</span><span class="id"> [exact:measurableI|rewrite</span><span class="id"> -setDE;</span><span class="id"> exact:measurableD]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIACA</span><span class="id"> setICr</span><span class="id"> setI0</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> I</span><span class="id"> :=</span><span class="id"> [the</span><span class="id"> measurableType</span><span class="id"> _</span><span class="id"> of</span><span class="id"> g_sigma_algebraType</span> (<span class="id">@measurable</span><span class="id"> _</span><span class="id"> T</span>)<span class="id">]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> measure_extension</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> mu^*</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> measure_extension0</span><span class="id"> :</span><span class="id"> measure_extension</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> mu_ext0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> measure_extension_ge0</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> measure_extension</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> mu_ext_ge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> measure_extension_semi_sigma_additive</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">semi_sigma_additive</span><span class="id"> measure_extension</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> rewrite</span><span class="id"> /measure_extension</span>.<br/>
<span class="id">apply:</span><span class="id"> caratheodory_measure_sigma_additive</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> sub_caratheodory</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> exact:</span> (<span class="id">sub_caratheodory</span> (<span class="id">mF</span><span class="id"> i</span>)).<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> measure_extension</span><br/>
&nbsp;&nbsp;<span class="id">measure_extension0</span><span class="id"> measure_extension_ge0</span><br/>
&nbsp;&nbsp;<span class="id">measure_extension_semi_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_extension_sigma_finite</span><span class="id"> :</span><span class="id"> @sigma_finite</span><span class="id"> _</span><span class="id"> T</span><span class="id"> _</span><span class="id"> setT</span><span class="id"> mu</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">@sigma_finite</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> setT</span><span class="id"> measure_extension</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> -[S</span><span class="id"> setTS</span><span class="id"> mS];</span><span class="gallina-kwd"> exists</span><span class="id"> S</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> :=</span> (<span class="id">mS</span><span class="id"> i</span>).<span class="id">1;</span><span class="id"> exact:</span><span class="id"> sub_sigma_algebra</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /measure_extension</span><span class="id"> /=</span><span class="id"> measurable_mu_extE</span><span class="id"> //;</span><br/>
&nbsp;&nbsp;<span class="id">[exact:</span> (<span class="id">mS</span><span class="id"> i</span>).<span class="id">2</span><span class="id"> |</span><span class="id"> exact:</span> (<span class="id">mS</span><span class="id"> i</span>).<span class="id">1]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_extension_unique</span><span class="id"> :</span><span class="id"> sigma_finite</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> mu</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> mu'</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R},</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> X,</span><span class="id"> d</span>.<span class="id">-measurable</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> X</span><span class="id"> =</span><span class="id"> mu'</span><span class="id"> X</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> X,</span> (<span class="id">d</span>.<span class="id">-measurable</span>).<span class="id">-sigma</span>.<span class="id">-measurable</span><span class="id"> X</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">measure_extension</span><span class="id"> X</span><span class="id"> =</span><span class="id"> mu'</span><span class="id"> X</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [F</span><span class="id"> TF</span><span class="id"> /all_and2[Fm</span><span class="id"> muF]]</span><span class="id"> mu'</span><span class="id"> mu'mu</span><span class="id"> X</span><span class="id"> mX</span>.<br/>
<span class="id">apply:</span> (<span class="id">@measure_unique</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [the</span><span class="id"> measurableType</span><span class="id"> _</span><span class="id"> of</span><span class="id"> I]</span><span class="id"> d</span>.<span class="id">-measurable</span><span class="id"> F</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> Am</span><span class="id"> Bm;</span><span class="id"> apply:</span><span class="id"> measurableI</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> Am;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> /measure_extension</span><span class="id"> measurable_mu_extE//</span><span class="id"> mu'mu</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> k;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> /measure_extension</span><span class="id"> measurable_mu_extE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> measure_extension</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> caratheodory_measurable_mu_ext</span><span class="id"> d</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>)<span class="id"> A</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">d</span>.<span class="id">-measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> mu^*</span>.<span class="id">-cara</span>.<span class="id">-measurable</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Am;</span><span class="id"> apply:</span><span class="id"> sub_caratheodory</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> sub_sigma_algebra</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> completed_measure_extension</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ereal_scope</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Notation</span><span class="id"> rT</span><span class="id"> :=</span> (<span class="id">SetRing</span>.<span class="id">type</span><span class="id"> T</span>).<br/>
<span class="vernacular">Let</span><span class="id"> Rmu</span><span class="id"> :</span><span class="id"> set</span><span class="id"> rT</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> SetRing</span>.<span class="id">measure</span><span class="id"> mu</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> I</span><span class="id"> :=</span><span class="id"> [the</span><span class="id"> measurableType</span><span class="id"> _</span><span class="id"> of</span><span class="id"> caratheodory_type</span> (<span class="id">mu^*</span>)<span class="id">%mu]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> completed_measure_extension</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span><span class="id"> :=</span> (<span class="id">mu^*</span>)<span class="id">%mu</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> measure0</span><span class="id"> :</span><span class="id"> completed_measure_extension</span><span class="id"> set0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> mu_ext0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> measure_ge0</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>)<span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> completed_measure_extension</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> mu_ext_ge0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> measure_semi_sigma_additive</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">semi_sigma_additive</span><span class="id"> completed_measure_extension</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> F</span><span class="id"> mF</span><span class="id"> tF</span><span class="id"> mUF;</span><span class="id"> rewrite</span><span class="id"> /completed_measure_extension</span>.<br/>
<span class="id">exact:</span><span class="id"> caratheodory_measure_sigma_additive</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isMeasure</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> completed_measure_extension</span><br/>
&nbsp;&nbsp;<span class="id">measure0</span><span class="id"> measure_ge0</span><span class="id"> measure_semi_sigma_additive</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> completed_measure_extension_sigma_finite</span><span class="id"> :</span><span class="id"> @sigma_finite</span><span class="id"> _</span><span class="id"> T</span><span class="id"> _</span><span class="id"> setT</span><span class="id"> mu</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">@sigma_finite</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> setT</span><span class="id"> completed_measure_extension</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> -[S</span><span class="id"> setTS</span><span class="id"> mS];</span><span class="gallina-kwd"> exists</span><span class="id"> S</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> move=&gt;</span><span class="id"> i;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> sub_caratheodory;</span><span class="id"> apply:</span><span class="id"> sub_sigma_algebra</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">mS</span><span class="id"> i</span>).<span class="id">1</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /completed_measure_extension</span><span class="id"> /=</span><span class="id"> measurable_mu_extE</span><span class="id"> //;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[exact:</span> (<span class="id">mS</span><span class="id"> i</span>).<span class="id">2</span><span class="id"> |</span><span class="id"> exact:</span> (<span class="id">mS</span><span class="id"> i</span>).<span class="id">1]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> completed_measure_extension</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> preimage_classes</span><span class="id"> d1</span><span class="id"> d2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T1</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d1</span>) (<span class="id">T2</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d2</span>) (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f1</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T1</span>) (<span class="id">f2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T2</span>) <span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">&lt;&lt;s</span><span class="id"> preimage_class</span><span class="id"> setT</span><span class="id"> f1</span><span class="id"> measurable</span><span class="id"> `|`</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">preimage_class</span><span class="id"> setT</span><span class="id"> f2</span><span class="id"> measurable</span><span class="id"> &gt;&gt;</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> product_lemma</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d1</span><span class="id"> d2</span> (<span class="id">T1</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d1</span>) (<span class="id">T2</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d2</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> pointedType</span>) (<span class="id">f1</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T1</span>) (<span class="id">f2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T2</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">T3</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> T3</span><span class="id"> -&gt;</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> preimage_classes_comp</span><span class="id"> :</span><span class="id"> preimage_classes</span> (<span class="id">f1</span><span class="id"> \o</span><span class="id"> g</span>) (<span class="id">f2</span><span class="id"> \o</span><span class="id"> g</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">preimage_class</span><span class="id"> setT</span><span class="id"> g</span> (<span class="id">preimage_classes</span><span class="id"> f1</span><span class="id"> f2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> {1}/preimage_classes</span><span class="id"> -sigma_algebra_preimage_classE;</span><span class="id"> congr</span> (<span class="id">&lt;&lt;s</span><span class="id"> _</span><span class="id"> &gt;&gt;</span>).<br/>
<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> C;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> [[A</span><span class="id"> mA</span><span class="id"> &lt;-{C}]|[A</span><span class="id"> mA</span><span class="id"> &lt;-{C}]]</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span> (<span class="id">f1</span><span class="id"> @^-1`</span><span class="id"> A</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> left;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> setTI</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span> (<span class="id">f2</span><span class="id"> @^-1`</span><span class="id"> A</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> right;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> setTI</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> [A</span><span class="id"> [[B</span><span class="id"> mB</span><span class="id"> &lt;-{A}</span><span class="id"> &lt;-{C}]|[B</span><span class="id"> mB</span><span class="id"> &lt;-{A}</span><span class="id"> &lt;-{C}]]]</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> left;</span><span class="id"> rewrite</span><span class="id"> !setTI;</span><span class="gallina-kwd"> exists</span><span class="id"> B</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> setTI</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> right;</span><span class="id"> rewrite</span><span class="id"> !setTI;</span><span class="gallina-kwd"> exists</span><span class="id"> B</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> setTI</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> product_lemma</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> measure_prod_display</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">measure_display</span><span class="id"> *</span><span class="id"> measure_display</span>)<span class="id"> -&gt;</span><span class="id"> measure_display</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> product_salgebra_instance</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d1</span><span class="id"> d2</span> (<span class="id">T1</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d1</span>) (<span class="id">T2</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d2</span>).<br/>
<span class="vernacular">Let</span><span class="id"> f1</span><span class="id"> :=</span><span class="id"> @fst</span><span class="id"> T1</span><span class="id"> T2</span>.<br/>
<span class="vernacular">Let</span><span class="id"> f2</span><span class="id"> :=</span><span class="id"> @snd</span><span class="id"> T1</span><span class="id"> T2</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> prod_salgebra_set0</span><span class="id"> :</span><span class="id"> preimage_classes</span><span class="id"> f1</span><span class="id"> f2</span> (<span class="id">set0</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">T1</span><span class="id"> *</span><span class="id"> T2</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> sigma_algebra0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> prod_salgebra_setC</span><span class="id"> A</span><span class="id"> :</span><span class="id"> preimage_classes</span><span class="id"> f1</span><span class="id"> f2</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">preimage_classes</span><span class="id"> f1</span><span class="id"> f2</span> (<span class="id">~`</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> sigma_algebraC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> prod_salgebra_bigcup</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> _^nat</span>)<span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> preimage_classes</span><span class="id"> f1</span><span class="id"> f2</span> (<span class="id">F</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">preimage_classes</span><span class="id"> f1</span><span class="id"> f2</span> (<span class="id">\bigcup_i</span> (<span class="id">F</span><span class="id"> i</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> sigma_algebra_bigcup</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Pointed</span>.<span class="id">on</span> (<span class="id">T1</span><span class="id"> *</span><span class="id"> T2</span>)<span class="id">%type</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> prod_salgebra_mixin</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@isMeasurable</span>.<span class="id">Build</span> (<span class="id">measure_prod_display</span> (<span class="id">d1,</span><span class="id"> d2</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T1</span><span class="id"> *</span><span class="id"> T2</span>)<span class="id">%type</span> (<span class="id">preimage_classes</span><span class="id"> f1</span><span class="id"> f2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">prod_salgebra_set0</span>) (<span class="id">prod_salgebra_setC</span>) (<span class="id">prod_salgebra_bigcup</span>).<br/>
<br/>
<span class="vernacular">End</span><span class="id"> product_salgebra_instance</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;p .-prod&quot;</span><span class="id"> :=</span> (<span class="id">measure_prod_display</span><span class="id"> p</span>)<span class="id"> :</span><span class="id"> measure_display_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;p .-prod.-measurable&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;((<span class="id">p</span>.<span class="id">-prod</span>).<span class="id">-measurable</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span> (_<span class="id"> *</span><span class="id"> _</span>)))<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">classical_set_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurableX</span><span class="id"> d1</span><span class="id"> d2</span> (<span class="id">T1</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d1</span>) (<span class="id">T2</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T1</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> measurable</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> measurable</span> (<span class="id">A</span><span class="id"> `*`</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mA</span><span class="id"> mB</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> A</span><span class="id"> `*`</span><span class="id"> B</span><span class="id"> =</span> (<span class="id">A</span><span class="id"> `*`</span><span class="id"> setT</span>)<span class="id"> `&amp;`</span> (<span class="id">setT</span><span class="id"> `*`</span><span class="id"> B</span>)<span class="id"> :&gt;</span><span class="id"> set</span> (<span class="id">T1</span><span class="id"> *</span><span class="id"> T2</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{1}</span>(<span class="id">setIT</span><span class="id"> A</span>)<span class="id"> -{1}</span>(<span class="id">setTI</span><span class="id"> B</span>)<span class="id"> setXI</span>.<br/>
<span class="id">rewrite</span><span class="id"> setXT</span><span class="id"> setTX;</span><span class="id"> apply:</span><span class="id"> measurableI</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> sub_sigma_algebra;</span><span class="id"> left;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> setTI</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> sub_sigma_algebra;</span><span class="id"> right;</span><span class="gallina-kwd"> exists</span><span class="id"> B</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> setTI</span>.<br/>
Qed.</div></details>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 1.3.0&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `measurableX`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> measurableM</span><span class="id"> :=</span><span class="id"> measurableX</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> product_salgebra_algebraOfSetsType</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d1</span><span class="id"> d2</span> (<span class="id">T1</span><span class="id"> :</span><span class="id"> algebraOfSetsType</span><span class="id"> d1</span>) (<span class="id">T2</span><span class="id"> :</span><span class="id"> algebraOfSetsType</span><span class="id"> d2</span>).<br/>
<span class="vernacular">Let</span><span class="id"> M1</span><span class="id"> :=</span><span class="id"> @measurable</span><span class="id"> _</span><span class="id"> T1</span>.<br/>
<span class="vernacular">Let</span><span class="id"> M2</span><span class="id"> :=</span><span class="id"> @measurable</span><span class="id"> _</span><span class="id"> T2</span>.<br/>
<span class="vernacular">Let</span><span class="id"> M1xM2</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> `*`</span><span class="id"> B</span><span class="id"> |</span><span class="id"> A</span><span class="gallina-kwd"> in</span><span class="id"> M1</span><span class="id"> &amp;</span><span class="id"> B</span><span class="gallina-kwd"> in</span><span class="id"> M2]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_prod_measurableType</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">d1,</span><span class="id"> d2</span>).<span class="id">-prod</span>.<span class="id">-measurable</span><span class="id"> =</span><span class="id"> &lt;&lt;s</span><span class="id"> M1xM2</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> smallest_sub;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> smallest_sigma_algebra</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> subUset;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> have</span><span class="id"> /subset_trans</span><span class="id"> :</span><span class="id"> preimage_class</span><span class="id"> setT</span><span class="id"> fst</span><span class="id"> M1</span><span class="id"> `&lt;=`</span><span class="id"> M1xM2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> [X</span><span class="id"> MX</span><span class="id"> &lt;-];</span><span class="gallina-kwd"> exists</span><span class="id"> X=&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> setT;</span><span class="id"> rewrite</span><span class="id"> /M2</span><span class="id"> //</span><span class="id"> setIC//</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply;</span><span class="id"> exact:</span><span class="id"> sub_sigma_algebra</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> have</span><span class="id"> /subset_trans</span><span class="id"> :</span><span class="id"> preimage_class</span><span class="id"> setT</span><span class="id"> snd</span><span class="id"> M2</span><span class="id"> `&lt;=`</span><span class="id"> M1xM2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> [Y</span><span class="id"> MY</span><span class="id"> &lt;-];</span><span class="gallina-kwd"> exists</span><span class="id"> setT;</span><span class="id"> rewrite</span><span class="id"> /M1</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> Y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply;</span><span class="id"> exact:</span><span class="id"> sub_sigma_algebra</span>.<br/>
<span class="id">apply:</span><span class="id"> smallest_sub;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> smallest_sigma_algebra</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> [A</span><span class="id"> MA]</span><span class="id"> [B</span><span class="id"> MB]</span><span class="id"> &lt;-;</span><span class="id"> apply:</span><span class="id"> measurableX</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> sub_sigma_algebra</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> product_salgebra_algebraOfSetsType</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> product_salgebra_g_measurableTypeR</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d1</span> (<span class="id">T1</span><span class="id"> :</span><span class="id"> algebraOfSetsType</span><span class="id"> d1</span>) (<span class="id">T2</span><span class="id"> :</span><span class="id"> pointedType</span>) (<span class="id">C2</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T2</span>)).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> setTC2</span><span class="id"> :</span><span class="id"> setT</span><span class="id"> `&lt;=`</span><span class="id"> C2</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_prod_g_measurableTypeR</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">@measurable</span><span class="id"> _</span><span class="id"> [the</span><span class="id"> measurableType</span><span class="id"> _</span><span class="id"> of</span><span class="id"> T1</span><span class="id"> *</span><span class="id"> g_sigma_algebraType</span><span class="id"> C2</span><span class="id"> :</span><span class="id"> Type]</span><br/>
&nbsp;&nbsp;<span class="id">=</span><span class="id"> &lt;&lt;s</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> `*`</span><span class="id"> B</span><span class="id"> |</span><span class="id"> A</span><span class="gallina-kwd"> in</span><span class="id"> measurable</span><span class="id"> &amp;</span><span class="id"> B</span><span class="gallina-kwd"> in</span><span class="id"> C2]</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> measurable_prod_measurableType</span><span class="id"> //;</span><span class="id"> congr</span> (<span class="id">&lt;&lt;s</span><span class="id"> _</span><span class="id"> &gt;&gt;</span>).<br/>
<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> X;</span><span class="id"> split=&gt;</span><span class="id"> [[A</span><span class="id"> mA]</span><span class="id"> [B</span><span class="id"> mB]</span><span class="id"> &lt;-{X}|[A</span><span class="id"> C1A]</span><span class="id"> [B</span><span class="id"> C2B]</span><span class="id"> &lt;-{X}]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> B</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> setTC2</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> B</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> sub_sigma_algebra</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> product_salgebra_g_measurableTypeR</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> product_salgebra_g_measurableType</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">T1</span><span class="id"> T2</span><span class="id"> :</span><span class="id"> pointedType</span>) (<span class="id">C1</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T1</span>)) (<span class="id">C2</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">set</span><span class="id"> T2</span>)).<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">setTC1</span><span class="id"> :</span><span class="id"> setT</span><span class="id"> `&lt;=`</span><span class="id"> C1</span>) (<span class="id">setTC2</span><span class="id"> :</span><span class="id"> setT</span><span class="id"> `&lt;=`</span><span class="id"> C2</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_prod_g_measurableType</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">@measurable</span><span class="id"> _</span> (<span class="id">g_sigma_algebraType</span><span class="id"> C1</span><span class="id"> *</span><span class="id"> g_sigma_algebraType</span><span class="id"> C2</span>)<span class="id">%type</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">&lt;&lt;s</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> `*`</span><span class="id"> B</span><span class="id"> |</span><span class="id"> A</span><span class="gallina-kwd"> in</span><span class="id"> C1</span><span class="id"> &amp;</span><span class="id"> B</span><span class="gallina-kwd"> in</span><span class="id"> C2]</span><span class="id"> &gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> measurable_prod_measurableType</span><span class="id"> //;</span><span class="id"> congr</span> (<span class="id">&lt;&lt;s</span><span class="id"> _</span><span class="id"> &gt;&gt;</span>).<br/>
<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> X;</span><span class="id"> split=&gt;</span><span class="id"> [[A</span><span class="id"> mA]</span><span class="id"> [B</span><span class="id"> mB]</span><span class="id"> &lt;-{X}|[A</span><span class="id"> C1A]</span><span class="id"> [B</span><span class="id"> C2B]</span><span class="id"> &lt;-{X}]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> A;</span><span class="id"> [exact:</span><span class="id"> setTC1|exists</span><span class="id"> B</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> setTC2]</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> A;</span><span class="id"> [exact:</span><span class="id"> sub_sigma_algebra|exists</span><span class="id"> B</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> sub_sigma_algebra]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> product_salgebra_g_measurableType</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> prod_measurable_fun</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span><span class="id"> d1</span><span class="id"> d2</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">T1</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T2</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d2</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prod_measurable_funP</span> (<span class="id">h</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T1</span><span class="id"> *</span><span class="id"> T2</span>)<span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> setT</span><span class="id"> h</span><span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> setT</span> (<span class="id">fst</span><span class="id"> \o</span><span class="id"> h</span>)<span class="id"> /\</span><span class="id"> measurable_fun</span><span class="id"> setT</span> (<span class="id">snd</span><span class="id"> \o</span><span class="id"> h</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">@iff_trans</span><span class="id"> _</span> (<span class="id">preimage_classes</span> (<span class="id">fst</span><span class="id"> \o</span><span class="id"> h</span>) (<span class="id">snd</span><span class="id"> \o</span><span class="id"> h</span>)<span class="id"> `&lt;=`</span><span class="id"> measurable</span>)).<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> preimage_classes_comp;</span><span class="id"> split=&gt;</span><span class="id"> [mf</span><span class="id"> A</span><span class="id"> [C</span><span class="id"> HC</span><span class="id"> &lt;-]|f12];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> mf</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> A</span><span class="id"> mA;</span><span class="id"> apply:</span><span class="id"> f12;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span>.<br/>
<span class="id">-</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [h12|[mf1</span><span class="id"> mf2]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> A</span><span class="id"> mA;</span><span class="id"> apply:</span><span class="id"> h12;</span><span class="id"> apply:</span><span class="id"> sub_sigma_algebra;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> [left;</span><span class="gallina-kwd"> exists</span><span class="id"> A|right;</span><span class="gallina-kwd"> exists</span><span class="id"> A]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> smallest_sub;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> sigma_algebra_measurable</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> subUset;</span><span class="id"> split=&gt;</span><span class="id"> [|]</span><span class="id"> A</span><span class="id"> [C</span><span class="id"> mC</span><span class="id"> &lt;-];</span><span class="id"> [exact:</span><span class="id"> mf1|exact:</span><span class="id"> mf2]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_fun_prod</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T1</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> setT</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> setT</span><span class="id"> g</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> setT</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">f</span><span class="id"> x,</span><span class="id"> g</span><span class="id"> x</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> mf</span><span class="id"> mg;</span><span class="id"> exact/prod_measurable_funP</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> prod_measurable_fun</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.3&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `measurable_fun_prod`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> measurable_fun_pair</span><span class="id"> :=</span><span class="id"> measurable_fun_prod</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> prod_measurable_proj</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d1</span><span class="id"> d2</span> (<span class="id">T1</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d1</span>) (<span class="id">T2</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d2</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_fst</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T1</span><span class="id"> *</span><span class="id"> T2]</span><span class="id"> fst</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /prod_measurable_funP[]</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@measurable_id</span><span class="id"> _</span><span class="id"> [the</span><span class="id"> measurableType</span><span class="id"> _</span><span class="id"> of</span> (<span class="id">T1</span><span class="id"> *</span><span class="id"> T2</span>)<span class="id">%type]</span><span class="id"> setT</span>.<br/>
Qed.</div></details>
<span class="id">#[local]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> measurable_fst</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_snd</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T1</span><span class="id"> *</span><span class="id"> T2]</span><span class="id"> snd</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /prod_measurable_funP[]</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@measurable_id</span><span class="id"> _</span><span class="id"> [the</span><span class="id"> measurableType</span><span class="id"> _</span><span class="id"> of</span> (<span class="id">T1</span><span class="id"> *</span><span class="id"> T2</span>)<span class="id">%type]</span><span class="id"> setT</span>.<br/>
Qed.</div></details>
<span class="id">#[local]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> measurable_snd</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_swap</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> _]</span> (<span class="id">@swap</span><span class="id"> T1</span><span class="id"> T2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> measurable_fun_prod</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> prod_measurable_proj</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> measurable_fst</span><span class="id"> {d1</span><span class="id"> d2</span><span class="id"> T1</span><span class="id"> T2}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> measurable_snd</span><span class="id"> {d1</span><span class="id"> d2</span><span class="id"> T1</span><span class="id"> T2}</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.3&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `measurable_fst`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> measurable_fun_fst</span><span class="id"> :=</span><span class="id"> measurable_fst</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.3&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `measurable_snd`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> measurable_fun_snd</span><span class="id"> :=</span><span class="id"> measurable_snd</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.3&quot;</span><span class="id">,</span><span class="id"> note=</span><span class="id">&quot;renamed `measurable_swap`&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> measurable_fun_swap</span><span class="id"> :=</span><span class="id"> measurable_swap</span> (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">measurable_fun</span><span class="id"> _</span><span class="id"> fst</span>)<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> measurable_fst]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">measurable_fun</span><span class="id"> _</span><span class="id"> snd</span>)<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> measurable_snd]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_fun_if_pair</span><span class="id"> d</span><span class="id"> d'</span> (<span class="id">X</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Y</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d'</span>) (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> setT</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> measurable_fun</span><span class="id"> setT</span><span class="id"> y</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">measurable_fun</span><span class="id"> setT</span> (<span class="gallina-kwd">fun</span><span class="id"> tb</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> tb</span>.<span class="id">2</span><span class="gallina-kwd"> then</span><span class="id"> x</span><span class="id"> tb</span>.<span class="id">1</span><span class="gallina-kwd"> else</span><span class="id"> y</span><span class="id"> tb</span>.<span class="id">1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> mx</span><span class="id"> my;</span><span class="id"> apply:</span><span class="id"> measurable_fun_ifT</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> exact:</span><span class="id"> measurableT_comp</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> partial_measurable_fun</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span><span class="id"> d1</span><span class="id"> d2</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">T1</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d1</span>)<br/>
&nbsp;&nbsp;(<span class="id">T2</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d2</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> *</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_pair1</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T1</span>)<span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T2]</span> (<span class="id">pair</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> m1pairx</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T2]</span> (<span class="id">fst</span><span class="id"> \o</span><span class="id"> pair</span><span class="id"> x</span>)<span class="gallina-kwd"> by</span><span class="id"> exact/measurable_cst</span>.<br/>
<span class="id">have</span><span class="id"> m2pairx</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T2]</span> (<span class="id">snd</span><span class="id"> \o</span><span class="id"> pair</span><span class="id"> x</span>)<span class="gallina-kwd"> by</span><span class="id"> exact/measurable_id</span>.<br/>
<span class="id">exact/</span>(<span class="id">prod_measurable_funP</span><span class="id"> _</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measurable_pair2</span> (<span class="id">y</span><span class="id"> :</span><span class="id"> T2</span>)<span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T1]</span> (<span class="id">pair^~</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> m1pairy</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T1]</span> (<span class="id">fst</span><span class="id"> \o</span><span class="id"> pair^~y</span>)<span class="gallina-kwd"> by</span><span class="id"> exact/measurable_id</span>.<br/>
<span class="id">have</span><span class="id"> m2pairy</span><span class="id"> :</span><span class="id"> measurable_fun</span><span class="id"> [set:</span><span class="id"> T1]</span> (<span class="id">snd</span><span class="id"> \o</span><span class="id"> pair^~y</span>)<span class="gallina-kwd"> by</span><span class="id"> exact/measurable_cst</span>.<br/>
<span class="id">exact/</span>(<span class="id">prod_measurable_funP</span><span class="id"> _</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> partial_measurable_fun</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">measurable_fun</span><span class="id"> _</span> (<span class="id">pair</span><span class="id"> _</span>))<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> measurable_pair1]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">measurable_fun</span><span class="id"> _</span> (<span class="id">pair^~</span><span class="id"> _</span>))<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">solve</span><span class="id"> [apply:</span><span class="id"> measurable_pair2]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> absolute_continuity</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> m</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> measure_dominates</span><span class="id"> m1</span><span class="id"> m2</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> A,</span><span class="id"> measurable</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> m2</span><span class="id"> A</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> m1</span><span class="id"> A</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;m1 `&lt;&lt; m2&quot;</span><span class="id"> :=</span> (<span class="id">measure_dominates</span><span class="id"> m1</span><span class="id"> m2</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_dominates_trans</span><span class="id"> m1</span><span class="id"> m2</span><span class="id"> m3</span><span class="id"> :</span><span class="id"> m1</span><span class="id"> `&lt;&lt;</span><span class="id"> m2</span><span class="id"> -&gt;</span><span class="id"> m2</span><span class="id"> `&lt;&lt;</span><span class="id"> m3</span><span class="id"> -&gt;</span><span class="id"> m1</span><span class="id"> `&lt;&lt;</span><span class="id"> m3</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> m12</span><span class="id"> m23</span><span class="id"> A</span><span class="id"> mA</span><span class="id"> /m23-/</span>(_<span class="id"> mA</span>)<span class="id"> /m12;</span><span class="id"> exact</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> absolute_continuity</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;m1 `&lt;&lt; m2&quot;</span><span class="id"> :=</span> (<span class="id">measure_dominates</span><span class="id"> m1</span><span class="id"> m2</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> absolute_continuity_lemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> measurableType</span><span class="id"> d</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> m</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> measure_dominates_ae_eq</span><span class="id"> m1</span><span class="id"> m2</span><span class="id"> f</span><span class="id"> g</span><span class="id"> E</span><span class="id"> :</span><span class="id"> measurable</span><span class="id"> E</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">m2</span><span class="id"> `&lt;&lt;</span><span class="id"> m1</span><span class="id"> -&gt;</span><span class="id"> ae_eq</span><span class="id"> m1</span><span class="id"> E</span><span class="id"> f</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> ae_eq</span><span class="id"> m2</span><span class="id"> E</span><span class="id"> f</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> mE</span><span class="id"> m21</span><span class="id"> [A</span><span class="id"> [mA</span><span class="id"> A0</span><span class="id"> ?]];</span><span class="gallina-kwd"> exists</span><span class="id"> A;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> m21</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> absolute_continuity_lemmas</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> essential_supremum</span>.<br/>
<span class="vernacular">Context</span><span class="id"> d</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> semiRingOfSetsType</span><span class="id"> d}</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span>.<br/>
<span class="vernacular">Variable</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {measure</span><span class="id"> set</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> \bar</span><span class="id"> R}</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> ess_sup</span><span class="id"> f</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ereal_inf</span> (<span class="id">EFin</span><span class="id"> @`</span><span class="id"> [set</span><span class="id"> r</span><span class="id"> |</span><span class="id"> mu</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> `]r,</span><span class="id"> +oo[</span>)<span class="id"> =</span><span class="id"> 0]</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ess_sup_ge0</span><span class="id"> f</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> mu</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> t,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> f</span><span class="id"> t</span>)<span class="id">%R</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> ess_sup</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> muT</span><span class="id"> f0;</span><span class="id"> apply:</span><span class="id"> lb_ereal_inf</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /=</span><span class="id"> [r</span><span class="id"> /eqP</span><span class="id"> rf</span><span class="id"> &lt;-];</span><span class="id"> rewrite</span><span class="id"> leNgt</span>.<br/>
<span class="id">apply/negP</span><span class="id"> =&gt;</span><span class="id"> r0;</span><span class="id"> apply/negP</span><span class="id"> :</span><span class="id"> rf;</span><span class="id"> rewrite</span><span class="id"> gt_eqF//</span> (_<span class="id"> :</span><span class="id"> _</span><span class="id"> @^-1`</span><span class="id"> _</span><span class="id"> =</span><span class="id"> setT</span>)<span class="id">//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/seteqP;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> _</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> in_itv/=</span> (<span class="id">lt_le_trans</span><span class="id"> _</span> (<span class="id">f0</span><span class="id"> x</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> essential_supremum</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
