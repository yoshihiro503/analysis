
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.analysis.function_spaces</title>
<meta name="description" content="Documentation of Coq module mathcomp.analysis.function_spaces" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.analysis.function_spaces</h1>
<span class="vernacular">From</span><span class="id"> HB</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> structures</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> all_ssreflect</span><span class="id"> all_algebra</span><span class="id"> finmap</span><span class="id"> generic_quotient</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> boolp</span><span class="id"> classical_sets</span><span class="id"> functions</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> cardinality</span><span class="id"> mathcomp_extra</span><span class="id"> fsbigop</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> reals</span><span class="id"> signed</span><span class="id"> topology</span><span class="id"> separation_axioms</span>.<br/>
<br/>
<div class="ssrdoc md">
# The topology of functions spaces

Function spaces have no canonical topology. We develop the theory of
several general-purpose function space topologies here.

## Topologies on `U -&gt; V`
There is no canonical topology on `U-&gt;V` in this library. Mathematically,
the right topology usually depends on context. We provide three general
options in this file which work for various amounts of structures on the
domain and codomain.

Topologies we consider are:
- Topology of pointwise convergence
  + requires only a topology on V
- Topology of uniform convergence
  + requires only a uniformity on V
- Topology of uniform convergence on subspaces
  + requires only a uniformity on V
- The compact-open topology
  + requires a topology on U and V

if you're looking for the topology of compact convergence, note that
it is exactly the compact-open topology via `compact_open_fam_compactP`.

To locally assign a topology to `-&gt;`, import one of the following modules
- ArrowAsProduct assigns the product topology
- ArrowAsUniformType assigns the uniform topology
- ArrowAsCompactOpen assign the compact-open topology

The major results are:
- Compactness in the product topology via Tychonoff's
- Compactness in the compact convergence topology via Ascoli's
- Conditions when the supremum and weak topology commute in products
- The compact-open topology is the topopology of compact convergence
- Cartesian closedness for the category of locally compact topologies

## Function space notations
```
      {uniform` A -&gt; V} == the space U -&gt; V, equipped with the topology
                           of uniform convergence from a set A to V, where
                           V is a uniformType
       {uniform U -&gt; V} := {uniform` [set: U] -&gt; V}
   {uniform A, F --&gt; f} == F converges to f in {uniform A -&gt; V}
     {uniform, F --&gt; f} := {uniform setT, F --&gt; f}
      prod_topology I T == the topology of pointwise convergence on the
                           dependent space `forall (i:I), T i`
 arrow_uniform_type U V == the topology of uniform convergence on the
                           type `U -&gt; V`
          {ptws U -&gt; V} == prod_topology for the non-dependent product
separate_points_from_closed f == for a closed set U and point x outside
                           some member of the family f, it sends f_i(x)
                           outside (closure (f_i @` U))
                           Used together with join_product.
         join_product f == the function (x =&gt; f ^~ x)
                           When the family f separates points from closed
                           sets, join_product is an embedding.
        {ptws, F --&gt; f} == F converges to f in {ptws U -&gt; V}
   {family fam, U -&gt; V} == the supremum of {uniform A -&gt; f} for each A in
                           `fam`
                           In particular, {family compact, U -&gt; V} is the
                           topology of compact convergence.
  {family fam, F --&gt; f} == F converges to f in {family fam, U -&gt; V}
 {compact_open, U -&gt; V} == compact-open topology
{compact_open, F --&gt; f} == F converges to f in {compact_open, U -&gt; V}
                   eval == the evaluation map for continuous functions
```

## Ascoli's theorem notations
```
     equicontinuous W x == the set (W : X -&gt; Y) is equicontinuous at x
           singletons T := [set [set x] | x in [set: T]]
 pointwise_precompact W == for each (x : X), the set of images
                           [f x | f in W] is precompact
```
</div>
<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'uniform`' A -&gt; V }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> A</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 69,</span><span class="id"> format</span> <span class="id">&quot;{ 'uniform`'  A  -&gt;  V }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'uniform' U -&gt; V }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> U</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 69,</span><span class="id"> format</span> <span class="id">&quot;{ 'uniform'  U  -&gt;  V }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'uniform' A , F --&gt; f }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> A</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 69,</span><span class="id"> F</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 69,</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;{ 'uniform'  A ,  F  --&gt;  f }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'uniform' , F --&gt; f }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> F</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 69,</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;{ 'uniform' ,  F  --&gt;  f }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'ptws' U -&gt; V }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> U</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 69,</span><span class="id"> format</span> <span class="id">&quot;{ 'ptws'  U  -&gt;  V }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'ptws' , F --&gt; f }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> F</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 69,</span><span class="id"> format</span> <span class="id">&quot;{ 'ptws' ,  F  --&gt;  f }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'family' fam , U -&gt; V }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> U</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 69,</span><span class="id"> format</span> <span class="id">&quot;{ 'family'  fam ,  U  -&gt;  V }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'family' fam , F --&gt; f }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> F</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 69,</span><span class="id"> format</span> <span class="id">&quot;{ 'family'  fam ,  F  --&gt;  f }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'compact-open' , U -&gt; V }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> U</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 69,</span><span class="id"> format</span> <span class="id">&quot;{ 'compact-open' ,  U  -&gt;  V }&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;{ 'compact-open' , F --&gt; f }&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> F</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 69,</span><span class="id"> format</span> <span class="id">&quot;{ 'compact-open' ,  F  --&gt;  f }&quot;</span>).<br/>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<br/>
<span class="vernacular">Obligation</span><span class="vernacular"> Tactic</span><span class="id"> :=</span><span class="id"> idtac</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> Order</span>.<span class="id">TTheory</span><span class="id"> GRing</span>.<span class="id">Theory</span><span class="id"> Num</span>.<span class="id">Theory</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<br/>
<div class="doc">Product topology, also known as the topology of pointwise convergence </div>
<span class="vernacular">Section</span><span class="id"> Product_Topology</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> prod_topology</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Type</span>)<span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> T</span><span class="id"> i</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> I</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> product_topology_def</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> topologicalType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">sup_topology</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> Topological</span>.<span class="id">class</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">weak_topology</span> (<span class="gallina-kwd">fun</span><span class="id"> f</span><span class="id"> :</span><span class="id"> [the</span><span class="id"> choiceType</span><span class="id"> of</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> T</span><span class="id"> i]</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> i</span>))).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> topologicalType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Topological</span>.<span class="id">copy</span> (<span class="id">prod_topology</span><span class="id"> T</span>) (<span class="id">product_topology_def</span><span class="id"> T</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> uniformType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Uniform</span>.<span class="id">copy</span> (<span class="id">prod_topology</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">sup_topology</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> Uniform</span>.<span class="id">class</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[the</span><span class="id"> uniformType</span><span class="id"> of</span><span class="id"> weak_topology</span> (<span class="id">@proj</span><span class="id"> _</span><span class="id"> T</span><span class="id"> i</span>)<span class="id">]</span>)).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">Ii</span><span class="id"> :</span><span class="id"> countType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Tc</span><span class="id"> :</span><span class="id"> Ii</span><span class="id"> -&gt;</span><span class="id"> pseudoMetricType</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> PseudoMetric</span>.<span class="id">copy</span> (<span class="id">prod_topology</span><span class="id"> Tc</span>)<br/>
&nbsp;&nbsp;(<span class="id">sup_pseudometric</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> PseudoMetric</span>.<span class="id">class</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[the</span><span class="id"> pseudoMetricType</span><span class="id"> R</span><span class="id"> of</span><span class="id"> weak_topology</span> (<span class="id">@proj</span><span class="id"> _</span><span class="id"> Tc</span><span class="id"> i</span>)<span class="id">]</span>) (<span class="id">countableP</span><span class="id"> _</span>)).<br/>
<br/>
<span class="vernacular">End</span><span class="id"> Product_Topology</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'ptws' U -&gt; V }&quot;</span><span class="id"> :=</span> (<span class="id">prod_topology</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> :</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> V</span>))<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'ptws' , F --&gt; f }&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">cvg_to</span><span class="id"> F</span> (<span class="id">nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {ptws</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> _}</span>)))<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<br/>
<span class="vernacular">Module</span><span class="id"> ArrowAsProduct</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">U</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> topologicalType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Topological</span>.<span class="id">copy</span> (<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> U,</span><span class="id"> T</span><span class="id"> x</span>) (<span class="id">prod_topology</span><span class="id"> T</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">U</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> uniformType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Uniform</span>.<span class="id">copy</span> (<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> U,</span><span class="id"> T</span><span class="id"> x</span>) (<span class="id">prod_topology</span><span class="id"> T</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">U</span><span class="id"> T</span><span class="id"> :</span><span class="id"> topologicalType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Topological</span>.<span class="id">copy</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">continuousType</span><span class="id"> U</span><span class="id"> T</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">weak_topology</span> (<span class="id">id</span><span class="id"> :</span><span class="id"> continuousType</span><span class="id"> U</span><span class="id"> T</span><span class="id"> -&gt;</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> T</span>))).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> topologicalType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> uniformType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Uniform</span>.<span class="id">copy</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">continuousType</span><span class="id"> U</span><span class="id"> T</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">weak_topology</span> (<span class="id">id</span><span class="id"> :</span><span class="id"> continuousType</span><span class="id"> U</span><span class="id"> T</span><span class="id"> -&gt;</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> T</span>))).<br/>
<br/>
<span class="vernacular">End</span><span class="id"> ArrowAsProduct</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> product_spaces</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Import</span><span class="id"> ArrowAsProduct</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> projection_maps</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> eqType}</span><span class="id"> {K</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> topologicalType}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> proj_continuous</span><span class="id"> i</span><span class="id"> :</span><span class="id"> continuous</span> (<span class="id">@proj</span><span class="id"> I</span><span class="id"> K</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> f;</span><span class="id"> have</span><span class="id"> /cvg_sup/</span>(_<span class="id"> i</span>)<span class="id">/cvg_image</span><span class="id"> :</span><span class="id"> f</span><span class="id"> --&gt;</span><span class="id"> f</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> cvg_id</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> h;</span><span class="id"> apply:</span><span class="id"> cvg_trans</span> (<span class="id">h</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> {h}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Q</span><span class="id"> /=</span><span class="id"> [W</span><span class="id"> nbdW</span><span class="id"> &lt;-];</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> nbdW;</span><span class="id"> exact:</span><span class="id"> preimage_image</span>.<br/>
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span> (<span class="id">dfwith</span><span class="id"> f</span><span class="id"> i</span><span class="id"> y</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> dfwithin</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dfwith_continuous</span><span class="id"> g</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> I</span>)<span class="id"> :</span><span class="id"> continuous</span> (<span class="id">@dfwith</span><span class="id"> I</span><span class="id"> K</span><span class="id"> g</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> U</span><span class="id"> []</span><span class="id"> P</span><span class="id"> []</span><span class="id"> []</span><span class="id"> Q</span><span class="id"> QfinP</span><span class="id"> &lt;-</span><span class="id"> []</span><span class="id"> V</span><span class="id"> JV</span><span class="id"> Vpz</span>.<br/>
<span class="id">move/</span>(<span class="id">@preimage_subset</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">dfwith</span><span class="id"> g</span><span class="id"> i</span>))<span class="id">/filterS;</span><span class="id"> apply</span>.<br/>
<span class="id">apply:</span> (<span class="id">@filterS</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> ((<span class="id">dfwith</span><span class="id"> g</span><span class="id"> i</span>)<span class="id"> @^-1`</span><span class="id"> V</span>))<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> V</span>.<br/>
<span class="id">have</span><span class="id"> [L</span><span class="id"> Lsub</span><span class="id"> /[dup]</span><span class="id"> VL</span><span class="id"> &lt;-]</span><span class="id"> :=</span><span class="id"> QfinP</span><span class="id"> _</span><span class="id"> JV;</span><span class="id"> rewrite</span><span class="id"> preimage_bigcap</span>.<br/>
<span class="id">apply:</span><span class="id"> filter_bigI</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> M</span><span class="id"> /[dup]</span><span class="id"> LM</span><span class="id"> /Lsub</span><span class="id"> /set_mem</span><span class="id"> []</span><span class="id"> w</span><span class="id"> _</span><span class="id"> [+]</span><span class="id"> +</span><span class="id"> /[dup]</span><span class="id"> +</span><span class="id"> &lt;-</span>.<br/>
<span class="id">have</span><span class="id"> [-&gt;|wnx]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> w</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> N</span><span class="id"> oN</span><span class="id"> NM</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">@filterS</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> N</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> dfwithin</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> open_nbhs_nbhs;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> move:</span><span class="id"> Vpz</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -VL</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> LM</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -NM</span><span class="id"> /=</span><span class="id"> dfwithin</span>.<br/>
<span class="id">apply:</span><span class="id"> nearW</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> move:</span><span class="id"> Vpz</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -VL</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> LM</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -NM</span><span class="id"> /=</span><span class="id"> ?dfwithout</span><span class="id"> //</span><span class="id"> eq_sym</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> proj_open</span><span class="id"> i</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">prod_topology</span><span class="id"> K</span>))<span class="id"> :</span><span class="id"> open</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> open</span> (<span class="id">proj</span><span class="id"> i</span><span class="id"> @`</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> oA;</span><span class="id"> rewrite</span><span class="id"> openE</span><span class="id"> =&gt;</span><span class="id"> z</span><span class="id"> [f</span><span class="id"> Af</span><span class="id"> &lt;-];</span><span class="id"> rewrite</span><span class="id"> openE</span><span class="gallina-kwd"> in</span><span class="id"> oA</span>.<br/>
<span class="id">have</span><span class="id"> {oA}</span><span class="id"> :=</span><span class="id"> oA</span><span class="id"> _</span><span class="id"> Af;</span><span class="id"> rewrite</span><span class="id"> /interior</span><span class="id"> =&gt;</span><span class="id"> nAf</span>.<br/>
<span class="id">apply:</span> (<span class="id">@filterS</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> ((<span class="id">dfwith</span><span class="id"> f</span><span class="id"> i</span>)<span class="id"> @^-1`</span><span class="id"> A</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> w</span><span class="id"> Apw;</span><span class="gallina-kwd"> exists</span> (<span class="id">dfwith</span><span class="id"> f</span><span class="id"> i</span><span class="id"> w</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> projK</span>.<br/>
<span class="id">apply:</span><span class="id"> dfwith_continuous</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> move:</span><span class="id"> nAf;</span><span class="id"> congr</span> (<span class="id">nbhs</span><span class="id"> _</span><span class="id"> A</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> functional_extensionality_dep</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> case:</span><span class="id"> dfwithP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> hausdorff_product</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> hausdorff_space</span> (<span class="id">K</span><span class="id"> x</span>))<span class="id"> -&gt;</span><span class="id"> hausdorff_space</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> K</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> hsdfK</span><span class="id"> p</span><span class="id"> q</span><span class="id"> /=</span><span class="id"> clstr;</span><span class="id"> apply:</span><span class="id"> functional_extensionality_dep</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
<span class="id">apply:</span><span class="id"> hsdfK;</span><span class="id"> move:</span><span class="id"> clstr;</span><span class="id"> rewrite</span><span class="id"> ?cluster_cvgE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> -[G</span><span class="id"> PG</span><span class="id"> [GtoQ</span><span class="id"> psubG]]</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">proj</span><span class="id"> x</span><span class="id"> @</span><span class="id"> G</span>)<span class="id">;</span><span class="id"> [exact:</span><span class="id"> fmap_proper_filter|split]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> cvg_trans;</span><span class="id"> last</span><span class="id"> exact:</span> (<span class="id">@proj_continuous</span><span class="id"> x</span><span class="id"> q</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> cvg_app;</span><span class="id"> exact:</span><span class="id"> GtoQ</span>.<br/>
<span class="id">move/</span>(<span class="id">cvg_app</span> (<span class="id">proj</span><span class="id"> x</span>))<span class="id">:</span><span class="id"> psubG</span><span class="id"> =&gt;</span><span class="id"> /cvg_trans;</span><span class="id"> apply</span>.<br/>
<span class="id">exact:</span><span class="id"> proj_continuous</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> projection_maps</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> tychonoff</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> topologicalType</span>)<br/>
&nbsp;&nbsp;(<span class="id">A</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> set</span> (<span class="id">T</span><span class="id"> i</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> compact</span> (<span class="id">A</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">compact</span><span class="id"> [set</span><span class="id"> f</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> T</span><span class="id"> i</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> A</span><span class="id"> i</span> (<span class="id">f</span><span class="id"> i</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case:</span> (<span class="id">pselect</span> (<span class="id">[set</span><span class="id"> f</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> T</span><span class="id"> i</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> A</span><span class="id"> i</span> (<span class="id">f</span><span class="id"> i</span>)<span class="id">]</span><span class="id"> ==</span><span class="id"> set0</span>)). <br/>
&nbsp;&nbsp;<span class="id">move/eqP</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> compact0</span>.<br/>
<span class="id">case/negP/set0P=&gt;</span><span class="id"> a0</span><span class="id"> Aa0</span><span class="id"> Aco;</span><span class="id"> rewrite</span><span class="id"> compact_ultra</span><span class="id"> =&gt;</span><span class="id"> F</span><span class="id"> FU</span><span class="id"> FA</span>.<br/>
<span class="id">set</span><span class="id"> subst_coord</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> I</span>) (<span class="id">pi</span><span class="id"> :</span><span class="id"> T</span><span class="id"> i</span>) (<span class="id">f</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> I,</span><span class="id"> T</span><span class="id"> x</span>) (<span class="id">j</span><span class="id"> :</span><span class="id"> I</span>)<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> eqP</span><span class="id"> is</span><span class="id"> ReflectT</span><span class="id"> e</span><span class="gallina-kwd"> then</span><span class="id"> ecast</span><span class="id"> i</span> (<span class="id">T</span><span class="id"> i</span>) (<span class="id">esym</span><span class="id"> e</span>)<span class="id"> pi</span><span class="gallina-kwd"> else</span><span class="id"> f</span><span class="id"> j</span>.<br/>
<span class="id">have</span><span class="id"> subst_coordT</span><span class="id"> i</span><span class="id"> pi</span><span class="id"> f</span><span class="id"> :</span><span class="id"> subst_coord</span><span class="id"> i</span><span class="id"> pi</span><span class="id"> f</span><span class="id"> i</span><span class="id"> =</span><span class="id"> pi</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /subst_coord;</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> e</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">eq_irrelevance</span><span class="id"> e</span> (<span class="id">erefl</span><span class="id"> _</span>)).<br/>
<span class="id">have</span><span class="id"> subst_coordN</span><span class="id"> i</span><span class="id"> pi</span><span class="id"> f</span><span class="id"> j</span><span class="id"> :</span><span class="id"> i</span><span class="id"> !=</span><span class="id"> j</span><span class="id"> -&gt;</span><span class="id"> subst_coord</span><span class="id"> i</span><span class="id"> pi</span><span class="id"> f</span><span class="id"> j</span><span class="id"> =</span><span class="id"> f</span><span class="id"> j</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> inej;</span><span class="id"> rewrite</span><span class="id"> /subst_coord;</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> e</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> inej;</span><span class="id"> rewrite</span><span class="id"> {1}e</span><span class="id"> =&gt;</span><span class="id"> /negP</span>.<br/>
<span class="id">have</span><span class="id"> pr_surj</span><span class="id"> i</span><span class="id"> :</span><span class="id"> @^~</span><span class="id"> i</span><span class="id"> @`</span><span class="id"> [set:</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> T</span><span class="id"> i]</span><span class="id"> =</span><span class="id"> setT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> pi;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">subst_coord</span><span class="id"> i</span><span class="id"> pi</span><span class="id"> a0</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> subst_coordT</span>.<br/>
<span class="id">pose</span><span class="id"> pF</span><span class="id"> i</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> @^~</span><span class="id"> i</span><span class="id"> @`</span><span class="id"> B</span><span class="id"> |</span><span class="id"> B</span><span class="gallina-kwd"> in</span><span class="id"> F]</span>.<br/>
<span class="id">have</span><span class="id"> pFultra</span><span class="id"> i</span><span class="id"> :</span><span class="id"> UltraFilter</span> (<span class="id">pF</span><span class="id"> i</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> ultra_image</span> (<span class="id">pr_surj</span><span class="id"> i</span>).<br/>
<span class="id">have</span><span class="id"> pFA</span><span class="id"> i</span><span class="id"> :</span><span class="id"> pF</span><span class="id"> i</span> (<span class="id">A</span><span class="id"> i</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> [set</span><span class="id"> g</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> A</span><span class="id"> i</span> (<span class="id">g</span><span class="id"> i</span>)<span class="id">]</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> pi;</span><span class="id"> split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [g</span><span class="id"> Ag</span><span class="id"> &lt;-];</span><span class="id"> apply:</span><span class="id"> Ag</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> Aipi;</span><span class="id"> have</span><span class="id"> [f</span><span class="id"> Af]</span><span class="id"> :=</span><span class="id"> filter_ex</span><span class="id"> FA</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">subst_coord</span><span class="id"> i</span><span class="id"> pi</span><span class="id"> f</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> subst_coordT</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> j;</span><span class="id"> have</span><span class="id"> [&lt;-{j}|]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> i</span><span class="id"> j;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subst_coordT</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /subst_coordN</span><span class="id"> -&gt;;</span><span class="id"> apply:</span><span class="id"> Af</span>.<br/>
<span class="id">have</span><span class="id"> cvpFA</span><span class="id"> i</span><span class="id"> :</span><span class="id"> A</span><span class="id"> i</span><span class="id"> `&amp;`</span><span class="id"> [set</span><span class="id"> p</span><span class="id"> |</span><span class="id"> pF</span><span class="id"> i</span><span class="id"> --&gt;</span><span class="id"> p]</span><span class="id"> !=set0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -ultra_cvg_clusterE;</span><span class="id"> apply:</span><span class="id"> Aco</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> xget</span> (<span class="id">a0</span><span class="id"> i</span>) (<span class="id">A</span><span class="id"> i</span><span class="id"> `&amp;`</span><span class="id"> [set</span><span class="id"> p</span><span class="id"> |</span><span class="id"> pF</span><span class="id"> i</span><span class="id"> --&gt;</span><span class="id"> p]</span>)).<br/>
<span class="id">split=&gt;</span><span class="id"> [i|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> have</span><span class="id"> /</span>(<span class="id">xgetPex</span> (<span class="id">a0</span><span class="id"> i</span>))<span class="id"> []</span><span class="id"> :=</span><span class="id"> cvpFA</span><span class="id"> i</span>.<br/>
<span class="id">apply/cvg_sup</span><span class="id"> =&gt;</span><span class="id"> i;</span><span class="id"> apply/cvg_image=&gt;</span><span class="id"> //</span>. <br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /</span>(<span class="id">xgetPex</span> (<span class="id">a0</span><span class="id"> i</span>))<span class="id"> []</span><span class="id"> :=</span><span class="id"> cvpFA</span><span class="id"> i</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perfect_prod</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> I</span>) (<span class="id">K</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> topologicalType</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">perfect_set</span><span class="id"> [set:</span><span class="id"> K</span><span class="id"> i]</span><span class="id"> -&gt;</span><span class="id"> perfect_set</span><span class="id"> [set:</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> K</span><span class="id"> i]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /perfectTP</span><span class="id"> KPo;</span><span class="id"> apply/perfectTP</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> oF;</span><span class="id"> apply:</span> (<span class="id">KPo</span> (<span class="id">f</span><span class="id"> i</span>)).<br/>
<span class="id">rewrite</span> (_<span class="id"> :</span><span class="id"> [set</span><span class="id"> f</span><span class="id"> i]</span><span class="id"> =</span><span class="id"> proj</span><span class="id"> i</span><span class="id"> @`</span><span class="id"> [set</span><span class="id"> f]</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">@proj_open</span><span class="id"> {classic</span><span class="id"> I}</span><span class="id"> _</span><span class="id"> i</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> oF</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> //;</span><span class="id"> [move=&gt;</span><span class="id"> -&gt;</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> f</span><span class="id"> |</span><span class="id"> case=&gt;</span><span class="id"> g</span><span class="id"> -&gt;]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perfect_diagonal</span> (<span class="id">K</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> topologicalType</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="gallina-kwd"> exists</span><span class="id"> xy</span><span class="id"> :</span><span class="id"> K</span><span class="id"> i</span><span class="id"> *</span><span class="id"> K</span><span class="id"> i,</span><span class="id"> xy</span>.<span class="id">1</span><span class="id"> !=</span><span class="id"> xy</span>.<span class="id">2</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">perfect_set</span><span class="id"> [set:</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> K</span><span class="id"> i]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> npts;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> closedT</span>.<br/>
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> //</span><span class="id"> _</span>.<br/>
<span class="id">pose</span><span class="id"> distincts</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> nat</span>)<span class="id"> :=</span><span class="id"> projT1</span> (<span class="id">sigW</span> (<span class="id">npts</span><span class="id"> i</span>)).<br/>
<span class="id">pose</span><span class="id"> derange</span><span class="id"> i</span> (<span class="id">z</span><span class="id"> :</span><span class="id"> K</span><span class="id"> i</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> z</span><span class="id"> ==</span> (<span class="id">distincts</span><span class="id"> i</span>).<span class="id">1</span><span class="gallina-kwd"> then</span> (<span class="id">distincts</span><span class="id"> i</span>).<span class="id">2</span><span class="gallina-kwd"> else</span> (<span class="id">distincts</span><span class="id"> i</span>).<span class="id">1</span>.<br/>
<span class="id">pose</span><span class="id"> g</span> (<span class="id">N</span><span class="id"> i</span><span class="id"> :</span><span class="id"> nat</span>)<span class="id"> :=</span><span class="gallina-kwd"> if</span> (<span class="id">i</span><span class="id"> &lt;</span><span class="id"> N</span>)<span class="id">%N</span><span class="gallina-kwd"> then</span><span class="id"> f</span><span class="id"> i</span><span class="gallina-kwd"> else</span><span class="id"> derange</span><span class="id"> _</span> (<span class="id">f</span><span class="id"> i</span>).<br/>
<span class="id">have</span><span class="id"> gcvg</span><span class="id"> :</span><span class="id"> g</span><span class="id"> @</span><span class="id"> \oo</span><span class="id"> --&gt;</span><span class="id"> f</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/cvg_sup</span><span class="id"> =&gt;</span><span class="id"> N</span><span class="id"> U</span><span class="id"> [V]</span><span class="id"> [[W]</span><span class="id"> oW</span><span class="id"> &lt;-]</span><span class="id"> WfN</span><span class="id"> WU</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">filterS</span><span class="id"> WU</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> nbhs_simpl</span><span class="id"> /g;</span><span class="gallina-kwd"> exists</span><span class="id"> N</span>.<span class="id">+1</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i</span><span class="id"> /=</span><span class="id"> -&gt;</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> /gcvg;</span><span class="id"> rewrite</span><span class="id"> nbhs_simpl</span><span class="id"> =&gt;</span><span class="id"> -[N</span><span class="id"> _</span><span class="id"> An]</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">g</span><span class="id"> N</span>)<span class="id">;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> An;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> leqnn</span>.<br/>
<span class="id">apply/eqP</span><span class="id"> =&gt;</span><span class="id"> M;</span><span class="id"> suff:</span><span class="id"> g</span><span class="id"> N</span><span class="id"> N</span><span class="id"> !=</span><span class="id"> f</span><span class="id"> N</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> M;</span><span class="id"> move/eqP</span>.<br/>
<span class="id">rewrite</span><span class="id"> /g</span><span class="id"> ltnn</span><span class="id"> /derange</span><span class="id"> eq_sym;</span><span class="id"> have</span><span class="id"> [-&gt;|//]</span><span class="id"> :=</span><span class="id"> eqVneq</span> (<span class="id">f</span><span class="id"> N</span>) (<span class="id">distincts</span><span class="id"> N</span>).<span class="id">1</span>.<br/>
<span class="id">exact:</span><span class="id"> projT2</span> (<span class="id">sigW</span> (<span class="id">npts</span><span class="id"> N</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> zero_dimension_prod</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> topologicalType</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> zero_dimensional</span> (<span class="id">T</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">zero_dimensional</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> T</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> dctTI</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /eqP</span><span class="id"> xneqy</span>.<br/>
<span class="id">have</span><span class="id"> [i/eqP/dctTI</span><span class="id"> [U</span><span class="id"> [clU</span><span class="id"> Ux</span><span class="id"> nUy]]]</span><span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> i,</span><span class="id"> x</span><span class="id"> i</span><span class="id"> &lt;&gt;</span><span class="id"> y</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/existsNP=&gt;</span><span class="id"> W;</span><span class="id"> exact/xneqy/functional_extensionality_dep</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">proj</span><span class="id"> i</span><span class="id"> @^-1`</span><span class="id"> U</span>)<span class="id">;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> clopen_comp</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">exact/proj_continuous</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> totally_disconnected_prod</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>)<br/>
&nbsp;&nbsp;(<span class="id">T</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> topologicalType</span>) (<span class="id">A</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> set</span> (<span class="id">T</span><span class="id"> i</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> totally_disconnected</span> (<span class="id">A</span><span class="id"> i</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">@totally_disconnected</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> T</span><span class="id"> i</span>) (<span class="gallina-kwd">fun</span><span class="id"> f</span><span class="id"> =&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> A</span><span class="id"> i</span> (<span class="id">f</span><span class="id"> i</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> dsctAi</span><span class="id"> x</span><span class="id"> /=</span><span class="id"> Aix;</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> -&gt;;</span><span class="id"> exact:</span><span class="id"> connected_component_refl</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> f</span><span class="id"> /=</span><span class="id"> [C</span><span class="id"> /=</span><span class="id"> [Cx</span><span class="id"> CA</span><span class="id"> ctC</span><span class="id"> Cf]];</span><span class="id"> apply/functional_extensionality_dep</span><span class="id"> =&gt;</span><span class="id"> i</span>.<br/>
<span class="id">suff</span><span class="id"> :</span><span class="id"> proj</span><span class="id"> i</span><span class="id"> @`</span><span class="id"> C</span><span class="id"> `&lt;=`</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> i]</span><span class="gallina-kwd"> by</span><span class="id"> apply;</span><span class="gallina-kwd"> exists</span><span class="id"> f</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">dsctAi</span><span class="id"> i</span>)<span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> Ti</span><span class="id"> ?;</span><span class="gallina-kwd"> exists</span> (<span class="id">proj</span><span class="id"> i</span><span class="id"> @`</span><span class="id"> C</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">split;</span><span class="id"> [by</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> |</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> [r</span><span class="id"> Cr</span><span class="id"> &lt;-];</span><span class="id"> exact:</span><span class="id"> CA</span><span class="id"> |]</span>.<br/>
<span class="id">apply/</span>(<span class="id">connected_continuous_connected</span><span class="id"> ctC</span>)<span class="id">/continuous_subspaceT</span>.<br/>
<span class="id">exact:</span><span class="id"> proj_continuous</span>.<br/>
Qed.</div></details>
<br/>
<div class="doc md"> A handy technique for embedding a space `T` into a product. The key
  interface is `separate_points_from_closed`, which guarantees that the
  topologies
   - `T`'s native topology
   - `sup (weak f_i)`: the sup of all the weak topologies of `f_i`
   - `weak (x =&gt; (f_1 x, f_2 x, ...))`: the weak topology from the product space

  are equivalent (the last equivalence seems to require `accessible_space`).</div>
<span class="vernacular">Section</span><span class="id"> product_embeddings</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> topologicalType}</span><span class="id"> {U_</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> topologicalType}</span>.<br/>
<span class="vernacular">Variable</span> (<span class="id">f_</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U_</span><span class="id"> i</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> separate_points_from_closed</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> x,</span><br/>
&nbsp;&nbsp;<span class="id">closed</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> ~</span><span class="id"> U</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists</span><span class="id"> i,</span><span class="id"> ~</span> (<span class="id">closure</span> (<span class="id">f_</span><span class="id"> i</span><span class="id"> @`</span><span class="id"> U</span>)) (<span class="id">f_</span><span class="id"> i</span><span class="id"> x</span>).<br/>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> sepf</span><span class="id"> :</span><span class="id"> separate_points_from_closed</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> ctsf</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> continuous</span> (<span class="id">f_</span><span class="id"> i</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> weakT</span><span class="id"> :=</span><span class="id"> [the</span><span class="id"> topologicalType</span><span class="id"> of</span><br/>
&nbsp;&nbsp;<span class="id">sup_topology</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> Topological</span>.<span class="id">on</span> (<span class="id">weak_topology</span> (<span class="id">f_</span><span class="id"> i</span>)))<span class="id">]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> PU</span><span class="id"> :=</span><span class="id"> [the</span><span class="id"> topologicalType</span><span class="id"> of</span><span class="id"> prod_topology</span><span class="id"> U_]</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> sup_open</span><span class="id"> :=</span> (<span class="id">@open</span><span class="id"> weakT</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;'weak_open' i&quot;</span><span class="id"> :=</span> (<span class="id">@open</span><span class="id"> weakT</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> natural_open</span><span class="id"> :=</span> (<span class="id">@open</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> weak_sep_cvg</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> T</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span> (<span class="id">F</span><span class="id"> --&gt;</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>))<span class="id"> &lt;-&gt;</span> (<span class="id">F</span><span class="id"> --&gt;</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> weakT</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> FTx;</span><span class="id"> apply/cvg_sup</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> U</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /=</span><span class="id"> -&gt;</span><span class="id"> :=</span><span class="id"> @nbhsE</span> (<span class="id">weak_topology</span> (<span class="id">f_</span><span class="id"> i</span>))<span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> B</span><span class="id"> [[C</span><span class="id"> oC</span><span class="id"> &lt;-</span><span class="id"> ?]]</span><span class="id"> /filterS;</span><span class="id"> apply;</span><span class="id"> apply:</span><span class="id"> FTx;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> nbhsE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">f_</span><span class="id"> i</span><span class="id"> @^-1`</span><span class="id"> C</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> open_comp</span>.<br/>
<span class="id">move/cvg_sup</span><span class="id"> =&gt;</span><span class="id"> wiFx</span><span class="id"> U;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> nbhs_simpl</span><span class="id"> nbhsE</span><span class="id"> =&gt;</span><span class="id"> [[B</span><span class="id"> [oB</span><span class="id"> ?]]]</span>.<br/>
<span class="id">move/filterS;</span><span class="id"> apply;</span><span class="id"> have</span><span class="id"> [//|i</span><span class="id"> nclfix]</span><span class="id"> :=</span><span class="id"> @sepf</span><span class="id"> _</span><span class="id"> x</span> (<span class="id">open_closedC</span><span class="id"> oB</span>).<br/>
<span class="id">apply:</span> (<span class="id">wiFx</span><span class="id"> i</span>)<span class="id">;</span><span class="id"> have</span><span class="id"> /=</span><span class="id"> -&gt;</span><span class="id"> :=</span><span class="id"> @nbhsE</span> (<span class="id">weak_topology</span> (<span class="id">f_</span><span class="id"> i</span>))<span class="id"> x</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">f_</span><span class="id"> i</span><span class="id"> @^-1`</span> (<span class="id">~`</span><span class="id"> closure</span><span class="id"> [set</span><span class="id"> f_</span><span class="id"> i</span><span class="id"> x</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> ~`</span><span class="id"> B]</span>))<span class="id">;</span><span class="id"> [split=&gt;//|]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> open_comp;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ?openC//;</span><span class="id"> exact:</span><span class="id"> closed_closure</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> +</span><span class="id"> _;</span><span class="id"> exact:</span> (<span class="id">@weak_continuous</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">f_</span><span class="id"> i</span>)).<br/>
<span class="id">rewrite</span><span class="id"> -interiorC</span><span class="id"> interiorEbigcup</span><span class="id"> preimage_bigcup</span><span class="id"> =&gt;</span><span class="id"> z</span><span class="id"> [V</span><span class="id"> [oV]]</span><span class="id"> VnB</span><span class="id"> =&gt;</span><span class="id"> /VnB</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/forall2NP</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> z</span>)<span class="id"> []</span><span class="id"> //</span><span class="id"> /contrapT</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> weak_sep_nbhsE</span><span class="id"> x</span><span class="id"> :</span><span class="id"> @nbhs</span><span class="id"> T</span><span class="id"> T</span><span class="id"> x</span><span class="id"> =</span><span class="id"> @nbhs</span><span class="id"> T</span><span class="id"> weakT</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> U;</span><span class="id"> split;</span><span class="id"> move:</span><span class="id"> U</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> weak_sep_cvg</span><span class="id"> x</span> (<span class="id">nbhs_filter</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> weakT</span>))<span class="id">;</span><span class="id"> exact/P</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> weak_sep_cvg</span><span class="id"> x</span> (<span class="id">nbhs_filter</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>))<span class="id">;</span><span class="id"> exact/P</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> weak_sep_openE</span><span class="id"> :</span><span class="id"> @open</span><span class="id"> T</span><span class="id"> =</span><span class="id"> @open</span><span class="id"> weakT</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> A;</span><span class="id"> rewrite</span><span class="id"> ?openE</span><span class="id"> /interior</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> +</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> z</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> weak_sep_nbhsE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> join_product</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> PU</span><span class="id"> :=</span><span class="id"> f_</span><span class="id"> ^~</span><span class="id"> x</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> join_product_continuous</span><span class="id"> :</span><span class="id"> continuous</span><span class="id"> join_product</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">suff</span><span class="id"> :</span><span class="id"> continuous</span> (<span class="id">join_product</span><span class="id"> :</span><span class="id"> weakT</span><span class="id"> -&gt;</span><span class="id"> PU</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> cts</span><span class="id"> x</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> /cts;</span><span class="id"> rewrite</span><span class="id"> nbhs_simpl</span><span class="id"> /=</span><span class="id"> -weak_sep_nbhsE</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> apply/cvg_sup;</span><span class="id"> first</span><span class="id"> exact/fmap_filter/</span>(<span class="id">nbhs_filter</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> weakT</span>)).<br/>
<span class="id">move=&gt;</span><span class="id"> i;</span><span class="id"> move:</span><span class="id"> x;</span><span class="id"> apply/</span>(<span class="id">@continuousP</span><span class="id"> _</span> (<span class="id">weak_topology</span> (<span class="id">@^~</span><span class="id"> i</span>)))<span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> [B</span><span class="id"> ?</span><span class="id"> E]</span>.<br/>
<span class="id">rewrite</span><span class="id"> -E</span> (_<span class="id"> :</span><span class="id"> @^~</span><span class="id"> i</span><span class="id"> =</span> <span class="id"> proj</span><span class="id"> i</span>)<span class="id"> //</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> join_product</span><span class="id"> @^-1`</span> (<span class="id">proj</span><span class="id"> i</span><span class="id"> @^-1`</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> f_</span><span class="id"> i</span><span class="id"> @^-1`</span><span class="id"> B</span><span class="gallina-kwd"> by</span><span class="id"> []</span>.<br/>
<span class="id">apply:</span><span class="id"> open_comp</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> +</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /cvg_to</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> U</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nbhs_simpl</span><span class="id"> /=</span><span class="id"> -weak_sep_nbhsE;</span><span class="id"> move:</span><span class="id"> x</span><span class="id"> U;</span><span class="id"> exact:</span><span class="id"> ctsf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> prod_open</span><span class="id"> :=</span> (<span class="id">@open</span> (<span class="id">subspace</span> (<span class="id">range</span><span class="id"> join_product</span>))).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> join_product_open</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> open</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">open</span> ((<span class="id">join_product</span><span class="id"> @`</span><span class="id"> A</span>)<span class="id"> :</span><span class="id"> set</span> (<span class="id">subspace</span> (<span class="id">range</span><span class="id"> join_product</span>))).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> oA;</span><span class="id"> rewrite</span><span class="id"> openE</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> /=</span><span class="id"> [x</span><span class="id"> Ax]</span><span class="id"> jxy</span>.<br/>
<span class="id">have</span><span class="id"> [//</span><span class="id"> |</span><span class="id"> i</span><span class="id"> nAfiy]</span><span class="id"> :=</span><span class="id"> @sepf</span> (<span class="id">~`</span><span class="id"> A</span>)<span class="id"> x</span> (<span class="id">open_closedC</span><span class="id"> oA</span>).<br/>
<span class="id">pose</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> PU</span><span class="id"> :=</span><span class="id"> proj</span><span class="id"> i</span><span class="id"> @^-1`</span> (<span class="id">~`</span><span class="id"> closure</span> (<span class="id">f_</span><span class="id"> i</span><span class="id"> @`</span><span class="id"> ~`</span><span class="id"> A</span>)).<br/>
<span class="id">apply:</span> (<span class="id">@filterS</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">range</span><span class="id"> join_product</span><span class="id"> `&amp;`</span><span class="id"> B</span>)).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> [[w</span><span class="id"> ?]]</span><span class="id"> wzE</span><span class="id"> Bz;</span><span class="gallina-kwd"> exists</span><span class="id"> w</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> Bz;</span><span class="id"> rewrite</span><span class="id"> /B</span><span class="id"> -wzE</span><span class="id"> -interiorC</span><span class="id"> interiorEbigcup</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> K</span><span class="id"> [oK</span><span class="id"> KsubA]</span><span class="id"> /KsubA</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> proj</span><span class="id"> i</span> (<span class="id">join_product</span><span class="id"> w</span>)<span class="id"> =</span><span class="id"> f_</span><span class="id"> i</span><span class="id"> w</span><span class="gallina-kwd"> by</span><span class="id"> []</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /exists2P/forallNP/</span>(_<span class="id"> w</span>)<span class="id">/not_andP</span><span class="id"> []</span><span class="id"> //</span><span class="id"> /contrapT</span>.<br/>
<span class="id">apply:</span><span class="id"> open_nbhs_nbhs;</span><span class="id"> split;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -jxy</span>.<br/>
<span class="id">apply:</span><span class="id"> openI;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> open_subspaceT</span>.<br/>
<span class="id">apply:</span><span class="id"> open_subspaceW;</span><span class="id"> apply:</span><span class="id"> open_comp;</span><span class="id"> last</span><span class="id"> exact/closed_openC/closed_closure</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> +</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> proj_continuous</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> join_product_inj</span><span class="id"> :</span><span class="id"> accessible_space</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> set_inj</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> join_product</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /accessible_closed_set1</span><span class="id"> cl1</span><span class="id"> x</span><span class="id"> y;</span><span class="id"> case:</span> (<span class="id">eqVneq</span><span class="id"> x</span><span class="id"> y</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> xny</span><span class="id"> _</span><span class="id"> _</span><span class="id"> jxjy</span>.<br/>
<span class="id">have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> @sepf</span><span class="id"> [set</span><span class="id"> y]</span><span class="id"> x</span> (<span class="id">cl1</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> exact/eqP</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> i</span><span class="id"> P;</span><span class="id"> suff</span><span class="id"> :</span><span class="id"> join_product</span><span class="id"> x</span><span class="id"> i</span><span class="id"> !=</span><span class="id"> join_product</span><span class="id"> y</span><span class="id"> i</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> jxjy</span><span class="id"> =&gt;</span><span class="id"> /eqP</span>.<br/>
<span class="id">apply/negP;</span><span class="id"> move:</span><span class="id"> P;</span><span class="id"> apply:</span><span class="id"> contra_not</span><span class="id"> =&gt;</span><span class="id"> /eqP;</span><span class="id"> rewrite</span><span class="id"> /join_product</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subset_closure;</span><span class="gallina-kwd"> exists</span><span class="id"> y</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> join_product_weak</span><span class="id"> :</span><span class="id"> set_inj</span><span class="id"> [set:</span><span class="id"> T]</span><span class="id"> join_product</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">@open</span><span class="id"> T</span><span class="id"> =</span><span class="id"> @open</span> (<span class="id">weak_topology</span><span class="id"> join_product</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> inj;</span><span class="id"> rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> U;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [V</span><span class="id"> ?</span><span class="id"> &lt;-];</span><span class="id"> apply:</span><span class="id"> open_comp</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> +</span><span class="id"> _;</span><span class="id"> exact:</span><span class="id"> join_product_continuous</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /join_product_open/open_subspaceP</span><span class="id"> [V</span><span class="id"> [oU</span><span class="id"> VU]]</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> V</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> @f_equal</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">preimage</span><span class="id"> join_product</span>)<span class="id"> _</span><span class="id"> _</span><span class="id"> VU</span>.<br/>
<span class="id">rewrite</span><span class="id"> !preimage_setI</span><span class="id"> //</span><span class="id"> !preimage_range</span><span class="id"> !setIT</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> preimage_image</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> z</span><span class="id"> [w</span><span class="id"> Uw]</span><span class="id"> /inj</span><span class="id"> &lt;-</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> product_embeddings</span>.<br/>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> prod_topology_filter</span> (<span class="id">U</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> ptopologicalType</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> prod_topology</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> (<span class="id">nbhs</span><span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">exact:</span><span class="id"> nbhs_pfilter</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> product_spaces</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">U</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> ptopologicalType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Pointed</span>.<span class="id">copy</span> (<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> U,</span><span class="id"> T</span><span class="id"> x</span>) (<span class="id">prod_topology</span><span class="id"> T</span>).<br/>
<br/>
<div class="doc md"> the uniform topologies type</div>
<span class="vernacular">Section</span><span class="id"> fct_Uniform</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> relation_scope</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">U</span><span class="id"> :</span><span class="id"> uniformType</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> fct_ent</span><span class="id"> :=</span><span class="id"> filter_from</span> (<span class="id">@entourage</span><span class="id"> U</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> P</span><span class="id"> =&gt;</span><span class="id"> [set</span><span class="id"> fg</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> t</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> P</span> (<span class="id">fg</span>.<span class="id">1</span><span class="id"> t,</span><span class="id"> fg</span>.<span class="id">2</span><span class="id"> t</span>)<span class="id">]</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fct_ent_filter</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> fct_ent</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> filter_from_filter;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> setT;</span><span class="id"> apply:</span><span class="id"> filterT</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> A</span><span class="id"> B</span><span class="id"> entA</span><span class="id"> entB</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">A</span><span class="id"> `&amp;`</span><span class="id"> B</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> filterI</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> fg</span><span class="id"> ABfg;</span><span class="id"> split=&gt;</span><span class="id"> t;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> ABfg</span><span class="id"> t</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fct_ent_refl</span><span class="id"> A</span><span class="id"> :</span><span class="id"> fct_ent</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> diagonal</span><span class="id"> `&lt;=`</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [B</span><span class="id"> entB</span><span class="id"> sBA]</span><span class="id"> fg</span><span class="id"> feg;</span><span class="id"> apply/sBA</span><span class="id"> =&gt;</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> feg</span>.<br/>
<span class="id">exact:</span><span class="id"> entourage_refl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fct_ent_inv</span><span class="id"> A</span><span class="id"> :</span><span class="id"> fct_ent</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> fct_ent</span><span class="id"> A^-1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [B</span><span class="id"> entB</span><span class="id"> sBA];</span><span class="gallina-kwd"> exists</span><span class="id"> B^-1;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> entourage_inv</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> fg</span><span class="id"> Bgf;</span><span class="id"> exact/sBA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fct_ent_split</span><span class="id"> A</span><span class="id"> :</span><span class="id"> fct_ent</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists2</span><span class="id"> B,</span><span class="id"> fct_ent</span><span class="id"> B</span><span class="id"> &amp;</span><span class="id"> B</span><span class="id"> \;</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> [B</span><span class="id"> entB</span><span class="id"> sBA]</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> [set</span><span class="id"> fg</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> split_ent</span><span class="id"> B</span> (<span class="id">fg</span>.<span class="id">1</span><span class="id"> t,</span><span class="id"> fg</span>.<span class="id">2</span><span class="id"> t</span>)<span class="id">]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">split_ent</span><span class="id"> B</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> fg</span><span class="id"> [h</span><span class="id"> spBfh</span><span class="id"> spBhg]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> sBA</span><span class="id"> =&gt;</span><span class="id"> t;</span><span class="id"> apply:</span><span class="id"> entourage_split</span> (<span class="id">spBfh</span><span class="id"> t</span>) (<span class="id">spBhg</span><span class="id"> t</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> arrow_uniform_type</span><span class="id"> :</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>.<br/>
<br/>
<span class="id">#[export]</span><span class="id"> HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Choice</span>.<span class="id">on</span><span class="id"> arrow_uniform_type</span>.<br/>
<span class="id">#[export]</span><span class="id"> HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> isUniform</span>.<span class="id">Build</span><span class="id"> arrow_uniform_type</span><br/>
&nbsp;&nbsp;<span class="id">fct_ent_filter</span><span class="id"> fct_ent_refl</span><span class="id"> fct_ent_inv</span><span class="id"> fct_ent_split</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> fct_Uniform</span>.<br/>
<br/>
<span class="id">#[export]</span><span class="id"> HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> puniformType}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Pointed</span>.<span class="id">on</span> (<span class="id">arrow_uniform_type</span><span class="id"> T</span><span class="id"> U</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_fct_entourageP</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">U</span><span class="id"> :</span><span class="id"> uniformType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">arrow_uniform_type</span><span class="id"> T</span><span class="id"> U</span>)) (<span class="id">FF</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> arrow_uniform_type</span><span class="id"> T</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">F</span><span class="id"> --&gt;</span><span class="id"> f</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> A,</span><span class="id"> entourage</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\forall</span><span class="id"> g</span><span class="id"> \near</span><span class="id"> F,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> A</span> (<span class="id">f</span><span class="id"> t,</span><span class="id"> g</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> [/cvg_entourageP</span><span class="id"> Ff</span><span class="id"> A</span><span class="id"> entA|Ff]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">Ff</span><span class="id"> [set</span><span class="id"> fg</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> t</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> A</span> (<span class="id">fg</span>.<span class="id">1</span><span class="id"> t,</span><span class="id"> fg</span>.<span class="id">2</span><span class="id"> t</span>)<span class="id">]</span>)<span class="id">;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span>.<br/>
<span class="id">apply/cvg_entourageP</span><span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> [P</span><span class="id"> entP</span><span class="id"> sPA]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> near=&gt;</span><span class="id"> g</span><span class="id"> do</span><span class="id"> apply:</span><span class="id"> sPA;</span><span class="id"> apply:</span><span class="id"> Ff</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> fun_Complete</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> completeType}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fun_complete</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">arrow_uniform_type</span><span class="id"> T</span><span class="id"> U</span>))<br/>
&nbsp;&nbsp;<span class="id">{FF</span><span class="id"> :</span> <span class="id"> ProperFilter</span><span class="id"> F}</span><span class="id"> :</span><span class="id"> cauchy</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> cvg</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Fc</span>.<br/>
<span class="id">have</span><span class="id"> /</span>(_<span class="id"> _</span>)<span class="id"> /cauchy_cvg</span><span class="id"> /cvg_app_entourageP</span><span class="id"> cvF</span><span class="id"> :</span><span class="id"> cauchy</span> (<span class="id">@^~_</span><span class="id"> @</span><span class="id"> F</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> A</span><span class="id"> /=</span><span class="id"> entA;</span><span class="id"> rewrite</span><span class="id"> near_simpl</span><span class="id"> -near2E</span><span class="id"> near_map2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> Fc;</span><span class="gallina-kwd"> exists</span><span class="id"> A</span>.<br/>
<span class="id">apply/cvg_ex;</span><span class="gallina-kwd"> exists</span> (<span class="gallina-kwd">fun</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> lim</span> (<span class="id">@^~t</span><span class="id"> @</span><span class="id"> F</span>)).<br/>
<span class="id">apply/cvg_fct_entourageP</span><span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> entA;</span><span class="id"> near=&gt;</span><span class="id"> f</span><span class="id"> =&gt;</span><span class="id"> t;</span><span class="id"> near</span><span class="id"> F</span><span class="id"> =&gt;</span><span class="id"> g</span>.<br/>
<span class="id">apply:</span> (<span class="id">entourage_split</span> (<span class="id">g</span><span class="id"> t</span>))<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> near:</span><span class="id"> g;</span><span class="id"> apply:</span><span class="id"> cvF</span>.<br/>
<span class="id">move:</span> (<span class="id">t</span>)<span class="id">;</span><span class="id"> near:</span><span class="id"> g;</span><span class="id"> near:</span><span class="id"> f;</span><span class="id"> apply:</span><span class="id"> nearP_dep;</span><span class="id"> apply:</span><span class="id"> Fc</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">split_ent</span><span class="id"> A</span>)<span class="id">^-1%relation</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Uniform_isComplete</span>.<span class="id">Build</span><br/>
&nbsp;&nbsp;(<span class="id">arrow_uniform_type</span><span class="id"> T</span><span class="id"> U</span>)<span class="id"> fun_complete</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Uniform_isComplete</span>.<span class="id">Build</span> (<span class="id">arrow_uniform_type</span><span class="id"> T</span><span class="id"> U</span>)<span class="id"> cauchy_cvg</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> fun_Complete</span>.<br/>
<br/>
<div class="doc">Functional metric spaces </div>
<span class="vernacular">Section</span><span class="id"> fct_PseudoMetric</span>.<br/>
<span class="vernacular">Variable</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>) (<span class="id">U</span><span class="id"> :</span><span class="id"> pseudoMetricType</span><span class="id"> R</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> fct_ball</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> arrow_uniform_type</span><span class="id"> T</span><span class="id"> U</span>) (<span class="id">eps</span><span class="id"> :</span><span class="id"> R</span>)<br/>
&nbsp;&nbsp;(<span class="id">y</span><span class="id"> :</span><span class="id"> arrow_uniform_type</span><span class="id"> T</span><span class="id"> U</span>)<span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> t</span><span class="id"> :</span><span class="id"> T,</span><span class="id"> ball</span> (<span class="id">x</span><span class="id"> t</span>)<span class="id"> eps</span> (<span class="id">y</span><span class="id"> t</span>).<br/>
<span class="vernacular">Lemma</span><span class="id"> fct_ball_center</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">e</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> e</span><span class="id"> -&gt;</span><span class="id"> fct_ball</span><span class="id"> x</span><span class="id"> e</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /posnumP[{}e]</span><span class="id"> ?</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fct_ball_sym</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">e</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><span class="id"> fct_ball</span><span class="id"> x</span><span class="id"> e</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> fct_ball</span><span class="id"> y</span><span class="id"> e</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> P</span><span class="id"> t;</span><span class="id"> apply:</span><span class="id"> ball_sym</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> fct_ball_triangle</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">e1</span><span class="id"> e2</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">fct_ball</span><span class="id"> x</span><span class="id"> e1</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> fct_ball</span><span class="id"> y</span><span class="id"> e2</span><span class="id"> z</span><span class="id"> -&gt;</span><span class="id"> fct_ball</span><span class="id"> x</span> (<span class="id">e1</span><span class="id"> +</span><span class="id"> e2</span>)<span class="id"> z</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> xy</span><span class="id"> yz</span><span class="id"> t;</span><span class="id"> apply:</span> (<span class="id">@ball_triangle</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">y</span><span class="id"> t</span>)). Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> fct_entourage</span><span class="id"> :</span><span class="id"> entourage</span><span class="id"> =</span><span class="id"> entourage_</span><span class="id"> fct_ball</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> A;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [_/posnumP[e]</span><span class="id"> sbeA];</span><span class="gallina-kwd"> exists</span><span class="id"> [set</span><span class="id"> xy</span><span class="id"> |</span><span class="id"> ball</span><span class="id"> xy</span>.<span class="id">1</span><span class="id"> e%:num</span><span class="id"> xy</span>.<span class="id">2]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> [P];</span><span class="id"> rewrite</span><span class="id"> -entourage_ballE</span><span class="id"> =&gt;</span><span class="id"> -[_/posnumP[e]</span><span class="id"> sbeP]</span><span class="id"> sPA</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> e%:num</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> fg</span><span class="id"> fg_e;</span><span class="id"> apply:</span><span class="id"> sPA</span><span class="id"> =&gt;</span><span class="id"> t;</span><span class="id"> apply:</span><span class="id"> sbeP;</span><span class="id"> apply:</span><span class="id"> fg_e</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Uniform_isPseudoMetric</span>.<span class="id">Build</span><span class="id"> R</span><br/>
&nbsp;&nbsp;(<span class="id">arrow_uniform_type</span><span class="id"> T</span><span class="id"> U</span>)<span class="id"> fct_ball_center</span><span class="id"> fct_ball_sym</span><br/>
&nbsp;&nbsp;<span class="id">fct_ball_triangle</span><span class="id"> fct_entourage</span>.<br/>
<span class="vernacular">End</span><span class="id"> fct_PseudoMetric</span>.<br/>
<br/>
<span class="vernacular">Module</span><span class="id"> ArrowAsUniformType</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">V</span><span class="id"> :</span><span class="id"> uniformType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Uniform</span>.<span class="id">copy</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>) (<span class="id">arrow_uniform_type</span><span class="id"> U</span><span class="id"> V</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> numFieldType</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">V</span><span class="id"> :</span><span class="id"> pseudoMetricType</span><span class="id"> R</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">PseudoMetric</span>.<span class="id">copy</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>) (<span class="id">arrow_uniform_type</span><span class="id"> U</span><span class="id"> V</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> topologicalType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> uniformType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Uniform</span>.<span class="id">copy</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">continuousType</span><span class="id"> U</span><span class="id"> T</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">weak_topology</span> (<span class="id">id</span><span class="id"> :</span><span class="id"> continuousType</span><span class="id"> U</span><span class="id"> T</span><span class="id"> -&gt;</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> T</span>))).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> topologicalType</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">T</span><span class="id"> :</span><span class="id"> pseudoMetricType</span><span class="id"> R</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">PseudoMetric</span>.<span class="id">on</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">weak_topology</span> (<span class="id">id</span><span class="id"> :</span><span class="id"> continuousType</span><span class="id"> U</span><span class="id"> T</span><span class="id"> -&gt;</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> T</span>))).<br/>
<br/>
<span class="vernacular">End</span><span class="id"> ArrowAsUniformType</span>.<br/>
<br/>
<div class="doc">Limit switching </div>
<span class="vernacular">Section</span><span class="id"> Cvg_switch</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T1</span><span class="id"> T2</span><span class="id"> :</span><span class="id"> choiceType}</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Import</span><span class="id"> ArrowAsUniformType</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_switch_1</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> uniformType}</span><br/>
&nbsp;&nbsp;<span class="id">F1</span><span class="id"> {FF1</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F1}</span><span class="id"> F2</span><span class="id"> {FF2</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F2}</span><br/>
&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">h</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">l</span><span class="id"> :</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> @</span><span class="id"> F1</span><span class="id"> --&gt;</span><span class="id"> g</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> x1,</span><span class="id"> f</span><span class="id"> x1</span><span class="id"> @</span><span class="id"> F2</span><span class="id"> --&gt;</span><span class="id"> h</span><span class="id"> x1</span>)<span class="id"> -&gt;</span><span class="id"> h</span><span class="id"> @</span><span class="id"> F1</span><span class="id"> --&gt;</span><span class="id"> l</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">g</span><span class="id"> @</span><span class="id"> F2</span><span class="id"> --&gt;</span><span class="id"> l</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> fg</span><span class="id"> fh</span><span class="id"> hl;</span><span class="id"> apply/cvg_app_entourageP</span><span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> entA</span>.<br/>
<span class="id">near</span><span class="id"> F1</span><span class="id"> =&gt;</span><span class="id"> x1;</span><span class="id"> near=&gt;</span><span class="id"> x2;</span><span class="id"> apply:</span> (<span class="id">entourage_split</span> (<span class="id">h</span><span class="id"> x1</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/xsectionP;</span><span class="id"> near:</span><span class="id"> x1;</span><span class="id"> exact:</span><span class="id"> hl</span>.<br/>
<span class="id">apply:</span> (<span class="id">entourage_split</span> (<span class="id">f</span><span class="id"> x1</span><span class="id"> x2</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/xsectionP;</span><span class="id"> near:</span><span class="id"> x2;</span><span class="id"> exact:</span><span class="id"> fh</span>.<br/>
<span class="id">move:</span> (<span class="id">x2</span>)<span class="id">;</span><span class="id"> near:</span><span class="id"> x1;</span><span class="id"> have</span><span class="id"> /cvg_fct_entourageP</span><span class="id"> /</span>(_<span class="id"> _^-1%relation</span>)<span class="id">:=</span><span class="id"> fg;</span><span class="id"> apply</span>.<br/>
<span class="id">exact:</span><span class="id"> entourage_inv</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_switch_2</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> completeType}</span><br/>
&nbsp;&nbsp;<span class="id">F1</span><span class="id"> {FF1</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F1}</span><span class="id"> F2</span><span class="id"> {FF2</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F2}</span><br/>
&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">h</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> @</span><span class="id"> F1</span><span class="id"> --&gt;</span><span class="id"> g</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> @</span><span class="id"> F2</span><span class="id"> --&gt;</span><span class="id"> h</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[cvg</span><span class="id"> h</span><span class="id"> @</span><span class="id"> F1</span><span class="gallina-kwd"> in</span><span class="id"> U]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> fg</span><span class="id"> fh;</span><span class="id"> apply:</span><span class="id"> cauchy_cvg</span><span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> entA</span>.<br/>
<span class="id">rewrite</span><span class="id"> !near_simpl</span><span class="id"> -near2_pair</span><span class="id"> near_map2;</span><span class="id"> near=&gt;</span><span class="id"> x1</span><span class="id"> y1</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> near</span><span class="id"> F2</span><span class="id"> =&gt;</span><span class="id"> x2</span>.<br/>
<span class="id">apply:</span> (<span class="id">entourage_split</span> (<span class="id">f</span><span class="id"> x1</span><span class="id"> x2</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/xsectionP;</span><span class="id"> near:</span><span class="id"> x2;</span><span class="id"> exact:</span><span class="id"> fh</span>.<br/>
<span class="id">apply:</span> (<span class="id">entourage_split</span> (<span class="id">f</span><span class="id"> y1</span><span class="id"> x2</span>))<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/xsectionP;</span><span class="id"> near:</span><span class="id"> x2;</span><span class="id"> apply/</span>(<span class="id">fh</span><span class="id"> _</span> (<span class="id">xsection</span><span class="id"> _^-1%relation</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> nbhs_entourage</span> (<span class="id">entourage_inv</span><span class="id"> _</span>).<br/>
<span class="id">apply:</span> (<span class="id">entourage_split</span> (<span class="id">g</span><span class="id"> x2</span>))<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> move:</span> (<span class="id">x2</span>)<span class="id">;</span><span class="id"> [near:</span><span class="id"> x1|near:</span><span class="id"> y1]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /cvg_fct_entourageP</span><span class="id"> /</span>(_<span class="id"> _^-1%relation</span>)<span class="id"> :=</span><span class="id"> fg;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> entourage_inv</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /cvg_fct_entourageP</span><span class="id"> :=</span><span class="id"> fg;</span><span class="id"> apply</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_switch</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> completeType}</span><br/>
&nbsp;&nbsp;<span class="id">F1</span> (<span class="id">FF1</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F1</span>)<span class="id"> F2</span> (<span class="id">FF2</span><span class="id"> :</span><span class="id"> ProperFilter</span><span class="id"> F2</span>)<br/>
&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">h</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">f</span><span class="id"> @</span><span class="id"> F1</span><span class="id"> --&gt;</span><span class="id"> g</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> x1,</span><span class="id"> f</span><span class="id"> x1</span><span class="id"> @</span><span class="id"> F2</span><span class="id"> --&gt;</span><span class="id"> h</span><span class="id"> x1</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> l</span><span class="id"> :</span><span class="id"> U,</span><span class="id"> h</span><span class="id"> @</span><span class="id"> F1</span><span class="id"> --&gt;</span><span class="id"> l</span><span class="id"> /\</span><span class="id"> g</span><span class="id"> @</span><span class="id"> F2</span><span class="id"> --&gt;</span><span class="id"> l</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Hfg</span><span class="id"> Hfh;</span><span class="id"> have</span><span class="id"> hcv</span><span class="id"> :=</span><span class="id"> !!</span><span class="id"> cvg_switch_2</span><span class="id"> Hfg</span><span class="id"> Hfh</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">lim</span> (<span class="id">h</span><span class="id"> @</span><span class="id"> F1</span>))<span class="id">;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> cvg_switch_1</span><span class="id"> Hfg</span><span class="id"> Hfh</span><span class="id"> hcv</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Cvg_switch</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> uniform_fun</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">V</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<span class="id"> :</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'uniform`' A -&gt; V }&quot;</span><span class="id"> :=</span> (<span class="id">@uniform_fun</span><span class="id"> _</span><span class="id"> A</span><span class="id"> V</span>)<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'uniform' U -&gt; V }&quot;</span><span class="id"> :=</span> (<span class="id">{uniform`</span><span class="id"> [set:</span><span class="id"> U]</span><span class="id"> -&gt;</span><span class="id"> V}</span>)<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'uniform' A , F --&gt; f }&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">cvg_to</span><span class="id"> F</span> (<span class="id">nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {uniform`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> _}</span>)))<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'uniform' , F --&gt; f }&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">cvg_to</span><span class="id"> F</span> (<span class="id">nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {uniform</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> _}</span>)))<span class="id"> :</span><span class="id"> classical_set_scope</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> sigL_arrow</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">V</span><span class="id"> :</span><span class="id"> uniformType</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> -&gt;</span><span class="id"> arrow_uniform_type</span><span class="id"> A</span><span class="id"> V</span><span class="id"> :=</span><span class="id"> @sigL</span><span class="id"> _</span><span class="id"> V</span><span class="id"> A</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">V</span><span class="id"> :</span><span class="id"> uniformType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Uniform</span>.<span class="id">copy</span><span class="id"> {uniform`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> V}</span> (<span class="id">weak_topology</span> (<span class="id">@sigL_arrow</span><span class="id"> _</span><span class="id"> A</span><span class="id"> V</span>)).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> RestrictedUniformTopology</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> {V</span><span class="id"> :</span><span class="id"> uniformType}</span> .<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniform_nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {uniform`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> V}</span>)<span class="id"> P:</span><br/>
&nbsp;&nbsp;<span class="id">nbhs</span><span class="id"> f</span><span class="id"> P</span><span class="id"> &lt;-&gt;</span> (<span class="gallina-kwd">exists</span><span class="id"> E,</span><span class="id"> entourage</span><span class="id"> E</span><span class="id"> /\</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set</span><span class="id"> h</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> y,</span><span class="id"> A</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> E</span>(<span class="id">f</span><span class="id"> y,</span><span class="id"> h</span><span class="id"> y</span>)<span class="id">]</span><span class="id"> `&lt;=`</span><span class="id"> P</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [[Q</span><span class="id"> [[/=</span><span class="id"> W</span><span class="id"> oW</span><span class="id"> &lt;-</span><span class="id"> /=]</span><span class="id"> Wf</span><span class="id"> subP]]|[E</span><span class="id"> [entE</span><span class="id"> subP]]]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> openE</span><span class="id"> /=</span><span class="id"> /interior</span><span class="gallina-kwd"> in</span><span class="id"> oW</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">oW</span><span class="id"> _</span><span class="id"> Wf</span>)<span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> [</span><span class="id"> /=</span><span class="id"> E</span><span class="id"> entE]</span><span class="id"> Esub</span><span class="id"> subW</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> E;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> h</span><span class="id"> Eh;</span><span class="id"> apply/subP/subW/xsectionP/Esub</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [[u</span><span class="id"> Au]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> Eh</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -inE</span>.<br/>
<span class="id">case</span><span class="id"> :</span> (<span class="id">pselect</span> (<span class="gallina-kwd">exists</span> (<span class="id">u</span><span class="id"> :</span><span class="id"> U</span>)<span class="id">,</span><span class="id"> True</span>))<span class="id">;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> nU;</span><span class="id"> apply:</span> (<span class="id">filterS</span><span class="id"> subP</span>)<span class="id">;</span><span class="id"> apply:</span> (<span class="id">@filterS</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> setT</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> t</span><span class="id"> _</span><span class="id"> /=</span><span class="id"> y;</span><span class="id"> move:</span><span class="id"> nU;</span><span class="id"> apply:</span><span class="id"> absurd;</span><span class="gallina-kwd"> exists</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> filterT</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> u0</span><span class="id"> _;</span><span class="id"> near=&gt;</span><span class="id"> g;</span><span class="id"> apply:</span><span class="id"> subP</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> /mem_set</span><span class="id"> Ay;</span><span class="id"> rewrite</span><span class="id"> -!</span>(<span class="id">sigLE</span><span class="id"> A</span>).<br/>
<span class="id">move:</span> (<span class="id">SigSub</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> near:</span><span class="id"> g</span>.<br/>
<span class="id">have</span><span class="id"> :=</span> (<span class="id">@cvg_image</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">@sigL_arrow</span><span class="id"> _</span><span class="id"> A</span><span class="id"> V</span>)<span class="id"> _</span><span class="id"> f</span> (<span class="id">nbhs_filter</span><span class="id"> f</span>)<br/>
&nbsp;&nbsp;(<span class="id">image_sigL</span> (<span class="id">f</span><span class="id"> u0</span>))).<span class="id">1</span><span class="id"> cvg_id</span><span class="id"> [set</span><span class="id"> h</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> y,</span><span class="id"> E</span> (<span class="id">sigL</span><span class="id"> A</span><span class="id"> f</span><span class="id"> y,</span><span class="id"> h</span><span class="id"> y</span>)<span class="id">]</span>.<br/>
<span class="id">case</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> [set</span><span class="id"> fg</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> y,</span><span class="id"> E</span> (<span class="id">fg</span>.<span class="id">1</span><span class="id"> y,</span><span class="id"> fg</span>.<span class="id">2</span><span class="id"> y</span>)<span class="id">]</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> E</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> g</span><span class="id"> /xsectionP</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> B</span><span class="id"> nbhsB</span><span class="id"> rBrE;</span><span class="id"> apply:</span> (<span class="id">filterS</span><span class="id"> _</span><span class="id"> nbhsB</span>)<span class="id"> =&gt;</span><span class="id"> g</span><span class="id"> Bg</span><span class="id"> [y</span><span class="id"> yA]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> rBrE;</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> case</span><span class="id"> =&gt;</span><span class="id"> [+</span><span class="id"> _];</span><span class="id"> apply;</span><span class="gallina-kwd"> exists</span><span class="id"> g</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniform_entourage</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">@entourage</span><span class="id"> [the</span><span class="id"> uniformType</span><span class="id"> of</span><span class="id"> {uniform`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> V}]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">filter_from</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">@entourage</span><span class="id"> V</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> P</span><span class="id"> =&gt;</span><span class="id"> [set</span><span class="id"> fg</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> t</span><span class="id"> :</span><span class="id"> U,</span><span class="id"> A</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> P</span> (<span class="id">fg</span>.<span class="id">1</span><span class="id"> t,</span><span class="id"> fg</span>.<span class="id">2</span><span class="id"> t</span>)<span class="id">]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> P</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> /=</span><span class="id"> E</span><span class="id"> [F</span><span class="id"> entF</span><span class="id"> FsubE</span><span class="id"> EsubP];</span><span class="gallina-kwd"> exists</span><span class="id"> F</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> case=&gt;</span><span class="id"> f</span><span class="id"> g</span><span class="id"> Ffg</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/EsubP/FsubE=&gt;</span><span class="id"> [[x</span><span class="id"> p]]</span><span class="id"> /=;</span><span class="id"> apply:</span><span class="id"> Ffg;</span><span class="id"> move/set_mem:</span> (<span class="id">p</span>).<br/>
<span class="id">case=&gt;</span><span class="id"> E</span><span class="id"> entE</span><span class="id"> EsubP;</span><span class="gallina-kwd"> exists</span><span class="id"> [set</span><span class="id"> fg</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> E</span> (<span class="id">fg</span>.<span class="id">1</span><span class="id"> t,</span><span class="id"> fg</span>.<span class="id">2</span><span class="id"> t</span>)<span class="id">]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> E</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> f</span><span class="id"> g</span><span class="id"> Efg;</span><span class="id"> apply:</span><span class="id"> EsubP</span><span class="id"> =&gt;</span><span class="id"> t</span><span class="id"> /mem_set</span><span class="id"> At</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> Efg</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> /</span>(_ (<span class="id">@exist</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> in_mem</span><span class="id"> x</span> (<span class="id">mem</span><span class="id"> A</span>))<span class="id"> _</span><span class="id"> At</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> RestrictedUniformTopology</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> restricted_cvgE</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> uniformType}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>))<span class="id"> A</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{uniform</span><span class="id"> A,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> =</span> (<span class="id">F</span><span class="id"> --&gt;</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {uniform`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> V}</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pointwise_cvgE</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> Type}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> topologicalType}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>)) (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{ptws,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> =</span> (<span class="id">F</span><span class="id"> --&gt;</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {ptws</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V}</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<br/>
<div class="doc md"> We use this function to help Coq identify the correct notation to use
  when printing. Otherwise you get goals like `F --&gt; f -&gt; F --&gt; f`.</div>
<span class="vernacular">Definition</span><span class="id"> uniform_fun_family</span><span class="id"> {U}</span><span class="id"> V</span> (<span class="id">fam</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :=</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'family' fam , U -&gt; V }&quot;</span><span class="id"> :=</span>  (<span class="id">@uniform_fun_family</span><span class="id"> U</span><span class="id"> V</span><span class="id"> fam</span>).<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'family' fam , F --&gt; f }&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">cvg_to</span><span class="id"> F</span> (<span class="id">@nbhs</span><span class="id"> _</span><span class="id"> {family</span><span class="id"> fam,</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> _}</span><span class="id"> f</span>))<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> uniformType}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fam</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Uniform</span>.<span class="id">copy</span><span class="id"> {family</span><span class="id"> fam,</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V}</span> (<span class="id">sup_topology</span> (<span class="gallina-kwd">fun</span><span class="id"> k</span><span class="id"> :</span><span class="id"> sigT</span><span class="id"> fam</span><span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Uniform</span>.<span class="id">class</span><span class="id"> [the</span><span class="id"> uniformType</span><span class="id"> of</span><span class="id"> {uniform`</span><span class="id"> projT1</span><span class="id"> k</span><span class="id"> -&gt;</span><span class="id"> V}]</span>)).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> UniformCvgLemmas</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> uniformType}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniform_set1</span><span class="id"> F</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> {uniform</span><span class="id"> [set</span><span class="id"> x],</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> =</span> (<span class="id">g</span><span class="id"> x</span><span class="id"> @[g</span><span class="id"> --&gt;</span><span class="id"> F]</span><span class="id"> --&gt;</span><span class="id"> f</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF;</span><span class="id"> rewrite</span><span class="id"> propeqE;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> +</span><span class="id"> W</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> [set</span><span class="id"> t</span><span class="id"> |</span><span class="id"> W</span> (<span class="id">t</span><span class="id"> x</span>)<span class="id">]</span>)<span class="id"> +;</span><span class="id"> rewrite</span><span class="id"> -nbhs_entourageE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> uniform_nbhs</span><span class="id"> =&gt;</span><span class="id"> +</span><span class="id"> [Q</span><span class="id"> entQ</span><span class="id"> subW]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply;</span><span class="gallina-kwd"> exists</span><span class="id"> Q;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> h</span><span class="id"> Qf;</span><span class="id"> exact/subW/xsectionP/Qf</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> Ff</span><span class="id"> W;</span><span class="id"> rewrite</span><span class="id"> uniform_nbhs</span><span class="id"> =&gt;</span><span class="id"> [[E]</span><span class="id"> [entE</span><span class="id"> subW]]</span>.<br/>
<span class="id">apply:</span> (<span class="id">filterS</span><span class="id"> subW</span>)<span class="id">;</span><span class="id"> move/</span>(<span class="id">nbhs_entourage</span> (<span class="id">f</span><span class="id"> x</span>))<span class="id">/Ff:</span><span class="id"> entE</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> near_simpl</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> filter_app;</span><span class="id"> apply:</span><span class="id"> nearW=&gt;</span><span class="id"> ?</span><span class="id"> /xsectionP</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniform_subset_nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>) (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">B</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {uniform`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> V}</span>)<span class="id"> `=&gt;`</span><span class="id"> nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {uniform`</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> V}</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move</span><span class="id"> =&gt;</span><span class="id"> BsubA</span><span class="id"> P</span><span class="id"> /uniform_nbhs</span><span class="id"> [E</span><span class="id"> [entE</span><span class="id"> EsubP]]</span>.<br/>
<span class="id">apply:</span> (<span class="id">filterS</span><span class="id"> EsubP</span>)<span class="id">;</span><span class="id"> apply/uniform_nbhs;</span><span class="gallina-kwd"> exists</span><span class="id"> E;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> h</span><span class="id"> Eh</span><span class="id"> y</span><span class="id"> /BsubA</span><span class="id"> Ay;</span><span class="id"> exact:</span><span class="id"> Eh</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniform_subset_cvg</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>) (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> F</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> {uniform</span><span class="id"> A,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> {uniform</span><span class="id"> B,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move</span><span class="id"> =&gt;</span><span class="id"> FF</span><span class="id"> /uniform_subset_nbhs</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> f</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> nbhsF</span><span class="id"> Acvg;</span><span class="id"> apply:</span><span class="id"> cvg_trans;</span><span class="id"> [exact:</span><span class="id"> Acvg|exact:</span><span class="id"> nbhsF]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pointwise_uniform_cvg</span>  (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> {uniform,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> {ptws,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF;</span><span class="id"> rewrite</span><span class="id"> cvg_sup</span><span class="id"> =&gt;</span><span class="id"> +</span><span class="id"> i;</span><span class="id"> have</span><span class="id"> isubT</span><span class="id"> :</span><span class="id"> [set</span><span class="id"> i]</span><span class="id"> `&lt;=`</span><span class="id"> setT</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /</span>(<span class="id">uniform_subset_cvg</span><span class="id"> _</span><span class="id"> isubT</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> uniform_set1</span>.<br/>
<span class="id">rewrite</span><span class="id"> cvg_image;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split=&gt;</span><span class="id"> v</span><span class="id"> //</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span> (<span class="id">cst</span><span class="id"> v</span>).<br/>
<span class="id">apply:</span><span class="id"> cvg_trans</span><span class="id"> =&gt;</span><span class="id"> W</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> nbhs_simpl;</span><span class="gallina-kwd"> exists</span> (<span class="id">@^~</span><span class="id"> i</span><span class="id"> @^-1`</span><span class="id"> W</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> image_preimage</span><span class="id"> //</span><span class="id"> eqEsubset;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> j</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> j</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_sigL</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{uniform</span><span class="id"> A,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{uniform,</span><span class="id"> sigL</span><span class="id"> A</span><span class="id"> @</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> sigL</span><span class="id"> A</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> cvgF</span><span class="id"> P'</span><span class="id"> /uniform_nbhs</span><span class="id"> [E</span><span class="id"> [entE</span><span class="id"> EsubP]]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">filterS</span><span class="id"> EsubP</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> cvgF</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">filterS</span> (<span class="id">P</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> h</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> y,</span><span class="id"> A</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> y,</span><span class="id"> h</span><span class="id"> y</span>)<span class="id">]</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> h/=</span><span class="id"> Eh</span><span class="id"> [y</span><span class="id"> ?]</span><span class="id"> _;</span><span class="id"> apply</span><span class="id"> Eh;</span><span class="id"> rewrite</span><span class="id"> -inE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span> (<span class="id">apply/uniform_nbhs;</span><span class="id"> eexists;</span><span class="id"> split;</span><span class="id"> eauto</span>).<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> cvgF</span><span class="id"> P'</span><span class="id"> /=</span><span class="id"> /uniform_nbhs</span><span class="id"> [</span><span class="id"> E</span><span class="id"> [/=</span><span class="id"> entE</span><span class="id"> EsubP]]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">filterS</span><span class="id"> EsubP</span>).<br/>
&nbsp;&nbsp;<span class="id">move:</span> (<span class="id">cvgF</span> <span class="id"> [set</span><span class="id"> h</span><span class="id"> |</span> (<span class="gallina-kwd">forall</span><span class="id"> y</span><span class="id"> ,</span><span class="id"> E</span> (<span class="id">sigL</span><span class="id"> A</span><span class="id"> f</span><span class="id"> y,</span><span class="id"> h</span><span class="id"> y</span>))<span class="id">]</span>)<span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">set</span><span class="id"> Q</span><span class="id"> :=</span> (<span class="id">x</span><span class="gallina-kwd"> in</span> (_<span class="id"> -&gt;</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> move=&gt;</span><span class="id"> W</span>.<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> Q</span><span class="gallina-kwd"> by</span><span class="id"> apply</span><span class="id"> W,</span><span class="id"> uniform_nbhs;</span><span class="gallina-kwd"> exists</span><span class="id"> E;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> h</span><span class="id"> +</span><span class="id"> ?;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> {}/W</span><span class="id"> {}/Q;</span><span class="id"> near_simpl</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> R;</span><span class="id"> apply:</span> (<span class="id">filterS</span><span class="id"> _</span><span class="id"> R</span>)<span class="id"> =&gt;</span><span class="id"> h</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> forall_sig</span><span class="id"> /sigL</span><span class="id"> /=</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_in_close</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> {uniform`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> V}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> A,</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> g}</span><span class="id"> -&gt;</span><span class="id"> close</span><span class="id"> f</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> entourage_close</span><span class="id"> =&gt;</span><span class="id"> /eq_sigLP</span><span class="id"> eqfg</span><span class="id"> ?</span><span class="id"> [E</span><span class="id"> entE];</span><span class="id"> apply=&gt;</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /map_pair/sigL_arrow</span><span class="id"> eqfg;</span><span class="id"> exact:</span><span class="id"> entourage_refl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> hausdorrf_close_eq_in</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> {uniform`</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> V}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">hausdorff_space</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> close</span><span class="id"> f</span><span class="id"> g</span><span class="id"> =</span><span class="id"> {in</span><span class="id"> A,</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> g}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> hV</span>.<br/>
<span class="id">rewrite</span><span class="id"> propeqE;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> eq_in_close</span>.<br/>
<span class="id">rewrite</span><span class="id"> entourage_close</span><span class="id"> =&gt;</span><span class="id"> C</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> uA;</span><span class="id"> apply:</span><span class="id"> hV</span>.<br/>
<span class="id">rewrite</span><span class="id"> /cluster</span><span class="id"> -nbhs_entourageE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> [X'</span><span class="id"> eX</span><span class="id"> X'X]</span><span class="id"> [Y'</span><span class="id"> eY</span><span class="id"> Y'Y]</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">g</span><span class="id"> u</span>)<span class="id">;</span><span class="id"> split;</span><span class="id"> [apply:</span><span class="id"> X'X|</span><span class="id"> apply:</span><span class="id"> Y'Y];</span><span class="id"> apply/xsectionP;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> entourage_refl</span>.<br/>
<span class="id">apply:</span> (<span class="id">C</span><span class="id"> [set</span><span class="id"> fg</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> y,</span><span class="id"> A</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> X'</span> (<span class="id">fg</span>.<span class="id">1</span><span class="id"> y,</span><span class="id"> fg</span>.<span class="id">2</span><span class="id"> y</span>)<span class="id">]</span>)<span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> uniform_entourage;</span><span class="gallina-kwd"> exists</span><span class="id"> X'</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniform_nbhsT</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {uniform</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V}</span>))<span class="id"> =</span><span class="id"> nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> arrow_uniform_type</span><span class="id"> U</span><span class="id"> V</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split=&gt;</span><span class="id"> A</span>.<br/>
&nbsp;&nbsp;<span class="id">case/uniform_nbhs</span><span class="id"> =&gt;</span><span class="id"> E</span><span class="id"> [entE]</span><span class="id"> /filterS;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> [set</span><span class="id"> fh</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> y,</span><span class="id"> E</span> (<span class="id">fh</span>.<span class="id">1</span><span class="id"> y,</span><span class="id"> fh</span>.<span class="id">2</span><span class="id"> y</span>)<span class="id">];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> E</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> /xsectionP</span><span class="id"> /=</span>.<br/>
<span class="id">case</span><span class="id"> =&gt;</span><span class="id"> J</span><span class="id"> [E</span><span class="id"> entE</span><span class="id"> EJ]</span><span class="id"> /filterS;</span><span class="id"> apply;</span><span class="id"> apply/uniform_nbhs;</span><span class="gallina-kwd"> exists</span><span class="id"> E</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> z</span><span class="id"> /=</span><span class="id"> Efz;</span><span class="id"> apply/xsectionP/EJ</span><span class="id"> =&gt;</span><span class="id"> t</span><span class="id"> /=;</span><span class="id"> exact:</span><span class="id"> Efz</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_uniformU</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>))<span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{uniform</span><span class="id"> A,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> {uniform</span><span class="id"> B,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{uniform</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id">,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> AFf</span><span class="id"> BFf</span><span class="id"> Q</span><span class="id"> /=/uniform_nbhs</span><span class="id"> [E</span><span class="id"> [entE</span><span class="id"> EsubQ]]</span>.<br/>
<span class="id">apply:</span> (<span class="id">filterS</span><span class="id"> EsubQ</span>).<br/>
<span class="id">rewrite</span> (<span class="id">_:</span> <span class="id"> [set</span><span class="id"> h</span><span class="id"> |</span> (<span class="gallina-kwd">forall</span><span class="id"> y</span><span class="id"> :</span><span class="id"> U,</span> (<span class="id">A</span><span class="id"> `|`</span><span class="id"> B</span>)<span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> y,</span><span class="id"> h</span><span class="id"> y</span>))<span class="id">]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set</span><span class="id"> h</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> y,</span><span class="id"> A</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> y,</span><span class="id"> h</span><span class="id"> y</span>)<span class="id">]</span><span class="id"> `&amp;`</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set</span><span class="id"> h</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> y,</span><span class="id"> B</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> y,</span><span class="id"> h</span><span class="id"> y</span>)<span class="id">]</span>).<br/>
<span class="id">-</span><span class="id"> apply:</span><span class="id"> filterI;</span><span class="id"> [apply:</span><span class="id"> AFf|</span><span class="id"> apply:</span><span class="id"> BFf]</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply/uniform_nbhs;</span><span class="gallina-kwd"> exists</span><span class="id"> E;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply/uniform_nbhs;</span><span class="gallina-kwd"> exists</span><span class="id"> E;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split=&gt;</span><span class="id"> h</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> R;</span><span class="id"> split=&gt;</span><span class="id"> t</span><span class="id"> ?;</span><span class="id"> apply:</span><span class="id"> R;[left|</span><span class="id"> right]</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> [R1</span><span class="id"> R2]</span><span class="id"> y</span><span class="id"> [?</span><span class="id"> |</span><span class="id"> ?];</span><span class="id"> [apply:</span><span class="id"> R1|</span><span class="id"> apply:</span><span class="id"> R2]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cvg_uniform_set0</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>)) (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{uniform</span><span class="id"> set0,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> P</span><span class="id"> /=</span><span class="id"> /uniform_nbhs</span><span class="id"> [E</span><span class="id"> [?</span><span class="id"> R]]</span>.<br/>
<span class="id">suff</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> P</span><span class="id"> =</span><span class="id"> setT</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> filterT</span>.<br/>
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subset_trans</span><span class="id"> R</span><span class="id"> =&gt;</span><span class="id"> g</span><span class="id"> _</span><span class="id"> ?</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fam_cvgP</span> (<span class="id">fam</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>)) (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> {family</span><span class="id"> fam,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U,</span><span class="id"> fam</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> {uniform</span><span class="id"> A,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f</span><span class="id"> }</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /cvg_sup</span><span class="id"> +</span><span class="id"> A</span><span class="id"> FA;</span><span class="id"> move/</span>(_ (<span class="id">existT</span><span class="id"> _</span><span class="id"> _</span><span class="id"> FA</span>)).<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> famFf</span><span class="id"> /=;</span><span class="id"> apply/cvg_sup</span><span class="id"> =&gt;</span><span class="id"> [[?</span><span class="id"> ?]</span><span class="id"> FA];</span><span class="id"> apply:</span><span class="id"> famFf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> family_cvg_subset</span> (<span class="id">famA</span><span class="id"> famB</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">famA</span><span class="id"> `&lt;=`</span><span class="id"> famB</span><span class="id"> -&gt;</span><span class="id"> {family</span><span class="id"> famB,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> {family</span><span class="id"> famA,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> FF</span><span class="id"> S</span><span class="id"> /fam_cvgP</span><span class="id"> famBFf;</span><span class="id"> apply/fam_cvgP</span><span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> ?;</span><span class="id"> apply/famBFf/S</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> family_cvg_finite_covers</span> (<span class="id">famA</span><span class="id"> famB</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<br/>
&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>)) (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> P,</span><span class="id"> famA</span><span class="id"> P</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> choiceType</span>)<span class="id"> f,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> famB</span> (<span class="id">f</span><span class="id"> i</span>))<span class="id"> /\</span><span class="id"> finite_subset_cover</span><span class="id"> [set:</span><span class="id"> I]</span><span class="id"> f</span><span class="id"> P</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{family</span><span class="id"> famB,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> {family</span><span class="id"> famA,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> ex_finCover</span><span class="id"> /fam_cvgP</span><span class="id"> rFf;</span><span class="id"> apply/fam_cvgP</span><span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> famAA</span>.<br/>
<span class="id">move:</span><span class="id"> ex_finCover</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> famAA</span>)<span class="id"> [R</span><span class="id"> [g</span><span class="id"> [g_famB</span><span class="id"> [D</span><span class="id"> _]]]]</span>.<br/>
<span class="id">move/uniform_subset_cvg;</span><span class="id"> apply</span>.<br/>
<span class="id">elim/finSet_rect:</span><span class="id"> D</span><span class="id"> =&gt;</span><span class="id"> X</span><span class="id"> IHX</span>.<br/>
<span class="id">have</span><span class="id"> [-&gt;|/set0P[x</span><span class="id"> xX]]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> [set`</span><span class="id"> X]</span><span class="id"> set0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> coverE</span><span class="id"> bigcup_set0;</span><span class="id"> apply:</span><span class="id"> cvg_uniform_set0</span>.<br/>
<span class="id">rewrite</span><span class="id"> coverE</span> (<span class="id">bigcup_fsetD1</span><span class="id"> x</span>)<span class="id">//;</span><span class="id"> apply:</span><span class="id"> cvg_uniformU</span>.<br/>
&nbsp;&nbsp;<span class="id">exact/rFf/g_famB</span>.<br/>
<span class="id">exact/IHX/fproperD1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> UniformCvgLemmas</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniform_restrict_cvg</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> puniformType}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>)) (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> A</span><span class="id"> :</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{uniform</span><span class="id"> A,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> &lt;-&gt;</span><span class="id"> {uniform,</span><span class="id"> restrict</span><span class="id"> A</span><span class="id"> @</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> restrict</span><span class="id"> A</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF;</span><span class="id"> rewrite</span><span class="id"> cvg_sigL;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> -sigLK;</span><span class="id"> move/</span>(<span class="id">cvg_app</span><span class="id"> valL</span>)<span class="id"> =&gt;</span><span class="id"> D</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> cvg_trans;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> D</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> P</span><span class="id"> /uniform_nbhs</span><span class="id"> [E</span><span class="id"> [/=entE</span><span class="id"> EsubP]];</span><span class="id"> apply:</span> (<span class="id">filterS</span><span class="id"> EsubP</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/uniform_nbhs;</span><span class="gallina-kwd"> exists</span><span class="id"> E;</span><span class="id"> split=&gt;</span><span class="id"> //=</span><span class="id"> h</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /sigL</span><span class="id"> =&gt;</span><span class="id"> R</span><span class="id"> u</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> oinv_set_val</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> insubP=&gt;</span><span class="id"> /=</span><span class="id"> *;</span><span class="id"> [apply:</span><span class="id"> R|apply:</span><span class="id"> entourage_refl]</span>.<br/>
<span class="id">-</span><span class="id"> move/</span>(<span class="id">@cvg_app</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">sigL</span><span class="id"> A</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -fmap_comp</span><span class="id"> sigL_restrict</span><span class="id"> =&gt;</span><span class="id"> D</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> cvg_trans;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> D</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> P</span><span class="id"> /uniform_nbhs</span><span class="id"> [E</span><span class="id"> [/=entE</span><span class="id"> EsubP]];</span><span class="id"> apply:</span> (<span class="id">filterS</span><span class="id"> EsubP</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/uniform_nbhs;</span><span class="gallina-kwd"> exists</span><span class="id"> E;</span><span class="id"> split=&gt;</span><span class="id"> //=</span><span class="id"> h</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /sigL</span><span class="id"> =&gt;</span><span class="id"> R</span><span class="id"> [u</span><span class="id"> Au]</span><span class="id"> _</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> R</span><span class="id"> u</span><span class="id"> I;</span><span class="id"> rewrite</span><span class="id"> /patch</span><span class="id"> Au</span>.<br/>
Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> FamilyConvergence</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fam_cvgE</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> uniformType}</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> fam</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{family</span><span class="id"> fam,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> =</span> (<span class="id">F</span><span class="id"> --&gt;</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {family</span><span class="id"> fam,</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V}</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fam_nbhs</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> uniformType}</span> (<span class="id">fam</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">E</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">V</span><span class="id"> *</span><span class="id"> V</span>)) (<span class="id">f</span><span class="id"> :</span><span class="id"> {family</span><span class="id"> fam,</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">entourage</span><span class="id"> E</span><span class="id"> -&gt;</span><span class="id"> fam</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> nbhs</span><span class="id"> f</span><span class="id"> [set</span><span class="id"> g</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> y,</span><span class="id"> A</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> y,</span><span class="id"> g</span><span class="id"> y</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> entE</span><span class="id"> famA;</span><span class="id"> have</span><span class="id"> /fam_cvgP</span><span class="id"> /</span>(_<span class="id"> A</span>)<span class="id"> :</span> (<span class="id">nbhs</span><span class="id"> f</span><span class="id"> --&gt;</span><span class="id"> f</span>)<span class="gallina-kwd"> by</span><span class="id"> [];</span><span class="id"> apply</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply</span><span class="id"> uniform_nbhs;</span><span class="gallina-kwd"> exists</span><span class="id"> E;</span><span class="id"> split</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fam_compact_nbhs</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> topologicalType}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> uniformType}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">O</span><span class="id"> :</span><span class="id"> set</span><span class="id"> V</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">open</span><span class="id"> O</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> O</span><span class="id"> -&gt;</span><span class="id"> compact</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> continuous</span><span class="id"> f</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V}</span>)<span class="id"> [set</span><span class="id"> g</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> y,</span><span class="id"> A</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> O</span> (<span class="id">g</span><span class="id"> y</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> oO</span><span class="id"> fAO</span><span class="id"> /[dup]</span><span class="id"> cA</span><span class="id"> /compact_near_coveringP/near_covering_withinP</span><span class="id"> cfA</span><span class="id"> ctsf</span>.<br/>
<span class="id">near=&gt;</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> /=;</span> (<span class="id">suff:</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> [set</span><span class="id"> y</span><span class="id"> |</span><span class="id"> O</span> (<span class="id">z</span><span class="id"> y</span>)<span class="id">]</span><span class="gallina-kwd"> by</span><span class="id"> exact</span>)<span class="id">;</span><span class="id"> near:</span><span class="id"> z</span>.<br/>
<span class="id">apply:</span><span class="id"> cfA</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> Ax;</span><span class="id"> have</span><span class="id"> :</span><span class="id"> O</span> (<span class="id">f</span><span class="id"> x</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> fAO</span>.<br/>
<span class="id">move:</span> (<span class="id">oO</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> openE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> /[apply]</span><span class="id"> /[dup]</span><span class="id"> /ctsf</span><span class="id"> Ofx</span><span class="id"> /=</span>.<br/>
<span class="id">rewrite</span><span class="id"> /interior</span><span class="id"> -nbhs_entourageE</span><span class="id"> =&gt;</span><span class="id"> -[E</span><span class="id"> entE</span><span class="id"> EfO]</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> xsection</span> (<span class="id">split_ent</span><span class="id"> E</span>) (<span class="id">f</span><span class="id"> x</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set</span><span class="id"> g</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> w,</span><span class="id"> A</span><span class="id"> w</span><span class="id"> -&gt;</span><span class="id"> split_ent</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> w,</span><span class="id"> g</span><span class="id"> w</span>)<span class="id">]</span>).<br/>
&nbsp;&nbsp;<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> fam_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> ctsf;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> -nbhs_entourageE;</span><span class="gallina-kwd"> exists</span> (<span class="id">split_ent</span><span class="id"> E</span>).<br/>
<span class="id">case=&gt;</span><span class="id"> y</span><span class="id"> g</span><span class="id"> [/=</span><span class="id"> /xsectionP</span><span class="id"> Efxy]</span><span class="id"> AEg</span><span class="id"> Ay;</span><span class="id"> apply/EfO/xsectionP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subset_split_ent</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span> (<span class="id">f</span><span class="id"> y</span>)<span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> exact:</span><span class="id"> AEg</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> FamilyConvergence</span>.<br/>
<br/>
<div class="doc md"> It turns out `{family compact, U -&gt; V}` can be generalized to only assume
  `topologicalType` on `V`. This topology is called the compact-open topology.
   This topology is special because it is the _only_ topology that will allow
   `curry`/`uncurry` to be continuous.</div>
<span class="vernacular">Section</span><span class="id"> compact_open</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> topologicalType}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> compact_open</span><span class="id"> :</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> compact_open_setwise</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {K</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> compact_openK</span><span class="id"> :=</span><span class="gallina-kwd"> let</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> K</span><span class="gallina-kwd"> in</span><span class="id"> compact_open</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> compact_openK_nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> compact_openK</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">filter_from</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set</span><span class="id"> O</span><span class="id"> |</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> K</span><span class="id"> `&lt;=`</span><span class="id"> O</span><span class="id"> /\</span><span class="id"> open</span><span class="id"> O]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">fun</span><span class="id"> O</span><span class="id"> =&gt;</span><span class="id"> [set</span><span class="id"> g</span><span class="id"> |</span><span class="id"> g</span><span class="id"> @`</span><span class="id"> K</span><span class="id"> `&lt;=`</span><span class="id"> O]</span>).<br/>
<br/>
<span class="id">Global</span><span class="vernacular"> Instance</span><span class="id"> compact_openK_nbhs_filter</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> compact_openK</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span> (<span class="id">compact_openK_nbhs</span><span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> case=&gt;</span><span class="id"> g</span><span class="id"> [gKO</span><span class="id"> oO]</span><span class="id"> /</span>(_<span class="id"> f</span>)<span class="id">;</span><span class="id"> apply</span>.<br/>
<span class="id">apply:</span><span class="id"> filter_from_filter;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> setT;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> openT</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> P</span><span class="id"> Q</span><span class="id"> [fKP</span><span class="id"> oP]</span><span class="id"> [fKQ</span><span class="id"> oQ];</span><span class="gallina-kwd"> exists</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> Q</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> [z</span><span class="id"> Kz</span><span class="id"> M-];</span><span class="id"> split;</span><span class="id"> [apply:</span><span class="id"> fKP</span><span class="id"> |</span><span class="id"> apply:</span><span class="id"> fKQ];</span><span class="gallina-kwd"> exists</span><span class="id"> z</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> openI</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> g</span><span class="id"> /=</span><span class="id"> gPQ;</span><span class="id"> split;</span><span class="id"> exact:</span> (<span class="id">subset_trans</span><span class="id"> gPQ</span>).<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Choice</span>.<span class="id">on</span><span class="id"> compact_openK</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> hasNbhs</span>.<span class="id">Build</span><span class="id"> compact_openK</span><span class="id"> compact_openK_nbhs</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> compact_open_of_nbhs</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> compact_openK</span><span class="id"> |</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> nbhs^~</span><span class="id"> A]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> compact_openK_nbhsE_subproof</span> (<span class="id">p</span><span class="id"> :</span><span class="id"> compact_openK</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">compact_openK_nbhs</span><span class="id"> p</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[set</span><span class="id"> A</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> B</span><span class="id"> :</span><span class="id"> set</span><span class="id"> compact_openK,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> compact_open_of_nbhs</span><span class="id"> B,</span><span class="id"> B</span><span class="id"> p</span><span class="id"> &amp;</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> A]]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> B</span><span class="id"> /=</span><span class="id"> [fKB</span><span class="id"> oB</span><span class="id"> gKBA];</span><span class="gallina-kwd"> exists</span><span class="id"> [set</span><span class="id"> g</span><span class="id"> |</span><span class="id"> g</span><span class="id"> @`</span><span class="id"> K</span><span class="id"> `&lt;=`</span><span class="id"> B];</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> h</span><span class="id"> /=</span><span class="id"> hKB;</span><span class="gallina-kwd"> exists</span><span class="id"> B</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> B</span><span class="id"> [oB</span><span class="id"> Bf</span><span class="id"> /filterS];</span><span class="id"> apply;</span><span class="id"> exact:</span><span class="id"> oB</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> compact_openK_openE_subproof</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">compact_open_of_nbhs</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> A</span><span class="id"> |</span><span class="id"> A</span><span class="id"> `&lt;=`</span><span class="id"> compact_openK_nbhs^~</span><span class="id"> A]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Nbhs_isTopological</span>.<span class="id">Build</span><span class="id"> compact_openK</span><span class="id"> compact_openK_nbhs_filter</span><br/>
&nbsp;&nbsp;<span class="id">compact_openK_nbhsE_subproof</span><span class="id"> compact_openK_openE_subproof</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> compact_open_setwise</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> compact_open_def</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">sup_topology</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> :</span><span class="id"> sigT</span> (<span class="id">@compact</span><span class="id"> T</span>)<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Topological</span>.<span class="id">class</span> (<span class="id">@compact_openK</span> (<span class="id">projT1</span><span class="id"> i</span>))).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Nbhs</span>.<span class="id">copy</span><span class="id"> compact_open</span><span class="id"> compact_open_def</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :</span><span class="id"> Nbhs_isTopological</span><span class="id"> compact_open</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Topological</span>.<span class="id">copy</span><span class="id"> compact_open</span><span class="id"> compact_open_def</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> compact_open_cvgP</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> compact_open</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span><span class="id"> :</span><span class="id"> compact_open</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">F</span><span class="id"> --&gt;</span><span class="id"> f</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> K</span><span class="id"> O,</span><span class="id"> @compact</span><span class="id"> T</span><span class="id"> K</span><span class="id"> -&gt;</span><span class="id"> @open</span><span class="id"> U</span><span class="id"> O</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> @`</span><span class="id"> K</span><span class="id"> `&lt;=`</span><span class="id"> O</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">F</span><span class="id"> [set</span><span class="id"> g</span><span class="id"> |</span><span class="id"> g</span><span class="id"> @`</span><span class="id"> K</span><span class="id"> `&lt;=`</span><span class="id"> O]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/cvg_sup</span><span class="id"> =&gt;</span><span class="id"> +</span><span class="id"> K</span><span class="id"> O</span><span class="id"> cptK</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> =&gt;</span><span class="id"> /</span>(_ (<span class="id">existT</span><span class="id"> _</span><span class="id"> _</span><span class="id"> cptK</span>))<span class="id">;</span><span class="id"> apply;</span><span class="gallina-kwd"> exists</span><span class="id"> O</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> fko;</span><span class="id"> apply/cvg_sup</span><span class="id"> =&gt;</span><span class="id"> -[A</span><span class="id"> cptK]</span><span class="id"> O</span><span class="id"> /=</span><span class="id"> [C</span><span class="id"> /=</span><span class="id"> [fAC</span><span class="id"> oC]]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/filterS;</span><span class="id"> apply;</span><span class="id"> exact:</span><span class="id"> fko</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> compact_open_open</span> (<span class="id">K</span><span class="id"> :</span><span class="id"> set</span><span class="id"> T</span>) (<span class="id">O</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">compact</span><span class="id"> K</span><span class="id"> -&gt;</span><span class="id"> open</span><span class="id"> O</span><span class="id"> -&gt;</span><span class="id"> open</span> (<span class="id">[set</span><span class="id"> g</span><span class="id"> |</span><span class="id"> g</span><span class="id"> @`</span><span class="id"> K</span><span class="id"> `&lt;=`</span><span class="id"> O]</span><span class="id"> :</span><span class="id"> set</span><span class="id"> compact_open</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> C</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> g</span><span class="id"> |</span><span class="id"> g</span><span class="id"> @`</span><span class="id"> K</span><span class="id"> `&lt;=`</span><span class="id"> O];</span><span class="id"> move=&gt;</span><span class="id"> cptK</span><span class="id"> oO</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> [set</span><span class="id"> C];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> bigcup_set1</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> -&gt;;</span><span class="gallina-kwd"> exists</span> (<span class="id">fset1</span><span class="id"> C</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> set_fset1</span><span class="id"> bigcap_set1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> /[!inE]</span><span class="id"> -&gt;;</span><span class="gallina-kwd"> exists</span> (<span class="id">existT</span><span class="id"> _</span><span class="id"> _</span><span class="id"> cptK</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> z</span><span class="id"> Cz;</span><span class="gallina-kwd"> exists</span><span class="id"> O</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> compact_open</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> topologicalType}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> ptopologicalType}</span><span class="id"> K</span><span class="id"> :=</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Pointed</span>.<span class="id">on</span> (<span class="id">@compact_openK</span><span class="id"> U</span><span class="id"> V</span><span class="id"> K</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> topologicalType}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> ptopologicalType}</span><span class="id"> :=</span> <br/>
&nbsp;&nbsp;<span class="id">Pointed</span>.<span class="id">on</span> (<span class="id">@compact_open</span><span class="id"> U</span><span class="id"> V</span>).<br/>
<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'compact-open' , U -&gt; V }&quot;</span><span class="id"> :=</span> (<span class="id">@compact_open</span><span class="id"> U</span><span class="id"> V</span>).<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'compact-open' , F --&gt; f }&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">F</span><span class="id"> --&gt;</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> @compact_open</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> compact_open_uniform</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> topologicalType}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> puniformType}</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> small_ent_sub</span><span class="id"> :=</span><span class="id"> @small_set_sub</span><span class="id"> _</span> (<span class="id">@entourage</span><span class="id"> V</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> compact_open_fam_compactP</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">continuous</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{compact-open,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> &lt;-&gt;</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ctsf</span><span class="id"> FF;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> cptF;</span><span class="id"> apply/compact_open_cvgP</span><span class="id"> =&gt;</span><span class="id"> K</span><span class="id"> O</span><span class="id"> cptK</span><span class="id"> oO</span><span class="id"> fKO</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> cptF;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> fam_compact_nbhs</span><span class="id"> oO</span><span class="id"> fKO</span><span class="id"> cptK</span><span class="id"> ctsf;</span><span class="id"> apply:</span><span class="id"> filter_app</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> near=&gt;</span><span class="id"> g</span><span class="id"> =&gt;</span><span class="id"> /=</span> <span class="id"> gKO</span><span class="id"> ?</span><span class="id"> [z</span><span class="id"> Kx</span><span class="id"> &lt;-];</span><span class="id"> exact:</span><span class="id"> gKO</span>.<br/>
<span class="id">move/compact_open_cvgP=&gt;</span><span class="id"> cptOF;</span><span class="id"> apply/cvg_sup</span><span class="id"> =&gt;</span><span class="id"> -[K</span><span class="id"> cptK</span><span class="id"> R]</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> D</span><span class="id"> [[E</span><span class="id"> oE</span><span class="id"> &lt;-]</span><span class="id"> Ekf]</span><span class="id"> /filterS;</span><span class="id"> apply</span>.<br/>
<span class="id">move:</span><span class="id"> oE;</span><span class="id"> rewrite</span><span class="id"> openE</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> Ekf</span>)<span class="id">;</span><span class="id"> case</span><span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> [J</span><span class="id"> entJ]</span><span class="id"> EKR</span><span class="id"> KfE</span>.<br/>
<span class="id">near=&gt;</span><span class="id"> z;</span><span class="id"> apply/KfE/xsectionP/EKR</span><span class="id"> =&gt;</span><span class="id"> -[u</span><span class="id"> Kp];</span><span class="id"> rewrite</span><span class="id"> /sigL_arrow</span><span class="id"> /=</span><span class="id"> /set_val</span><span class="id"> /=</span><span class="id"> /eqincl</span>.<br/>
(<span class="id">have</span><span class="id"> Ku</span><span class="id"> :</span><span class="id"> K</span><span class="id"> u</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="gallina-kwd"> in</span><span class="id"> Kp</span>)<span class="id">;</span><span class="id"> move:</span><span class="id"> u</span><span class="id"> Ku</span><span class="id"> {D</span><span class="id"> Kp};</span><span class="id"> near:</span><span class="id"> z</span>.<br/>
<span class="id">move/compact_near_coveringP/near_covering_withinP</span><span class="id"> :</span> (<span class="id">cptK</span>)<span class="id">;</span><span class="id"> apply</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> u</span><span class="id"> Ku;</span><span class="id"> near</span> (<span class="id">powerset_filter_from</span> (<span class="id">@entourage</span><span class="id"> V</span>))<span class="id"> =&gt;</span><span class="id"> E'</span>.<br/>
<span class="id">have</span><span class="id"> entE'</span><span class="id"> :</span><span class="id"> entourage</span><span class="id"> E'</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span> (<span class="id">near</span> (<span class="id">near_small_set</span><span class="id"> _</span>)).<br/>
<span class="id">pose</span><span class="id"> C</span><span class="id"> :=</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> xsection</span><span class="id"> E'</span> (<span class="id">f</span><span class="id"> u</span>).<br/>
<span class="id">pose</span><span class="id"> B</span><span class="id"> :=</span><span class="id"> \bigcup_</span>(<span class="id">z</span><span class="gallina-kwd"> in</span><span class="id"> K</span><span class="id"> `&amp;`</span><span class="id"> closure</span><span class="id"> C</span>)<span class="id"> interior</span> (<span class="id">xsection</span><span class="id"> E'</span> (<span class="id">f</span><span class="id"> z</span>)).<br/>
<span class="id">have</span><span class="id"> oB</span><span class="id"> :</span><span class="id"> open</span><span class="id"> B</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> bigcup_open</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> open_interior</span>.<br/>
<span class="id">have</span><span class="id"> fKB</span><span class="id"> :</span><span class="id"> f</span><span class="id"> @`</span> (<span class="id">K</span><span class="id"> `&amp;`</span><span class="id"> closure</span><span class="id"> C</span>)<span class="id"> `&lt;=`</span><span class="id"> B</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> [z</span><span class="id"> KCz</span><span class="id"> &lt;-];</span><span class="gallina-kwd"> exists</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> /interior</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -nbhs_entourageE;</span><span class="gallina-kwd"> exists</span><span class="id"> E'</span>.<br/>
<span class="id">have</span><span class="id"> cptKC</span><span class="id"> :</span><span class="id"> compact</span> (<span class="id">K</span><span class="id"> `&amp;`</span><span class="id"> closure</span><span class="id"> C</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> compact_closedI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> closed_closure</span>.<br/>
<span class="id">have</span><span class="id"> :=</span><span class="id"> cptOF</span> (<span class="id">K</span><span class="id"> `&amp;`</span><span class="id"> closure</span><span class="id"> C</span>)<span class="id"> B</span><span class="id"> cptKC</span><span class="id"> oB</span><span class="id"> fKB</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">C,</span><span class="id"> [set</span><span class="id"> g</span><span class="id"> |</span><span class="id"> [set</span><span class="id"> g</span><span class="id"> x</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> K</span><span class="id"> `&amp;`</span><span class="id"> closure</span><span class="id"> C]</span><span class="id"> `&lt;=`</span><span class="id"> B]</span>).<br/>
&nbsp;&nbsp;<span class="id">split;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> cptOF</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">ctsf</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> /filter_of</span><span class="id"> -nbhs_entourageE;</span><span class="gallina-kwd"> exists</span><span class="id"> E'</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> z</span><span class="id"> h</span><span class="id"> /=</span><span class="id"> [Cz</span><span class="id"> KB</span><span class="id"> Kz]</span>.<br/>
<span class="id">case:</span> (<span class="id">KB</span> (<span class="id">h</span><span class="id"> z</span>))<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> z;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> subset_closure</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> w</span><span class="id"> [Kw</span><span class="id"> Cw</span><span class="id"> /interior_subset</span><span class="id"> Jfwhz];</span><span class="id"> apply:</span><span class="id"> subset_split_ent</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">f</span><span class="id"> w</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">near</span> (<span class="id">small_ent_sub</span><span class="id"> _</span>)<span class="id"> E'</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact/xsectionP</span>.<br/>
<span class="id">apply:</span><span class="id"> subset_split_ent</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span> (<span class="id">f</span><span class="id"> u</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/entourage_sym;</span><span class="id"> apply:</span> (<span class="id">near</span> (<span class="id">small_ent_sub</span><span class="id"> _</span>)<span class="id"> E'</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact/xsectionP</span>.<br/>
<span class="id">have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> Cw</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> xsection</span><span class="id"> E'</span> (<span class="id">f</span><span class="id"> w</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> ctsf;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> -nbhs_entourageE;</span><span class="gallina-kwd"> exists</span><span class="id"> E'</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> r</span><span class="id"> [Cr</span><span class="id"> /=</span><span class="id"> Ewr];</span><span class="id"> apply:</span><span class="id"> subset_split_ent</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span> (<span class="id">f</span><span class="id"> r</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">near</span> (<span class="id">small_ent_sub</span><span class="id"> _</span>)<span class="id"> E'</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact/xsectionP</span>.<br/>
<span class="id">apply/entourage_sym;</span><span class="id"> apply:</span> (<span class="id">near</span> (<span class="id">small_ent_sub</span><span class="id"> _</span>)<span class="id"> E'</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">exact/xsectionP</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> compact_open_uniform</span>.<br/>
<br/>
<span class="vernacular">Module</span><span class="id"> ArrowAsCompactOpen</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> topologicalType</span>) (<span class="id">V</span><span class="id"> :</span><span class="id"> topologicalType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Topological</span>.<span class="id">copy</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> {compact-open,</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V}</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> topologicalType</span>) (<span class="id">V</span><span class="id"> :</span><span class="id"> topologicalType</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Topological</span>.<span class="id">copy</span> (<span class="id">continuousType</span><span class="id"> U</span><span class="id"> V</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">weak_topology</span> (<span class="id">id</span><span class="id"> :</span> (<span class="id">continuousType</span><span class="id"> U</span><span class="id"> V</span>)<span class="id"> -&gt;</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>)) ).<br/>
<span class="vernacular">End</span><span class="id"> ArrowAsCompactOpen</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> compactly_in</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> topologicalType}</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[set</span><span class="id"> B</span><span class="id"> |</span><span class="id"> B</span><span class="id"> `&lt;=`</span><span class="id"> A</span><span class="id"> /\</span><span class="id"> compact</span><span class="id"> B]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> compact_cvg_within_compact</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> topologicalType}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> uniformType}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">C</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>)) (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> compact</span><span class="id"> C</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{uniform</span><span class="id"> C,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> &lt;-&gt;</span><span class="id"> {family</span><span class="id"> compactly_in</span><span class="id"> C,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF</span><span class="id"> CC</span>.<br/>
<span class="id">apply:</span> (<span class="id">iff_trans</span><span class="id"> _</span> (<span class="id">iff_sym</span> (<span class="id">fam_cvgP</span><span class="id"> _</span><span class="id"> _</span><span class="id"> FF</span>)))<span class="id">;</span><span class="id"> split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> CFf</span><span class="id"> D</span><span class="id"> [/uniform_subset_cvg</span><span class="id"> +</span><span class="id"> _];</span><span class="id"> apply</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply;</span><span class="id"> split</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> UniformContinuousLimits</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniform_limit_continuous</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> topologicalType}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> uniformType}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>)) (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span><span class="id"> F</span><span class="id"> -&gt;</span> (<span class="id">\forall</span><span class="id"> g</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> continuous</span> (<span class="id">g</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{uniform,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> continuous</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> PF</span><span class="id"> ctsF</span><span class="id"> Ff</span><span class="id"> x;</span><span class="id"> apply/cvg_app_entourageP</span><span class="id"> =&gt;</span><span class="id"> A</span><span class="id"> entA;</span><span class="id"> near</span><span class="id"> F</span><span class="id"> =&gt;</span><span class="id"> g;</span><span class="id"> near=&gt;</span><span class="id"> y</span>.<br/>
<span class="id">apply:</span> (<span class="id">entourage_split</span> (<span class="id">g</span><span class="id"> x</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> near:</span><span class="id"> g;</span><span class="id"> apply/Ff/uniform_nbhs;</span><span class="gallina-kwd"> exists</span> (<span class="id">split_ent</span><span class="id"> A</span>)<span class="id">;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?;</span><span class="id"> exact</span>.<br/>
<span class="id">apply:</span> (<span class="id">entourage_split</span> (<span class="id">g</span><span class="id"> y</span>))<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> near:</span><span class="id"> y;</span><span class="id"> near:</span><span class="id"> g</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">filterS</span><span class="id"> _</span><span class="id"> ctsF</span>)<span class="id"> =&gt;</span><span class="id"> g</span><span class="id"> /</span>(_<span class="id"> x</span>)<span class="id"> /cvg_app_entourageP;</span><span class="id"> exact</span>.<br/>
<span class="id">apply/Ff/uniform_nbhs;</span><span class="gallina-kwd"> exists</span> (<span class="id">split_ent</span> (<span class="id">split_ent</span><span class="id"> A</span>))<span class="id">^-1%relation</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split;</span><span class="id"> [exact:</span><span class="id"> entourage_inv</span><span class="id"> |</span><span class="id"> move=&gt;</span><span class="id"> g</span><span class="id"> fg;</span><span class="id"> near_simpl;</span><span class="id"> near=&gt;</span><span class="id"> z;</span><span class="id"> exact:</span><span class="id"> fg]</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniform_limit_continuous_subspace</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> topologicalType}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> puniformType}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">K</span><span class="id"> :</span><span class="id"> set</span><span class="id"> U</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span> (<span class="id">U</span><span class="id"> -&gt;</span><span class="id"> V</span>)) (<span class="id">f</span><span class="id"> :</span><span class="id"> subspace</span><span class="id"> K</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span><span class="id"> F</span><span class="id"> -&gt;</span> (<span class="id">\forall</span><span class="id"> g</span><span class="id"> \near</span><span class="id"> F,</span><span class="id"> continuous</span> (<span class="id">g</span><span class="id"> :</span><span class="id"> subspace</span><span class="id"> K</span><span class="id"> -&gt;</span><span class="id"> V</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{uniform</span><span class="id"> K,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> {within</span><span class="id"> K,</span><span class="id"> continuous</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> PF</span><span class="id"> ctsF</span><span class="id"> Ff;</span><span class="id"> apply:</span> (<span class="id">@subspace_eq_continuous</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">restrict</span><span class="id"> K</span><span class="id"> f</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /restrict</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> -&gt;</span>.<br/>
<span class="id">apply:</span> (<span class="id">@uniform_limit_continuous</span> (<span class="id">subspace</span><span class="id"> K</span>)<span class="id"> _</span> (<span class="id">restrict</span><span class="id"> K</span><span class="id"> @</span><span class="id"> F</span>)<span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">filterS</span><span class="id"> _</span><span class="id"> ctsF</span>)<span class="id"> =&gt;</span><span class="id"> g;</span><span class="id"> apply:</span><span class="id"> subspace_eq_continuous</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /restrict</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply</span> (<span class="id">@uniform_restrict_cvg</span><span class="id"> _</span><span class="id"> _</span><span class="id"> F</span> )<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> PF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> UniformContinuousLimits</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> UniformPointwise</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {U</span><span class="id"> :</span><span class="id"> topologicalType}</span><span class="id"> {V</span><span class="id"> :</span><span class="id"> uniformType}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> singletons</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> [set</span><span class="id"> x]</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> [set:</span><span class="id"> T]]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pointwise_cvg_family_singleton</span><span class="id"> F</span> (<span class="id">f:</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> {ptws,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> =</span><span class="id"> {family</span><span class="id"> @singletons</span><span class="id"> U,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FF;</span><span class="id"> apply/propext</span>.<br/>
<span class="id">rewrite</span> (<span class="id">@fam_cvgP</span><span class="id"> _</span><span class="id"> _</span><span class="id"> singletons</span>). <span class="comment">(*&nbsp;BUG:&nbsp;slowdown&nbsp;if&nbsp;no&nbsp;arguments&nbsp;*)</span><br/>
<span class="id">rewrite</span><span class="id"> cvg_sup;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> +</span><span class="id"> A</span><span class="id"> [x</span><span class="id"> _</span><span class="id"> &lt;-]</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> x</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> uniform_set1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> cvg_image;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split=&gt;</span><span class="id"> v</span><span class="id"> //</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span> (<span class="id">cst</span><span class="id"> v</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> cvg_trans</span><span class="id"> =&gt;</span><span class="id"> W</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> ?nbhs_simpl</span><span class="id"> /fmap</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> [[W'</span><span class="id"> +</span><span class="id"> &lt;-]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> =&gt;</span><span class="id"> g</span><span class="id"> W'g</span><span class="id"> /=;</span><span class="gallina-kwd"> exists</span><span class="id"> g</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> +</span><span class="id"> i;</span><span class="id"> have</span><span class="id"> /[swap]</span><span class="id"> /[apply]</span><span class="id"> :</span><span class="id"> singletons</span><span class="id"> [set</span><span class="id"> i]</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<br/>
<span class="id">rewrite</span><span class="id"> uniform_set1</span>.<br/>
<span class="id">rewrite</span><span class="id"> cvg_image;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split=&gt;</span><span class="id"> v</span><span class="id"> //</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span> (<span class="id">cst</span><span class="id"> v</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> +</span><span class="id"> W</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> ?nbhs_simpl</span><span class="id"> =&gt;</span><span class="id"> Q</span><span class="id"> =&gt;</span><span class="id"> /Q</span><span class="id"> Q';</span><span class="gallina-kwd"> exists</span> (<span class="id">@^~</span><span class="id"> i</span><span class="id"> @^-1`</span><span class="id"> W</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqEsubset;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [j</span><span class="id"> [?</span><span class="id"> +</span><span class="id"> &lt;-//]|j</span><span class="id"> Wj];</span><span class="gallina-kwd"> exists</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> j</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pointwise_cvg_compact_family</span><span class="id"> F</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> {ptws,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> PF;</span><span class="id"> rewrite</span><span class="id"> pointwise_cvg_family_singleton;</span><span class="id"> apply:</span><span class="id"> family_cvg_subset</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> A</span><span class="id"> [x</span><span class="id"> _</span><span class="id"> &lt;-];</span><span class="id"> exact:</span><span class="id"> compact_set1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pointwise_cvgP</span><span class="id"> F</span> (<span class="id">f:</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>)<span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">Filter</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> {ptws,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> forall</span> (<span class="id">t</span><span class="id"> :</span><span class="id"> U</span>)<span class="id">,</span> (<span class="gallina-kwd">fun</span><span class="id"> g</span><span class="id"> =&gt;</span><span class="id"> g</span><span class="id"> t</span>)<span class="id"> @</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f</span><span class="id"> t</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Ff;</span><span class="id"> rewrite</span><span class="id"> pointwise_cvg_family_singleton;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">move/fam_cvgP</span><span class="id"> =&gt;</span><span class="id"> +</span><span class="id"> t</span><span class="id"> A</span><span class="id"> At</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> [set</span><span class="id"> t]</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> uniform_set1;</span><span class="id"> apply</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> t</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> pf;</span><span class="id"> apply/fam_cvgP</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> [t</span><span class="id"> _</span><span class="id"> &lt;-];</span><span class="id"> rewrite</span><span class="id"> uniform_set1;</span><span class="id"> exact:</span><span class="id"> pf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> UniformPointwise</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ArzelaAscoli</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {X</span><span class="id"> :</span><span class="id"> topologicalType}</span><span class="id"> {Y</span><span class="id"> :</span><span class="id"> puniformType}</span><span class="id"> {hsdf</span><span class="id"> :</span><span class="id"> hausdorff_space</span><span class="id"> Y}</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">I</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>).<br/>
<br/>
<div class="doc">The key condition in Arzela-Ascoli that, like uniform continuity, moves a
    quantifier around so all functions have the same "deltas": </div>
<span class="vernacular">Definition</span><span class="id"> equicontinuous</span><span class="id"> {I}</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">d</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span> (<span class="id">X</span><span class="id"> -&gt;</span><span class="id"> Y</span>))<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> x</span> (<span class="id">E</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">Y</span><span class="id"> *</span><span class="id"> Y</span>))<span class="id">,</span><span class="id"> entourage</span><span class="id"> E</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\forall</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> x,</span><span class="gallina-kwd"> forall</span><span class="id"> i,</span><span class="id"> W</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> E</span> (<span class="id">d</span><span class="id"> i</span><span class="id"> x,</span><span class="id"> d</span><span class="id"> i</span><span class="id"> y</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> equicontinuous_subset</span><span class="id"> {I</span><span class="id"> J}</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">V</span><span class="id"> :</span><span class="id"> set</span><span class="id"> J</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{fW</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span><span class="id"> {fV</span><span class="id"> :</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">fW</span><span class="id"> @`W</span><span class="id"> `&lt;=`</span><span class="id"> fV</span><span class="id"> @`</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> equicontinuous</span><span class="id"> V</span><span class="id"> fV</span><span class="id"> -&gt;</span><span class="id"> equicontinuous</span><span class="id"> W</span><span class="id"> fW</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> WsubV</span><span class="id"> +</span><span class="id"> x</span><span class="id"> E</span><span class="id"> entE</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> x</span><span class="id"> E</span><span class="id"> entE</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> VE</span><span class="id"> i</span><span class="id"> Wi</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">WsubV</span> (<span class="id">fW</span><span class="id"> i</span>))<span class="id">;</span><span class="id"> [exists</span><span class="id"> i</span><span class="id"> |</span><span class="id"> move=&gt;</span><span class="id"> j</span><span class="id"> Vj</span><span class="id"> &lt;-;</span><span class="id"> exact:</span><span class="id"> VE]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> equicontinuous_subset_id</span> (<span class="id">W</span><span class="id"> V</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">X</span><span class="id"> -&gt;</span><span class="id"> Y</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">W</span><span class="id"> `&lt;=`</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> equicontinuous</span><span class="id"> V</span><span class="id"> id</span><span class="id"> -&gt;</span><span class="id"> equicontinuous</span><span class="id"> W</span><span class="id"> id</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> WsubV;</span><span class="id"> apply:</span><span class="id"> equicontinuous_subset</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> [y</span><span class="id"> ?</span><span class="id"> &lt;-</span><span class="id"> /=];</span><span class="gallina-kwd"> exists</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">exact:</span><span class="id"> WsubV</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> equicontinuous_continuous_for</span><span class="id"> {I}</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">fW</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y</span>)<span class="id"> i</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{for</span><span class="id"> x,</span><span class="id"> equicontinuous</span><span class="id"> W</span><span class="id"> fW}</span><span class="id"> -&gt;</span><span class="id"> W</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> {for</span><span class="id"> x,</span><span class="id"> continuous</span> (<span class="id">fW</span><span class="id"> i</span>)<span class="id">}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ectsW</span><span class="id"> Wf;</span><span class="id"> apply/cvg_entourageP</span><span class="id"> =&gt;</span><span class="id"> E</span><span class="id"> entE;</span><span class="id"> near_simpl</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> near=&gt;</span><span class="id"> y;</span><span class="id"> apply:</span> (<span class="id">near</span> (<span class="id">ectsW</span><span class="id"> _</span><span class="id"> entE</span>)<span class="id"> y</span>).<br/>
<span class="id">Unshelve</span>.<span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> equicontinuous_continuous</span><span class="id"> {I}</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">fW</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span> (<span class="id">X</span><span class="id"> -&gt;</span><span class="id"> Y</span>)) (<span class="id">i</span><span class="id"> :</span><span class="id"> I</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span><span class="id"> W</span><span class="id"> fW</span><span class="id"> -&gt;</span><span class="id"> W</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> continuous</span> (<span class="id">fW</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ectsW</span><span class="id"> Wf</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> equicontinuous_continuous_for;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> Wf</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> ectsW</span>.<br/>
Qed.</div></details>
<br/>
<div class="doc md"> A convenient notion that is in between compactness in
   `{family compact, X -&gt; y}` and compactness in `{ptws X -&gt; y}`:</div>
<span class="vernacular">Definition</span><span class="id"> pointwise_precompact</span><span class="id"> {I}</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">d</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> precompact</span><span class="id"> [set</span><span class="id"> d</span><span class="id"> i</span><span class="id"> x</span><span class="id"> |</span><span class="id"> i</span><span class="gallina-kwd"> in</span><span class="id"> W]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pointwise_precompact_subset</span><span class="id"> {I</span><span class="id"> J}</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">V</span><span class="id"> :</span><span class="id"> set</span><span class="id"> J</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{fW</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span><span class="id"> {fV</span><span class="id"> :</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">fW</span><span class="id"> @`</span><span class="id"> W</span><span class="id"> `&lt;=`</span><span class="id"> fV</span><span class="id"> @`</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> pointwise_precompact</span><span class="id"> V</span><span class="id"> fV</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">pointwise_precompact</span><span class="id"> W</span><span class="id"> fW</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> WsubV</span><span class="id"> +</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> x</span>)<span class="id"> pcptV;</span><span class="id"> apply:</span><span class="id"> precompact_subset</span><span class="id"> pcptV</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> [i</span><span class="id"> Wi</span><span class="id"> &lt;-]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">WsubV</span> (<span class="id">fW</span><span class="id"> i</span>))<span class="id">;</span><span class="id"> [exists</span><span class="id"> i</span><span class="id"> |</span><span class="id"> move=&gt;</span><span class="id"> j</span><span class="id"> Vj</span><span class="id"> &lt;-;</span><span class="gallina-kwd"> exists</span><span class="id"> j]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pointwise_precompact_precompact</span><span class="id"> {I}</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> I</span>) (<span class="id">fW</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span> (<span class="id">X</span><span class="id"> -&gt;</span><span class="id"> Y</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">pointwise_precompact</span><span class="id"> W</span><span class="id"> fW</span><span class="id"> -&gt;</span><span class="id"> precompact</span> ((<span class="id">fW</span><span class="id"> @`</span><span class="id"> W</span>)<span class="id"> :</span><span class="id"> set</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> precompactE</span><span class="id"> =&gt;</span><span class="id"> ptwsPreW</span>.<br/>
<span class="id">pose</span><span class="id"> K</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> closure</span><span class="id"> [set</span><span class="id"> fW</span><span class="id"> i</span><span class="id"> x</span><span class="id"> |</span><span class="id"> i</span><span class="gallina-kwd"> in</span><span class="id"> W]</span>.<br/>
<span class="id">set</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> f</span><span class="id"> :</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> X,</span><span class="id"> K</span><span class="id"> x</span> (<span class="id">f</span><span class="id"> x</span>)<span class="id">]</span>.<br/>
<span class="id">have</span><span class="id"> C</span><span class="id"> :</span><span class="id"> compact</span><span class="id"> R</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> tychonoff</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -precompactE;</span><span class="id"> move:</span><span class="id"> ptwsPreW;</span><span class="id"> exact</span>.<br/>
<span class="id">apply:</span> (<span class="id">subclosed_compact</span><span class="id"> _</span><span class="id"> C</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> closed_closure</span>.<br/>
<span class="id">have</span><span class="id"> WsubR</span><span class="id"> :</span> (<span class="id">fW</span><span class="id"> @`</span><span class="id"> W</span>)<span class="id"> `&lt;=`</span><span class="id"> R</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> f</span><span class="id"> Wf</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /R</span><span class="id"> /K</span><span class="id"> closure_limit_point;</span><span class="id"> left</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> Wf</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> ?</span><span class="id"> &lt;-;</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<br/>
<span class="id">rewrite</span><span class="id"> closureE;</span><span class="id"> apply:</span><span class="id"> smallest_sub</span> (<span class="id">compact_closed</span><span class="id"> _</span><span class="id"> C</span>)<span class="id"> WsubR</span>.<br/>
<span class="id">exact:</span><span class="id"> hausdorff_product</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniform_pointwise_compact</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">X</span><span class="id"> -&gt;</span><span class="id"> Y</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">compact</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">@uniform_fun_family</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> compact</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">compact</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> [x</span><span class="gallina-kwd"> in</span><span class="id"> x</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> _]compact_ultra</span><span class="id"> [x</span><span class="gallina-kwd"> in</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> _]compact_ultra</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> +</span><span class="id"> F</span><span class="id"> UF</span><span class="id"> FW</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> F</span><span class="id"> UF</span><span class="id"> FW</span>)<span class="id"> [h</span><span class="id"> [Wh</span><span class="id"> Fh]];</span><span class="gallina-kwd"> exists</span><span class="id"> h;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Q</span><span class="id"> Fq;</span><span class="id"> apply:</span> (<span class="id">pointwise_cvg_compact_family</span><span class="id"> _</span><span class="id"> Fh</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> precompact_pointwise_precompact</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">precompact</span><span class="id"> W</span><span class="id"> -&gt;</span><span class="id"> pointwise_precompact</span><span class="id"> W</span><span class="id"> id</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> +</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> ?precompactE</span><span class="id"> =&gt;</span><span class="id"> pcptW</span>.<br/>
<span class="id">have</span><span class="id"> :</span><span class="id"> compact</span> (<span class="id">proj</span><span class="id"> x</span><span class="id"> @`</span> (<span class="id">closure</span><span class="id"> W</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> continuous_compact</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> continuous_subspaceT=&gt;</span><span class="id"> g</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> E</span><span class="id"> nbhsE;</span><span class="id"> have</span><span class="id"> :=</span> (<span class="id">@proj_continuous</span><span class="id"> _</span><span class="id"> _</span><span class="id"> x</span><span class="id"> g</span><span class="id"> E</span><span class="id"> nbhsE</span>).<br/>
&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">@pointwise_cvg_compact_family</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">nbhs</span><span class="id"> g</span>)).<br/>
<span class="id">move=&gt;</span><span class="id"> /[dup]/</span>(<span class="id">compact_closed</span><span class="id"> hsdf</span>)<span class="id">/closure_id</span><span class="id"> -&gt;</span><span class="id"> /subclosed_compact</span>.<br/>
<span class="id">apply;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> closed_closure</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/closure_subset/image_subset;</span><span class="id"> exact:</span> (<span class="id">@subset_closure</span><span class="id"> _</span><span class="id"> W</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pointwise_cvg_entourage</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> X</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>)<span class="id"> E</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">entourage</span><span class="id"> E</span><span class="id"> -&gt;</span><span class="id"> \forall</span><span class="id"> g</span><span class="id"> \near</span><span class="id"> f,</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> x,</span><span class="id"> g</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> entE;</span><span class="id"> have</span><span class="id"> :</span> (<span class="id">{ptws,</span><span class="id"> nbhs</span><span class="id"> f</span><span class="id"> --&gt;</span><span class="id"> f}</span>)<span class="gallina-kwd"> by</span><span class="id"> []</span>.<br/>
<span class="id">have</span><span class="id"> ?</span><span class="id"> :</span><span class="id"> Filter</span> (<span class="id">nbhs</span><span class="id"> f</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> nbhs_pfilter</span>. <span class="comment">(*&nbsp;NB:&nbsp;This&nbsp;Filter&nbsp;(nbhs&nbsp;f)&nbsp;used&nbsp;to&nbsp;infer&nbsp;correctly.&nbsp;*)</span><br/>
<span class="id">rewrite</span><span class="id"> pointwise_cvg_family_singleton</span><span class="id"> =&gt;</span><span class="id"> /fam_cvgP</span><span class="id"> /</span>(_<span class="id"> [set</span><span class="id"> x]</span>).<br/>
<span class="id">rewrite</span><span class="id"> uniform_set1</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> [set</span><span class="id"> y</span><span class="id"> |</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> x,</span><span class="id"> y</span>)<span class="id">]</span>)<span class="id">;</span><span class="id"> apply;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> E</span><span class="id"> entE;</span><span class="id"> exact/cvg_entourageP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> equicontinuous_closure</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span><span class="id"> W</span><span class="id"> id</span><span class="id"> -&gt;</span><span class="id"> equicontinuous</span> (<span class="id">closure</span><span class="id"> W</span>)<span class="id"> id</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ectsW</span><span class="id"> x</span><span class="id"> E</span><span class="id"> entE;</span><span class="id"> near=&gt;</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> clWf</span>.<br/>
<span class="id">have</span><span class="id"> ?</span><span class="id"> :</span><span class="id"> ProperFilter</span> (<span class="id">within</span><span class="id"> W</span> (<span class="id">nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>))).<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> within_nbhs_proper</span>. <span class="comment">(*&nbsp;TODO:&nbsp;This&nbsp;ProperFilter&nbsp;_&nbsp;also&nbsp;used&nbsp;to&nbsp;infer&nbsp;correctly.&nbsp;*)</span><br/>
<span class="id">near</span> (<span class="id">within</span><span class="id"> W</span> (<span class="id">nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>)))<span class="id"> =&gt;</span><span class="id"> g</span>.<br/>
<span class="id">near:</span><span class="id"> g;</span><span class="id"> rewrite</span><span class="id"> near_withinE;</span><span class="id"> near_simpl;</span><span class="id"> near=&gt;</span><span class="id"> g</span><span class="id"> =&gt;</span><span class="id"> Wg</span>.<br/>
<span class="id">apply:</span> (<span class="id">@entourage_split</span><span class="id"> _</span> (<span class="id">g</span><span class="id"> x</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">near</span> (<span class="id">pointwise_cvg_entourage</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
<span class="id">apply:</span> (<span class="id">@entourage_split</span><span class="id"> _</span> (<span class="id">g</span><span class="id"> y</span>))<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> exact:</span> (<span class="id">near</span> (<span class="id">@ectsW</span><span class="id"> x</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/entourage_sym;</span><span class="id"> exact:</span> (<span class="id">near</span> (<span class="id">pointwise_cvg_entourage</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> small_ent_sub</span><span class="id"> :=</span><span class="id"> @small_set_sub</span><span class="id"> _</span> (<span class="id">@entourage</span><span class="id"> Y</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pointwise_compact_cvg</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> set_system</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">ProperFilter</span><span class="id"> F</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">\forall</span><span class="id"> W</span><span class="id"> \near</span><span class="id"> powerset_filter_from</span><span class="id"> F,</span><span class="id"> equicontinuous</span><span class="id"> W</span><span class="id"> id</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{ptws,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span><span class="id"> &lt;-&gt;</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> F</span><span class="id"> --&gt;</span><span class="id"> f}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> PF</span><span class="id"> /near_powerset_filter_fromP;</span><span class="id"> case</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> equicontinuous_subset_id</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> W;</span><span class="id"> wlog</span><span class="id"> Wf</span><span class="id"> :</span><span class="id"> f</span><span class="id"> W</span><span class="id"> /</span><span class="id"> W</span><span class="id"> f</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> +</span><span class="id"> FW</span><span class="id"> /equicontinuous_closure</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> f</span> (<span class="id">closure</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>)))<span class="id"> Q</span>.<br/>
&nbsp;&nbsp;<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> Ff;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> pointwise_cvg_compact_family</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/Q</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> closureEcvg;</span><span class="gallina-kwd"> exists</span><span class="id"> F;</span><span class="id"> [|split]</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> ?</span><span class="id"> /=</span><span class="id"> /filterS;</span><span class="id"> apply</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">filterS</span><span class="id"> _</span><span class="id"> FW</span>)<span class="id"> =&gt;</span><span class="id"> z</span><span class="id"> Wz;</span><span class="id"> apply:</span><span class="id"> subset_closure</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> FW</span><span class="id"> ectsW;</span><span class="id"> split=&gt;</span><span class="id"> [ptwsF|];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> pointwise_cvg_compact_family</span>.<br/>
<span class="id">apply/fam_cvgP</span><span class="id"> =&gt;</span><span class="id"> K</span><span class="id"> ?</span><span class="id"> U</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> uniform_nbhs</span><span class="id"> =&gt;</span><span class="id"> [[E</span><span class="id"> [eE</span><span class="id"> EsubU]]]</span>.<br/>
<span class="id">suff</span><span class="id"> :</span><span class="id"> \forall</span><span class="id"> g</span><span class="id"> \near</span><span class="id"> within</span><span class="id"> W</span> (<span class="id">nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>))<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> y,</span><span class="id"> K</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> E</span> (<span class="id">f</span><span class="id"> y,</span><span class="id"> g</span><span class="id"> y</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> near_withinE;</span><span class="id"> near_simpl</span><span class="id"> =&gt;</span><span class="id"> N;</span><span class="id"> apply:</span> (<span class="id">filter_app</span><span class="id"> _</span><span class="id"> _</span><span class="id"> FW</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> ptwsF;</span><span class="id"> near=&gt;</span><span class="id"> g</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> apply:</span><span class="id"> EsubU;</span><span class="id"> apply:</span> (<span class="id">near</span><span class="id"> N</span><span class="id"> g</span>).<br/>
<span class="id">near</span> (<span class="id">powerset_filter_from</span> (<span class="id">@entourage</span><span class="id"> Y</span>))<span class="id"> =&gt;</span><span class="id"> E'</span>.<br/>
<span class="id">have</span><span class="id"> entE'</span><span class="id"> :</span><span class="id"> entourage</span><span class="id"> E'</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span> (<span class="id">near</span> (<span class="id">near_small_set</span><span class="id"> _</span>)).<br/>
<span class="id">pose</span><span class="id"> Q</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span> (<span class="id">h</span><span class="id"> :</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y</span>)<span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> E'</span> (<span class="id">f</span><span class="id"> x,</span><span class="id"> h</span><span class="id"> x</span>).<br/>
<span class="id">apply:</span> (<span class="id">iffLR</span> (<span class="id">compact_near_coveringP</span><span class="id"> K</span>))<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> Kx</span>.<br/>
<span class="id">near=&gt;</span><span class="id"> y</span><span class="id"> g</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="id">apply:</span> (<span class="id">entourage_split</span> (<span class="id">f</span><span class="id"> x</span>)<span class="id"> eE</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span><span class="id"> entourage_sym;</span><span class="id"> apply:</span> (<span class="id">near</span> (<span class="id">small_ent_sub</span><span class="id"> _</span>)<span class="id"> E'</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">near</span> (<span class="id">ectsW</span><span class="id"> x</span><span class="id"> E'</span><span class="id"> entE'</span>)<span class="id"> y</span>).<br/>
<span class="id">apply:</span> (<span class="id">@entourage_split</span><span class="id"> _</span> (<span class="id">g</span><span class="id"> x</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">near</span> (<span class="id">small_ent_sub</span><span class="id"> _</span>)<span class="id"> E'</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">near:</span><span class="id"> g;</span><span class="id"> near_simpl;</span><span class="id"> apply:</span> (<span class="id">@cvg_within</span><span class="id"> _</span> (<span class="id">nbhs</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>))).<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> pointwise_cvg_entourage</span>.<br/>
<span class="id">apply:</span> (<span class="id">near</span> (<span class="id">small_ent_sub</span><span class="id"> _</span>)<span class="id"> E'</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">apply:</span> (<span class="id">near</span> (<span class="id">ectsW</span><span class="id"> x</span><span class="id"> E'</span><span class="id"> entE'</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">exact:</span> (<span class="id">near</span> (<span class="id">withinT</span><span class="id"> _</span> (<span class="id">nbhs_filter</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>)))).<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pointwise_compact_closure</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">X</span><span class="id"> -&gt;</span><span class="id"> Y</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span><span class="id"> W</span><span class="id"> id</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">closure</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">closure</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> ?closureEcvg</span><span class="id"> //</span><span class="id"> predeqE</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> ?</span>.<br/>
<span class="id">split;</span><span class="id"> move=&gt;</span><span class="id"> [F</span><span class="id"> PF</span><span class="id"> [Fx</span><span class="id"> WF]];</span> (<span class="gallina-kwd">exists</span><span class="id"> F;</span><span class="id"> last</span><span class="id"> split</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/@pointwise_compact_cvg</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply/near_powerset_filter_fromP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> equicontinuous_subset_id</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> W</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> WF</span>.<br/>
<span class="id">apply/@pointwise_compact_cvg</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply/near_powerset_filter_fromP</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> equicontinuous_subset_id</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> W</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> WF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pointwise_precompact_equicontinuous</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span> (<span class="id">X</span><span class="id"> -&gt;</span><span class="id"> Y</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">pointwise_precompact</span><span class="id"> W</span><span class="id"> id</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span><span class="id"> W</span><span class="id"> id</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">precompact</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y</span><span class="id"> }</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /pointwise_precompact_precompact</span><span class="id"> +</span><span class="id"> ectsW</span>.<br/>
<span class="id">rewrite</span><span class="id"> ?precompactE</span><span class="id"> compact_ultra</span><span class="id"> compact_ultra</span><span class="id"> pointwise_compact_closure</span><span class="id"> //</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /=</span><span class="id"> +</span><span class="id"> F</span><span class="id"> UF</span><span class="id"> FcW</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> F</span><span class="id"> UF</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> image_id</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> FcW</span>)<span class="id">[p</span><span class="id"> [cWp</span><span class="id"> Fp]]</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> p;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply/pointwise_compact_cvg</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">apply/near_powerset_filter_fromP;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> equicontinuous_subset_id</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">closure</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {ptws</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y</span><span class="id"> }</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">exact:</span><span class="id"> equicontinuous_closure</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> precompact_equicontinuous</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> lcptX</span><span class="id"> :</span><span class="id"> locally_compact</span><span class="id"> [set:</span><span class="id"> X]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> compact_equicontinuous</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> f,</span><span class="id"> W</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> continuous</span><span class="id"> f</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">compact</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span><span class="id"> W</span><span class="id"> id</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ctsW</span><span class="id"> cptW</span><span class="id"> x</span><span class="id"> E</span><span class="id"> entE</span>.<br/>
<span class="id">have</span><span class="id"> [//|U</span><span class="id"> UWx</span><span class="id"> [cptU</span><span class="id"> clU]]</span><span class="id"> :=</span><span class="id"> @lcptX</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> withinET</span><span class="gallina-kwd"> in</span><span class="id"> UWx</span>.<br/>
<span class="id">near</span> (<span class="id">powerset_filter_from</span> (<span class="id">@entourage</span><span class="id"> Y</span>))<span class="id"> =&gt;</span><span class="id"> E'</span>.<br/>
<span class="id">have</span><span class="id"> entE'</span><span class="id"> :</span><span class="id"> entourage</span><span class="id"> E'</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span> (<span class="id">near</span> (<span class="id">near_small_set</span><span class="id"> _</span>)).<br/>
<span class="id">pose</span><span class="id"> Q</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span> (<span class="id">y</span><span class="id"> :</span><span class="id"> X</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>)<span class="id"> =&gt;</span><span class="id"> E'</span> (<span class="id">f</span><span class="id"> x,</span><span class="id"> f</span><span class="id"> y</span>).<br/>
<span class="id">apply:</span> (<span class="id">iffLR</span> (<span class="id">compact_near_coveringP</span><span class="id"> W</span>))<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> f</span><span class="id"> Wf;</span><span class="id"> near=&gt;</span><span class="id"> g</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="id">apply:</span> (<span class="id">entourage_split</span> (<span class="id">f</span><span class="id"> x</span>)<span class="id"> entE</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/entourage_sym;</span><span class="id"> apply:</span> (<span class="id">near</span> (<span class="id">small_ent_sub</span><span class="id"> _</span>)<span class="id"> E'</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">near</span> (<span class="id">fam_nbhs</span><span class="id"> _</span><span class="id"> entE'</span> (<span class="id">@compact_set1</span><span class="id"> _</span><span class="id"> x</span>))<span class="id"> g</span>).<br/>
<span class="id">apply:</span> (<span class="id">entourage_split</span> (<span class="id">f</span><span class="id"> y</span>) (<span class="id">entourage_split_ent</span><span class="id"> entE</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">near</span> (<span class="id">small_ent_sub</span><span class="id"> _</span>)<span class="id"> E'</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/xsectionP;</span><span class="id"> near:</span><span class="id"> y;</span><span class="id"> apply:</span> (<span class="id">@ctsW</span><span class="id"> f</span><span class="id"> Wf</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> nbhs_entourage</span>.<br/>
<span class="id">apply:</span> (<span class="id">near</span> (<span class="id">small_ent_sub</span><span class="id"> _</span>)<span class="id"> E'</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">near</span> (<span class="id">fam_nbhs</span><span class="id"> _</span><span class="id"> entE'</span><span class="id"> cptU</span>)<span class="id"> g</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span> (<span class="id">near</span><span class="id"> UWx</span><span class="id"> y</span>).<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> precompact_equicontinuous</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> f,</span><span class="id"> W</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> continuous</span><span class="id"> f</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">precompact</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">equicontinuous</span><span class="id"> W</span><span class="id"> id</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> pcptW</span><span class="id"> ctsW;</span><span class="id"> apply:</span> (<span class="id">equicontinuous_subset_id</span> (<span class="id">@subset_closure</span><span class="id"> _</span><span class="id"> W</span>)).<br/>
<span class="id">apply:</span><span class="id"> compact_equicontinuous;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -precompactE</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> f;</span><span class="id"> rewrite</span><span class="id"> closureEcvg</span><span class="id"> =&gt;</span><span class="id"> [[G</span><span class="id"> PG</span><span class="id"> [Gf</span><span class="id"> GW]]]</span><span class="id"> x</span><span class="id"> B</span><span class="id"> /=</span>.<br/>
<span class="id">rewrite</span><span class="id"> -nbhs_entourageE</span><span class="id"> =&gt;</span><span class="id"> -[E</span><span class="id"> entE]</span><span class="id"> /filterS;</span><span class="id"> apply;</span><span class="id"> near_simpl</span>.<br/>
<span class="id">suff</span><span class="id"> ctsf</span><span class="id"> :</span><span class="id"> continuous</span><span class="id"> f</span>.<br/>
&nbsp;&nbsp;<span class="id">near=&gt;</span><span class="id"> x0;</span><span class="id"> apply/xsectionP;</span><span class="id"> near:</span><span class="id"> x0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> E</span><span class="id"> entE;</span><span class="id"> apply/cvg_app_entourageP;</span><span class="id"> exact:</span><span class="id"> ctsf</span>.<br/>
<span class="id">apply/continuous_localP</span><span class="id"> =&gt;</span><span class="id"> x';</span><span class="id"> apply/near_powerset_filter_fromP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> continuous_subspaceW</span>.<br/>
<span class="id">case:</span> (<span class="id">@lcptX</span><span class="id"> x'</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> U;</span><span class="id"> rewrite</span><span class="id"> withinET</span><span class="id"> =&gt;</span><span class="id"> nbhsU</span><span class="id"> [cptU</span><span class="id"> _]</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span> (<span class="id">uniform_limit_continuous_subspace</span><span class="id"> PG</span><span class="id"> _</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> near=&gt;</span><span class="id"> g;</span><span class="id"> apply:</span><span class="id"> continuous_subspaceT;</span><span class="id"> near:</span><span class="id"> g;</span><span class="id"> exact:</span><span class="id"> GW</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/fam_cvgP/</span>(_<span class="id"> _</span><span class="id"> cptU</span>)<span class="id"> :</span><span class="id"> Gf</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> precompact_equicontinuous</span>.<br/>
<br/>
<span class="vernacular">Theorem</span><span class="id"> Ascoli</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">locally_compact</span><span class="id"> [set:</span><span class="id"> X]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">pointwise_precompact</span><span class="id"> W</span><span class="id"> id</span><span class="id"> /\</span><span class="id"> equicontinuous</span><span class="id"> W</span><span class="id"> id</span><span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> f,</span><span class="id"> W</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> continuous</span><span class="id"> f</span>)<span class="id"> /\</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">precompact</span> (<span class="id">W</span><span class="id"> :</span><span class="id"> set</span><span class="id"> {family</span><span class="id"> compact,</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y}</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> lcpt;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> [[Wid</span><span class="id"> ectsW]|[fWf]pcptW]</span>.<br/>
&nbsp;&nbsp;<span class="id">split=&gt;</span><span class="id"> [?|];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> equicontinuous_continuous</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> pointwise_precompact_equicontinuous</span>.<br/>
<span class="id">split;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> precompact_equicontinuous</span>.<br/>
<span class="id">exact:</span><span class="id"> precompact_pointwise_precompact</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ArzelaAscoli</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> currying</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Import</span><span class="id"> ArrowAsCompactOpen</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> cartesian_closed</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {U</span><span class="id"> V</span><span class="id"> W</span><span class="id"> :</span><span class="id"> topologicalType}</span>.<br/>
<br/>
<div class="doc md"> In this section, we consider under what conditions \
       `[f in U ~&gt; V ~&gt; W | continuous f /\ forall u, continuous (f u)]` \
   and \
       `[f in U * V ~&gt; W | continuous f]` \
   are homeomorphic.
   - Always: \
         `curry` sends continuous functions to continuous functions.
   - `V` locally_compact + regular or Hausdorff: \
         `uncurry` sends continuous functions to continuous functions.
   - `U` regular or Hausdorff: \
         `curry` itself is a continuous map.
   - `U` regular or Hausdorff AND `V` locally_compact + regular or Hausdorff \
         `uncurry` itself is a continuous map. \
         Therefore `curry`/`uncurry` are homeomorphisms.

   So the category of locally compact regular spaces is cartesian closed.
</div>
<br/>
<span class="vernacular">Lemma</span><span class="id"> continuous_curry</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> *</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> W</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">continuous</span><span class="id"> f</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">continuous</span> (<span class="id">curry</span><span class="id"> f</span>)<span class="id"> /\</span><span class="gallina-kwd"> forall</span><span class="id"> u,</span><span class="id"> continuous</span> (<span class="id">curry</span><span class="id"> f</span><span class="id"> u</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ctsf;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> u</span><span class="id"> z;</span><span class="id"> apply:</span><span class="id"> continuous_comp;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> ctsf</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> cvg_pair</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> exact:</span><span class="id"> cvg_cst</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> apply/compact_open_cvgP</span><span class="id"> =&gt;</span><span class="id"> K</span><span class="id"> O</span><span class="id"> /=</span><span class="id"> cptK</span><span class="id"> oO</span><span class="id"> fKO</span>.<br/>
<span class="id">near=&gt;</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> w</span><span class="id"> /=</span><span class="id"> [+</span><span class="id"> +</span><span class="id"> &lt;-];</span><span class="id"> near:</span><span class="id"> z</span>.<br/>
<span class="id">move/compact_near_coveringP/near_covering_withinP</span><span class="id"> :</span><span class="id"> cptK;</span><span class="id"> apply</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> v</span><span class="id"> Kv;</span><span class="id"> have</span><span class="id"> [[P</span><span class="id"> Q]</span><span class="id"> [Px</span><span class="id"> Qv]</span><span class="id"> PQfO]</span><span class="id"> :</span><span class="id"> nbhs</span> (<span class="id">x,</span><span class="id"> v</span>) (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> O</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> ctsf;</span><span class="id"> move:</span><span class="id"> oO;</span><span class="id"> rewrite</span><span class="id"> openE;</span><span class="id"> apply;</span><span class="id"> apply:</span><span class="id"> fKO;</span><span class="gallina-kwd"> exists</span><span class="id"> v</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">Q,</span><span class="id"> P</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[b</span><span class="id"> a]</span><span class="id"> /=</span><span class="id"> [Qb</span><span class="id"> Pa]</span><span class="id"> Kb;</span><span class="id"> exact:</span><span class="id"> PQfO</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> continuous_curry_fun</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> *</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> W</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">continuous</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> continuous</span> (<span class="id">curry</span><span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case/continuous_curry</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> continuous_curry_cvg</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> *</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> W</span>) (<span class="id">u</span><span class="id"> :</span><span class="id"> U</span>) (<span class="id">v</span><span class="id"> :</span><span class="id"> V</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">continuous</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> curry</span><span class="id"> f</span><span class="id"> z</span>.<span class="id">1</span><span class="id"> z</span>.<span class="id">2</span><span class="id"> @[z</span><span class="id"> --&gt;</span> (<span class="id">u,</span><span class="id"> v</span>)<span class="id">]</span><span class="id"> --&gt;</span><span class="id"> curry</span><span class="id"> f</span><span class="id"> u</span><span class="id"> v</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> cf</span><span class="id"> D</span><span class="id"> /cf;</span><span class="id"> rewrite</span><span class="id"> !nbhs_simpl</span><span class="id"> /curry</span><span class="id"> /=;</span><span class="id"> apply:</span><span class="id"> filterS</span><span class="id"> =&gt;</span><span class="id"> z</span><span class="id"> ?</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -surjective_pairing</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> continuous_uncurry_regular</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> W</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">locally_compact</span><span class="id"> [set:</span><span class="id"> V]</span><span class="id"> -&gt;</span><span class="id"> @regular_space</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> continuous</span><span class="id"> f</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> u,</span><span class="id"> continuous</span> (<span class="id">f</span><span class="id"> u</span>))<span class="id"> -&gt;</span><span class="id"> continuous</span> (<span class="id">uncurry</span><span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> lcV</span><span class="id"> reg</span><span class="id"> cf</span><span class="id"> cfp</span><span class="id"> /=</span><span class="id"> [u</span><span class="id"> v]</span><span class="id"> D;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> nbhsE</span><span class="id"> =&gt;</span><span class="id"> -[O</span><span class="id"> [oO</span><span class="id"> Ofuv]]</span><span class="id"> /filterS</span>.<br/>
<span class="id">apply;</span><span class="id"> have</span><span class="id"> [B]</span><span class="id"> :=</span><span class="id"> @lcV</span><span class="id"> v</span><span class="id"> I;</span><span class="id"> rewrite</span><span class="id"> withinET</span><span class="id"> =&gt;</span><span class="id"> Bv</span><span class="id"> [cptB</span><span class="id"> clB]</span>.<br/>
<span class="id">have</span><span class="id"> [R</span><span class="id"> Rv</span><span class="id"> RO]</span><span class="id"> :</span><span class="gallina-kwd"> exists2</span><span class="id"> R,</span><span class="id"> nbhs</span><span class="id"> v</span><span class="id"> R</span><span class="id"> &amp;</span><span class="gallina-kwd"> forall</span><span class="id"> z,</span><span class="id"> closure</span><span class="id"> R</span><span class="id"> z</span><span class="id"> -&gt;</span><span class="id"> O</span> (<span class="id">f</span><span class="id"> u</span><span class="id"> z</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> reg</span><span class="id"> v</span> (<span class="id">f</span><span class="id"> u</span><span class="id"> @^-1`</span><span class="id"> O</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> cfp;</span><span class="id"> exact:</span><span class="id"> open_nbhs_nbhs</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> R</span><span class="id"> ?</span><span class="id"> ?;</span><span class="gallina-kwd"> exists</span><span class="id"> R</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> [set</span><span class="id"> g</span><span class="id"> |</span><span class="id"> g</span><span class="id"> @`</span> (<span class="id">B</span><span class="id"> `&amp;`</span><span class="id"> closure</span><span class="id"> R</span>)<span class="id"> `&lt;=`</span><span class="id"> O],</span><span class="id"> B</span><span class="id"> `&amp;`</span><span class="id"> closure</span><span class="id"> R</span>).<br/>
&nbsp;&nbsp;<span class="id">split;</span><span class="id"> [apply/cf/open_nbhs_nbhs;</span><span class="id"> split</span><span class="id"> |</span><span class="id"> apply:</span><span class="id"> filterI]</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> apply:</span><span class="id"> compact_open_open</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> compact_closedI</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> closed_closure</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> [x</span><span class="id"> [?</span><span class="id"> +</span><span class="id"> &lt;-]];</span><span class="id"> apply:</span><span class="id"> RO</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterS;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> subset_closure</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> a</span><span class="id"> r</span><span class="id"> /=</span><span class="id"> [fBMO</span><span class="id"> [Br]</span><span class="id"> cmR];</span><span class="id"> apply:</span><span class="id"> fBMO;</span><span class="gallina-kwd"> exists</span><span class="id"> r</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> continuous_uncurry</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> W</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">locally_compact</span><span class="id"> [set:</span><span class="id"> V]</span><span class="id"> -&gt;</span><span class="id"> hausdorff_space</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> continuous</span><span class="id"> f</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> u,</span><span class="id"> continuous</span> (<span class="id">f</span><span class="id"> u</span>))<span class="id"> -&gt;</span><span class="id"> continuous</span> (<span class="id">uncurry</span><span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> lcV</span><span class="id"> hsdf</span><span class="id"> ctsf</span><span class="id"> cf;</span><span class="id"> apply:</span><span class="id"> continuous_uncurry_regular</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> v;</span><span class="id"> have</span><span class="id"> [B]</span><span class="id"> :=</span><span class="id"> @lcV</span><span class="id"> v</span><span class="id"> I;</span><span class="id"> rewrite</span><span class="id"> withinET</span><span class="id"> =&gt;</span><span class="id"> Bv</span><span class="id"> [cptB</span><span class="id"> clB]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> z;</span><span class="id"> exact:</span> (<span class="id">compact_regular</span><span class="id"> _</span><span class="id"> cptB</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> curry_continuous</span> (<span class="id">f</span><span class="id"> :</span> (<span class="id">U</span><span class="id"> *</span><span class="id"> V</span>)<span class="id">%type</span><span class="id"> -&gt;</span><span class="id"> W</span>)<span class="id"> :</span><span class="id"> continuous</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> @regular_space</span><span class="id"> U</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{for</span><span class="id"> f,</span><span class="id"> continuous</span><span class="id"> curry}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ctsf</span><span class="id"> regU;</span><span class="id"> apply/compact_open_cvgP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> fmap_filter;</span><span class="id"> exact:</span><span class="id"> nbhs_filter</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> K</span><span class="id"> ?</span><span class="id"> cptK</span><span class="id"> [D</span><span class="id"> OfinIo</span><span class="id"> &lt;-]</span><span class="id"> fKD</span><span class="id"> /=;</span><span class="id"> near=&gt;</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> w</span><span class="id"> [+</span><span class="id"> +</span><span class="id"> &lt;-];</span><span class="id"> near:</span><span class="id"> z</span>.<br/>
<span class="id">move/compact_near_coveringP/near_covering_withinP</span><span class="id"> :</span> (<span class="id">cptK</span>)<span class="id">;</span><span class="id"> apply</span><span class="id"> =&gt;</span><span class="id"> u</span><span class="id"> Ku</span>.<br/>
<span class="id">have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> fKD</span> (<span class="id">curry</span><span class="id"> f</span><span class="id"> u</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> u</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> E</span><span class="id"> /[dup]</span><span class="id"> /[swap]</span><span class="id"> /OfinIo</span><span class="id"> [N</span><span class="id"> Asub</span><span class="id"> &lt;-</span><span class="id"> DIN</span><span class="id"> INf]</span>.<br/>
<span class="id">suff</span><span class="id"> :</span><span class="id"> \forall</span><span class="id"> x'</span><span class="id"> \near</span><span class="id"> u</span><span class="id"> &amp;</span><span class="id"> i</span><span class="id"> \near</span><span class="id"> nbhs</span><span class="id"> f,</span><span class="id"> K</span><span class="id"> x'</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">\bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> [set`</span><span class="id"> N]</span>)<span class="id"> i</span>) (<span class="id">curry</span><span class="id"> i</span><span class="id"> x'</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> filter_app;</span><span class="id"> near=&gt;</span><span class="id"> a</span><span class="id"> b</span><span class="id"> =&gt;</span><span class="id"> /[apply]</span><span class="id"> ?</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">\bigcap_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> [set`</span><span class="id"> N]</span>)<span class="id"> i</span>).<br/>
<span class="id">apply:</span><span class="id"> filter_bigI_within</span><span class="id"> =&gt;</span><span class="id"> R</span><span class="id"> RN;</span><span class="id"> have</span><span class="id"> /set_mem</span><span class="id"> [[M</span><span class="id"> cptM</span><span class="id"> _]]</span><span class="id"> :=</span><span class="id"> Asub</span><span class="id"> _</span><span class="id"> RN</span>.<br/>
<span class="id">have</span><span class="id"> Rfu</span><span class="id"> :</span><span class="id"> R</span> (<span class="id">curry</span><span class="id"> f</span><span class="id"> u</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> INf</span>.<br/>
<span class="id">move/</span>(_<span class="id"> _</span><span class="id"> Rfu</span>)<span class="id"> =&gt;</span><span class="id"> [O</span><span class="id"> [fMO</span><span class="id"> oO]</span><span class="id"> MOR];</span><span class="id"> near=&gt;</span><span class="id"> p</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> Ki;</span><span class="id"> apply:</span><span class="id"> MOR</span><span class="id"> =&gt;</span><span class="id"> +</span><span class="id"> [+</span><span class="id"> +</span><span class="id"> &lt;-]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> v</span><span class="id"> Mv;</span><span class="id"> move:</span><span class="id"> v</span><span class="id"> Mv</span><span class="id"> Ki;</span><span class="id"> near:</span><span class="id"> p</span>.<br/>
<span class="id">have</span><span class="id"> umb</span><span class="id"> :</span><span class="id"> \forall</span><span class="id"> y</span><span class="id"> \near</span><span class="id"> u,</span> (<span class="gallina-kwd">forall</span><span class="id"> b,</span><span class="id"> M</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> nbhs</span> (<span class="id">y,</span><span class="id"> b</span>) (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> O</span>)).<br/>
&nbsp;&nbsp;<span class="id">move/compact_near_coveringP/near_covering_withinP</span><span class="id"> :</span> (<span class="id">cptM</span>)<span class="id">;</span><span class="id"> apply</span><span class="id"> =&gt;</span><span class="id"> v</span><span class="id"> Mv</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [[P</span><span class="id"> Q]</span><span class="id"> [Pu</span><span class="id"> Qv]</span><span class="id"> PQO]</span><span class="id"> :</span><span class="id"> nbhs</span> (<span class="id">u,</span><span class="id"> v</span>) (<span class="id">f</span><span class="id"> @^-1`</span><span class="id"> O</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> ctsf;</span><span class="id"> apply:</span><span class="id"> open_nbhs_nbhs;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> fMO;</span><span class="gallina-kwd"> exists</span><span class="id"> v</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">Q,</span><span class="id"> P</span>)<span class="id">;</span><span class="id"> [by</span><span class="id"> []|</span><span class="id"> move=&gt;</span><span class="id"> [b</span><span class="id"> a</span><span class="id"> [/=</span><span class="id"> Qb</span><span class="id"> Pa</span><span class="id"> Mb]]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> ctsf;</span><span class="id"> apply:</span><span class="id"> open_nbhs_nbhs;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> PQO</span>.<br/>
<span class="id">move/compact_near_coveringP/near_covering_withinP</span><span class="id"> :</span> (<span class="id">cptM</span>)<span class="id">;</span><span class="id"> apply</span><span class="id"> =&gt;</span><span class="id"> v</span><span class="id"> Mv</span>.<br/>
<span class="id">have</span><span class="id"> [P'</span><span class="id"> P'u</span><span class="id"> cPO]</span><span class="id"> :=</span><span class="id"> regU</span><span class="id"> u</span><span class="id"> _</span><span class="id"> umb</span>.<br/>
<span class="id">pose</span><span class="id"> L</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> h</span><span class="id"> |</span><span class="id"> h</span><span class="id"> @`</span> ((<span class="id">K</span><span class="id"> `&amp;`</span><span class="id"> closure</span><span class="id"> P'</span>)<span class="id"> `*`</span><span class="id"> M</span>)<span class="id"> `&lt;=`</span><span class="id"> O]</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">setT,</span><span class="id"> P'</span><span class="id"> `*`</span><span class="id"> L</span>).<br/>
&nbsp;&nbsp;<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> [exact:</span><span class="id"> filterT|];</span><span class="gallina-kwd"> exists</span> (<span class="id">P',</span><span class="id"> L</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> open_nbhs_nbhs;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> apply:</span><span class="id"> compact_open_open</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> compact_setX</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> compact_closedI</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> closed_closure</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> [[a</span><span class="id"> b]</span><span class="id"> [[Ka</span><span class="id"> /cPO</span><span class="id"> +]</span><span class="id"> Mb</span><span class="id"> &lt;-]]</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> Mb</span>)<span class="id">/nbhs_singleton</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> [b</span><span class="id"> [a</span><span class="id"> h]]</span><span class="id"> [/=</span><span class="id"> _</span><span class="id"> [Pa]</span><span class="id"> +]</span><span class="id"> Ma</span><span class="id"> Ka;</span><span class="id"> apply</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">a,</span><span class="id"> b</span>)<span class="id">;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact/subset_closure</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uncurry_continuous</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> W</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">locally_compact</span><span class="id"> [set:</span><span class="id"> V]</span><span class="id"> -&gt;</span><span class="id"> @regular_space</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> @regular_space</span><span class="id"> U</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">continuous</span><span class="id"> f</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> u,</span><span class="id"> continuous</span> (<span class="id">f</span><span class="id"> u</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{for</span><span class="id"> f,</span><span class="id"> continuous</span><span class="id"> uncurry}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> lcV</span><span class="id"> regV</span><span class="id"> regU</span><span class="id"> ctsf</span><span class="id"> ctsfp;</span><span class="id"> apply/compact_open_cvgP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> fmap_filter;</span><span class="id"> exact:nbhs_filter</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /=</span><span class="id"> K</span><span class="id"> O</span><span class="id"> cptK</span><span class="id"> oO</span><span class="id"> fKO;</span><span class="id"> near=&gt;</span><span class="id"> h</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> [+</span><span class="id"> +</span><span class="id"> &lt;-];</span><span class="id"> near:</span><span class="id"> h</span>.<br/>
<span class="id">move/compact_near_coveringP/near_covering_withinP:</span> (<span class="id">cptK</span>)<span class="id">;</span><span class="id"> apply</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> u</span><span class="id"> v</span><span class="id"> Kuv</span>.<br/>
<span class="id">have</span><span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> P</span><span class="id"> Q,</span><span class="id"> [/\</span><span class="id"> closed</span><span class="id"> P,</span><span class="id"> compact</span><span class="id"> Q,</span><span class="id"> nbhs</span><span class="id"> u</span><span class="id"> P,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">nbhs</span><span class="id"> v</span><span class="id"> Q</span><span class="id"> &amp;</span><span class="id"> P</span><span class="id"> `*`</span><span class="id"> Q</span><span class="id"> `&lt;=`</span><span class="id"> uncurry</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> O]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> :</span><span class="id"> continuous</span> (<span class="id">uncurry</span><span class="id"> f</span>)<span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> continuous_uncurry_regular</span>.<br/>
&nbsp;&nbsp;<span class="id">move/continuousP/</span>(_<span class="id"> _</span><span class="id"> oO</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> openE</span><span class="id"> =&gt;</span><span class="id"> /</span>(_ (<span class="id">u,</span><span class="id"> v</span>))<span class="id">[]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> fKO;</span><span class="gallina-kwd"> exists</span> (<span class="id">u,</span><span class="id"> v</span>).<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> /=</span><span class="id"> P'</span><span class="id"> Q'</span><span class="id"> [P'u</span><span class="id"> Q'v]</span><span class="id"> PQO</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [B]</span><span class="id"> :=</span><span class="id"> @lcV</span><span class="id"> v</span><span class="id"> I;</span><span class="id"> rewrite</span><span class="id"> withinET;</span><span class="id"> move=&gt;</span><span class="id"> Bv</span><span class="id"> [cptB</span><span class="id"> clB]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [P</span><span class="id"> Pu</span><span class="id"> cPP']</span><span class="id"> :=</span><span class="id"> regU</span><span class="id"> u</span><span class="id"> P'</span><span class="id"> P'u;</span><span class="id"> have</span><span class="id"> [Q</span><span class="id"> Qv</span><span class="id"> cQQ']</span><span class="id"> :=</span><span class="id"> regV</span><span class="id"> v</span><span class="id"> Q'</span><span class="id"> Q'v</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">closure</span><span class="id"> P</span>)<span class="id">,</span> (<span class="id">B</span><span class="id"> `&amp;`</span><span class="id"> closure</span><span class="id"> Q</span>)<span class="id">;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> exact:</span><span class="id"> closed_closure</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> compact_closedI</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> closed_closure</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterS;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> subset_closure</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> filterI=&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> filterS;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> subset_closure</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> case</span><span class="id"> =&gt;</span><span class="id"> a</span><span class="id"> b</span><span class="id"> [/cPP'</span><span class="id"> ?]</span><span class="id"> [_</span><span class="id"> /cQQ'</span><span class="id"> ?];</span><span class="id"> exact:</span><span class="id"> PQO</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> P</span><span class="id"> [Q</span><span class="id"> [clP</span><span class="id"> cptQ</span><span class="id"> Pu</span><span class="id"> Qv</span><span class="id"> PQfO]];</span><span class="id"> pose</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> g</span><span class="id"> :</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> W</span><span class="id"> |</span><span class="id"> g</span><span class="id"> @`</span><span class="id"> Q</span><span class="id"> `&lt;=`</span><span class="id"> O]</span>.<br/>
(<span class="id">have</span><span class="id"> oR</span><span class="id"> :</span><span class="id"> open</span><span class="id"> R</span><span class="gallina-kwd"> by</span><span class="id"> exact:</span><span class="id"> compact_open_open</span>)<span class="id">;</span><span class="id"> pose</span><span class="id"> P'</span><span class="id"> :=</span><span class="id"> f</span><span class="id"> @^-1`</span><span class="id"> R</span>.<br/>
<span class="id">pose</span><span class="id"> L</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> h</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span><span class="id"> -&gt;</span><span class="id"> W</span><span class="id"> |</span><span class="id"> h</span><span class="id"> @`</span> (<span class="id">fst</span><span class="id"> @`</span><span class="id"> K</span><span class="id"> `&amp;`</span><span class="id"> P</span>)<span class="id"> `&lt;=`</span><span class="id"> R]</span>.<br/>
<span class="gallina-kwd">exists</span> ((<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> P'</span>)<span class="id"> `*`</span><span class="id"> Q,</span><span class="id"> L</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> exists</span> (<span class="id">P</span><span class="id"> `&amp;`</span><span class="id"> P',</span><span class="id"> Q</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> apply:</span><span class="id"> filterI</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> ctsf;</span><span class="id"> apply:</span><span class="id"> open_nbhs_nbhs;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> [b</span><span class="id"> Qb</span><span class="id"> &lt;-]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">PQfO</span> (<span class="id">u,</span><span class="id"> b</span>))<span class="id">;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> nbhs_singleton</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> nbhs_simpl</span><span class="id"> /=;</span><span class="id"> apply:</span><span class="id"> open_nbhs_nbhs;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> compact_open_open</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> compact_closedI</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> continuous_compact</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> continuous_subspaceT</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> cvg_fst</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /=</span><span class="id"> _</span><span class="id"> [a</span><span class="id"> [Kxa</span><span class="id"> Pa]</span><span class="id"> &lt;-]</span><span class="id"> _</span><span class="id"> [b</span><span class="id"> Qb</span><span class="id"> &lt;-]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">PQfO</span> (<span class="id">a,</span><span class="id"> b</span>))<span class="id">;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> exact:</span><span class="id"> nbhs_singleton</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> [[a</span><span class="id"> b</span><span class="id"> h]]</span><span class="id"> [/=</span><span class="id"> [[Pa</span><span class="id"> P'a]</span><span class="id"> Qb</span><span class="id"> Lh]</span><span class="id"> Kab]</span>.<br/>
<span class="id">apply:</span> (<span class="id">Lh</span> (<span class="id">h</span><span class="id"> a</span>))<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> a</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span> (<span class="id">a,</span><span class="id"> b</span>).<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> b</span>.<br/>
<span class="id">Unshelve</span>.<span class="id"> all:</span><span class="gallina-kwd"> by</span><span class="id"> end_near</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> cartesian_closed</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> currying</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> eval</span><span class="id"> {X</span><span class="id"> Y</span><span class="id"> :</span><span class="id"> topologicalType}</span><span class="id"> :</span><span class="id"> continuousType</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> *</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> Y</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">uncurry</span> (<span class="id">id</span><span class="id"> :</span><span class="id"> continuousType</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> -&gt;</span> (<span class="id">X</span><span class="id"> -&gt;</span><span class="id"> Y</span>)).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> composition</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Import</span><span class="id"> ArrowAsCompactOpen</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eval_continuous</span><span class="id"> {X</span><span class="id"> Y</span><span class="id"> :</span><span class="id"> topologicalType}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">locally_compact</span><span class="id"> [set:</span><span class="id"> X]</span><span class="id"> -&gt;</span><span class="id"> regular_space</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> continuous</span> (<span class="id">@eval</span><span class="id"> X</span><span class="id"> Y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> lcX</span><span class="id"> rsX;</span><span class="id"> apply:</span><span class="id"> continuous_uncurry_regular</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> weak_continuous</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> exact:</span><span class="id"> cts_fun</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> compose_continuous</span><span class="id"> {X</span><span class="id"> Y</span><span class="id"> Z</span><span class="id"> :</span><span class="id"> topologicalType}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">locally_compact</span><span class="id"> [set:</span><span class="id"> X]</span><span class="id"> -&gt;</span><span class="id"> @regular_space</span><span class="id"> X</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">locally_compact</span><span class="id"> [set:</span><span class="id"> Y]</span><span class="id"> -&gt;</span><span class="id"> @regular_space</span><span class="id"> Y</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">continuous</span> (<span class="id">uncurry</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">comp</span><span class="id"> :</span><span class="id"> continuousType</span><span class="id"> Y</span><span class="id"> Z</span><span class="id"> -&gt;</span><span class="id"> continuousType</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> -&gt;</span><span class="id"> continuousType</span><span class="id"> X</span><span class="id"> Z</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> lX</span><span class="id"> rX</span><span class="id"> lY</span><span class="id"> rY;</span><span class="id"> apply:</span><span class="id"> continuous_comp_weak</span>.<br/>
<span class="id">set</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> _</span><span class="id"> \o</span><span class="id"> _</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[F]uncurryK;</span><span class="id"> apply:</span><span class="id"> continuous_curry_fun</span>.<br/>
<span class="id">pose</span><span class="id"> g</span><span class="id"> :=</span><span class="id"> uncurry</span><span class="id"> F</span><span class="id"> \o</span><span class="id"> prodAr</span><span class="id"> \o</span><span class="id"> swap;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="gallina-kwd"> in</span><span class="id"> g</span><span class="id"> *</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> uncurry</span><span class="id"> F</span><span class="id"> =</span><span class="id"> uncurry</span><span class="id"> F</span><span class="id"> \o</span><span class="id"> prodAr</span><span class="id"> \o</span><span class="id"> prodA</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> funeqE</span><span class="id"> =&gt;</span><span class="id"> -[[]]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> z;</span><span class="id"> apply:</span><span class="id"> continuous_comp;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> prodA_continuous</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> uncurry</span><span class="id"> F</span><span class="id"> \o</span><span class="id"> prodAr</span><span class="id"> =</span><span class="id"> uncurry</span><span class="id"> F</span><span class="id"> \o</span><span class="id"> prodAr</span><span class="id"> \o</span><span class="id"> swap</span><span class="id"> \o</span><span class="id"> swap</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> funeqE</span><span class="id"> =&gt;</span><span class="id"> -[[]]</span>.<br/>
<span class="id">apply:</span><span class="id"> continuous_comp;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> swap_continuous</span>.<br/>
<span class="id">pose</span><span class="id"> h</span> (<span class="id">fxg</span><span class="id"> :</span><span class="id"> continuousType</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> *</span><span class="id"> X</span><span class="id"> *</span><span class="id"> continuousType</span><span class="id"> Y</span><span class="id"> Z</span>)<span class="id"> :</span><span class="id"> Z</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">eval</span> (<span class="id">fxg</span>.<span class="id">2,</span> (<span class="id">eval</span><span class="id"> fxg</span>.<span class="id">1</span>)).<br/>
<span class="id">have</span><span class="id"> &lt;-</span><span class="id"> :</span><span class="id"> h</span><span class="id"> =</span><span class="id"> uncurry</span><span class="id"> F</span><span class="id"> \o</span><span class="id"> prodAr</span><span class="id"> \o</span><span class="id"> swap</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /h/g/uncurry/swap/F</span><span class="id"> funeqE</span><span class="id"> =&gt;</span><span class="id"> -[[]]</span>.<br/>
<span class="id">rewrite</span><span class="id"> /h</span>.<br/>
<span class="id">apply:</span> (<span class="id">@continuous2_cvg</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> snd</span> (<span class="id">eval</span><span class="id"> \o</span><span class="id"> fst</span>) (<span class="id">curry</span><span class="id"> eval</span>)).<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> continuous_curry_cvg;</span><span class="id"> exact:</span><span class="id"> eval_continuous</span>.<br/>
<span class="id">-</span><span class="id"> exact:</span><span class="id"> cvg_snd</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> cvg_comp;</span><span class="id"> [exact:</span><span class="id"> cvg_fst</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> eval_continuous]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> composition</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
