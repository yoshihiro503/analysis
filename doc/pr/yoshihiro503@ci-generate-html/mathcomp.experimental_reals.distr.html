
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp.experimental_reals.distr</title>
<meta name="description" content="Documentation of Coq module mathcomp.experimental_reals.distr" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp.experimental_reals.distr</h1>
<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> all_ssreflect</span><span class="id"> all_algebra</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span>.<span class="id">classical</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> boolp</span><span class="id"> classical_sets</span><span class="id"> mathcomp_extra</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> xfinmap</span><span class="id"> constructive_ereal</span><span class="id"> reals</span><span class="id"> discrete</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> realseq</span><span class="id"> realsum</span>.<br/>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<span class="vernacular">Unset</span><span class="id"> SsrOldRewriteGoalsOrder</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> Order</span>.<span class="id">TTheory</span><span class="id"> GRing</span>.<span class="id">Theory</span><span class="id"> Num</span>.<span class="id">Theory</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> simpm</span><span class="id"> :=</span><span class="id"> Monoid</span>.<span class="id">simpm</span>.<br/>
<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;\dlet_ ( i &lt;- d ) E&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> E</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> i,</span><span class="id"> d</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 50,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;'[' \dlet_ ( i  &lt;-  d ) '/  '  E ']'&quot;</span>).<br/>
<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;\dlim_ ( n ) E&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> E</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 36,</span><span class="id"> n</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 50,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;'[' \dlim_ ( n ) '/  '  E ']'&quot;</span>).<br/>
<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;\P_[ mu ] E&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;\P_[ mu ]  E&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;\P_[ mu , A ] E&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;\P_[ mu ,  A ]  E&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;\E?_[ mu ] f&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;\E?_[ mu ]  f&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;\E_[ mu ] f&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;\E_[ mu ]  f&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;\E_[ mu , A ] f&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;\E_[ mu ,  A ]  f&quot;</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;\`| f |&quot;</span><span class="id"> :=</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> `|f</span><span class="id"> x|</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Distribution</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> realType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>).<br/>
<br/>
<span class="vernacular">Structure</span><span class="id"> distr</span><span class="id"> :=</span><span class="id"> Distr</span><span class="id"> {</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> :&gt;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R;</span><br/>
&nbsp;&nbsp;_ <span class="id"> :</span> <span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> x;</span><br/>
&nbsp;&nbsp;_ <span class="id"> :</span> <span class="id"> summable</span><span class="id"> mu;</span><br/>
&nbsp;&nbsp;_ <span class="id"> :</span> <span class="id"> psum</span><span class="id"> mu</span><span class="id"> &lt;=</span><span class="id"> 1</span><br/>
<span class="id">}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> distr_of</span><span class="id"> of</span><span class="id"> phant</span><span class="id"> R</span><span class="id"> &amp;</span><span class="id"> phant</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> distr</span>.<br/>
<span class="vernacular">End</span><span class="id"> Distribution</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'distr' T / R }&quot;</span><span class="id"> :=</span> (<span class="id">distr_of</span> (<span class="id">Phant</span><span class="id"> R</span>) (<span class="id">Phant</span><span class="id"> T</span>))<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> T</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;{ 'distr'  T  /  R }&quot;</span>)<br/>
&nbsp;&nbsp;<span class="id">:</span><span class="id"> type_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> DistrCoreTh</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ge0_mu</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> mu</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le1_mu</span><span class="id"> :</span><span class="id"> psum</span><span class="id"> mu</span><span class="id"> &lt;=</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> mu</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_mu</span><span class="id"> :</span><span class="id"> summable</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> mu</span>. Qed.</div></details>
<span class="vernacular">End</span><span class="id"> DistrCoreTh</span>.<br/>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">is_true</span> (<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> _</span>))<span class="id"> =&gt;</span><span class="id"> solve</span><span class="id"> [apply:</span><span class="id"> ge0_mu]</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> le1_mu</span><span class="id"> summable_mu</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Clamp</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> clamp</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">Num</span>.<span class="id">max</span> (<span class="id">Num</span>.<span class="id">min</span><span class="id"> x</span><span class="id"> 1</span>)<span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ge0_clamp</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> clamp</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> le_max</span><span class="id"> lexx</span><span class="id"> orbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le1_clamp</span><span class="id"> x</span><span class="id"> :</span><span class="id"> clamp</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ge_max</span><span class="id"> ge_min</span><span class="id"> lexx</span><span class="id"> ler01</span><span class="id"> orbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> cp01_clamp</span><span class="id"> :=</span> (<span class="id">ge0_clamp,</span><span class="id"> le1_clamp</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> clamp_in01</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> 1</span><span class="id"> -&gt;</span><span class="id"> clamp</span><span class="id"> x</span><span class="id"> =</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case/andP=&gt;</span><span class="id"> ge0_x</span><span class="id"> le1_x;</span><span class="id"> rewrite</span><span class="id"> /clamp</span><span class="id"> min_l</span><span class="id"> ?max_l</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> clamp_id</span><span class="id"> x</span><span class="id"> :</span><span class="id"> clamp</span> (<span class="id">clamp</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> clamp</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> clamp_in01</span><span class="id"> //</span><span class="id"> !cp01_clamp</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> clamp0</span><span class="id"> :</span><span class="id"> clamp</span><span class="id"> 0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> clamp_in01</span><span class="id"> //</span><span class="id"> lexx</span><span class="id"> ler01</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> clamp1</span><span class="id"> :</span><span class="id"> clamp</span><span class="id"> 1</span><span class="id"> =</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> clamp_in01</span><span class="id"> //</span><span class="id"> lexx</span><span class="id"> ler01</span>. Qed.</div></details>
<span class="vernacular">End</span><span class="id"> Clamp</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> StdDefs</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>).<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>) (<span class="id">A</span><span class="id"> B</span><span class="id"> E</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> dinsupp</span><span class="id"> mu</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> :&gt;</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> in_dinsupp</span><span class="id"> x</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span>)<span class="id"> =</span> (<span class="id">mu</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> 0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dinsuppP</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">mu</span><span class="id"> x</span><span class="id"> &lt;&gt;</span><span class="id"> 0</span>) (<span class="id">x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> /eqP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dinsuppPn</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">mu</span><span class="id"> x</span><span class="id"> =</span><span class="id"> 0</span>) (<span class="id">x</span><span class="id"> \notin</span><span class="id"> dinsupp</span><span class="id"> mu</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -topredE</span><span class="id"> /dinsupp</span><span class="id"> /=</span><span class="id"> negbK;</span><span class="id"> apply/eqP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> pr</span>  <span class="id"> mu</span><span class="id"> E</span>  <span class="id"> :=</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">E</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> mu</span><span class="id"> x</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> prc</span> <span class="id"> mu</span><span class="id"> E</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> pr</span><span class="id"> mu</span><span class="id"> [predI</span><span class="id"> E</span><span class="id"> &amp;</span><span class="id"> A]</span><span class="id"> /</span><span class="id"> pr</span><span class="id"> mu</span><span class="id"> A</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> esp</span> <span class="id"> mu</span><span class="id"> f</span>  <span class="id"> :=</span><span class="id"> sum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> *</span><span class="id"> mu</span><span class="id"> x</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> espc</span><span class="id"> mu</span><span class="id"> f</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> sum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> *</span><span class="id"> prc</span><span class="id"> mu</span> (<span class="id">pred1</span><span class="id"> x</span>)<span class="id"> A</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> has_esp</span><span class="id"> mu</span><span class="id"> f</span><span class="id"> :=</span><span class="id"> summable</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> *</span><span class="id"> mu</span><span class="id"> x</span>).<br/>
<span class="vernacular">End</span><span class="id"> StdDefs</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;\P_[ mu ] E&quot;</span>    <span class="id"> :=</span> (<span class="id">pr</span><span class="id"> mu</span><span class="id"> E</span>).<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;\P_[ mu , A ] E&quot;</span><span class="id"> :=</span> (<span class="id">prc</span><span class="id"> mu</span><span class="id"> E</span><span class="id"> A</span>).<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;\E_[ mu ] f&quot;</span>    <span class="id"> :=</span> (<span class="id">esp</span><span class="id"> mu</span><span class="id"> f</span>).<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;\E_[ mu , A ] f&quot;</span><span class="id"> :=</span> (<span class="id">espc</span><span class="id"> mu</span><span class="id"> f</span><span class="id"> A</span>).<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;\E?_[ mu ] f&quot;</span>   <span class="id"> :=</span> (<span class="id">has_esp</span><span class="id"> mu</span><span class="id"> f</span>).<br/>
<span class="vernacular">Notation</span><span class="id"> dweight</span><span class="id"> mu</span>       <span class="id"> :=</span> (<span class="id">\P_[mu]</span><span class="id"> predT</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> DistrTheory</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> isdistr</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> x</span>)<span class="id"> /\</span> (<span class="gallina-kwd">forall</span><span class="id"> J,</span><span class="id"> uniq</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> &lt;-</span><span class="id"> J</span>)<span class="id"> mu</span><span class="id"> j</span><span class="id"> &lt;=</span><span class="id"> 1</span>).<br/>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> isd</span><span class="id"> :</span><span class="id"> isdistr</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> isd1</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> isd</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> isd2</span><span class="id"> :</span><span class="id"> summable</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case:</span><span class="id"> isd=&gt;</span><span class="id"> _</span><span class="id"> h;</span><span class="id"> apply/summable_seqP;</span><span class="gallina-kwd"> exists</span><span class="id"> 1=&gt;</span><span class="id"> //</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> s</span><span class="id"> /h</span><span class="id"> /</span>(<span class="id">le_trans</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply;</span><span class="id"> rewrite</span><span class="id"> le_eqVlt;</span><span class="id"> apply/orP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> left;</span><span class="id"> apply/eqP/eq_bigr=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> ger0_norm</span><span class="id"> ?isd1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> isd3</span><span class="id"> :</span><span class="id"> psum</span><span class="id"> mu</span><span class="id"> &lt;=</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> psumE;</span><span class="id"> [apply/isd1</span><span class="id"> |</span><span class="id"> apply/isd2</span><span class="id"> |</span><span class="id"> apply/sup_le_ub]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> 0,</span><span class="id"> fset0;</span><span class="id"> rewrite</span><span class="id"> big_fset0</span>.<br/>
<span class="id">apply/ubP=&gt;</span><span class="id"> y</span><span class="id"> [x</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> big_fset_seq</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> isd</span><span class="id"> =&gt;</span><span class="id"> _;</span><span class="id"> apply;</span><span class="id"> case:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=</span><span class="id"> /canonical_uniq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> mkdistr</span><span class="id"> :=</span><span class="id"> @Distr</span><span class="id"> R</span><span class="id"> T</span><span class="id"> mu</span><span class="id"> isd1</span><span class="id"> isd2</span><span class="id"> isd3</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mkdistrE</span><span class="id"> :</span><span class="id"> mkdistr</span><span class="id"> =1</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> ispredistr</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> summable</span><span class="id"> mu]</span>.<br/>
<span class="vernacular">End</span><span class="id"> DistrTheory</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> isdistr_finP</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> finType}</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">isdistr</span><span class="id"> mu</span>)<span class="id"> &lt;-&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> x</span>)<span class="id"> /\</span> (<span class="id">\sum_j</span><span class="id"> mu</span><span class="id"> j</span><span class="id"> &lt;=</span><span class="id"> 1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> split=&gt;</span><span class="id"> -[</span><span class="id"> ge0_mu</span><span class="id"> le1];</span><span class="id"> split=&gt;</span><span class="id"> //</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply/le1;</span><span class="id"> rewrite</span><span class="id"> /index_enum</span><span class="id"> -enumT</span><span class="id"> enum_uniq</span>.<br/>
<span class="id">+</span><span class="id"> move=&gt;</span><span class="id"> J</span><span class="id"> uqJ;</span><span class="id"> rewrite</span><span class="id"> big_uniq</span><span class="id"> 1?</span>(<span class="id">le_trans</span><span class="id"> _</span><span class="id"> le1</span>)<span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _&lt;=X]</span>(<span class="id">bigID</span> (<span class="id">mem</span><span class="id"> J</span>))<span class="id"> /=</span><span class="id"> lerDl</span><span class="id"> sumr_ge0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le1_mu1</span><br/>
&nbsp;&nbsp;<span class="id">{R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> x</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/</span>(<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">psum</span><span class="id"> mu</span>))<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> -[mu</span><span class="id"> x]ger0_norm//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/ger1_psum</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> DistrD</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mnull</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T</span><span class="id"> =&gt;</span> (<span class="id">0</span><span class="id"> :</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> isd_mnull</span><span class="id"> :</span><span class="id"> isdistr</span><span class="id"> mnull</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> J</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> big1</span><span class="id"> ?ler01</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> dnull</span><span class="id"> :=</span><span class="id"> locked</span> (<span class="id">mkdistr</span><span class="id"> isd_mnull</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dnullE</span><span class="id"> x</span><span class="id"> :</span><span class="id"> dnull</span><span class="id"> x</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> unlock</span><span class="id"> dnull</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> mkdistrd</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> @idP</span><span class="id"> `[&lt;</span><span class="id"> isdistr</span><span class="id"> mu</span><span class="id"> &gt;]</span><span class="id"> is</span><span class="id"> ReflectT</span><span class="id"> Px</span><span class="gallina-kwd"> then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkdistr</span> (<span class="id">asboolW</span><span class="id"> Px</span>)<br/>
&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="id"> dnull</span>.<br/>
<span class="vernacular">End</span><span class="id"> DistrD</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lef_dnull</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">dnull</span><span class="id"> &lt;=1</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> dnullE</span><span class="id"> ge0_mu</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> Restr</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">p</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mrestr</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> p</span><span class="id"> x</span><span class="gallina-kwd"> then</span><span class="id"> mu</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> isd_mrestr</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :</span><span class="id"> isdistr</span> (<span class="id">mrestr</span><span class="id"> mu</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [x|J];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /mrestr;</span><span class="id"> case:</span><span class="id"> ifP</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> eqJ;</span><span class="id"> apply/</span>(<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">\sum_</span>(<span class="id">j</span><span class="id"> &lt;-</span><span class="id"> J</span>)<span class="id"> `|mu</span><span class="id"> j|</span>)).<br/>
<span class="id">+</span><span class="id"> apply/ler_sum=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /mrestr;</span><span class="id"> case:</span><span class="id"> ifPn=&gt;</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/ler_norm</span>.<span class="gallina-kwd"> by</span><span class="id"> apply/normr_ge0</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">le1_mu</span><span class="id"> mu</span>))<span class="id">/gerfinseq_psum</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> drestr</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :=</span><span class="id"> locked</span> (<span class="id">mkdistr</span> (<span class="id">isd_mrestr</span><span class="id"> mu</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drestrE</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">drestr</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> p</span><span class="id"> x</span><span class="gallina-kwd"> then</span><span class="id"> mu</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> unlock</span><span class="id"> drestr</span>. Qed.</div></details>
<span class="vernacular">End</span><span class="id"> Restr</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> RestrTheory</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drestrD</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>) (<span class="id">p</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>)<span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">mu</span><span class="id"> x</span><span class="id"> =</span><span class="id"> drestr</span><span class="id"> p</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> +</span><span class="id"> drestr</span> (<span class="id">predC</span><span class="id"> p</span>)<span class="id"> mu</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !drestrE</span><span class="id"> !inE;</span><span class="id"> case:</span><span class="id"> ifPn;</span><span class="id"> rewrite</span><span class="id"> /=</span> (<span class="id">addr0,</span><span class="id"> add0r</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dinsupp_restr</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>) (<span class="id">p</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>)<span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">x</span><span class="id"> \in</span><span class="id"> dinsupp</span> (<span class="id">drestr</span><span class="id"> p</span><span class="id"> mu</span>))<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span>)<span class="id"> &amp;&amp;</span><span class="id"> p</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/dinsuppP/idP</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> drestrE;</span><span class="id"> case:</span><span class="id"> ifP=&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> /dinsuppP</span><span class="id"> -&gt;</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> case/andP;</span><span class="id"> rewrite</span><span class="id"> drestrE</span><span class="id"> =&gt;</span><span class="id"> /dinsuppP</span><span class="id"> ?</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> RestrTheory</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> DRat</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> choiceType</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> distr</span><span class="id"> :=</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mrat</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T</span><span class="id"> =&gt;</span> (<span class="id">count</span> (<span class="id">pred1</span><span class="id"> x</span>)<span class="id"> s</span>)<span class="id">%:R</span><span class="id"> /</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id">%:R</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ge0_mrat</span><span class="id"> s</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> mrat</span><span class="id"> s</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> ?invr_ge0</span><span class="id"> //</span><span class="id"> ler0n</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> has_sup_mrat</span><span class="id"> s</span><span class="id"> J</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> J</span><span class="id"> -&gt;</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> J</span>)<span class="id"> mrat</span><span class="id"> s</span><span class="id"> i</span><span class="id"> &lt;=</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> uqJ;</span><span class="id"> rewrite</span><span class="id"> -mulr_suml</span><span class="id"> /=</span><span class="id"> -natr_sum;</span><span class="id"> case:</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> =P</span><span class="id"> 0%N</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> invr0</span><span class="id"> mulr0</span><span class="id"> ler01</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /eqP</span><span class="id"> nz_s;</span><span class="id"> rewrite</span><span class="id"> ler_pdivrMr</span><span class="id"> ?ltr0n</span><span class="id"> ?lt0n</span><span class="id"> //</span><span class="id"> mul1r</span>.<br/>
<span class="id">rewrite</span><span class="id"> ler_nat</span> (<span class="id">bigID</span> (<span class="id">mem</span><span class="id"> s</span>))<span class="id"> /=</span><span class="id"> [X</span><span class="gallina-kwd"> in</span> (<span class="id">_+X</span>)<span class="id">%N]big1</span><span class="id"> ?addn0</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> /count_memPn</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;:</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> undup</span><span class="id"> s</span>)<span class="id"> count_mem</span><span class="id"> i</span><span class="id"> s</span>)<span class="id">%N</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -sum1_size</span><span class="id"> -big_undup_iterop_count;</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Monoid</span>.<span class="id">iteropE</span><span class="id"> iter_addn</span><span class="id"> addn0</span><span class="id"> mul1n</span>.<br/>
<span class="id">rewrite</span><span class="id"> [X</span><span class="gallina-kwd"> in</span> (<span class="id">_&lt;=X</span>)<span class="id">%N]</span>(<span class="id">bigID</span> (<span class="id">mem</span><span class="id"> J</span>))<span class="id"> /=</span><span class="id"> -ltnS</span><span class="id"> -addSn</span>.<br/>
<span class="id">rewrite</span><span class="id"> ltn_addr</span><span class="id"> //=</span><span class="id"> ltnS</span><span class="id"> -big_filter</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span> (<span class="id">_&lt;=X</span>)<span class="id">%N]big_filter</span>.<br/>
<span class="id">rewrite</span><span class="id"> leq_eqVlt;</span><span class="id"> apply/orP;</span><span class="id"> left;</span><span class="id"> apply/eqP/perm_big</span>.<br/>
<span class="id">apply/uniq_perm;</span><span class="id"> rewrite</span><span class="id"> ?filter_uniq</span><span class="id"> ?undup_uniq</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !mem_filter</span><span class="id"> mem_undup</span><span class="id"> andbC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> mrat_sup</span><span class="id"> s</span><span class="id"> :</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span>)<span class="id">%N</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> undup</span><span class="id"> s</span>)<span class="id"> mrat</span><span class="id"> s</span><span class="id"> i</span><span class="id"> =</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> gt0_s;</span><span class="id"> rewrite</span><span class="id"> -mulr_suml</span><span class="id"> -natr_sum</span>.<br/>
<span class="id">apply/</span>(<span class="id">mulIf</span> (<span class="id">x</span><span class="id"> :=</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id">%:R</span>))<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> pnatr_eq0</span><span class="id"> -lt0n</span>.<br/>
<span class="id">rewrite</span><span class="id"> mul1r</span><span class="id"> -mulrA</span><span class="id"> mulVf</span><span class="id"> ?mulr1</span><span class="id"> ?pnatr_eq0</span><span class="id"> -?lt0n</span><span class="id"> //;</span><span class="id"> congr</span> (<span class="id">_%:R</span>).<br/>
<span class="id">rewrite</span><span class="id"> -sum1_size</span><span class="id"> -[in</span><span class="id"> RHS]big_undup_iterop_count/=;</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Monoid</span>.<span class="id">iteropE</span><span class="id"> iter_addn</span><span class="id"> addn0</span><span class="id"> mul1n</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Lemma</span><span class="id"> summable_mrat</span><span class="id"> s:</span><span class="id"> summable</span> (<span class="id">mrat</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/summable_seqP;</span><span class="gallina-kwd"> exists</span><span class="id"> 1=&gt;</span><span class="id"> //</span><span class="id"> J</span><span class="id"> uqJ;</span><span class="id"> rewrite</span> (<span class="id">eq_bigr</span> (<span class="id">mrat</span><span class="id"> s</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> ger0_norm</span><span class="id"> ?ge0_mrat</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/has_sup_mrat</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> isd_mrat</span><span class="id"> s</span><span class="id"> :</span><span class="id"> isdistr</span> (<span class="id">mrat</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split;</span><span class="id"> [apply/ge0_mrat</span><span class="id"> |</span><span class="id"> apply/has_sup_mrat]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> drat</span><span class="id"> s</span><span class="id"> :=</span><span class="id"> locked</span> (<span class="id">mkdistr</span> (<span class="id">isd_mrat</span><span class="id"> s</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drat1E</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">drat</span><span class="id"> s</span><span class="id"> x</span><span class="id"> =</span> (<span class="id">count_mem</span><span class="id"> x</span><span class="id"> s</span>)<span class="id">%:R</span><span class="id"> /</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id">%:R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> unlock</span><span class="id"> drat;</span><span class="id"> rewrite</span><span class="id"> mkdistrE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> dunit</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> locked</span> (<span class="id">drat</span><span class="id"> [::</span><span class="id"> x]</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> duni</span> <span class="id"> s</span><span class="id"> :=</span><span class="id"> locked</span> (<span class="id">drat</span> (<span class="id">undup</span><span class="id"> s</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dunit1E</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span> (<span class="id">dunit</span><span class="id"> x</span>)<span class="id"> y</span><span class="id"> =</span> (<span class="id">x</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id">%:R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> unlock</span><span class="id"> dunit;</span><span class="id"> rewrite</span><span class="id"> drat1E</span><span class="id"> /=</span><span class="id"> !</span>(<span class="id">simpm,</span><span class="id"> invr1</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> duni1E</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span> (<span class="id">duni</span><span class="id"> s</span>)<span class="id"> x</span><span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>)<span class="id">%:R</span><span class="id"> /</span> (<span class="id">size</span> (<span class="id">undup</span><span class="id"> s</span>))<span class="id">%:R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> unlock</span><span class="id"> duni;</span><span class="id"> rewrite</span><span class="id"> drat1E</span><span class="id"> count_uniq_mem</span><span class="id"> ?</span>(<span class="id">mem_undup,</span><span class="id"> undup_uniq</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> in_dunit</span><span class="id"> t</span><span class="id"> t'</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">t'</span><span class="id"> \in</span><span class="id"> dinsupp</span> (<span class="id">dunit</span><span class="id"> t</span>)<span class="id"> -&gt;</span><span class="id"> t'</span><span class="id"> =</span><span class="id"> t</span><span class="id"> :&gt;</span><span class="id"> T</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> in_dinsupp</span><span class="id"> dunit1E</span><span class="id"> pnatr_eq0</span><span class="id"> eqb0</span><span class="id"> negbK</span><span class="id"> =&gt;</span><span class="id"> /eqP</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> DRat</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Flip</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mflip</span> (<span class="id">xt</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> b</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> b</span><span class="gallina-kwd"> then</span><span class="id"> clamp</span><span class="id"> xt</span><span class="gallina-kwd"> else</span><span class="id"> 1</span><span class="id"> -</span><span class="id"> clamp</span><span class="id"> xt</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> isd_mflip</span><span class="id"> xt</span><span class="id"> :</span><span class="id"> isdistr</span> (<span class="id">mflip</span><span class="id"> xt</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> apply/isdistr_finP;</span><span class="id"> split=&gt;</span><span class="id"> [b|]</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> b;</span><span class="id"> rewrite</span><span class="id"> ?subr_ge0</span><span class="id"> cp01_clamp</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /index_enum</span><span class="id"> !unlock</span><span class="id"> /=</span><span class="id"> addr0</span><span class="id"> addrCA</span><span class="id"> subrr</span><span class="id"> addr0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> dflip</span> (<span class="id">xt</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :=</span><span class="id"> locked</span> (<span class="id">mkdistr</span> (<span class="id">isd_mflip</span><span class="id"> xt</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dflip1E</span><span class="id"> xt</span><span class="id"> :</span><span class="id"> dflip</span><span class="id"> xt</span><span class="id"> =1</span><span class="id"> mflip</span><span class="id"> xt</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> unlock</span><span class="id"> dflip;</span><span class="id"> apply/mkdistrE</span>. Qed.</div></details>
<span class="vernacular">End</span><span class="id"> Flip</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Std</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> distr</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> choiceType</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="vernacular"> Bind</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> distr</span><span class="id"> U</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> distr</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mlet</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> y</span><span class="id"> :</span><span class="id"> U</span><span class="id"> =&gt;</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> *</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> isd_mlet</span><span class="id"> :</span><span class="id"> isdistr</span><span class="id"> mlet</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [x|J</span><span class="id"> uqJ];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/ge0_psum</span>.<br/>
<span class="id">rewrite</span><span class="id"> /mlet</span><span class="id"> psum_bigop;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> u;</span><span class="id"> apply/</span>(<span class="id">le_summable</span> (<span class="id">F2</span><span class="id"> :=</span><span class="id"> mu</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> //=</span><span class="id"> ler_piMr</span><span class="id"> ?le1_mu1</span>.<br/>
<span class="id">apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">le1_mu</span><span class="id"> mu</span>))<span class="id">/le_psum</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> sumr_ge0</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> [y</span><span class="id"> _|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span>.<br/>
<span class="id">rewrite</span><span class="id"> -mulr_sumr</span><span class="id"> ler_piMr</span><span class="id"> //;</span><span class="id"> apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">le1_mu</span> (<span class="id">f</span><span class="id"> x</span>))).<br/>
<span class="id">have</span><span class="id"> :=</span><span class="id"> summable_mu</span> (<span class="id">f</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> /gerfinseq_psum</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> uqJ</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">le_trans</span><span class="id"> _</span>)<span class="id">/ler_sum=&gt;</span><span class="id"> y</span><span class="id"> _;</span><span class="id"> apply/ler_norm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> dlet</span><span class="id"> :=</span><span class="id"> locked</span> (<span class="id">mkdistr</span><span class="id"> isd_mlet</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dletE</span><span class="id"> y</span><span class="id"> :</span><span class="id"> dlet</span><span class="id"> y</span><span class="id"> =</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> *</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> unlock</span><span class="id"> dlet</span>. Qed.</div></details>
<span class="vernacular">End</span><span class="vernacular"> Bind</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;\dlet_ ( i &lt;- d ) E&quot;</span><span class="id"> :=</span> (<span class="id">dlet</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> E</span>)<span class="id"> d</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> dlift</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> {distr</span><span class="id"> A</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> d</span><span class="id"> =&gt;</span><span class="id"> \dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> d</span>)<span class="id"> f</span><span class="id"> x</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> diter</span><span class="id"> {A</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> n</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> {distr</span><span class="id"> A</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> a</span><span class="id"> =&gt;</span> (<span class="id">iter</span><span class="id"> n</span> (<span class="id">dlift</span><span class="id"> f</span>) (<span class="id">dunit</span><span class="id"> a</span>)).<br/>
<br/>
<span class="vernacular">Section</span><span class="vernacular"> BindTheory</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> choiceType</span>).<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> distr</span><span class="id"> U</span>) (<span class="id">mu</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> distr</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dlet_null</span><span class="id"> f</span><span class="id"> :</span><span class="id"> dlet</span><span class="id"> f</span><span class="id"> dnull</span><span class="id"> =1</span><span class="id"> dnull</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> dletE</span><span class="id"> dnullE</span><span class="id"> /=</span><span class="id"> /mlet</span><span class="id"> psum_eq0</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> dnullE</span><span class="id"> mul0r</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dlet_unit</span><span class="id"> f</span><span class="id"> v</span><span class="id"> :</span><span class="id"> \dlet_</span>(<span class="id">y</span><span class="id"> &lt;-</span><span class="id"> dunit</span><span class="id"> v</span>)<span class="id"> f</span><span class="id"> y</span><span class="id"> =1</span><span class="id"> f</span><span class="id"> v</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> dletE</span> (<span class="id">psum_finseq</span> (<span class="id">r</span><span class="id"> :=</span><span class="id"> [::</span><span class="id"> v]</span>))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> dunit1E</span><span class="id"> mulf_eq0</span><span class="id"> =&gt;</span><span class="id"> /norP[]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> pnatr_eq0</span><span class="id"> eqb0</span><span class="id"> negbK</span><span class="id"> =&gt;</span><span class="id"> /eqP-&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_seq1</span><span class="id"> dunit1E</span><span class="id"> eqxx</span><span class="id"> mul1r</span><span class="id"> ger0_norm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dlet_dunit_id</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> \dlet_</span>(<span class="id">t</span><span class="id"> &lt;-</span><span class="id"> mu</span>) (<span class="id">dunit</span><span class="id"> t</span>)<span class="id"> =1</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> dletE</span> (<span class="id">psum_finseq</span> (<span class="id">r</span><span class="id"> :=</span><span class="id"> [::</span><span class="id"> x]</span>))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> dunit1E</span><span class="id"> mulf_eq0</span><span class="id"> pnatr_eq0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/norP;</span><span class="id"> rewrite</span><span class="id"> eqb0</span><span class="id"> negbK</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_seq1</span><span class="id"> dunit1E</span><span class="id"> eqxx</span><span class="id"> mulr1</span><span class="id"> ger0_norm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_in_dlet</span><span class="id"> f</span><span class="id"> g</span><span class="id"> mu</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> dinsupp</span><span class="id"> mu,</span><span class="id"> f</span><span class="id"> =2</span><span class="id"> g}</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> =1</span><span class="id"> nu</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">dlet</span><span class="id"> f</span><span class="id"> mu</span><span class="id"> =1</span><span class="id"> dlet</span><span class="id"> g</span><span class="id"> nu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_f</span><span class="id"> eq_mu;</span><span class="id"> unlock</span><span class="id"> dlet=&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> apply/eq_psum=&gt;</span><span class="id"> x</span>.<br/>
<span class="id">rewrite</span><span class="id"> -eq_mu;</span><span class="id"> case/boolP:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span>)<span class="id"> =&gt;</span><span class="id"> [/eq_f</span><span class="id"> -&gt;//|]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/dinsuppPn=&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> !mul0r</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_mu_wgtd</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> mu</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> f</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> 1</span>)<span class="id"> -&gt;</span><span class="id"> summable</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> *</span><span class="id"> f</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> in01_f;</span><span class="id"> apply/summableMr=&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> 1</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> case/andP:</span> (<span class="id">in01_f</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> ge0_fx</span><span class="id"> le1_fx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ger0_norm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_mlet</span><span class="id"> f</span><span class="id"> mu</span><span class="id"> y</span><span class="id"> :</span><span class="id"> summable</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> *</span> (<span class="id">f</span><span class="id"> x</span>)<span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/summable_mu_wgtd=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> ge0_mu</span><span class="id"> le1_mu1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_in_dlet</span><span class="id"> f</span><span class="id"> g</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> dinsupp</span><span class="id"> mu,</span><span class="id"> f</span><span class="id"> &lt;=2</span><span class="id"> g}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">dlet</span><span class="id"> f</span><span class="id"> mu</span><span class="id"> &lt;=1</span><span class="id"> dlet</span><span class="id"> g</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
                          <span class="comment">(*&nbsp;summable&nbsp;-&gt;&nbsp;refactor&nbsp;*)</span><br/>
<span class="id">move=&gt;</span><span class="id"> le_f;</span><span class="id"> unlock</span><span class="id"> dlet=&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> apply/le_psum/summable_mlet</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> //=;</span><span class="id"> case:</span> (<span class="id">mu</span><span class="id"> x</span><span class="id"> =P</span><span class="id"> 0</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> !mul0r</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/dinsuppPn/le_f/</span>(_<span class="id"> y</span>)<span class="id"> =&gt;</span><span class="id"> h;</span><span class="id"> rewrite</span><span class="id"> ler_pM</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_mu_dlet</span><span class="id"> f</span><span class="id"> mu</span><span class="id"> nu</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> &lt;=1</span><span class="id"> nu</span><span class="id"> -&gt;</span><span class="id"> dlet</span><span class="id"> f</span><span class="id"> mu</span><span class="id"> &lt;=1</span><span class="id"> dlet</span><span class="id"> f</span><span class="id"> nu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> le_mu</span><span class="id"> x;</span><span class="id"> unlock</span><span class="id"> dlet;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> /mlet</span>.<br/>
<span class="id">apply/le_psum/summable_mlet</span><span class="id"> =&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> //=</span>.<br/>
<span class="id">case:</span> (<span class="id">mu</span><span class="id"> y</span><span class="id"> =P</span><span class="id"> 0</span>)<span class="id"> =&gt;</span><span class="id"> [-&gt;|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mul0r</span><span class="id"> mulr_ge0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;/dinsuppPn=&gt;</span><span class="id"> h;</span><span class="id"> rewrite</span><span class="id"> ler_pM</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_dlet</span><span class="id"> f</span><span class="id"> g</span><span class="id"> mu</span><span class="id"> nu</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mu</span><span class="id"> &lt;=1</span><span class="id"> nu</span><br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> {in</span><span class="id"> dinsupp</span><span class="id"> mu,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> &lt;=1</span><span class="id"> g</span><span class="id"> x}</span><br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> \dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> mu</span>)<span class="id"> f</span><span class="id"> x</span><span class="id"> &lt;=1</span><span class="id"> \dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> nu</span>)<span class="id"> g</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> move=&gt;</span><span class="id"> le_mu</span><span class="id"> le_fg</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">le_trans</span> (<span class="id">le_in_dlet</span><span class="id"> le_fg</span><span class="id"> _</span>))<span class="id">/le_mu_dlet</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dletC</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>) (<span class="id">nu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> U</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\dlet_</span>(_<span class="id"> &lt;-</span><span class="id"> mu</span>)<span class="id"> nu</span>)<span class="id"> y</span><span class="id"> =</span> (<span class="id">dweight</span><span class="id"> mu</span>)<span class="id"> *</span> (<span class="id">nu</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> dletE</span><span class="id"> /pr</span><span class="id"> [_</span><span class="id"> *</span><span class="id"> nu</span><span class="id"> y]mulrC</span><span class="id"> -psumZ</span><span class="id"> //=;</span><span class="id"> apply/eq_psum</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /=</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mul1r</span><span class="id"> mulrC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dinsupp_dlet</span><span class="id"> f</span><span class="id"> mu</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">y</span><span class="id"> \in</span><span class="id"> dinsupp</span> (<span class="id">\dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> mu</span>)<span class="id"> f</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span><span class="id"> &amp;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> !=</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/dinsuppP;</span><span class="id"> rewrite</span><span class="id"> dletE</span><span class="id"> =&gt;</span><span class="id"> /neq0_psum</span><span class="id"> [x</span><span class="id"> /eqP];</span><span class="id"> rewrite</span><span class="id"> mulf_eq0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case/norP=&gt;</span><span class="id"> /eqP/dinsuppPn</span><span class="id"> mux</span><span class="id"> nz_fxy;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dlet_dinsupp</span><span class="id"> f</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> dinsupp</span> (<span class="id">dlet</span><span class="id"> f</span><span class="id"> mu</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /dinsuppP</span><span class="id"> /eqP</span><span class="id"> mux</span><span class="id"> nz_fxy;</span><span class="id"> apply/dinsuppP;</span><span class="id"> rewrite</span><span class="id"> dletE</span>.<br/>
<span class="id">move/eq0_psum</span><span class="id"> =&gt;</span><span class="id"> /</span>(_ (<span class="id">summable_mlet</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> /eqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulf_eq0</span> (<span class="id">negbTE</span><span class="id"> mux</span>) (<span class="id">negbTE</span><span class="id"> nz_fxy</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dlet_eq0</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>)<span class="id"> mu</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> dinsupp</span><span class="id"> mu,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> f</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> y}</span><span class="id"> -&gt;</span> (<span class="id">\dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> mu</span>)<span class="id"> dunit</span> (<span class="id">f</span><span class="id"> x</span>))<span class="id"> y</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> h;</span><span class="id"> unlock</span><span class="id"> dlet</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> apply/psum_eq0</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
<span class="id">case/boolP:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span>)<span class="id"> =&gt;</span><span class="id"> [|/dinsuppPn-&gt;];</span><br/>
&nbsp;&nbsp;<span class="id">last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mul0r</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/h;</span><span class="id"> rewrite</span><span class="id"> dunit1E</span><span class="id"> =&gt;</span><span class="id"> /negbTE</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> mulr0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq0_dlet</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> {distr</span><span class="id"> U</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> mu</span>)<span class="id"> F</span><span class="id"> x</span>)<span class="id"> y</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> x</span><span class="id"> y</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">unlock</span><span class="id"> dlet;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> /mlet</span><span class="id"> =&gt;</span><span class="id"> /eq0_psum</span><span class="id"> h</span><span class="id"> x</span><span class="id"> /dinsuppP</span><span class="id"> /eqP</span><span class="id"> mu_x</span>.<br/>
<span class="id">have</span><span class="id"> {}/h:</span><span class="id"> summable</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> *</span><span class="id"> F</span><span class="id"> x</span><span class="id"> y</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/</span>(<span class="id">le_summable</span> (<span class="id">F2</span><span class="id"> :=</span><span class="id"> mu</span>))<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> //=</span><span class="id"> ler_piMr</span><span class="id"> //</span><span class="id"> le1_mu1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/</span>(_<span class="id"> x</span>)<span class="id">/eqP;</span><span class="id"> rewrite</span><span class="id"> mulf_eq0</span> (<span class="id">negbTE</span><span class="id"> mu_x</span>)<span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> /eqP</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="vernacular"> BindTheory</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> DLetDLet</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> V</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">f1</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> distr</span><span class="id"> U</span>) (<span class="id">f2</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> distr</span><span class="id"> V</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __deprecated__dlet_dlet</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> \dlet_</span>(<span class="id">y</span><span class="id"> &lt;-</span><span class="id"> mu</span>)<span class="id"> f1</span><span class="id"> y</span>)<span class="id"> f2</span><span class="id"> x</span><br/>
&nbsp;&nbsp;<span class="id">=1</span><span class="id"> \dlet_</span>(<span class="id">y</span><span class="id"> &lt;-</span><span class="id"> mu</span>) (<span class="id">\dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> f1</span><span class="id"> y</span>)<span class="id"> f2</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> z;</span><span class="id"> unlock</span><span class="id"> dlet</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> /mlet</span><span class="id"> /=</span>.<br/>
<span class="id">pose</span><span class="id"> S</span><span class="id"> y</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> *</span> (<span class="id">f1</span><span class="id"> x</span><span class="id"> y</span><span class="id"> *</span><span class="id"> f2</span><span class="id"> y</span><span class="id"> z</span>).<br/>
<span class="id">rewrite</span> (<span class="id">eq_psum</span> (<span class="id">F2</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> psum</span> (<span class="id">S^~</span><span class="id"> y</span>)))<span class="id"> =&gt;</span><span class="id"> [x|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -psumZ</span><span class="id"> //;</span><span class="id"> apply/eq_psum</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> /=</span>.<br/>
<span class="id">rewrite</span><span class="id"> __admitted__interchange_psum</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> apply/summableZ/summable_mlet</span>.<br/>
<span class="id">+</span><span class="id"> rewrite</span><span class="id"> {}/S;</span><span class="id"> apply/</span>(<span class="id">le_summable</span> (<span class="id">F2</span><span class="id"> :=</span><span class="id"> mu</span>))<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> ge0_psum</span><span class="id"> /=</span><span class="id"> psumZ</span><span class="id"> ?ler_piMr</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">le1_mu</span> (<span class="id">f1</span><span class="id"> x</span>)))<span class="id">/le_psum</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> //=</span><span class="id"> ler_piMr</span><span class="id"> ?le1_mu1</span>.<br/>
<span class="id">apply/eq_psum=&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -psumZr</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_psum=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> {}/S</span><span class="id"> mulrA</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> DLetDLet</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> DLetAlg</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">mu</span><span class="id"> mu1</span><span class="id"> mu2</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dlet_additive</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> {distr</span><span class="id"> U</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> z</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> =</span><span class="id"> mu1</span><span class="id"> x</span><span class="id"> +</span><span class="id"> mu2</span><span class="id"> x</span>)<span class="id"> -&gt;</span> (<span class="id">\dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> mu</span>)<span class="id"> f</span><span class="id"> x</span>)<span class="id"> z</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">\dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> mu1</span>)<span class="id"> f</span><span class="id"> x</span>)<span class="id"> z</span><span class="id"> +</span> (<span class="id">\dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> mu2</span>)<span class="id"> f</span><span class="id"> x</span>)<span class="id"> z</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> muD;</span><span class="id"> rewrite</span><span class="id"> !dletE</span><span class="id"> -psumD</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span>.<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/summable_mlet</span>.<span class="gallina-kwd"> by</span><span class="id"> apply/summable_mlet</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_psum=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -mulrDl</span><span class="id"> -muD</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> DLetAlg</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mlim</span><span class="id"> T</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> distr</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> fine</span> (<span class="id">nlim</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> n</span><span class="id"> x</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> isd_mlim</span><span class="id"> T</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> distr</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> isdistr</span> (<span class="id">mlim</span><span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [x|J];</span><span class="id"> rewrite</span><span class="id"> /mlim</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> nlimP=&gt;</span><span class="id"> //</span><span class="id"> l</span><span class="id"> cvSl;</span><span class="id"> apply/fine_ge0/</span>(<span class="id">ncvg_geC</span><span class="id"> _</span><span class="id"> cvSl</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> apply/ge0_mu</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> uqJ;</span><span class="id"> pose</span><span class="id"> F</span><span class="id"> j</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> `[&lt;</span><span class="id"> iscvg</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> n</span><span class="id"> j</span>)<span class="id"> &gt;]</span><span class="gallina-kwd"> then</span><span class="gallina-kwd"> fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> n</span><span class="id"> j</span><span class="gallina-kwd"> else</span><span class="id"> 0%:S</span>.<br/>
<span class="id">apply/</span>(<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">\sum_</span>(<span class="id">j</span><span class="id"> &lt;-</span><span class="id"> J</span>) (<span class="id">fine</span> (<span class="id">nlim</span> (<span class="id">F</span><span class="id"> j</span>) <span class="comment">(*:&nbsp;R*)</span>)))).<br/>
&nbsp;&nbsp;<span class="id">apply/ler_sum=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /F;</span><span class="id"> case/boolP:</span><span class="id"> `[&lt;</span><span class="id"> _</span><span class="id"> &gt;]</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">move/asboolPn=&gt;</span><span class="id"> h;</span><span class="id"> rewrite</span><span class="id"> nlimC;</span><span class="id"> case:</span><span class="id"> nlimP=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> //</span><span class="id"> l</span><span class="id"> cf;</span><span class="id"> case:</span><span class="id"> h;</span><span class="gallina-kwd"> exists</span><span class="id"> l</span>.<br/>
<span class="id">rewrite</span><span class="id"> -lee_fin</span><span class="id"> -nlim_sumR</span><span class="id"> =&gt;</span><span class="id"> [i</span><span class="id"> _|]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /F;</span><span class="id"> case/boolP:</span><span class="id"> `[&lt;</span><span class="id"> _</span><span class="id"> &gt;]</span><span class="id"> =&gt;</span><span class="id"> [/asboolP</span><span class="id"> //|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _;</span><span class="id"> apply/iscvgC</span>.<br/>
<span class="id">rewrite</span><span class="id"> leNgt;</span><span class="id"> apply/negP;</span><span class="id"> pose</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> \sum_</span>(<span class="id">j</span><span class="id"> &lt;-</span><span class="id"> J</span>)<span class="id"> F</span><span class="id"> j</span><span class="id"> n</span>.<br/>
<span class="id">move/ncvg_gt=&gt;</span><span class="id"> -/</span>(_<span class="id"> s</span> (<span class="id">nlim_ncvg</span><span class="id"> _</span>))<span class="id"> []</span>.<br/>
&nbsp;&nbsp;<span class="id">suff:</span><span class="id"> iscvg</span><span class="id"> s</span><span class="gallina-kwd"> by</span><span class="id"> case=&gt;</span><span class="id"> l</span><span class="id"> cs;</span><span class="gallina-kwd"> exists</span><span class="id"> l%:E</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/iscvg_sum=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /F;</span><span class="id"> case/boolP:</span><span class="id"> `[&lt;</span><span class="id"> _</span><span class="id"> &gt;]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/asboolP</span>.<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> _;</span><span class="id"> apply/iscvgC</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> K</span><span class="id"> /</span>(_<span class="id"> _</span> (<span class="id">leqnn</span><span class="id"> K</span>))<span class="id"> /=;</span><span class="id"> apply/negP;</span><span class="id"> rewrite</span><span class="id"> -leNgt</span>.<br/>
<span class="id">apply/</span>(<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">\sum_</span>(<span class="id">j</span><span class="id"> &lt;-</span><span class="id"> J</span>)<span class="id"> f</span><span class="id"> K</span><span class="id"> j</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /</span>(<span class="id">gerfinseq_psum</span><span class="id"> uqJ</span>)<span class="id"> :=</span><span class="id"> summable_mu</span> (<span class="id">f</span><span class="id"> K</span>).<br/>
&nbsp;&nbsp;<span class="id">move/le_trans=&gt;</span><span class="id"> -/</span>(_<span class="id"> _</span> (<span class="id">le1_mu</span> (<span class="id">f</span><span class="id"> K</span>)))<span class="id">=&gt;</span><span class="id"> h</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">le_trans</span><span class="id"> _</span><span class="id"> h</span>)<span class="id">/ler_sum=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> apply/ler_norm</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/ler_sum=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /F;</span><span class="id"> case/boolP:</span><span class="id"> `[&lt;</span><span class="id"> _</span><span class="id"> &gt;]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> dlim</span><span class="id"> T</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> distr</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">locked</span> (<span class="id">mkdistr</span> (<span class="id">isd_mlim</span><span class="id"> f</span>)).<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;\dlim_ ( n ) E&quot;</span><span class="id"> :=</span> (<span class="id">dlim</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> E</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dlimE</span><span class="id"> T</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> distr</span><span class="id"> T</span>)<span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">\dlim_</span>(<span class="id">n</span>)<span class="id"> f</span><span class="id"> n</span>)<span class="id"> x</span><span class="id"> =</span><span class="id"> fine</span> (<span class="id">nlim</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> n</span><span class="id"> x</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> unlock</span><span class="id"> dlim</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> DLimTheory</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> choiceType</span>).<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> distr</span><span class="id"> T</span>) (<span class="id">h</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> {distr</span><span class="id"> U</span><span class="id"> /</span><span class="id"> R}</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dlimC</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> \dlim_</span>(<span class="id">n</span>)<span class="id"> mu</span><span class="id"> =1</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !dlimE;</span><span class="id"> rewrite</span><span class="id"> nlimC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_dlim</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> f</span><span class="id"> =2</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> dlim</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> dlim</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_f;</span><span class="id"> unlock</span><span class="id"> dlim=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> /mlim;</span><span class="id"> congr</span> (_<span class="id"> _</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_nlim</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> eq_f</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_from_dlim</span><span class="id"> K</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n,</span> (<span class="id">K</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> n</span><span class="id"> =1</span><span class="id"> g</span><span class="id"> n</span>)<span class="id"> -&gt;</span><span class="id"> dlim</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> dlim</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_fg</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !dlimE;</span><span class="id"> congr</span> (_<span class="id"> _</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">eq_from_nlim</span> (<span class="id">K</span><span class="id"> :=</span><span class="id"> K</span>))<span class="id">;</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> /eq_fg</span><span class="id"> /</span>(_<span class="id"> x</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> dlim_bump</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">dlim</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> mu</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id"> =1</span><span class="id"> dlim</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !dlimE</span><span class="id"> -[in</span><span class="id"> RHS]nlim_bump</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> dlim_lift</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> p</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">dlim</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> mu</span> (<span class="id">n</span><span class="id"> +</span><span class="id"> p</span>)<span class="id">%N</span>)<span class="id"> =1</span><span class="id"> dlim</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !dlimE</span> (<span class="id">nlim_lift</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span> (<span class="id">mu</span><span class="id"> n</span>)<span class="id"> x</span>)). Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> dcvg</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="gallina-kwd"> exists</span><span class="id"> l,</span><span class="id"> ncvg</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> l</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> ducvg</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> l,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> ncvg</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> l</span>.<br/>
<br/>
<span class="vernacular">CoInductive</span><span class="id"> dlim_spec</span><span class="id"> f</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><br/>
<span class="id">|</span><span class="id"> DLimCvg</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> l</span><span class="id"> :</span><span class="id"> R,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> l</span><span class="id"> -&gt;</span><span class="id"> l</span><span class="id"> &lt;=</span><span class="id"> 1</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ncvg</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> l%:E</span><span class="id"> -&gt;</span><span class="id"> dlim_spec</span><span class="id"> f</span><span class="id"> x</span><span class="id"> l</span><br/>
<br/>
<span class="id">|</span><span class="id"> DLimOut</span><span class="id"> :</span><span class="id"> ~</span> (<span class="gallina-kwd">exists</span><span class="id"> l</span><span class="id"> :</span><span class="id"> \bar</span><span class="id"> R,</span><span class="id"> ncvg</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> l</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dlim_spec</span><span class="id"> f</span><span class="id"> x</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dlimP</span><span class="id"> f</span><span class="id"> x</span><span class="id"> :</span><span class="id"> dlim_spec</span><span class="id"> f</span><span class="id"> x</span> (<span class="id">dlim</span><span class="id"> f</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> dlimE;</span><span class="id"> case:</span><span class="id"> nlimP</span><span class="id"> =&gt;</span><span class="id"> [l</span><span class="id"> h|?]</span><span class="id"> /=;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/DLimOut</span>.<br/>
<span class="id">have:</span> (<span class="id">0%:E</span><span class="id"> &lt;=</span><span class="id"> l</span>)<span class="id">%E</span><span class="gallina-kwd"> by</span><span class="id"> apply/ncvg_geC:</span><span class="id"> h</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> apply/ge0_mu</span>.<br/>
<span class="id">have:</span> (<span class="id">l</span><span class="id"> &lt;=</span><span class="id"> 1%:E</span>)<span class="id">%E</span><span class="gallina-kwd"> by</span><span class="id"> apply/ncvg_leC:</span><span class="id"> h</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> apply/le1_mu1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> l</span><span class="id"> h</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> l</span><span class="id"> h</span><span class="id"> /=</span><span class="id"> ge0_l</span><span class="id"> ge1_;</span><span class="id"> apply/DLimCvg</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dcvgP</span><span class="id"> f</span><span class="id"> :</span><span class="id"> dcvg</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> l,</span> (<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> l</span><span class="id"> &lt;=</span><span class="id"> 1</span>)<span class="id"> &amp;</span><span class="id"> ncvg</span> (<span class="id">f^~</span><span class="id"> x</span>)<span class="id"> l%:E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> cv_f</span><span class="id"> x;</span><span class="id"> case:</span> (<span class="id">dlimP</span><span class="id"> f</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> [l</span><span class="id"> ge0_l</span><span class="id"> le1_l</span><span class="id"> cv|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> l</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply/andP;</span><span class="id"> split</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case;</span><span class="id"> case:</span> (<span class="id">cv_f</span><span class="id"> x</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dcvg_homo</span><span class="id"> f</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n</span><span class="id"> m,</span> (<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> m</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> n</span><span class="id"> &lt;=1</span><span class="id"> f</span><span class="id"> m</span>)<span class="id"> -&gt;</span><span class="id"> dcvg</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mn_f</span><span class="id"> x;</span><span class="id"> have:</span><span class="gallina-kwd"> forall</span><span class="id"> n</span><span class="id"> m,</span> (<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> m</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> n</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> f</span><span class="id"> m</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> n</span><span class="id"> m</span><span class="id"> /mn_f;</span><span class="id"> apply</span>.<br/>
<span class="id">case/ncvg_mono_bnd</span><span class="id"> =&gt;</span><span class="id"> {mn_f};</span><span class="id"> first</span><span class="id"> apply/asboolP/nboundedP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> 2%:R</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n;</span><span class="id"> apply/</span>(<span class="id">@le_lt_trans</span><span class="id"> _</span><span class="id"> _</span><span class="id"> 1%:R</span>)<span class="id">/ltr_nat</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ger0_norm</span><span class="id"> //</span><span class="id"> le1_mu1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> h;</span><span class="gallina-kwd"> exists</span><span class="id"> y%:E</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ge0_dlim</span><span class="id"> f</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> dlim</span><span class="id"> f</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> case:</span><span class="id"> dlimP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le1_dlim</span><span class="id"> f</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> dlim</span><span class="id"> f</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> case:</span><span class="id"> dlimP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _;</span><span class="id"> apply/ler01</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_dlim</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> f</span><span class="id"> n</span><span class="id"> &lt;=1</span><span class="id"> g</span><span class="id"> n</span>)<span class="id"> -&gt;</span><span class="id"> dcvg</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> dlim</span><span class="id"> f</span><span class="id"> &lt;=1</span><span class="id"> dlim</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> le</span><span class="id"> dcvg_g</span><span class="id"> x;</span><span class="id"> case:</span><span class="id"> dlimP</span><span class="id"> =&gt;</span><span class="id"> [|_];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/ge0_dlim</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> l</span><span class="id"> _</span><span class="id"> _</span><span class="id"> h;</span><span class="id"> case:</span><span class="id"> dlimP</span><span class="id"> =&gt;</span><span class="id"> [l'</span><span class="id"> _</span><span class="id"> _</span><span class="id"> h'|];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> case</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -lee_fin;</span><span class="id"> apply/</span>(<span class="id">ncvg_le</span><span class="id"> _</span><span class="id"> h'</span><span class="id"> h</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> leub_dlim</span><span class="id"> f</span><span class="id"> mu</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> n,</span><span class="id"> f</span><span class="id"> n</span><span class="id"> &lt;=1</span><span class="id"> mu</span>)<span class="id"> -&gt;</span><span class="id"> dlim</span><span class="id"> f</span><span class="id"> &lt;=1</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> le</span><span class="id"> x;</span><span class="id"> apply/</span>(<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> ((<span class="id">\dlim_</span>(<span class="id">n</span>)<span class="id"> mu</span>)<span class="id"> x</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/le_dlim</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> y;</span><span class="gallina-kwd"> exists</span> (<span class="id">mu</span><span class="id"> y</span>)<span class="id">%:E;</span><span class="id"> apply/ncvgC</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> dlimE</span><span class="id"> nlimC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dlim_ub</span><span class="id"> f</span><span class="id"> k</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n</span><span class="id"> m,</span> (<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> m</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> n</span><span class="id"> &lt;=1</span><span class="id"> f</span><span class="id"> m</span>)<span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> k</span><span class="id"> &lt;=1</span><span class="id"> dlim</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> mn_f</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> dlimE</span><span class="id"> -lee_fin;</span><span class="id"> pose</span><span class="id"> u</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> f</span><span class="id"> n</span><span class="id"> x</span>.<br/>
<span class="id">apply/</span>(<span class="id">ncvg_homo_le</span> (<span class="id">u</span><span class="id"> :=</span><span class="id"> u</span>))<span class="id">=&gt;</span><span class="id"> [m</span><span class="id"> n</span><span class="id"> /mn_f|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply</span>.<br/>
<span class="id">move/dcvg_homo:</span><span class="id"> mn_f</span><span class="id"> =&gt;</span><span class="id"> /dcvgP</span><span class="id"> /</span>(_<span class="id"> x</span>)<span class="id"> [l</span><span class="id"> _]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> cv;</span><span class="id"> rewrite</span> (<span class="id">nlimE</span><span class="id"> cv</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __admitted__dlet_lim</span><span class="id"> f</span><span class="id"> h</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> n</span><span class="id"> m,</span> (<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> m</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> n</span><span class="id"> &lt;=1</span><span class="id"> f</span><span class="id"> m</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> dlim</span><span class="id"> f</span>)<span class="id"> h</span><span class="id"> x</span><span class="id"> =1</span><span class="id"> \dlim_</span>(<span class="id">n</span>)<span class="id"> \dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> f</span><span class="id"> n</span>)<span class="id"> h</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
 Admitted.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __admitted__dlim_let</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> {distr</span><span class="id"> U</span><span class="id"> /</span><span class="id"> R}</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> n</span><span class="id"> m,</span> (<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> m</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> n</span><span class="id"> x</span><span class="id"> &lt;=1</span><span class="id"> f</span><span class="id"> m</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\dlim_</span>(<span class="id">n</span>)<span class="id"> \dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> mu</span>) (<span class="id">f</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> mu</span>)<span class="id"> \dlim_</span>(<span class="id">n</span>) (<span class="id">f</span><span class="id"> n</span><span class="id"> x</span>).<br/>
<span class="vernacular">Proof</span><span class="gallina-kwd"> using</span><span class="gallina-kwd"> Type</span>.<span class="vernacular">End</span><span class="id"> DLimTheory</span>.<br/>
<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;lacks proof, use __admitted__dlet_lim explicitly if you really want to use this lemma&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> dlet_lim</span><span class="id"> :=</span><span class="id"> __admitted__dlet_lim</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;lacks proof, use __admitted__dlim_let explicitly if you really want to use this lemma&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> dlim_let</span><span class="id"> :=</span><span class="id"> __admitted__dlim_let</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Marginals</span>.<br/>
<span class="vernacular">Variable</span> (<span class="id">T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> choiceType</span>) (<span class="id">h</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> distr</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> dmargin</span><span class="id"> :=</span><span class="id"> \dlet_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> mu</span>) (<span class="id">dunit</span> (<span class="id">h</span><span class="id"> x</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dmarginE</span><span class="id"> :</span><span class="id"> dmargin</span><span class="id"> =</span><span class="id"> \dlet_</span>(<span class="id">y</span><span class="id"> &lt;-</span><span class="id"> mu</span>) (<span class="id">dunit</span> (<span class="id">h</span><span class="id"> y</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">End</span><span class="id"> Marginals</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> MarginalsTh</span>.<br/>
<span class="vernacular">Variable</span> (<span class="id">T</span><span class="id"> U</span><span class="id"> V</span><span class="id"> :</span><span class="id"> choiceType</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dmargin_psumE</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>)<span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">dmargin</span><span class="id"> f</span><span class="id"> mu</span>)<span class="id"> y</span><span class="id"> =</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> mu</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> dmarginE</span><span class="id"> dletE;</span><span class="id"> apply/eq_psum</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulrC</span><span class="id"> dunit1E</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __deprecated__dlet_dmargin</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> {distr</span><span class="id"> V</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">\dlet_</span>(<span class="id">u</span><span class="id"> &lt;-</span><span class="id"> dmargin</span><span class="id"> f</span><span class="id"> mu</span>)<span class="id"> g</span><span class="id"> u</span><span class="id"> =1</span><span class="id"> \dlet_</span>(<span class="id">t</span><span class="id"> &lt;-</span><span class="id"> mu</span>) (<span class="id">g</span> (<span class="id">f</span><span class="id"> t</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> __deprecated__dlet_dlet;</span><span class="id"> apply:</span><span class="id"> eq_in_dlet=&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> _</span><span class="id"> z;</span><span class="id"> rewrite</span><span class="id"> dlet_unit</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __deprecated__dmargin_dlet</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> V</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> {distr</span><span class="id"> U</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">dmargin</span><span class="id"> f</span> (<span class="id">\dlet_</span>(<span class="id">t</span><span class="id"> &lt;-</span><span class="id"> mu</span>)<span class="id"> g</span><span class="id"> t</span>)<span class="id"> =1</span><span class="id"> \dlet_</span>(<span class="id">t</span><span class="id"> &lt;-</span><span class="id"> mu</span>) (<span class="id">dmargin</span><span class="id"> f</span> (<span class="id">g</span><span class="id"> t</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/__deprecated__dlet_dlet</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dmargin_dunit</span> (<span class="id">t</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>)<span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">dmargin</span><span class="id"> f</span> (<span class="id">dunit</span><span class="id"> t</span>)<span class="id"> =1</span><span class="id"> dunit</span> (<span class="id">f</span><span class="id"> t</span>)<span class="id"> :&gt;</span><span class="id"> {distr</span><span class="id"> U</span><span class="id"> /</span><span class="id"> R}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/dlet_unit</span>. Qed.</div></details>
<span class="vernacular">End</span><span class="id"> MarginalsTh</span>.<br/>
<span class="vernacular">End</span><span class="id"> Std</span>.<br/>
<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;relies on admitted, use __deprecated__dlet_dlet explicitly if you really want to use this lemma&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> dlet_dlet</span><span class="id"> :=</span><span class="id"> __deprecated__dlet_dlet</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;relies on admitted, use __deprecated__dmargin_dlet explicitly if you really want to use this lemma&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> dmargin_dlet</span><span class="id"> :=</span><span class="id"> __deprecated__dmargin_dlet</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;relies on admitted, use __deprecated__dlet_dmargin explicitly if you really want to use this lemma&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> dlet_dmargin</span><span class="id"> :=</span><span class="id"> __deprecated__dlet_dmargin</span>.<br/>
<br/>
<span class="vernacular">Notation</span><span class="id"> dfst</span><span class="id"> mu</span><span class="id"> :=</span> (<span class="id">dmargin</span><span class="id"> fst</span><span class="id"> mu</span>).<br/>
<span class="vernacular">Notation</span><span class="id"> dsnd</span><span class="id"> mu</span><span class="id"> :=</span> (<span class="id">dmargin</span><span class="id"> snd</span><span class="id"> mu</span>).<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;\dlet_ ( i &lt;- d ) E&quot;</span><span class="id"> :=</span> (<span class="id">dlet</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> E</span>)<span class="id"> d</span>).<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;\dlim_ ( n ) E&quot;</span><span class="id"> :=</span> (<span class="id">dlim</span> (<span class="gallina-kwd">fun</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> E</span>)).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> DSwap</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span> (<span class="id">A</span><span class="id"> *</span><span class="id"> B</span>)<span class="id"> /</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> dswap</span><span class="id"> :</span><span class="id"> {distr</span> (<span class="id">B</span><span class="id"> *</span><span class="id"> A</span>)<span class="id"> /</span><span class="id"> R}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">dmargin</span> (<span class="gallina-kwd">fun</span><span class="id"> xy</span><span class="id"> =&gt;</span> (<span class="id">xy</span>.<span class="id">2,</span><span class="id"> xy</span>.<span class="id">1</span>))<span class="id"> mu</span>.<br/>
<span class="vernacular">End</span><span class="id"> DSwap</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> DSwapCoreTheory</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span> (<span class="id">A</span><span class="id"> *</span><span class="id"> B</span>)<span class="id"> /</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dswapE</span><span class="id"> xy</span><span class="id"> :</span><span class="id"> dswap</span><span class="id"> mu</span><span class="id"> xy</span><span class="id"> =</span><span class="id"> mu</span> (<span class="id">xy</span>.<span class="id">2,</span><span class="id"> xy</span>.<span class="id">1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> dletE</span><span class="id"> /=</span> (<span class="id">psum_finseq</span> (<span class="id">r</span><span class="id"> :=</span><span class="id"> [::</span> (<span class="id">xy</span>.<span class="id">2,</span><span class="id"> xy</span>.<span class="id">1</span>)<span class="id">]</span>))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> a</span><span class="id"> b;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> dunit1E</span><span class="id"> /=</span><span class="id"> mulf_eq0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/norP=&gt;</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> pnatr_eq0</span><span class="id"> eqb0</span><span class="id"> negbK=&gt;</span><span class="id"> /eqP</span><span class="id"> &lt;-</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> xy=&gt;</span><span class="id"> x</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> big_seq1</span><span class="id"> dunit1E</span><span class="id"> /=</span><span class="id"> eqxx</span><span class="id"> mulr1</span><span class="id"> ger0_norm</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> DSwapCoreTheory</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> DSwapTheory</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> choiceType}</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span> (<span class="id">A</span><span class="id"> *</span><span class="id"> B</span>)<span class="id"> /</span><span class="id"> R}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dswapK</span><span class="id"> :</span><span class="id"> dswap</span> (<span class="id">dswap</span><span class="id"> mu</span>)<span class="id"> =1</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case=&gt;</span><span class="id"> x</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> !dswapE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dinsupp_swap</span><span class="id"> xy</span><span class="id"> :</span> (<span class="id">xy</span>.<span class="id">2,</span><span class="id"> xy</span>.<span class="id">1</span>)<span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">xy</span><span class="id"> \in</span><span class="id"> dinsupp</span> (<span class="id">dswap</span><span class="id"> mu</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> h;</span><span class="id"> apply/dinsuppP;</span><span class="id"> rewrite</span><span class="id"> dswapE;</span><span class="id"> apply/dinsuppPn</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __deprecated__dfst_dswap</span><span class="id"> :</span><span class="id"> dfst</span> (<span class="id">dswap</span><span class="id"> mu</span>)<span class="id"> =1</span><span class="id"> dsnd</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> z;</span><span class="id"> rewrite</span><span class="id"> __deprecated__dlet_dlet;</span><span class="id"> apply/eq_in_dlet</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[x</span><span class="id"> y]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> t</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> dlet_unit</span><span class="id"> /=</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __deprecated__dsnd_dswap</span><span class="id"> :</span><span class="id"> dsnd</span> (<span class="id">dswap</span><span class="id"> mu</span>)<span class="id"> =1</span><span class="id"> dfst</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> z;</span><span class="id"> rewrite</span><span class="id"> __deprecated__dlet_dlet;</span><span class="id"> apply/eq_in_dlet</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[x</span><span class="id"> y]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> t</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> dlet_unit</span><span class="id"> /=</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> DSwapTheory</span>.<br/>
<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;relies on admitted, use __deprecated__dfst_dswap explicitly if you really want to use this lemma&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> dfst_dswap</span><span class="id"> :=</span><span class="id"> __deprecated__dfst_dswap</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;relies on admitted, use __deprecated__dsnd_dswap explicitly if you really want to use this lemma&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> dsnd_dswap</span><span class="id"> :=</span><span class="id"> __deprecated__dsnd_dswap</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> DFst</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> choiceType}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dfstE</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> U</span>)<span class="id"> /</span> <span class="id"> R}</span>)<span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">dfst</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> =</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> mu</span> (<span class="id">x,</span><span class="id"> y</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> dmargin_psumE</span><span class="id"> /=;</span><span class="id"> pose</span><span class="id"> h</span><span class="id"> y</span><span class="id"> :</span><span class="id"> T</span><span class="id"> *</span><span class="id"> U</span><span class="id"> :=</span> (<span class="id">x,</span><span class="id"> y</span>).<br/>
<span class="id">rewrite</span> (<span class="id">reindex_psum</span> (<span class="id">P</span><span class="id"> :=</span><span class="id"> [pred</span><span class="id"> z</span><span class="id"> |</span><span class="id"> z</span>.<span class="id">1</span><span class="id"> ==</span><span class="id"> x]</span>) (<span class="id">h</span><span class="id"> :=</span><span class="id"> h</span>))<span class="id"> /=</span>.<br/>
<span class="id">+</span><span class="id"> case=&gt;</span><span class="id"> a</span><span class="id"> b;</span><span class="id"> rewrite</span><span class="id"> !inE/=</span><span class="id"> mulf_eq0</span><span class="id"> =&gt;</span><span class="id"> /norP[]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> pnatr_eq0</span><span class="id"> eqb0</span><span class="id"> negbK</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> snd</span><span class="id"> =&gt;</span><span class="id"> [z|[z1</span><span class="id"> z2]];</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> //=</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_psum</span><span class="id"> =&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> eqxx</span><span class="id"> mul1r</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_fst</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> U</span>)<span class="id"> /</span><span class="id"> R}</span>)<span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> mu</span> (<span class="id">x,</span><span class="id"> y</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> /summable_seqP</span><span class="id"> /=</span><span class="id"> :=</span><span class="id"> summable_mu</span><span class="id"> mu</span><span class="id"> =&gt;</span><span class="id"> -[M</span><span class="id"> ge0_M</span><span class="id"> h]</span>.<br/>
<span class="id">apply/summable_seqP;</span><span class="gallina-kwd"> exists</span><span class="id"> M</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> J</span><span class="id"> uqJ;</span><span class="id"> pose</span><span class="id"> X</span><span class="id"> :=</span><span class="id"> [seq</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> |</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> J]</span>.<br/>
<span class="id">apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">h</span><span class="id"> X</span><span class="id"> _</span>))<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> map_inj_uniq</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> y1</span><span class="id"> y2</span><span class="id"> []</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> le_eqVlt</span><span class="id"> big_map</span><span class="id"> eqxx</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> DFst</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> DSnd</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> choiceType}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __deprecated__dsndE</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> U</span>)<span class="id"> /</span><span class="id"> R}</span>)<span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">dsnd</span><span class="id"> mu</span><span class="id"> y</span><span class="id"> =</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> mu</span> (<span class="id">x,</span><span class="id"> y</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -__deprecated__dfst_dswap</span><span class="id"> dfstE;</span><span class="id"> apply/eq_psum=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> dswapE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_snd</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> U</span>)<span class="id"> /</span><span class="id"> R}</span>)<span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">summable</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> mu</span> (<span class="id">x,</span><span class="id"> y</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> :=</span><span class="id"> summable_fst</span> (<span class="id">dswap</span><span class="id"> mu</span>)<span class="id"> y;</span><span class="id"> apply/eq_summable</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> dswapE</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> DSnd</span>.<br/>
<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;relies on admitted, use __deprecated__dsndE explicitly if you really want to use this lemma&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> dsndE</span><span class="id"> :=</span><span class="id"> __deprecated__dsndE</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PrCoreTheory</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> choiceType}</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>) (<span class="id">A</span><span class="id"> B</span><span class="id"> E</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_pr</span><span class="id"> E</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> summable</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">E</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> mu</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/</span>(<span class="id">le_summable</span> (<span class="id">F2</span><span class="id"> :=</span><span class="id"> mu</span>))<span class="id"> =&gt;</span><span class="id"> [x|];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/summable_mu</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> ?ler0n</span><span class="id"> //=</span><span class="id"> ler_piMl</span><span class="id"> //</span><span class="id"> lern1</span><span class="id"> leq_b1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_pred0</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> \P_[mu]</span><span class="id"> pred0</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /pr</span><span class="id"> psum_eq0</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> mul0r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_pred1</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> :</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> =</span><span class="id"> \P_[mu]</span> (<span class="id">pred1</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /pr</span> (<span class="id">psum_finseq</span> (<span class="id">r</span><span class="id"> :=</span><span class="id"> [::</span><span class="id"> x]</span>))<span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> [y|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE;</span><span class="id"> case:</span> (<span class="id">y</span><span class="id"> =P</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">mul0r,</span><span class="id"> eqxx</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_seq1</span><span class="id"> /=</span><span class="id"> eqxx</span><span class="id"> mul1r</span><span class="id"> ger0_norm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_exp</span><span class="id"> mu</span> (<span class="id">E</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> \P_[mu]</span><span class="id"> E</span><span class="id"> =</span><span class="id"> \E_[mu]</span> (<span class="gallina-kwd">fun</span><span class="id"> m</span><span class="id"> =&gt;</span> (<span class="id">E</span><span class="id"> m</span>)<span class="id">%:R</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /pr</span><span class="id"> psum_sum</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> //</span><span class="id"> ler0n</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_predT</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> \P_[mu]</span><span class="id"> predT</span><span class="id"> =</span><span class="id"> psum</span><span class="id"> mu</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/eq_psum=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mul1r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_dunit</span><span class="id"> E</span><span class="id"> x</span><span class="id"> :</span><span class="id"> \P_[dunit</span><span class="id"> x]</span><span class="id"> E</span><span class="id"> =</span> (<span class="id">E</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> :&gt;</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /pr</span> (<span class="id">psum_finseq</span> (<span class="id">r</span><span class="id"> :=</span><span class="id"> [::</span><span class="id"> x]</span>))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> dunit1E</span><span class="id"> [x==_]eq_sym</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">y</span><span class="id"> =P</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> mulr0</span><span class="id"> eqxx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_seq1</span><span class="id"> dunit1E</span><span class="id"> eqxx</span><span class="id"> mulr1</span><span class="id"> ger0_norm</span><span class="id"> ?ler0n</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> exp_dunit</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> \E_[dunit</span><span class="id"> x]</span><span class="id"> f</span><span class="id"> =</span><span class="id"> f</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /esp</span> (<span class="id">sum_seq1</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> [y|];</span><span class="id"> rewrite</span><span class="id"> dunit1E</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">x</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> mulr0</span><span class="id"> eqxx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqxx</span><span class="id"> mulr1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> exp_cst</span><span class="id"> mu</span><span class="id"> r</span><span class="id"> :</span><span class="id"> \E_[mu]</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> r</span>)<span class="id"> =</span><span class="id"> \P_[mu]</span><span class="id"> predT</span><span class="id"> *</span><span class="id"> r</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> pr_predT</span><span class="id"> psum_sum</span><span class="id"> //</span><span class="id"> [RHS]mulrC</span><span class="id"> -sumZ;</span><span class="id"> apply/eq_sum</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> exp0</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> \E_[mu]</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> 0</span>)<span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> exp_cst</span><span class="id"> mulr0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_expC</span><span class="id"> mu</span><span class="id"> c</span><span class="id"> :</span><span class="id"> \E?_[mu]</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> c</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/summableMl</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> `|c|</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_exp0</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> \E?_[mu]</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> 0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/</span>(<span class="id">has_expC</span><span class="id"> mu</span><span class="id"> 0</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_exp1</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> \E?_[mu]</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> 1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/</span>(<span class="id">has_expC</span><span class="id"> mu</span><span class="id"> 1</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_expZ</span><span class="id"> mu</span><span class="id"> c</span><span class="id"> F</span><span class="id"> :</span><span class="id"> \E?_[mu]</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> \E?_[mu]</span> (<span class="id">c</span><span class="id"> \*o</span><span class="id"> F</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> heF;</span><span class="id"> have:</span><span class="id"> summable</span> (<span class="id">c</span><span class="id"> \*o</span> (<span class="id">F</span><span class="id"> \*</span><span class="id"> mu</span>))<span class="gallina-kwd"> by</span><span class="id"> apply/summableZ</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_summable</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> mulrA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> expZ</span><span class="id"> mu</span><span class="id"> F</span><span class="id"> c</span><span class="id"> :</span><span class="id"> \E_[mu]</span> (<span class="id">c</span><span class="id"> \*o</span><span class="id"> F</span>)<span class="id"> =</span><span class="id"> c</span><span class="id"> *</span><span class="id"> \E_[mu]</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -sumZ;</span><span class="id"> apply/eq_sum=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> mulrA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ge0_pr</span><span class="id"> A</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> \P_[mu]</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/ge0_psum</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ge0_prc</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> \P_[mu,</span><span class="id"> B]</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /prc</span><span class="id"> mulr_ge0</span><span class="id"> ?invr_ge0</span><span class="id"> //</span><span class="id"> ge0_pr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_in_pr</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mu</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> dinsupp</span><span class="id"> mu,</span><span class="id"> A</span><span class="id"> =i</span><span class="id"> B}</span><span class="id"> -&gt;</span><span class="id"> \P_[mu]</span><span class="id"> A</span><span class="id"> =</span><span class="id"> \P_[mu]</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_AB;</span><span class="id"> apply/eq_psum</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> case/boolP:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/eq_AB;</span><span class="id"> rewrite</span><span class="id"> -!topredE</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/dinsuppPn=&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> !mulr0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_pr</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> A</span><span class="id"> =i</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> \P_[mu]</span><span class="id"> A</span><span class="id"> =</span><span class="id"> \P_[mu]</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq_AB;</span><span class="id"> apply/eq_in_pr=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> apply/eq_AB</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_exp</span><span class="id"> mu</span> (<span class="id">f1</span><span class="id"> f2</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id">:</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">{in</span><span class="id"> dinsupp</span><span class="id"> mu,</span><span class="id"> f1</span><span class="id"> =1</span><span class="id"> f2}</span><span class="id"> -&gt;</span><span class="id"> \E_[mu]</span><span class="id"> f1</span><span class="id"> =</span><span class="id"> \E_[mu]</span><span class="id"> f2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_f;</span><span class="id"> apply/eq_sum</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> case/boolP:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/eq_f=&gt;</span><span class="id"> -&gt;</span>.<span class="gallina-kwd"> by</span><span class="id"> move/dinsuppPn=&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> !mulr0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_pred0_eq</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>) (<span class="id">E</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">E</span><span class="id"> =1</span><span class="id"> pred0</span><span class="id"> -&gt;</span><span class="id"> \P_[mu]</span><span class="id"> E</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">pr_pred0</span><span class="id"> mu</span>)<span class="id">;</span><span class="id"> apply/eq_pr</span>. Qed.</div></details>
<span class="vernacular">End</span><span class="id"> PrCoreTheory</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PrTheory</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {T</span><span class="id"> U</span><span class="id"> :</span><span class="id"> choiceType}</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> eqType}</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>) (<span class="id">A</span><span class="id"> B</span><span class="id"> E</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __deprecated__pr_dlet</span><span class="id"> E</span><span class="id"> f</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> U</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\P_[dlet</span><span class="id"> f</span><span class="id"> mu]</span><span class="id"> E</span><span class="id"> =</span><span class="id"> \E_[mu]</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> \P_[f</span><span class="id"> x]</span><span class="id"> E</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /esp</span><span class="id"> -psum_sum</span><span class="id"> =&gt;</span><span class="id"> [x|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> ?ge0_pr</span>.<br/>
<span class="id">rewrite</span><span class="id"> /pr;</span><span class="id"> unlock</span><span class="id"> dlet</span><span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> /mlet</span><span class="id"> /=</span>.<br/>
<span class="id">pose</span><span class="id"> F</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :=</span> (<span class="id">E</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span> (<span class="id">mu</span><span class="id"> y</span><span class="id"> *</span><span class="id"> f</span><span class="id"> y</span><span class="id"> x</span>).<br/>
<span class="id">transitivity</span> (<span class="id">psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> psum</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> F</span><span class="id"> x</span><span class="id"> y</span>)))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> {}/F</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eq_psum</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -psumZ</span><span class="id"> ?ler0n</span>.<br/>
<span class="id">rewrite</span><span class="id"> __admitted__interchange_psum</span><span class="id"> /=;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eq_psum=&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> mulrC</span><span class="id"> -psumZ</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eq_psum=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> mulrCA</span>.<br/>
<span class="id">+</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> summable_pr</span><span class="id"> E</span> (<span class="id">dlet</span><span class="id"> f</span><span class="id"> mu</span>)<span class="id">;</span><span class="id"> apply/eq_summable</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> dletE</span><span class="id"> psumZ</span><span class="id"> ?ler0n</span>.<br/>
<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> y;</span><span class="id"> apply/summable_condl/summable_mlet</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_dmargin</span><span class="id"> E</span><span class="id"> f</span> (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> U</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\P_[dmargin</span><span class="id"> f</span><span class="id"> mu]</span><span class="id"> E</span><span class="id"> =</span><span class="id"> \P_[mu]</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> f</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> E]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /dmargin</span><span class="id"> __deprecated__pr_dlet</span><span class="id"> pr_exp;</span><span class="id"> apply/eq_exp=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> pr_dunit</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq0_pr</span><span class="id"> A</span><span class="id"> mu</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> A</span>)<span class="id"> -&gt;</span><span class="id"> \P_[mu]</span><span class="id"> A</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> h;</span><span class="id"> apply/psum_eq0=&gt;</span><span class="id"> x;</span><span class="id"> apply/eqP</span>.<br/>
<span class="id">rewrite</span><span class="id"> mulf_eq0</span><span class="id"> orbC;</span><span class="id"> case/boolP:</span> (<span class="id">mu</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> 0</span>)<span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/h;</span><span class="id"> rewrite</span><span class="id"> -topredE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> /negbTE-&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq0_prc</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mu</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> A</span>)<br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> \P_[mu,</span><span class="id"> B]</span><span class="id"> A</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> h;</span><span class="id"> rewrite</span><span class="id"> /prc</span><span class="id"> eq0_pr</span><span class="id"> ?mul0r</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /h</span><span class="id"> {h}</span><span class="id"> /orb_idl</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> negb_and</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> &lt;-;</span><span class="id"> rewrite</span><span class="id"> orbAC</span><span class="id"> orbN</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subset_pr</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> {subset</span><span class="id"> B</span><span class="id"> &lt;=</span><span class="id"> A}</span><span class="id"> -&gt;</span><span class="id"> \P_[mu]</span><span class="id"> B</span><span class="id"> &lt;=</span><span class="id"> \P_[mu]</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> le_BA;</span><span class="id"> apply/le_psum;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/summableMl</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> 1=&gt;</span><span class="id"> //</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ger0_norm</span><span class="id"> ?</span>(<span class="id">ler0n,</span><span class="id"> lern1</span>)<span class="id"> ?leq_b1</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> ?ler0n</span><span class="id"> ?ler_wpM2r</span><span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> ler_nat;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> le_BA</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -!topredE</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">B</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le1_pr</span><span class="id"> A</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> \P_[mu]</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/</span>(<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span><span class="id"> \P_[mu]</span><span class="id"> predT</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/subset_pr</span>.<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> pr_predT</span><span class="id"> le1_mu</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_exp</span><span class="id"> mu</span><span class="id"> f1</span><span class="id"> f2:</span><span class="id"> \E?_[mu]</span><span class="id"> f1</span><span class="id"> -&gt;</span><span class="id"> \E?_[mu]</span><span class="id"> f2</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">f1</span><span class="id"> &lt;=1</span><span class="id"> f2</span><span class="id"> -&gt;</span><span class="id"> \E_[mu]</span><span class="id"> f1</span><span class="id"> &lt;=</span><span class="id"> \E_[mu]</span><span class="id"> f2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sm1</span><span class="id"> sm2</span><span class="id"> le_f;</span><span class="id"> apply/le_sum</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> ler_wpM2r</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_in_pr</span><span class="id"> E1</span><span class="id"> E2</span><span class="id"> mu</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> E1</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> E2</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\P_[mu]</span><span class="id"> E1</span><span class="id"> &lt;=</span><span class="id"> \P_[mu]</span><span class="id"> E2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> le;</span><span class="id"> rewrite</span><span class="id"> /pr;</span><span class="id"> apply/le_psum;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/summable_pr</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> ?ler0n</span><span class="id"> //=;</span><span class="id"> case/boolP:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> mu</span>).<br/>
&nbsp;&nbsp;<span class="id">move/le;</span><span class="id"> rewrite</span><span class="id"> -!topredE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> E12;</span><span class="id"> rewrite</span><span class="id"> ler_wpM2r</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ler_nat;</span><span class="id"> case:</span> (<span class="id">E1</span><span class="id"> x</span>)<span class="id"> E12</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/dinsuppPn=&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> !mulr0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le_mu_pr</span><span class="id"> A</span><span class="id"> mu</span><span class="id"> nu</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> nu</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> nu</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> mu</span><span class="id"> x</span>)<br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> \P_[nu]</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> \P_[mu]</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> h;</span><span class="id"> apply/le_psum;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/summable_pr</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> ?ler0n</span><span class="id"> //=</span>.<br/>
<span class="id">case/boolP:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> dinsupp</span><span class="id"> nu</span>)<span class="id"> =&gt;</span><span class="id"> [/h</span><span class="id"> {}h|];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/dinsuppPn=&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> mulr0</span><span class="id"> mulr_ge0</span><span class="id"> ?ler0n</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case/boolP:</span> (<span class="id">A</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> [/h|];</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">mul0r,</span><span class="id"> mul1r</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> le1_prc</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> \P_[mu,</span><span class="id"> B]</span><span class="id"> A</span><span class="id"> &lt;=</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> :=</span><span class="id"> ge0_pr</span><span class="id"> B</span><span class="id"> mu;</span><span class="id"> rewrite</span><span class="id"> /prc</span><span class="id"> le_eqVlt</span>.<br/>
<span class="id">case/orP=&gt;</span><span class="id"> [/eqP&lt;-|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> invr0</span><span class="id"> mulr0</span><span class="id"> ler01</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/ler_pdivrMr=&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> mul1r</span><span class="id"> le_in_pr</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> _</span><span class="id"> /andP[]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prc_sum</span><span class="id"> A</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> \P_[mu]</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">psum</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> \P_[mu,</span><span class="id"> A]</span> (<span class="id">pred1</span><span class="id"> x</span>))<span class="id"> =</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> gt0_pE;</span><span class="id"> rewrite</span><span class="id"> psumZr</span><span class="id"> ?</span>(<span class="id">invr_ge0,</span><span class="id"> ge0_pr</span>)<span class="id"> //</span>.<br/>
<span class="id">rewrite</span> (<span class="id">eq_psum</span> (<span class="id">F2</span><span class="id"> :=</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">A</span><span class="id"> x</span>)<span class="id">%:R</span><span class="id"> *</span><span class="id"> mu</span><span class="id"> x</span>)))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> divff</span><span class="id"> //</span><span class="id"> gt_eqF</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> /pr</span> (<span class="id">psum_finseq</span> (<span class="id">r</span><span class="id"> :=</span><span class="id"> [::</span><span class="id"> x]</span>))<span class="id"> ?big_seq1</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> !inE;</span><span class="id"> case:</span> (<span class="id">y</span><span class="id"> ==</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mul0r</span><span class="id"> eqxx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> eqxx</span><span class="id"> -topredE</span><span class="id"> ger0_norm</span><span class="id"> ?mulr_ge0</span><span class="id"> ?ler0n</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_eq0</span><span class="id"> mu</span><span class="id"> E</span><span class="id"> :</span><span class="id"> \P_[mu]</span><span class="id"> E</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> E</span><span class="id"> -&gt;</span><span class="id"> mu</span><span class="id"> x</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/eq0_psum=&gt;</span><span class="id"> /</span>(_ (<span class="id">summable_pr</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> =&gt;</span><span class="id"> h</span><span class="id"> x</span><span class="id"> xE;</span><span class="id"> move/</span>(_<span class="id"> x</span>)<span class="id">:</span><span class="id"> h</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> xE;</span><span class="id"> rewrite</span><span class="id"> -topredE</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> mul1r</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prID</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mu</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\P_[mu]</span><span class="id"> A</span><span class="id"> =</span><span class="id"> \P_[mu]</span><span class="id"> [predI</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> B]</span><span class="id"> +</span><span class="id"> \P_[mu]</span><span class="id"> [predI</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> predC</span><span class="id"> B]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> {1}/pr</span> (<span class="id">psumID</span><span class="id"> B</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/summable_pr</span>.<br/>
<span class="id">congr</span> (_<span class="id"> +</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply/eq_psum</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> -!topredE</span><span class="id"> /=;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulrA</span><span class="id"> -natrM</span><span class="id"> mulnb</span><span class="id"> andbC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_or_indep</span> (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>) (<span class="id">mu</span><span class="id"> :</span><span class="id"> {distr</span><span class="id"> T</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> B</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\P_[mu]</span><span class="id"> [predU</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> B]</span><span class="id"> =</span><span class="id"> \P_[mu]</span><span class="id"> A</span><span class="id"> +</span><span class="id"> \P_[mu]</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> dsj;</span><span class="id"> rewrite</span><span class="id"> /pr</span><span class="id"> -psumD;</span><span class="id"> try</span><span class="id"> solve</span><span class="id"> [</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/summable_pr</span><span class="id"> |</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> ?ler0n</span><br/>
<span class="id">]</span>.<br/>
<span class="id">apply/eq_psum=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -mulrDl</span><span class="id"> -!topredE</span><span class="id"> /=</span><span class="id"> -natrD</span>.<br/>
<span class="id">case/boolP:</span> (<span class="id">A</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> Ax;</span><span class="id"> case/boolP:</span> (<span class="id">B</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> Bx</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/dsj:</span><span class="id"> Ax;</span><span class="id"> rewrite</span><span class="id"> -topredE</span><span class="id"> /=</span><span class="id"> Bx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_mem_map</span><span class="id"> f</span><span class="id"> mu</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> U</span>)<span class="id"> :</span><span class="id"> uniq</span><span class="id"> r</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\P_[mu]</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> f</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> r]</span><br/>
&nbsp;&nbsp;<span class="id">=</span><span class="id"> \sum_</span>(<span class="id">y</span><span class="id"> &lt;-</span><span class="id"> r</span>)<span class="id"> \P_[mu]</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> f</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> y]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> r</span><span class="id"> =&gt;</span><span class="id"> [_|y</span><span class="id"> r</span><span class="id"> ih];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> big_nil</span><span class="id"> pr_pred0_eq</span><span class="id"> //</span>.<br/>
<span class="id">case/andP=&gt;</span><span class="id"> yNr</span><span class="id"> /ih</span><span class="id"> {ih}h;</span><span class="id"> rewrite</span><span class="id"> big_cons</span><span class="id"> -h</span><span class="id"> -pr_or_indep</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> =&gt;</span><span class="id"> /eqP-&gt;</span>.<span class="gallina-kwd"> by</span><span class="id"> apply/eq_pr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_mem</span><span class="id"> mu</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> uniq</span><span class="id"> r</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\P_[mu]</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> r]</span><span class="id"> =</span><span class="id"> \sum_</span>(<span class="id">x</span><span class="id"> &lt;-</span><span class="id"> r</span>)<span class="id"> mu</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> r</span><span class="id"> =&gt;</span><span class="id"> [_|y</span><span class="id"> r</span><span class="id"> ih];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> big_nil</span><span class="id"> pr_pred0_eq</span><span class="id"> //</span>.<br/>
<span class="id">case/andP=&gt;</span><span class="id"> yNr</span><span class="id"> /ih</span><span class="id"> {ih}h;</span><span class="id"> rewrite</span><span class="id"> big_cons</span><span class="id"> /=</span><span class="id"> pr_pred1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -h</span><span class="id"> -pr_or_indep</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /eqP</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_bigor_indep</span><span class="id"> mu</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> pred</span><span class="id"> T</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> I</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> r</span><br/>
&nbsp;&nbsp;<span class="id">-&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> p1</span><span class="id"> p2</span><span class="id"> x,</span><span class="id"> p1</span><span class="id"> !=</span><span class="id"> p2</span><span class="id"> -&gt;</span><span class="id"> p1</span><span class="id"> \in</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="id"> p2</span><span class="id"> \in</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> P</span><span class="id"> p1</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> P</span><span class="id"> p2</span>)<br/>
&nbsp;&nbsp;<span class="id">-&gt;</span><span class="id"> \P_[mu]</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> has</span><span class="id"> [pred</span><span class="id"> p</span><span class="id"> |</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> P</span><span class="id"> p]</span><span class="id"> r]</span><br/>
&nbsp;&nbsp;<span class="id">=</span><span class="id"> \sum_</span>(<span class="id">p</span><span class="id"> &lt;-</span><span class="id"> r</span>)<span class="id"> \P_[mu]</span> (<span class="id">P</span><span class="id"> p</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> uq_r</span><span class="id"> dj;</span><span class="id"> pose</span><span class="id"> S</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> \big[orb/false]_</span>(<span class="id">p</span><span class="id"> &lt;-</span><span class="id"> r</span>) (<span class="id">x</span><span class="id"> \in</span><span class="id"> P</span><span class="id"> p</span>).<br/>
<span class="id">rewrite</span> (<span class="id">eq_pr</span> (<span class="id">B</span><span class="id"> :=</span><span class="id"> S</span>))<span class="id"> =&gt;</span><span class="id"> [x|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> -big_has</span>.<br/>
<span class="id">rewrite</span><span class="id"> {}/S;</span><span class="id"> elim:</span><span class="id"> r</span><span class="id"> uq_r</span><span class="id"> dj</span><span class="id"> =&gt;</span><span class="id"> [_|p</span><span class="id"> r</span><span class="id"> ih</span><span class="id"> /andP[pNr</span><span class="id"> /ih</span><span class="id"> {ih}h]]</span><span class="id"> dj</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_nil</span><span class="id"> pr_pred0_eq</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> big_nil</span>.<br/>
<span class="id">rewrite</span><span class="id"> big_cons</span><span class="id"> -h</span><span class="id"> =&gt;</span><span class="id"> [p1</span><span class="id"> p2</span><span class="id"> x</span><span class="id"> ne_p</span><span class="id"> p1r</span><span class="id"> p2r|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/dj=&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> in_cons</span> (<span class="id">p1r,</span><span class="id"> p2r</span>)<span class="id"> orbT</span>.<br/>
<span class="id">rewrite</span><span class="id"> -pr_or_indep</span><span class="id"> =&gt;</span><span class="id"> [x</span><span class="id"> xNPp|]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -topredE</span><span class="id"> /=</span><span class="id"> big_has;</span><span class="id"> apply/hasPn</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> y_in_r</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/</span>(<span class="id">dj</span><span class="id"> p</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?in_cons</span><span class="id"> ?</span>(<span class="id">eqxx,</span><span class="id"> y_in_r,</span><span class="id"> orbT</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/contra:</span><span class="id"> pNr=&gt;</span><span class="id"> /eqP-&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_pr=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -!topredE</span><span class="id"> /=</span><span class="id"> big_cons</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_or</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> \P_[mu]</span><span class="id"> [predU</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> B]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">\P_[mu]</span><span class="id"> A</span><span class="id"> +</span><span class="id"> \P_[mu]</span><span class="id"> B</span><span class="id"> -</span><span class="id"> \P_[mu]</span><span class="id"> [predI</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> B]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> subr_eq</span><span class="id"> [in</span><span class="id"> X</span><span class="gallina-kwd"> in</span><span class="id"> _==X]addrC;</span><span class="id"> apply/eqP</span>.<br/>
<span class="id">rewrite</span> (<span class="id">prID</span><span class="id"> _</span><span class="id"> B</span>)<span class="id"> -addrA</span><span class="id"> -pr_or_indep</span><span class="id"> =&gt;</span><span class="id"> [x|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> =&gt;</span><span class="id"> /andP[]</span>.<br/>
<span class="id">congr</span> (_<span class="id"> +</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply/eq_pr</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> -!topredE</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/orb_id2r</span><span class="id"> =&gt;</span><span class="id"> /negbTE</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> andbT</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_and</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> \P_[mu]</span><span class="id"> [predI</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> B]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">\P_[mu]</span><span class="id"> A</span><span class="id"> +</span><span class="id"> \P_[mu]</span><span class="id"> B</span><span class="id"> -</span><span class="id"> \P_[mu]</span><span class="id"> [predU</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> B]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> pr_or</span><span class="id"> opprB</span><span class="id"> addrCA</span><span class="id"> subrr</span><span class="id"> addr0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ler_pr_or</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mu</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\P_[mu]</span><span class="id"> [predU</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> B]</span><span class="id"> &lt;=</span><span class="id"> \P_[mu]</span><span class="id"> A</span><span class="id"> +</span><span class="id"> \P_[mu]</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> pr_or</span><span class="id"> lerBlDr</span><span class="id"> lerDl</span><span class="id"> ge0_pr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ler_pr_and</span><span class="id"> A</span><span class="id"> B</span><span class="id"> mu</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">\P_[mu]</span><span class="id"> [predI</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> B]</span><span class="id"> &lt;=</span><span class="id"> \P_[mu]</span><span class="id"> A</span><span class="id"> +</span><span class="id"> \P_[mu]</span><span class="id"> B</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> pr_and</span><span class="id"> lerBlDr</span><span class="id"> lerDl</span><span class="id"> ge0_pr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_predC</span><span class="id"> E</span><span class="id"> mu:</span><span class="id"> \P_[mu]</span>(<span class="id">predC</span><span class="id"> E</span>)<span class="id"> =</span><span class="id"> \P_[mu]</span><span class="id"> predT</span><span class="id"> -</span><span class="id"> \P_[mu]</span><span class="id"> E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/esym/eqP;</span><span class="id"> rewrite</span><span class="id"> subr_eq</span><span class="id"> -pr_or_indep</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eqP/eq_pr=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> orNb</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pr_split</span><span class="id"> B</span><span class="id"> A</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> \P_[mu]</span><span class="id"> A</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\P_[mu]</span>       <span class="id"> B</span> <span class="id"> *</span><span class="id"> \P_[mu,</span>      <span class="id"> B]</span><span class="id"> A</span><br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> \P_[mu]</span> (<span class="id">predC</span><span class="id"> B</span>)<span class="id"> *</span><span class="id"> \P_[mu,</span><span class="id"> predC</span><span class="id"> B]</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">suff</span><span class="id"> h</span><span class="id"> A'</span><span class="id"> B':</span><span class="id"> \P_[mu]</span><span class="id"> [predI</span><span class="id"> A'</span><span class="id"> &amp;</span><span class="id"> B']</span><span class="id"> =</span><span class="id"> \P_[mu]</span><span class="id"> B'</span><span class="id"> *</span><span class="id"> \P_[mu,</span><span class="id"> B']</span><span class="id"> A'</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">prID</span><span class="id"> _</span><span class="id"> B</span>)<span class="id">;</span><span class="id"> congr</span> (_<span class="id"> +</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply/h</span>.<br/>
<span class="id">rewrite</span><span class="id"> /prc</span><span class="id"> mulrCA;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> eqVneq</span> (<span class="id">\P_[mu]</span><span class="id"> B'</span>)<span class="id"> 0;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> nzPB';</span><span class="id"> rewrite</span><span class="id"> divff</span><span class="id"> //</span><span class="id"> mulr1</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> zPB';</span><span class="id"> rewrite</span><span class="id"> zPB'</span><span class="id"> invr0</span><span class="id"> !mulr0;</span><span class="id"> apply/eq0_pr</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> mux;</span><span class="id"> move/pr_eq0:</span><span class="id"> zPB'</span><span class="id"> =&gt;</span><span class="id"> /</span>(_<span class="id"> x</span>)<span class="id"> h;</span><span class="id"> rewrite</span><span class="id"> !inE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/negP=&gt;</span><span class="id"> /andP[_</span><span class="id"> /h]</span><span class="id"> /dinsuppP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __admitted__exp_split</span><span class="id"> A</span><span class="id"> f</span><span class="id"> mu</span><span class="id"> :</span><span class="id"> \E?_[mu]</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> \E_[mu]</span><span class="id"> f</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\P_[mu]</span>       <span class="id"> A</span> <span class="id"> *</span><span class="id"> \E_[mu,</span>      <span class="id"> A]</span><span class="id"> f</span><br/>
&nbsp;&nbsp;<span class="id">+</span><span class="id"> \P_[mu]</span> (<span class="id">predC</span><span class="id"> A</span>)<span class="id"> *</span><span class="id"> \E_[mu,</span><span class="id"> predC</span><span class="id"> A]</span><span class="id"> f</span>.<br/>
<span class="vernacular">Proof</span><span class="gallina-kwd"> using</span><span class="gallina-kwd"> Type</span>.<br/>
<span class="vernacular">Lemma</span><span class="id"> has_esp_bounded</span><span class="id"> f</span><span class="id"> mu</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">exists</span><span class="id"> M,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> `|f</span><span class="id"> x|</span><span class="id"> &lt;</span><span class="id"> M</span>)<span class="id"> -&gt;</span><span class="id"> \E?_[mu]</span><span class="id"> f</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
                          <span class="comment">(*&nbsp;TO&nbsp;BE&nbsp;REMOVED&nbsp;*)</span><br/>
<span class="id">case=&gt;</span><span class="id"> M</span><span class="id"> ltM;</span><span class="id"> rewrite</span><span class="id"> /has_esp;</span><span class="id"> apply/summable_seqP</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">Num</span>.<span class="id">max</span><span class="id"> M</span><span class="id"> 0</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> le_max</span><span class="id"> lexx</span><span class="id"> orbT</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> J</span><span class="id"> uqJ;</span><span class="id"> apply/</span>(<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">\sum_</span>(<span class="id">j</span><span class="id"> &lt;-</span><span class="id"> J</span>)<span class="id"> M</span><span class="id"> *</span><span class="id"> mu</span><span class="id"> j</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply/ler_sum=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> normrM</span><span class="id"> [X</span><span class="gallina-kwd"> in</span><span class="id"> _*X]ger0_norm</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/ler_wpM2r=&gt;</span><span class="id"> //;</span><span class="id"> apply/ltW</span>.<br/>
<span class="id">case:</span> (<span class="id">ltrP</span><span class="id"> M</span><span class="id"> 0</span>)<span class="id"> =&gt;</span><span class="id"> [lt0_M|ge0_M]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ?</span>(<span class="id">ltW</span><span class="id"> lt0_M</span>)<span class="id"> //</span><span class="id"> -mulr_sumr</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nmulr_rle0</span><span class="id"> //;</span><span class="id"> apply/sumr_ge0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -mulr_sumr</span><span class="id"> ler_piMr</span><span class="id"> //</span><span class="id"> -pr_mem</span><span class="id"> ?le1_pr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bounded_has_exp</span><span class="id"> mu</span><span class="id"> F</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">exists</span><span class="id"> M,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> `|F</span><span class="id"> x|</span><span class="id"> &lt;=</span><span class="id"> M</span>)<span class="id"> -&gt;</span><span class="id"> \E?_[mu]</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> leM;</span><span class="id"> apply/summableMl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> summable_has_exp</span><span class="id"> mu</span><span class="id"> F</span><span class="id"> :</span><span class="id"> summable</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> \E?_[mu]</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> smF;</span><span class="id"> apply/summableMr</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> 1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> ger0_norm</span><span class="id"> //</span><span class="id"> le1_mu1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> exp_le_bd</span><span class="id"> mu</span><span class="id"> F</span> (<span class="id">M</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> M</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> `|F</span><span class="id"> x|</span><span class="id"> &lt;=</span><span class="id"> M</span>)<span class="id"> -&gt;</span><span class="id"> \E_[mu]</span><span class="id"> F</span><span class="id"> &lt;=</span><span class="id"> M</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> ge0M</span><span class="id"> bd;</span><span class="id"> apply/</span>(<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">\E_[mu]</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> M</span>))).<br/>
<span class="id">+</span><span class="id"> apply/le_exp</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply/bounded_has_exp;</span><span class="gallina-kwd"> exists</span><span class="id"> M</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> apply/has_expC</span>.<br/>
&nbsp;&nbsp;<span class="id">+</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> apply/</span>(<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">bd</span><span class="id"> x</span>))<span class="id">/ler_norm</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> exp_cst</span><span class="id"> ler_piMl</span><span class="id"> //</span><span class="id"> le1_pr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> __admitted__exp_dlet</span><span class="id"> mu</span> (<span class="id">nu</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> {distr</span><span class="id"> U</span><span class="id"> /</span><span class="id"> R}</span>)<span class="id"> F</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> eta,</span><span class="id"> \E?_[eta]</span><span class="id"> F</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">\E_[dlet</span><span class="id"> nu</span><span class="id"> mu]</span><span class="id"> F</span><span class="id"> =</span><span class="id"> \E_[mu]</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> \E_[nu</span><span class="id"> x]</span><span class="id"> F</span>).<br/>
<span class="vernacular">Proof</span><span class="gallina-kwd"> using</span><span class="id"> Type*</span>.<span class="vernacular">End</span><span class="id"> PrTheory</span>.<br/>
<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;relies on admitted, use __deprecated__pr_dlet explicitly if you really want to use this lemma&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> pr_dlet</span><span class="id"> :=</span><span class="id"> __deprecated__pr_dlet</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;lacks proof, use __admitted__exp_split explicitly if you really want to use this lemma&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> exp_split</span><span class="id"> :=</span><span class="id"> __admitted__exp_split</span>.<br/>
<span class="id">#[deprecated</span>(<span class="id">since=</span><span class="id">&quot;mathcomp-analysis 0.6.2&quot;</span><span class="id">,</span><br/>
&nbsp;&nbsp;<span class="id">note=</span><span class="id">&quot;lacks proof, use __admitted__exp_dlet explicitly is you really want to use this lemma&quot;</span>)<span class="id">]</span><br/>
<span class="vernacular">Notation</span><span class="id"> exp_dlet</span><span class="id"> :=</span><span class="id"> __admitted__exp_dlet</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Jensen</span>.<br/>
<span class="vernacular">Context</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> realType}</span><span class="id"> {I</span><span class="id"> :</span><span class="id"> finType}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> convexon</span> (<span class="id">a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> \bar</span><span class="id"> R</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> y,</span> (<span class="id">a</span><span class="id"> &lt;=</span><span class="id"> x%:E</span><span class="id"> &lt;=</span><span class="id"> b</span>)<span class="id">%E</span><span class="id"> -&gt;</span> (<span class="id">a</span><span class="id"> &lt;=</span><span class="id"> y%:E</span><span class="id"> &lt;=</span><span class="id"> b</span>)<span class="id">%E</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> t,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> t</span><span class="id"> &lt;=</span><span class="id"> 1</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> (<span class="id">t</span><span class="id"> *</span><span class="id"> x</span><span class="id"> +</span> (<span class="id">1</span><span class="id"> -</span><span class="id"> t</span>)<span class="id"> *</span><span class="id"> y</span>)<span class="id"> &lt;=</span><span class="id"> t</span><span class="id"> *</span> (<span class="id">f</span><span class="id"> x</span>)<span class="id"> +</span> (<span class="id">1</span><span class="id"> -</span><span class="id"> t</span>)<span class="id"> *</span> (<span class="id">f</span><span class="id"> y</span>).<br/>
<br/>
<span class="vernacular">Notation</span><span class="id"> convex</span><span class="id"> f</span><span class="id"> :=</span> (<span class="id">convexon</span><span class="id"> -oo</span><span class="id"> +oo</span><span class="id"> f</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Jensen</span>.<br/>
<span class="vernacular">Context</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">x</span><span class="id"> l</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> cvx_f</span><span class="id"> :</span><span class="id"> convex</span><span class="id"> f</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> ge0_l</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> l</span><span class="id"> x</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> eq1_l</span><span class="id"> :</span><span class="id"> \sum_i</span> (<span class="id">l</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> 1</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Jensen</span><span class="id"> :</span><span class="id"> f</span> (<span class="id">\sum_i</span> (<span class="id">l</span><span class="id"> i</span><span class="id"> *</span><span class="id"> x</span><span class="id"> i</span>))<span class="id"> &lt;=</span><span class="id"> \sum_i</span> (<span class="id">l</span><span class="id"> i</span><span class="id"> *</span><span class="id"> f</span> (<span class="id">x</span><span class="id"> i</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case:</span> (<span class="id">index_enum</span><span class="id"> I</span>)<span class="id"> eq1_l</span><span class="id"> =&gt;</span><span class="id"> [|i</span><span class="id"> s];</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">big_nil,</span><span class="id"> big_cons</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/esym/eqP;</span><span class="id"> rewrite</span><span class="id"> oner_eq0</span>.<br/>
<span class="id">elim:</span><span class="id"> {i}</span><span class="id"> s</span> (<span class="id">l</span><span class="id"> i</span>) (<span class="id">ge0_l</span><span class="id"> i</span>) (<span class="id">x</span><span class="id"> i</span>)<span class="id"> =&gt;</span><span class="id"> [|j</span><span class="id"> s</span><span class="id"> ih]</span><span class="id"> li</span><span class="id"> ge0_li</span><span class="id"> xi</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !big_nil</span><span class="id"> !addr0</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> !mul1r</span>.<br/>
<span class="id">rewrite</span><span class="id"> !big_cons;</span><span class="id"> have</span><span class="id"> :=</span><span class="id"> ge0_l</span><span class="id"> j;</span><span class="id"> rewrite</span><span class="id"> le_eqVlt</span>.<br/>
<span class="id">case/orP</span><span class="id"> =&gt;</span><span class="id"> [/eqP&lt;-|gt0_lj]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !Monoid</span>.<span class="id">simpm</span><span class="id"> /=</span><span class="id"> !Monoid</span>.<span class="id">simpm;</span><span class="id"> apply/ih</span>.<br/>
<span class="id">rewrite</span><span class="id"> !addrA</span><span class="id"> =&gt;</span><span class="id"> eq1;</span><span class="id"> pose</span><span class="id"> z</span><span class="id"> :=</span> (<span class="id">li</span><span class="id"> *</span><span class="id"> xi</span><span class="id"> +</span><span class="id"> l</span><span class="id"> j</span><span class="id"> *</span><span class="id"> x</span><span class="id"> j</span>)<span class="id"> /</span> (<span class="id">li</span><span class="id"> +</span><span class="id"> l</span><span class="id"> j</span>).<br/>
<span class="id">have</span><span class="id"> nz_lij:</span><span class="id"> li</span><span class="id"> +</span><span class="id"> l</span><span class="id"> j</span><span class="id"> !=</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> gt_eqF</span><span class="id"> ?ltr_wpDl</span>.<br/>
<span class="id">have/ih</span><span class="id"> :=</span><span class="id"> eq1</span><span class="id"> =&gt;</span><span class="id"> -/</span>(_<span class="id"> _</span><span class="id"> z</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> [_</span><span class="id"> *</span> (_<span class="id"> /</span><span class="id"> _</span>)<span class="id">]mulrC</span>.<br/>
<span class="id">rewrite</span><span class="id"> mulfVK</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> {}ih;</span><span class="id"> apply/</span>(<span class="id">le_trans</span> (<span class="id">ih</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> addr_ge0</span><span class="id"> ?ge0_l</span>.<br/>
<span class="id">rewrite</span><span class="id"> lerD2r</span><span class="id"> {ih}/z</span><span class="id"> [_</span><span class="id"> /</span><span class="id"> _]mulrDl</span><span class="id"> ![_*_/_]mulrAC</span>.<br/>
<span class="id">set</span><span class="id"> c1</span><span class="id"> :</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> _</span><span class="id"> /</span><span class="id"> _;</span><span class="id"> set</span><span class="id"> c2</span><span class="id"> :</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> _</span><span class="id"> /</span><span class="id"> _;</span><span class="id"> have</span><span class="id"> eqc2:</span><span class="id"> c2</span><span class="id"> =</span><span class="id"> 1</span><span class="id"> -</span><span class="id"> c1</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/</span>(<span class="id">mulfI</span><span class="id"> nz_lij</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> mulrBr</span><span class="id"> mulr1</span><span class="id"> ![</span>(<span class="id">li</span><span class="id"> +</span><span class="id"> l</span><span class="id"> j</span>)<span class="id">*_]mulrC</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> !mulfVK</span><span class="id"> //</span><span class="id"> eq_sym</span><span class="id"> subr_eq</span><span class="id"> addrC</span>.<br/>
<span class="id">set</span><span class="id"> c</span><span class="id"> :=</span> (<span class="id">li</span><span class="id"> +</span><span class="id"> l</span><span class="id"> j</span>)<span class="id">;</span><span class="id"> pose</span><span class="id"> z</span><span class="id"> :=</span> (<span class="id">c</span><span class="id"> *</span><span class="id"> c1</span><span class="id"> *</span><span class="id"> f</span><span class="id"> xi</span><span class="id"> +</span><span class="id"> c</span><span class="id"> *</span><span class="id"> c2</span><span class="id"> *</span><span class="id"> f</span> (<span class="id">x</span><span class="id"> j</span>)).<br/>
<span class="id">apply/</span>(<span class="id">@le_trans</span><span class="id"> _</span><span class="id"> _</span><span class="id"> z</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /z</span><span class="id"> ![_*</span>(<span class="id">_/_</span>)<span class="id">]mulrC</span><span class="id"> !mulfVK</span>.<br/>
<span class="id">rewrite</span><span class="id"> {}/z</span><span class="id"> -![c</span><span class="id"> *</span><span class="id"> _</span><span class="id"> *</span><span class="id"> _]mulrA</span><span class="id"> -mulrDr</span><span class="id"> ler_wpM2l</span><span class="id"> ?addr_ge0</span><span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> eqc2</span><span class="id"> cvx_f</span><span class="id"> //</span><span class="id"> ?leNye</span><span class="id"> ?leey</span><span class="id"> //</span><span class="id"> divr_ge0</span><span class="id"> ?addr_ge0</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ler_pdivrMr</span><span class="id"> ?mul1r</span><span class="id"> ?lerDl</span><span class="id"> ?ltr_wpDl</span>.<br/>
Qed.</div></details>
<span class="vernacular">End</span><span class="id"> Jensen</span>.<br/>
<span class="vernacular">End</span><span class="id"> Jensen</span>.<br/>
<br/>
<span class="vernacular">Notation</span><span class="id"> convex</span><span class="id"> f</span><span class="id"> :=</span> (<span class="id">convexon</span><span class="id"> \-inf</span><span class="id"> \+inf</span><span class="id"> f</span>).<br/>
<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/yoshihiro503/coq2html/">a fork of coq2html</a></div>
    </div>
  </div>
    </main>
</body>
</html>
